import { FernIr } from "@fern-fern/ir-sdk";
import { IntermediateRepresentation } from "@fern-fern/ir-sdk/api";
import { createHash } from "crypto";

// TODO: Use generated examples from ir-utils
// import { injectAutogeneratedExamples, generateEndpointV1Example } from "@fern-api/ir-utils";

export interface WireMockStubMapping {
    mappings: WireMockMapping[];
    meta?: {
        total: number;
    };
}

export interface WireMockMapping {
    id: string;
    name: string;
    request: {
        urlPathTemplate: string;
        method: string;
        pathParameters?: Record<string, { equalTo: string }>;
        formParameters?: Record<string, unknown>;
        bodyPatterns?: Array<{ matchesJsonPath: string }>;
    };
    response: {
        status: number;
        body: string;
        headers: Record<string, string>;
    };
    uuid: string;
    persistent: boolean;
    priority?: number;
    metadata: {
        mocklab: {
            created: {
                at: string;
                via: string;
            };
        };
    };
    postServeActions?: unknown[];
}

export class WireMock {
    public convertToWireMock(ir: IntermediateRepresentation): WireMockStubMapping {
        const mappings: WireMockMapping[] = [];

        // First pass: identify endpoints that share the same URL path and method
        // This is used to detect when we need to add body patterns to differentiate
        // between streaming and non-streaming variants of the same endpoint
        const endpointsByPathAndMethod = new Map<string, Array<{ endpoint: FernIr.HttpEndpoint; isSse: boolean }>>();

        for (const service of Object.values(ir.services)) {
            for (const endpoint of service.endpoints) {
                const urlPath = this.buildUrlPathTemplate(endpoint);
                const key = `${endpoint.method}:${urlPath}`;
                const exampleWrapper = endpoint.userSpecifiedExamples[0] ?? endpoint.autogeneratedExamples[0];
                const example = exampleWrapper?.example;
                const isSse = example?.response?.type === "ok" && example?.response?.value?.type === "sse";

                if (!endpointsByPathAndMethod.has(key)) {
                    endpointsByPathAndMethod.set(key, []);
                }
                endpointsByPathAndMethod.get(key)?.push({ endpoint, isSse });
            }
        }

        // Determine which URL paths have both SSE and non-SSE endpoints (need body pattern matching)
        const pathsNeedingBodyPatterns = new Set<string>();
        for (const [key, endpoints] of endpointsByPathAndMethod) {
            const hasSse = endpoints.some((e) => e.isSse);
            const hasNonSse = endpoints.some((e) => !e.isSse);
            if (hasSse && hasNonSse) {
                pathsNeedingBodyPatterns.add(key);
            }
        }

        // Second pass: generate mappings with body patterns only where needed
        for (const service of Object.values(ir.services)) {
            for (const endpoint of service.endpoints) {
                // Use the first available example (prefer user-specified over autogenerated)
                const exampleWrapper = endpoint.userSpecifiedExamples[0] ?? endpoint.autogeneratedExamples[0];

                if (exampleWrapper) {
                    const example = exampleWrapper.example;
                    const urlPath = this.buildUrlPathTemplate(endpoint);
                    const key = `${endpoint.method}:${urlPath}`;
                    const needsBodyPattern = pathsNeedingBodyPatterns.has(key);
                    const mapping = this.convertExampleToMapping(ir, service, endpoint, example, needsBodyPattern);
                    if (mapping) {
                        mappings.push(mapping);
                    }
                }
            }
        }

        const wiremockFile: WireMockStubMapping = {
            mappings,
            meta: {
                total: mappings.length
            }
        };

        return wiremockFile;
    }

    private deterministicUUIDv4(hashArgument: string): string {
        const hash = createHash("sha1").update(hashArgument);
        const hashBytes = hash.digest().subarray(0, 16);

        const bytes: number[] = Array.from(hashBytes);

        // Type-safe access with explicit checks
        const byte6 = bytes[6];
        const byte8 = bytes[8];

        if (byte6 === undefined || byte8 === undefined) {
            throw new Error("Invalid byte array: missing required bytes");
        }

        bytes[6] = (byte6 & 0x0f) | 0x40; // We set the version to 4 (UUID v4)
        bytes[8] = (byte8 & 0x3f) | 0x80; // We set the variant to the correct RFC 4122 variant

        const raw = bytes.map((byte) => (byte + 0x100).toString(16).substring(1)).join("");

        // We finally add the separators where needed to format it correctly
        return [
            raw.substring(0, 8),
            raw.substring(8, 12),
            raw.substring(12, 16),
            raw.substring(16, 20),
            raw.substring(20, 32)
        ].join("-");
    }

    private convertExampleToMapping(
        ir: IntermediateRepresentation,
        service: FernIr.HttpService,
        endpoint: FernIr.HttpEndpoint,
        example: FernIr.ExampleEndpointCall | undefined,
        needsBodyPattern: boolean
    ): WireMockMapping | null {
        // Build URL path template
        const urlPathTemplate = this.buildUrlPathTemplate(endpoint);

        // Extract path parameters from example
        const pathParameters: Record<string, { equalTo: string }> = {};
        for (const param of example?.endpointPathParameters || []) {
            const paramValue = this.extractExampleValue(param.value);
            if (paramValue !== null) {
                const paramName = param.name?.originalName;
                if (paramName) {
                    pathParameters[paramName] = { equalTo: String(paramValue) };
                }
            }
        }

        // Determine response status and body
        let status = 200;
        let bodyObj: string | number | boolean | object = "";
        let contentType = "application/json";
        let isSseResponse = false;

        if (example?.response) {
            if (example.response.type === "ok") {
                // Use the endpoint's defined status code, or default to 200
                status = endpoint.response?.statusCode ?? 200;
                if (example.response.value?.type === "body" && example.response.value.value) {
                    // For response bodies, use jsonExample directly to support both primitives and objects
                    bodyObj = example.response.value.value.jsonExample ?? "";
                } else if (example.response.value?.type === "sse") {
                    // Handle SSE responses
                    isSseResponse = true;
                    contentType = "text/event-stream";
                    bodyObj = example.response.value.value || [];
                }
            } else if (example.response.type === "error") {
                // Extract status code from error
                const errorName = example.response.error?.name?.originalName;
                if (errorName === "NotFoundError") {
                    status = 404;
                } else if (errorName === "InternalServerError") {
                    status = 500;
                }
                bodyObj = example.response.body?.jsonExample ?? "";
            }
        }

        // Format response body with validation and fallback
        let body = "";
        if (bodyObj !== null && bodyObj !== undefined) {
            if (isSseResponse && Array.isArray(bodyObj)) {
                // Format SSE response according to the SSE protocol
                // Each event should be formatted as: event: <event_name>\ndata: <json_data>\n\n
                const sseEvents = bodyObj as Array<{ event: string; data: { jsonExample?: unknown } }>;
                body = sseEvents
                    .map((sseEvent) => {
                        const eventName = sseEvent.event || "message";
                        // Access jsonExample from the data field
                        const eventData = sseEvent.data?.jsonExample ?? {};
                        const dataJson = JSON.stringify(eventData);
                        return `event: ${eventName}\ndata: ${dataJson}\n`;
                    })
                    .join("\n");
            } else if (typeof bodyObj === "object") {
                try {
                    body = JSON.stringify(bodyObj, null, 2);
                    if (!body || body.trim() === "") {
                        body = Array.isArray(bodyObj) ? "[]" : "{}";
                    } else {
                        JSON.parse(body);
                    }
                } catch {
                    body = Array.isArray(bodyObj) ? "[]" : "{}";
                }
            } else {
                // For primitives (string, number, boolean), use JSON.stringify to properly quote strings
                body = JSON.stringify(bodyObj);
            }
        }

        // Build descriptive name
        const endpointName = endpoint.displayName || endpoint.name.originalName;
        const exampleName = typeof example?.name === "string" ? example.name : "default";
        const name = `${endpointName} - ${exampleName}`;
        const uuid = this.deterministicUUIDv4(`${name}-${endpoint.id}-${urlPathTemplate}-${endpoint.method}`);

        // Only add body patterns when there are both SSE and non-SSE endpoints for the same URL path
        // This allows WireMock to differentiate between streaming and non-streaming requests
        const shouldAddBodyPattern = needsBodyPattern && isSseResponse;

        const mapping: WireMockMapping = {
            id: uuid,
            name,
            request: {
                urlPathTemplate,
                method: endpoint.method,
                pathParameters: Object.keys(pathParameters).length > 0 ? pathParameters : undefined,
                formParameters: {},
                // For SSE endpoints that share a URL path with non-SSE endpoints,
                // add body pattern to match stream: true
                bodyPatterns: shouldAddBodyPattern ? [{ matchesJsonPath: "$[?(@.stream == true)]" }] : undefined
            },
            response: {
                status,
                body,
                headers: {
                    "Content-Type": contentType
                }
            },
            uuid,
            persistent: true,
            // SSE endpoints get higher priority (lower number) so they match first when stream: true
            // Only set different priorities when there are conflicting endpoints
            priority: shouldAddBodyPattern ? 2 : 3,
            metadata: {
                mocklab: {
                    created: {
                        at: "2020-01-01T00:00:00.000Z",
                        via: "SYSTEM"
                    }
                }
            }
        };

        // Add postServeActions for certain mappings
        if (endpoint.method === "GET" && !mapping.request.pathParameters) {
            mapping.postServeActions = [];
        }

        // Remove formParameters if empty
        if (Object.keys(mapping.request.formParameters || {}).length === 0) {
            delete mapping.request.formParameters;
        }

        return mapping;
    }

    private buildUrlPathTemplate(endpoint: FernIr.HttpEndpoint): string {
        // Use fullPath to include the service basePath
        let path = endpoint.fullPath.head;
        for (const part of endpoint.fullPath.parts || []) {
            path += `{${part.pathParameter}}${part.tail}`;
        }
        // Ensure path always starts with /
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        // Strip URL fragment - fragments are never sent to the server in HTTP requests
        // e.g., "/oauth2/token#refresh" -> "/oauth2/token"
        const fragmentIndex = path.indexOf("#");
        if (fragmentIndex !== -1) {
            path = path.substring(0, fragmentIndex);
        }
        return path;
    }

    private exampleToQueryOrHeaderValue({ value }: { value: FernIr.ExampleTypeReference }): string | undefined {
        if (typeof value.jsonExample === "string") {
            const maybeDatetime = this.getDateTime(value);
            return maybeDatetime != null ? maybeDatetime.toISOString() : value.jsonExample;
        }
        if (typeof value.jsonExample === "number") {
            return value.jsonExample.toString();
        }
        return undefined;
    }

    private getDateTime(exampleTypeReference: FernIr.ExampleTypeReference): Date | undefined {
        switch (exampleTypeReference.shape.type) {
            case "container":
                if (exampleTypeReference.shape.container.type !== "optional") {
                    return undefined;
                }
                if (exampleTypeReference.shape.container.optional == null) {
                    return undefined;
                }
                return this.getDateTime(exampleTypeReference.shape.container.optional);
            case "named":
                if (exampleTypeReference.shape.shape.type !== "alias") {
                    return undefined;
                }
                return this.getDateTime(exampleTypeReference.shape.shape.value);
            case "primitive":
                return exampleTypeReference.shape.primitive.type === "datetime"
                    ? exampleTypeReference.shape.primitive.datetime
                    : undefined;
            case "unknown":
                return undefined;
        }
    }

    private extractExampleValue(
        exampleValue: FernIr.ExampleTypeReference
    ): FernIr.ExamplePrimitive | Date | string | number | boolean | Record<string, never> | null {
        if (!exampleValue) {
            return null;
        }

        // Try to get the jsonExample directly
        if (exampleValue.jsonExample !== undefined) {
            return exampleValue.jsonExample?.toString() || null;
        }

        // Navigate through shape if needed
        if (exampleValue.shape) {
            if (exampleValue.shape.type === "primitive" && exampleValue.shape.primitive) {
                const primitive = exampleValue.shape.primitive;
                // We need this because the primitive type is a union, and we need to handle the different cases.
                // Typescript isn't happy with accessing the primitive using the primitive type as a key.
                switch (primitive.type) {
                    case "string":
                        return primitive.string.original;
                    case "boolean":
                        return primitive.boolean;
                    case "integer":
                        return primitive.integer;
                    case "long":
                        return primitive.long;
                    case "uint":
                        return primitive.uint;
                    case "uint64":
                        return primitive.uint64;
                    case "float":
                        return primitive.float;
                    case "double":
                        return primitive.double;
                    case "date":
                        return primitive.date;
                    case "datetime":
                        return primitive.datetime;
                    case "uuid":
                        return primitive.uuid;
                    case "base64":
                        return primitive.base64;
                    case "bigInteger":
                        return primitive.bigInteger;
                    default:
                        return null;
                }
            }
            if (exampleValue.shape.type === "container" && exampleValue.shape.container) {
                const container = exampleValue.shape.container;
                if (container.type === "optional" && container.optional) {
                    return this.extractExampleValue(container.optional);
                }
            }
        }

        return null;
    }
}

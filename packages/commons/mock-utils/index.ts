import { FernIr } from "@fern-fern/ir-sdk";
import { IntermediateRepresentation } from "@fern-fern/ir-sdk/api";
import { createHash } from "crypto";

// TODO: Use generated examples from ir-utils
// import { injectAutogeneratedExamples, generateEndpointV1Example } from "@fern-api/ir-utils";

export interface WireMockStubMapping {
    mappings: WireMockMapping[];
    meta?: {
        total: number;
    };
}

export interface WireMockMapping {
    id: string;
    name: string;
    request: {
        urlPathTemplate: string;
        method: string;
        pathParameters?: Record<string, { equalTo: string }>;
        formParameters?: Record<string, unknown>;
    };
    response: {
        status: number;
        body: string;
        headers: Record<string, string>;
    };
    uuid: string;
    persistent: boolean;
    priority?: number;
    metadata: {
        mocklab: {
            created: {
                at: string;
                via: string;
            };
        };
    };
    postServeActions?: unknown[];
}

export class WireMock {
    public convertToWireMock(ir: IntermediateRepresentation): WireMockStubMapping {
        const mappings: WireMockMapping[] = [];

        // Iterate through all services and their endpoints
        for (const service of Object.values(ir.services)) {
            for (const endpoint of service.endpoints) {
                // Use the first available example (prefer user-specified over autogenerated)
                let exampleWrapper = endpoint.userSpecifiedExamples[0] ?? endpoint.autogeneratedExamples[0];

                if (exampleWrapper) {
                    const example = exampleWrapper.example;
                    const mapping = this.convertExampleToMapping(ir, service, endpoint, example);
                    if (mapping) {
                        mappings.push(mapping);
                    }
                }
            }
        }

        const wiremockFile: WireMockStubMapping = {
            mappings,
            meta: {
                total: mappings.length
            }
        };

        return wiremockFile;
    }

    private deterministicUUIDv4(hashArgument: string): string {
        const hash = createHash("sha1").update(hashArgument);
        const hashBytes = hash.digest().subarray(0, 16);

        const bytes: number[] = Array.from(hashBytes);

        // Type-safe access with explicit checks
        const byte6 = bytes[6];
        const byte8 = bytes[8];

        if (byte6 === undefined || byte8 === undefined) {
            throw new Error("Invalid byte array: missing required bytes");
        }

        bytes[6] = (byte6 & 0x0f) | 0x40; // We set the version to 4 (UUID v4)
        bytes[8] = (byte8 & 0x3f) | 0x80; // We set the variant to the correct RFC 4122 variant

        const raw = bytes.map((byte) => (byte + 0x100).toString(16).substring(1)).join("");

        // We finally add the separators where needed to format it correctly
        return [
            raw.substring(0, 8),
            raw.substring(8, 12),
            raw.substring(12, 16),
            raw.substring(16, 20),
            raw.substring(20, 32)
        ].join("-");
    }

    private convertExampleToMapping(
        ir: IntermediateRepresentation,
        service: FernIr.HttpService,
        endpoint: FernIr.HttpEndpoint,
        example?: FernIr.ExampleEndpointCall
    ): WireMockMapping | null {
        // Build URL path template
        const urlPathTemplate = this.buildUrlPathTemplate(endpoint);

        // Extract path parameters from example
        const pathParameters: Record<string, { equalTo: string }> = {};
        for (const param of example?.endpointPathParameters || []) {
            const paramValue = this.extractExampleValue(param.value);
            if (paramValue !== null) {
                const paramName = param.name?.originalName;
                if (paramName) {
                    pathParameters[paramName] = { equalTo: String(paramValue) };
                }
            }
        }

        // Determine response status and body
        let status = 200;
        let bodyObj: string | number | boolean | object = "";

        if (example?.response) {
            if (example.response.type === "ok") {
                // Use the endpoint's defined status code, or default to 200
                status = endpoint.response?.statusCode ?? 200;
                if (example.response.value?.type === "body" && example.response.value.value) {
                    // For response bodies, use jsonExample directly to support both primitives and objects
                    bodyObj = example.response.value.value.jsonExample ?? "";
                }
            } else if (example.response.type === "error") {
                // Extract status code from error
                const errorName = example.response.error?.name?.originalName;
                if (errorName === "NotFoundError") {
                    status = 404;
                } else if (errorName === "InternalServerError") {
                    status = 500;
                }
                bodyObj = example.response.body?.jsonExample?.toString() || "";
            }
        }

        // Format response body
        let body = "";
        if (bodyObj !== null && bodyObj !== undefined) {
            if (typeof bodyObj === "object") {
                const isArray = Array.isArray(bodyObj);
                body = JSON.stringify(bodyObj, null, 2)
                    .split("\n")
                    .map((line) => "  " + line)
                    .join("\n");

                // Wrap with appropriate brackets based on whether it's an array or object
                if (isArray) {
                    body = "[\n" + body.substring(4, body.length - 2) + "\n]";
                } else {
                    body = "{\n" + body.substring(4, body.length - 2) + "\n}";
                }
            } else {
                // For primitives (string, number, boolean), use JSON.stringify to properly quote strings
                body = JSON.stringify(bodyObj);
            }
        }

        // Build descriptive name
        const endpointName = endpoint.displayName || endpoint.name.originalName;
        const exampleName = example?.name || "default";
        const name = `${endpointName} - ${exampleName}`;
        const uuid = this.deterministicUUIDv4(`${name}-${endpoint.id}-${urlPathTemplate}-${endpoint.method}`);

        const mapping: WireMockMapping = {
            id: uuid,
            name,
            request: {
                urlPathTemplate,
                method: endpoint.method,
                pathParameters: Object.keys(pathParameters).length > 0 ? pathParameters : undefined,
                formParameters: {}
            },
            response: {
                status,
                body,
                headers: {
                    "Content-Type": "application/json"
                }
            },
            uuid,
            persistent: true,
            priority: 3,
            metadata: {
                mocklab: {
                    created: {
                        at: "2020-01-01T00:00:00.000Z",
                        via: "SYSTEM"
                    }
                }
            }
        };

        // Add postServeActions for certain mappings
        if (endpoint.method === "GET" && !mapping.request.pathParameters) {
            mapping.postServeActions = [];
        }

        // Remove formParameters if empty
        if (Object.keys(mapping.request.formParameters || {}).length === 0) {
            delete mapping.request.formParameters;
        }

        return mapping;
    }

    private buildUrlPathTemplate(endpoint: FernIr.HttpEndpoint): string {
        // Use fullPath to include the service basePath
        let path = endpoint.fullPath.head;
        for (const part of endpoint.fullPath.parts || []) {
            path += `{${part.pathParameter}}${part.tail}`;
        }
        // Ensure path always starts with /
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        return path;
    }

    private exampleToQueryOrHeaderValue({ value }: { value: FernIr.ExampleTypeReference }): string | undefined {
        if (typeof value.jsonExample === "string") {
            const maybeDatetime = this.getDateTime(value);
            return maybeDatetime != null ? maybeDatetime.toISOString() : value.jsonExample;
        }
        if (typeof value.jsonExample === "number") {
            return value.jsonExample.toString();
        }
        return undefined;
    }

    private getDateTime(exampleTypeReference: FernIr.ExampleTypeReference): Date | undefined {
        switch (exampleTypeReference.shape.type) {
            case "container":
                if (exampleTypeReference.shape.container.type !== "optional") {
                    return undefined;
                }
                if (exampleTypeReference.shape.container.optional == null) {
                    return undefined;
                }
                return this.getDateTime(exampleTypeReference.shape.container.optional);
            case "named":
                if (exampleTypeReference.shape.shape.type !== "alias") {
                    return undefined;
                }
                return this.getDateTime(exampleTypeReference.shape.shape.value);
            case "primitive":
                return exampleTypeReference.shape.primitive.type === "datetime"
                    ? exampleTypeReference.shape.primitive.datetime
                    : undefined;
            case "unknown":
                return undefined;
        }
    }

    private extractExampleValue(
        exampleValue: FernIr.ExampleTypeReference
    ): FernIr.ExamplePrimitive | Date | string | number | boolean | Record<string, never> | null {
        if (!exampleValue) {
            return null;
        }

        // Try to get the jsonExample directly
        if (exampleValue.jsonExample !== undefined) {
            return exampleValue.jsonExample?.toString() || null;
        }

        // Navigate through shape if needed
        if (exampleValue.shape) {
            if (exampleValue.shape.type === "primitive" && exampleValue.shape.primitive) {
                const primitive = exampleValue.shape.primitive;
                // We need this because the primitive type is a union, and we need to handle the different cases.
                // Typescript isn't happy with accessing the primitive using the primitive type as a key.
                switch (primitive.type) {
                    case "string":
                        return primitive.string.original;
                    case "boolean":
                        return primitive.boolean;
                    case "integer":
                        return primitive.integer;
                    case "long":
                        return primitive.long;
                    case "uint":
                        return primitive.uint;
                    case "uint64":
                        return primitive.uint64;
                    case "float":
                        return primitive.float;
                    case "double":
                        return primitive.double;
                    case "date":
                        return primitive.date;
                    case "datetime":
                        return primitive.datetime;
                    case "uuid":
                        return primitive.uuid;
                    case "base64":
                        return primitive.base64;
                    case "bigInteger":
                        return primitive.bigInteger;
                    default:
                        return null;
                }
            }
            if (exampleValue.shape.type === "container" && exampleValue.shape.container) {
                const container = exampleValue.shape.container;
                if (container.type === "optional" && container.optional) {
                    return this.extractExampleValue(container.optional);
                }
            }
        }

        return null;
    }
}

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator fiddle 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
types/
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "const { build } = require(\\"esbuild\\");

void main();

async function main() {
    await bundle({
        platform: \\"node\\",
        target: \\"node14\\",
        format: \\"cjs\\",
        outdir: \\"node\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"esm\\",
        outdir: \\"browser/esm\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"cjs\\",
        outdir: \\"browser/cjs\\",
    });
}

async function bundle({ platform, target, format, outdir }) {
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/index.ts\\",
        outfile: \`./dist/\${outdir}/index.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/core/index.ts\\",
        outfile: \`./dist/\${outdir}/core.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/serialization/index.ts\\",
        outfile: \`./dist/\${outdir}/serialization.js\`,
    });
}

async function runEsbuild({ platform, target, format, entryPoint, outfile }) {
    await build({
        platform,
        target,
        format,
        entryPoints: [entryPoint],
        outfile,
        bundle: true,
        alias: {
            // matches up with tsconfig paths
            \\"@fern-fern/fiddle-sdk\\": \\"./src\\",
        }
    }).catch(() => process.exit(1));
}
",
    "name": "build.js",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-fern/fiddle-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"dist\\",
        \\"types\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"node\\": \\"./dist/node/index.js\\",
            \\"import\\": \\"./dist/browser/esm/index.js\\",
            \\"require\\": \\"./dist/browser/cjs/index.js\\",
            \\"default\\": \\"./dist/browser/cjs/index.js\\"
        },
        \\"./core\\": {
            \\"node\\": \\"./dist/node/core.js\\",
            \\"import\\": \\"./dist/browser/esm/core.js\\",
            \\"require\\": \\"./dist/browser/cjs/core.js\\",
            \\"default\\": \\"./dist/browser/cjs/core.js\\"
        },
        \\"./serialization\\": {
            \\"node\\": \\"./dist/node/serialization.js\\",
            \\"import\\": \\"./dist/browser/esm/serialization.js\\",
            \\"require\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"default\\": \\"./dist/browser/cjs/serialization.js\\"
        }
    },
    \\"types\\": \\"./types/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"compile\\": \\"tsc && tsc-alias\\",
        \\"bundle\\": \\"node build.js\\",
        \\"build\\": \\"yarn compile && yarn bundle\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.15\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Client as HealthClient } from \\"./resources/health/client/Client\\";
import { Client as RemoteGenClient } from \\"./resources/remoteGen/client/Client\\";

export declare namespace FernFiddleClient {
  interface Options {
    environment: string;
  }
}

export class FernFiddleClient {
  constructor(private readonly options: FernFiddleClient.Options) {}

  #health: HealthClient | undefined;

  public get health(): HealthClient {
    return (this.#health ??= new HealthClient(this.options));
  }

  #remoteGen: RemoteGenClient | undefined;

  public get remoteGen(): RemoteGenClient {
    return (this.#remoteGen ??= new RemoteGenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernFiddle from \\"./resources\\";
export { FernFiddleClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import urlJoin from \\"url-join\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async status(): Promise<FernFiddle.health.status.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/health/\\"),
      method: \\"GET\\",
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: FernFiddle.health.status.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as status from \\"./status\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernFiddle.health.status.Error>;
export type Error = FernFiddle.health.status.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.health.status.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.health.status.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernFiddle.health.status.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.health.status.Error._Unknown, visitor: FernFiddle.health.status.Error._Visitor<_Result>) {
      return FernFiddle.health.status.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.health.status.Error,
    visitor: FernFiddle.health.status.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "status.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "health",
            "type": "directory",
          },
          Object {
            "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * from \\"./remoteGen/errors\\";
export * as health from \\"./health\\";
export * from \\"./remoteGen/client/requests\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createJob(request: FernFiddle.CreateJobRequest): Promise<FernFiddle.remoteGen.createJob.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job\\"),
      method: \\"POST\\",
      body: await serializers.remoteGen.createJob.Request.json({
        apiName: request.apiName,
        organizationName: request.organizationName,
        version: request.version,
        generators: request.generators,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.createJob.Response.parse(
          _response.body as serializers.remoteGen.createJob.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.remoteGen.createJob.Error.Raw)?.error) {
        case \\"IllegalApiNameError\\":
        case \\"GeneratorsDoNotExistError\\":
        case \\"CannotPublishToNpmScope\\":
        case \\"CannotPublishToMavenGroup\\":
        case \\"InsufficientPermissions\\":
          return {
            ok: false,
            error: await serializers.remoteGen.createJob.Error.parse(
              _response.error.body as serializers.remoteGen.createJob.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.createJob.Error._unknown(_response.error),
    };
  }

  public async createJobV2(request: FernFiddle.CreateJobRequestV2): Promise<FernFiddle.remoteGen.createJobV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job-v2\\"),
      method: \\"POST\\",
      body: await serializers.remoteGen.createJobV2.Request.json({
        apiName: request.apiName,
        organizationName: request.organizationName,
        version: request.version,
        generators: request.generators,
        uploadToS3: request.uploadToS3,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.createJobV2.Response.parse(
          _response.body as serializers.remoteGen.createJobV2.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.remoteGen.createJobV2.Error.Raw)?.error) {
        case \\"IllegalApiNameError\\":
        case \\"GeneratorsDoNotExistError\\":
        case \\"CannotPublishToNpmScope\\":
        case \\"CannotPublishToMavenGroup\\":
        case \\"InsufficientPermissions\\":
          return {
            ok: false,
            error: await serializers.remoteGen.createJobV2.Error.parse(
              _response.error.body as serializers.remoteGen.createJobV2.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.createJobV2.Error._unknown(_response.error),
    };
  }

  public async getJobStatus(jobId: FernFiddle.RemoteGenJobId): Promise<FernFiddle.remoteGen.getJobStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/api/remote-gen/jobs/\${jobId}/status\`),
      method: \\"POST\\",
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.getJobStatus.Response.parse(
          _response.body as serializers.remoteGen.getJobStatus.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.getJobStatus.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernFiddle.CreateJobResponse, FernFiddle.remoteGen.createJob.Error>;
export type Error =
  | FernFiddle.remoteGen.createJob.Error.IllegalApiNameError
  | FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError
  | FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope
  | FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup
  | FernFiddle.remoteGen.createJob.Error.InsufficientPermissions
  | FernFiddle.remoteGen.createJob.Error._Unknown;

export declare namespace Error {
  interface IllegalApiNameError extends _Utils {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError extends _Utils {
    error: \\"GeneratorsDoNotExistError\\";
    content: FernFiddle.GeneratorsDoNotExistError;
  }

  interface CannotPublishToNpmScope extends _Utils {
    error: \\"CannotPublishToNpmScope\\";
    content: FernFiddle.CannotPublishToNpmScope;
  }

  interface CannotPublishToMavenGroup extends _Utils {
    error: \\"CannotPublishToMavenGroup\\";
    content: FernFiddle.CannotPublishToMavenGroup;
  }

  interface InsufficientPermissions extends _Utils {
    error: \\"InsufficientPermissions\\";
    content: FernFiddle.InsufficientPermissions;
  }

  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    illegalApiNameError: () => _Result;
    generatorsDoNotExistError: (value: FernFiddle.GeneratorsDoNotExistError) => _Result;
    cannotPublishToNpmScope: (value: FernFiddle.CannotPublishToNpmScope) => _Result;
    cannotPublishToMavenGroup: (value: FernFiddle.CannotPublishToMavenGroup) => _Result;
    insufficientPermissions: (value: FernFiddle.InsufficientPermissions) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  illegalApiNameError: (): FernFiddle.remoteGen.createJob.Error.IllegalApiNameError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.IllegalApiNameError, \\"_visit\\"> = {
      error: \\"IllegalApiNameError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.IllegalApiNameError, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  generatorsDoNotExistError: (
    value: FernFiddle.GeneratorsDoNotExistError
  ): FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError, \\"_visit\\"> = {
      content: value,
      error: \\"GeneratorsDoNotExistError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  cannotPublishToNpmScope: (
    value: FernFiddle.CannotPublishToNpmScope
  ): FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToNpmScope\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  cannotPublishToMavenGroup: (
    value: FernFiddle.CannotPublishToMavenGroup
  ): FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToMavenGroup\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  insufficientPermissions: (
    value: FernFiddle.InsufficientPermissions
  ): FernFiddle.remoteGen.createJob.Error.InsufficientPermissions => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.InsufficientPermissions, \\"_visit\\"> = {
      content: value,
      error: \\"InsufficientPermissions\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.InsufficientPermissions, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.createJob.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernFiddle.remoteGen.createJob.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error._Unknown, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.createJob.Error,
    visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      case \\"IllegalApiNameError\\":
        return visitor.illegalApiNameError();
      case \\"GeneratorsDoNotExistError\\":
        return visitor.generatorsDoNotExistError(value.content);
      case \\"CannotPublishToNpmScope\\":
        return visitor.cannotPublishToNpmScope(value.content);
      case \\"CannotPublishToMavenGroup\\":
        return visitor.cannotPublishToMavenGroup(value.content);
      case \\"InsufficientPermissions\\":
        return visitor.insufficientPermissions(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createJob.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernFiddle.CreateJobResponse, FernFiddle.remoteGen.createJobV2.Error>;
export type Error =
  | FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError
  | FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError
  | FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope
  | FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup
  | FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions
  | FernFiddle.remoteGen.createJobV2.Error._Unknown;

export declare namespace Error {
  interface IllegalApiNameError extends _Utils {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError extends _Utils {
    error: \\"GeneratorsDoNotExistError\\";
    content: FernFiddle.GeneratorsDoNotExistError;
  }

  interface CannotPublishToNpmScope extends _Utils {
    error: \\"CannotPublishToNpmScope\\";
    content: FernFiddle.CannotPublishToNpmScope;
  }

  interface CannotPublishToMavenGroup extends _Utils {
    error: \\"CannotPublishToMavenGroup\\";
    content: FernFiddle.CannotPublishToMavenGroup;
  }

  interface InsufficientPermissions extends _Utils {
    error: \\"InsufficientPermissions\\";
    content: FernFiddle.InsufficientPermissions;
  }

  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    illegalApiNameError: () => _Result;
    generatorsDoNotExistError: (value: FernFiddle.GeneratorsDoNotExistError) => _Result;
    cannotPublishToNpmScope: (value: FernFiddle.CannotPublishToNpmScope) => _Result;
    cannotPublishToMavenGroup: (value: FernFiddle.CannotPublishToMavenGroup) => _Result;
    insufficientPermissions: (value: FernFiddle.InsufficientPermissions) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  illegalApiNameError: (): FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError, \\"_visit\\"> = {
      error: \\"IllegalApiNameError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  generatorsDoNotExistError: (
    value: FernFiddle.GeneratorsDoNotExistError
  ): FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError, \\"_visit\\"> = {
      content: value,
      error: \\"GeneratorsDoNotExistError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  cannotPublishToNpmScope: (
    value: FernFiddle.CannotPublishToNpmScope
  ): FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToNpmScope\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  cannotPublishToMavenGroup: (
    value: FernFiddle.CannotPublishToMavenGroup
  ): FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToMavenGroup\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  insufficientPermissions: (
    value: FernFiddle.InsufficientPermissions
  ): FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions, \\"_visit\\"> = {
      content: value,
      error: \\"InsufficientPermissions\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.createJobV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      FernFiddle.remoteGen.createJobV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error._Unknown, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.createJobV2.Error,
    visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      case \\"IllegalApiNameError\\":
        return visitor.illegalApiNameError();
      case \\"GeneratorsDoNotExistError\\":
        return visitor.generatorsDoNotExistError(value.content);
      case \\"CannotPublishToNpmScope\\":
        return visitor.cannotPublishToNpmScope(value.content);
      case \\"CannotPublishToMavenGroup\\":
        return visitor.cannotPublishToMavenGroup(value.content);
      case \\"InsufficientPermissions\\":
        return visitor.insufficientPermissions(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createJobV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<FernFiddle.RemoteGenTaskId, FernFiddle.Task>,
  FernFiddle.remoteGen.getJobStatus.Error
>;
export type Error = FernFiddle.remoteGen.getJobStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.getJobStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      FernFiddle.remoteGen.getJobStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.getJobStatus.Error._Unknown, visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.getJobStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.getJobStatus.Error,
    visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getJobStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createJob from \\"./createJob\\";
export * from \\"./requests\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequest {
  apiName: string;
  organizationName: string;
  version?: string;
  generators: FernFiddle.GeneratorConfig[];
}
",
                        "name": "CreateJobRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequestV2 {
  apiName: string;
  organizationName: string;
  version?: string;
  generators: FernFiddle.GeneratorConfigV2[];
  uploadToS3?: boolean;
}
",
                        "name": "CreateJobRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateJobRequest } from \\"./CreateJobRequest\\";
export { CreateJobRequestV2 } from \\"./CreateJobRequestV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type CannotPublishToMavenGroup = FernFiddle.CannotPublishToMavenGroupDetails;
",
                    "name": "CannotPublishToMavenGroup.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type CannotPublishToNpmScope = FernFiddle.CannotPublishToNpmScopeDetails;
",
                    "name": "CannotPublishToNpmScope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type GeneratorsDoNotExistError = FernFiddle.GeneratorsDoNotExistErrorBodyType;
",
                    "name": "GeneratorsDoNotExistError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type InsufficientPermissions = FernFiddle.InsufficientPermissionsDetails;
",
                    "name": "InsufficientPermissions.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./GeneratorsDoNotExistError\\";
export * from \\"./CannotPublishToNpmScope\\";
export * from \\"./CannotPublishToMavenGroup\\";
export * from \\"./InsufficientPermissions\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "remoteGen",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * from \\"./remoteGen/errors\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.remoteGen.createJob.Request.Raw, FernFiddle.CreateJobRequest> =
  core.schemas.object({
    apiName: core.schemas.string(),
    organizationName: core.schemas.string(),
    version: core.schemas.string().optional(),
    generators: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorConfig)),
  });

export declare namespace Request {
  interface Raw {
    apiName: string;
    organizationName: string;
    version?: string | null;
    generators: serializers.GeneratorConfig.Raw[];
  }
}

export const Response: core.schemas.Schema<serializers.remoteGen.createJob.Response.Raw, FernFiddle.CreateJobResponse> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateJobResponse);

export declare namespace Response {
  type Raw = serializers.CreateJobResponse.Raw;
}

export const Error: core.schemas.Schema<
  serializers.remoteGen.createJob.Error.Raw,
  FernFiddle.remoteGen.createJob.Error
> = core.schemas
  .union(\\"error\\", {
    IllegalApiNameError: core.schemas.object({}),
    GeneratorsDoNotExistError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).GeneratorsDoNotExistError),
    }),
    CannotPublishToNpmScope: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToNpmScope),
    }),
    CannotPublishToMavenGroup: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToMavenGroup),
    }),
    InsufficientPermissions: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).InsufficientPermissions),
    }),
  })
  .transform<FernFiddle.remoteGen.createJob.Error>({
    parse: (value) => {
      switch (value.error) {
        case \\"IllegalApiNameError\\":
          return FernFiddle.remoteGen.createJob.Error.illegalApiNameError();
        case \\"GeneratorsDoNotExistError\\":
          return FernFiddle.remoteGen.createJob.Error.generatorsDoNotExistError(value.content);
        case \\"CannotPublishToNpmScope\\":
          return FernFiddle.remoteGen.createJob.Error.cannotPublishToNpmScope(value.content);
        case \\"CannotPublishToMavenGroup\\":
          return FernFiddle.remoteGen.createJob.Error.cannotPublishToMavenGroup(value.content);
        case \\"InsufficientPermissions\\":
          return FernFiddle.remoteGen.createJob.Error.insufficientPermissions(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw =
    | Error.IllegalApiNameError
    | Error.GeneratorsDoNotExistError
    | Error.CannotPublishToNpmScope
    | Error.CannotPublishToMavenGroup
    | Error.InsufficientPermissions;

  interface IllegalApiNameError {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError {
    error: \\"GeneratorsDoNotExistError\\";
    content: serializers.GeneratorsDoNotExistError.Raw;
  }

  interface CannotPublishToNpmScope {
    error: \\"CannotPublishToNpmScope\\";
    content: serializers.CannotPublishToNpmScope.Raw;
  }

  interface CannotPublishToMavenGroup {
    error: \\"CannotPublishToMavenGroup\\";
    content: serializers.CannotPublishToMavenGroup.Raw;
  }

  interface InsufficientPermissions {
    error: \\"InsufficientPermissions\\";
    content: serializers.InsufficientPermissions.Raw;
  }
}
",
                    "name": "createJob.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Request.Raw,
  FernFiddle.CreateJobRequestV2
> = core.schemas.object({
  apiName: core.schemas.string(),
  organizationName: core.schemas.string(),
  version: core.schemas.string().optional(),
  generators: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorConfigV2)),
  uploadToS3: core.schemas.boolean().optional(),
});

export declare namespace Request {
  interface Raw {
    apiName: string;
    organizationName: string;
    version?: string | null;
    generators: serializers.GeneratorConfigV2.Raw[];
    uploadToS3?: boolean | null;
  }
}

export const Response: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Response.Raw,
  FernFiddle.CreateJobResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateJobResponse);

export declare namespace Response {
  type Raw = serializers.CreateJobResponse.Raw;
}

export const Error: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Error.Raw,
  FernFiddle.remoteGen.createJobV2.Error
> = core.schemas
  .union(\\"error\\", {
    IllegalApiNameError: core.schemas.object({}),
    GeneratorsDoNotExistError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).GeneratorsDoNotExistError),
    }),
    CannotPublishToNpmScope: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToNpmScope),
    }),
    CannotPublishToMavenGroup: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToMavenGroup),
    }),
    InsufficientPermissions: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).InsufficientPermissions),
    }),
  })
  .transform<FernFiddle.remoteGen.createJobV2.Error>({
    parse: (value) => {
      switch (value.error) {
        case \\"IllegalApiNameError\\":
          return FernFiddle.remoteGen.createJobV2.Error.illegalApiNameError();
        case \\"GeneratorsDoNotExistError\\":
          return FernFiddle.remoteGen.createJobV2.Error.generatorsDoNotExistError(value.content);
        case \\"CannotPublishToNpmScope\\":
          return FernFiddle.remoteGen.createJobV2.Error.cannotPublishToNpmScope(value.content);
        case \\"CannotPublishToMavenGroup\\":
          return FernFiddle.remoteGen.createJobV2.Error.cannotPublishToMavenGroup(value.content);
        case \\"InsufficientPermissions\\":
          return FernFiddle.remoteGen.createJobV2.Error.insufficientPermissions(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw =
    | Error.IllegalApiNameError
    | Error.GeneratorsDoNotExistError
    | Error.CannotPublishToNpmScope
    | Error.CannotPublishToMavenGroup
    | Error.InsufficientPermissions;

  interface IllegalApiNameError {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError {
    error: \\"GeneratorsDoNotExistError\\";
    content: serializers.GeneratorsDoNotExistError.Raw;
  }

  interface CannotPublishToNpmScope {
    error: \\"CannotPublishToNpmScope\\";
    content: serializers.CannotPublishToNpmScope.Raw;
  }

  interface CannotPublishToMavenGroup {
    error: \\"CannotPublishToMavenGroup\\";
    content: serializers.CannotPublishToMavenGroup.Raw;
  }

  interface InsufficientPermissions {
    error: \\"InsufficientPermissions\\";
    content: serializers.InsufficientPermissions.Raw;
  }
}
",
                    "name": "createJobV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.remoteGen.getJobStatus.Response.Raw,
  Record<FernFiddle.RemoteGenTaskId, FernFiddle.Task>
> = core.schemas.record(
  core.schemas.lazy(async () => (await import(\\"../..\\")).RemoteGenTaskId),
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Task)
);

export declare namespace Response {
  type Raw = Record<serializers.RemoteGenTaskId.Raw, serializers.Task.Raw>;
}
",
                    "name": "getJobStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createJob from \\"./createJob\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToMavenGroup: core.schemas.Schema<
  serializers.CannotPublishToMavenGroup.Raw,
  FernFiddle.CannotPublishToMavenGroup
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CannotPublishToMavenGroupDetails);

export declare namespace CannotPublishToMavenGroup {
  type Raw = serializers.CannotPublishToMavenGroupDetails.Raw;
}
",
                    "name": "CannotPublishToMavenGroup.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToNpmScope: core.schemas.Schema<
  serializers.CannotPublishToNpmScope.Raw,
  FernFiddle.CannotPublishToNpmScope
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CannotPublishToNpmScopeDetails);

export declare namespace CannotPublishToNpmScope {
  type Raw = serializers.CannotPublishToNpmScopeDetails.Raw;
}
",
                    "name": "CannotPublishToNpmScope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorsDoNotExistError: core.schemas.Schema<
  serializers.GeneratorsDoNotExistError.Raw,
  FernFiddle.GeneratorsDoNotExistError
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorsDoNotExistErrorBodyType);

export declare namespace GeneratorsDoNotExistError {
  type Raw = serializers.GeneratorsDoNotExistErrorBodyType.Raw;
}
",
                    "name": "GeneratorsDoNotExistError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const InsufficientPermissions: core.schemas.Schema<
  serializers.InsufficientPermissions.Raw,
  FernFiddle.InsufficientPermissions
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).InsufficientPermissionsDetails);

export declare namespace InsufficientPermissions {
  type Raw = serializers.InsufficientPermissionsDetails.Raw;
}
",
                    "name": "InsufficientPermissions.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./GeneratorsDoNotExistError\\";
export * from \\"./CannotPublishToNpmScope\\";
export * from \\"./CannotPublishToMavenGroup\\";
export * from \\"./InsufficientPermissions\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "remoteGen",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-fern/fiddle-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator nursery 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access restricted
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
types/
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "const { build } = require(\\"esbuild\\");

void main();

async function main() {
    await bundle({
        platform: \\"node\\",
        target: \\"node14\\",
        format: \\"cjs\\",
        outdir: \\"node\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"esm\\",
        outdir: \\"browser/esm\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"cjs\\",
        outdir: \\"browser/cjs\\",
    });
}

async function bundle({ platform, target, format, outdir }) {
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/index.ts\\",
        outfile: \`./dist/\${outdir}/index.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/core/index.ts\\",
        outfile: \`./dist/\${outdir}/core.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/serialization/index.ts\\",
        outfile: \`./dist/\${outdir}/serialization.js\`,
    });
}

async function runEsbuild({ platform, target, format, entryPoint, outfile }) {
    await build({
        platform,
        target,
        format,
        entryPoints: [entryPoint],
        outfile,
        bundle: true,
        alias: {
            // matches up with tsconfig paths
            \\"@fern/api\\": \\"./src\\",
        }
    }).catch(() => process.exit(1));
}
",
    "name": "build.js",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.1\\",
    \\"private\\": true,
    \\"repository\\": \\"https://github.com/fern/api}\\",
    \\"files\\": [
        \\"dist\\",
        \\"types\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"node\\": \\"./dist/node/index.js\\",
            \\"import\\": \\"./dist/browser/esm/index.js\\",
            \\"require\\": \\"./dist/browser/cjs/index.js\\",
            \\"default\\": \\"./dist/browser/cjs/index.js\\"
        },
        \\"./core\\": {
            \\"node\\": \\"./dist/node/core.js\\",
            \\"import\\": \\"./dist/browser/esm/core.js\\",
            \\"require\\": \\"./dist/browser/cjs/core.js\\",
            \\"default\\": \\"./dist/browser/cjs/core.js\\"
        },
        \\"./serialization\\": {
            \\"node\\": \\"./dist/node/serialization.js\\",
            \\"import\\": \\"./dist/browser/esm/serialization.js\\",
            \\"require\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"default\\": \\"./dist/browser/cjs/serialization.js\\"
        }
    },
    \\"types\\": \\"./types/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"compile\\": \\"tsc && tsc-alias\\",
        \\"bundle\\": \\"node build.js\\",
        \\"build\\": \\"yarn compile && yarn bundle\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.15\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Client as OwnerClient } from \\"./resources/owner/client/Client\\";
import { Client as TokenClient } from \\"./resources/token/client/Client\\";

export declare namespace FernApiClient {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class FernApiClient {
  constructor(private readonly options: FernApiClient.Options) {}

  #owner: OwnerClient | undefined;

  public get owner(): OwnerClient {
    return (this.#owner ??= new OwnerClient(this.options));
  }

  #token: TokenClient | undefined;

  public get token(): TokenClient {
    return (this.#token ??= new TokenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
export { FernApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateOwnerRequest): Promise<FernApi.owner.create.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/owner/\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.owner.create.Request.json({
        ownerId: request.ownerId,
        data: request.data,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 400:
          return {
            ok: false,
            error: FernApi.owner.create.Error.ownerAlreadyExistsError(
              await serializers.OwnerAlreadyExistsError.parse(
                _response.error.body as serializers.OwnerAlreadyExistsError.Raw
              )
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.create.Error._unknown(_response.error),
    };
  }

  public async get(ownerId: FernApi.OwnerId): Promise<FernApi.owner.get.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.owner.get.Response.parse(_response.body as serializers.owner.get.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.owner.get.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.get.Error._unknown(_response.error),
    };
  }

  public async update(
    ownerId: FernApi.OwnerId,
    request: FernApi.UpdateOwnerRequest
  ): Promise<FernApi.owner.update.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${ownerId}\`),
      method: \\"PUT\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.owner.update.Request.json({
        data: request.data,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.owner.update.Response.parse(_response.body as serializers.owner.update.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.owner.update.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.update.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernApi.owner.create.Error>;
export type Error = FernApi.owner.create.Error.OwnerAlreadyExistsError | FernApi.owner.create.Error._Unknown;

export declare namespace Error {
  interface OwnerAlreadyExistsError extends _Utils {
    statusCode: 400;
    content: FernApi.OwnerAlreadyExistsError;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerAlreadyExistsError: (value: FernApi.OwnerAlreadyExistsError) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerAlreadyExistsError: (
    value: FernApi.OwnerAlreadyExistsError
  ): FernApi.owner.create.Error.OwnerAlreadyExistsError => {
    const valueWithoutVisit: Omit<FernApi.owner.create.Error.OwnerAlreadyExistsError, \\"_visit\\"> = {
      content: value,
      statusCode: 400,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.create.Error.OwnerAlreadyExistsError, visitor: FernApi.owner.create.Error._Visitor<_Result>) {
      return FernApi.owner.create.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.create.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.create.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.create.Error._Unknown, visitor: FernApi.owner.create.Error._Visitor<_Result>) {
      return FernApi.owner.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.create.Error,
    visitor: FernApi.owner.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 400:
        return visitor.ownerAlreadyExistsError(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.get.Error>;
export type Error = FernApi.owner.get.Error.OwnerNotFoundError | FernApi.owner.get.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.get.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.get.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.get.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.get.Error.OwnerNotFoundError, visitor: FernApi.owner.get.Error._Visitor<_Result>) {
      return FernApi.owner.get.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.get.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.get.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.get.Error._Unknown, visitor: FernApi.owner.get.Error._Visitor<_Result>) {
      return FernApi.owner.get.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernApi.owner.get.Error, visitor: FernApi.owner.get.Error._Visitor<_Result>): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * from \\"./requests\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateOwnerRequest {
  ownerId: FernApi.OwnerId;
  data?: unknown;
}
",
                        "name": "CreateOwnerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
  data?: unknown;
}
",
                        "name": "UpdateOwnerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.update.Error>;
export type Error = FernApi.owner.update.Error.OwnerNotFoundError | FernApi.owner.update.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.update.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.update.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.update.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.update.Error.OwnerNotFoundError, visitor: FernApi.owner.update.Error._Visitor<_Result>) {
      return FernApi.owner.update.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.update.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.update.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.update.Error._Unknown, visitor: FernApi.owner.update.Error._Visitor<_Result>) {
      return FernApi.owner.update.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.update.Error,
    visitor: FernApi.owner.update.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export type OwnerAlreadyExistsError = FernApi.OwnerId;
",
                    "name": "OwnerAlreadyExistsError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerAlreadyExistsError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateTokenRequest): Promise<FernApi.token.create.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/create\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.token.create.Request.json({
        ownerId: request.ownerId,
        description: request.description,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.create.Response.parse(_response.body as serializers.token.create.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.create.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.create.Error._unknown(_response.error),
    };
  }

  public async getTokenMetadata(
    request: FernApi.GetTokenMetadataRequest
  ): Promise<FernApi.token.getTokenMetadata.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/metadata\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.token.getTokenMetadata.Request.json({
        token: request.token,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.getTokenMetadata.Response.parse(
          _response.body as serializers.token.getTokenMetadata.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.getTokenMetadata.Error.tokenNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.getTokenMetadata.Error._unknown(_response.error),
    };
  }

  public async getTokensForOwner(ownerId: FernApi.OwnerId): Promise<FernApi.token.getTokensForOwner.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/tokens/owner/\${ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.getTokensForOwner.Response.parse(
          _response.body as serializers.token.getTokensForOwner.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.getTokensForOwner.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.getTokensForOwner.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.CreateTokenResponse, FernApi.token.create.Error>;
export type Error = FernApi.token.create.Error.OwnerNotFoundError | FernApi.token.create.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.create.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.create.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.create.Error.OwnerNotFoundError, visitor: FernApi.token.create.Error._Visitor<_Result>) {
      return FernApi.token.create.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.create.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.create.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.create.Error._Unknown, visitor: FernApi.token.create.Error._Visitor<_Result>) {
      return FernApi.token.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.create.Error,
    visitor: FernApi.token.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.TokenMetadata, FernApi.token.getTokenMetadata.Error>;
export type Error =
  | FernApi.token.getTokenMetadata.Error.TokenNotFoundError
  | FernApi.token.getTokenMetadata.Error._Unknown;

export declare namespace Error {
  interface TokenNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    tokenNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  tokenNotFoundError: (): FernApi.token.getTokenMetadata.Error.TokenNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokenMetadata.Error.TokenNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokenMetadata.Error.TokenNotFoundError, visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) {
      return FernApi.token.getTokenMetadata.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.getTokenMetadata.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.getTokenMetadata.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokenMetadata.Error._Unknown, visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) {
      return FernApi.token.getTokenMetadata.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokenMetadata.Error,
    visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.tokenNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.TokenMetadata[], FernApi.token.getTokensForOwner.Error>;
export type Error =
  | FernApi.token.getTokensForOwner.Error.OwnerNotFoundError
  | FernApi.token.getTokensForOwner.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.getTokensForOwner.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) {
      return FernApi.token.getTokensForOwner.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.getTokensForOwner.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.getTokensForOwner.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokensForOwner.Error._Unknown, visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) {
      return FernApi.token.getTokensForOwner.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokensForOwner.Error,
    visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * from \\"./requests\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenRequest {
  ownerId: FernApi.OwnerId;
  description?: string;
}
",
                        "name": "CreateTokenRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
  token: string;
}
",
                        "name": "GetTokenMetadataRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.owner.create.Request.Raw, FernApi.CreateOwnerRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
    data: core.schemas.unknown(),
  });

export declare namespace Request {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.owner.get.Response.Raw, FernApi.Owner> = core.schemas.lazyObject(
  async () => (await import(\\"../..\\")).Owner
);

export declare namespace Response {
  type Raw = serializers.Owner.Raw;
}
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.owner.update.Request.Raw, FernApi.UpdateOwnerRequest> =
  core.schemas.object({
    data: core.schemas.unknown(),
  });

export declare namespace Request {
  interface Raw {
    data?: unknown;
  }
}

export const Response: core.schemas.Schema<serializers.owner.update.Response.Raw, FernApi.Owner> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Owner);

export declare namespace Response {
  type Raw = serializers.Owner.Raw;
}
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const OwnerAlreadyExistsError: core.schemas.Schema<
  serializers.OwnerAlreadyExistsError.Raw,
  FernApi.OwnerAlreadyExistsError
> = core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId);

export declare namespace OwnerAlreadyExistsError {
  type Raw = serializers.OwnerId.Raw;
}
",
                    "name": "OwnerAlreadyExistsError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerAlreadyExistsError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.token.create.Request.Raw, FernApi.CreateTokenRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
    description: core.schemas.string().optional(),
  });

export declare namespace Request {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    description?: string | null;
  }
}

export const Response: core.schemas.Schema<serializers.token.create.Response.Raw, FernApi.CreateTokenResponse> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateTokenResponse);

export declare namespace Response {
  type Raw = serializers.CreateTokenResponse.Raw;
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.token.getTokenMetadata.Request.Raw,
  FernApi.GetTokenMetadataRequest
> = core.schemas.object({
  token: core.schemas.string(),
});

export declare namespace Request {
  interface Raw {
    token: string;
  }
}

export const Response: core.schemas.Schema<serializers.token.getTokenMetadata.Response.Raw, FernApi.TokenMetadata> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).TokenMetadata);

export declare namespace Response {
  type Raw = serializers.TokenMetadata.Raw;
}
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.token.getTokensForOwner.Response.Raw, FernApi.TokenMetadata[]> =
  core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TokenMetadata));

export declare namespace Response {
  type Raw = serializers.TokenMetadata.Raw[];
}
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
types/
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "const { build } = require(\\"esbuild\\");

void main();

async function main() {
    await bundle({
        platform: \\"node\\",
        target: \\"node14\\",
        format: \\"cjs\\",
        outdir: \\"node\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"esm\\",
        outdir: \\"browser/esm\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"cjs\\",
        outdir: \\"browser/cjs\\",
    });
}

async function bundle({ platform, target, format, outdir }) {
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/index.ts\\",
        outfile: \`./dist/\${outdir}/index.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/core/index.ts\\",
        outfile: \`./dist/\${outdir}/core.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/serialization/index.ts\\",
        outfile: \`./dist/\${outdir}/serialization.js\`,
    });
}

async function runEsbuild({ platform, target, format, entryPoint, outfile }) {
    await build({
        platform,
        target,
        format,
        entryPoints: [entryPoint],
        outfile,
        bundle: true,
        alias: {
            // matches up with tsconfig paths
            \\"@fern/api\\": \\"./src\\",
        }
    }).catch(() => process.exit(1));
}
",
    "name": "build.js",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.0\\",
    \\"private\\": false,
    \\"files\\": [
        \\"dist\\",
        \\"types\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"node\\": \\"./dist/node/index.js\\",
            \\"import\\": \\"./dist/browser/esm/index.js\\",
            \\"require\\": \\"./dist/browser/cjs/index.js\\",
            \\"default\\": \\"./dist/browser/cjs/index.js\\"
        },
        \\"./core\\": {
            \\"node\\": \\"./dist/node/core.js\\",
            \\"import\\": \\"./dist/browser/esm/core.js\\",
            \\"require\\": \\"./dist/browser/cjs/core.js\\",
            \\"default\\": \\"./dist/browser/cjs/core.js\\"
        },
        \\"./serialization\\": {
            \\"node\\": \\"./dist/node/serialization.js\\",
            \\"import\\": \\"./dist/browser/esm/serialization.js\\",
            \\"require\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"default\\": \\"./dist/browser/cjs/serialization.js\\"
        }
    },
    \\"types\\": \\"./types/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"compile\\": \\"tsc && tsc-alias\\",
        \\"bundle\\": \\"node build.js\\",
        \\"build\\": \\"yarn compile && yarn bundle\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.15\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\",
        \\"tsc-alias\\": \\"^1.7.1\\"
    }
}",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
types/
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "const { build } = require(\\"esbuild\\");

void main();

async function main() {
    await bundle({
        platform: \\"node\\",
        target: \\"node14\\",
        format: \\"cjs\\",
        outdir: \\"node\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"esm\\",
        outdir: \\"browser/esm\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"cjs\\",
        outdir: \\"browser/cjs\\",
    });
}

async function bundle({ platform, target, format, outdir }) {
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/index.ts\\",
        outfile: \`./dist/\${outdir}/index.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/core/index.ts\\",
        outfile: \`./dist/\${outdir}/core.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/serialization/index.ts\\",
        outfile: \`./dist/\${outdir}/serialization.js\`,
    });
}

async function runEsbuild({ platform, target, format, entryPoint, outfile }) {
    await build({
        platform,
        target,
        format,
        entryPoints: [entryPoint],
        outfile,
        bundle: true,
        alias: {
            // matches up with tsconfig paths
            \\"@fern-trace/api-sdk\\": \\"./src\\",
        }
    }).catch(() => process.exit(1));
}
",
    "name": "build.js",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"dist\\",
        \\"types\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"node\\": \\"./dist/node/index.js\\",
            \\"import\\": \\"./dist/browser/esm/index.js\\",
            \\"require\\": \\"./dist/browser/cjs/index.js\\",
            \\"default\\": \\"./dist/browser/cjs/index.js\\"
        },
        \\"./core\\": {
            \\"node\\": \\"./dist/node/core.js\\",
            \\"import\\": \\"./dist/browser/esm/core.js\\",
            \\"require\\": \\"./dist/browser/cjs/core.js\\",
            \\"default\\": \\"./dist/browser/cjs/core.js\\"
        },
        \\"./serialization\\": {
            \\"node\\": \\"./dist/node/serialization.js\\",
            \\"import\\": \\"./dist/browser/esm/serialization.js\\",
            \\"require\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"default\\": \\"./dist/browser/cjs/serialization.js\\"
        }
    },
    \\"types\\": \\"./types/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"compile\\": \\"tsc && tsc-alias\\",
        \\"bundle\\": \\"node build.js\\",
        \\"build\\": \\"yarn compile && yarn bundle\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"buffer\\": \\"^6.0.3\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.15\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import * as core from \\"./core\\";
import { Client as AdminClient } from \\"./resources/admin/client/Client\\";
import { Client as HomepageClient } from \\"./resources/homepage/client/Client\\";
import { Client as MigrationClient } from \\"./resources/migration/client/Client\\";
import { Client as PlaylistClient } from \\"./resources/playlist/client/Client\\";
import { Client as ProblemClient } from \\"./resources/problem/client/Client\\";
import { Client as SubmissionClient } from \\"./resources/submission/client/Client\\";
import { Client as SyspropClient } from \\"./resources/sysprop/client/Client\\";
import { Client as V2Client } from \\"./resources/v2/client/Client\\";

export declare namespace TraceApiClient {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class TraceApiClient {
  constructor(private readonly options: TraceApiClient.Options) {}

  #admin: AdminClient | undefined;

  public get admin(): AdminClient {
    return (this.#admin ??= new AdminClient(this.options));
  }

  #homepage: HomepageClient | undefined;

  public get homepage(): HomepageClient {
    return (this.#homepage ??= new HomepageClient(this.options));
  }

  #migration: MigrationClient | undefined;

  public get migration(): MigrationClient {
    return (this.#migration ??= new MigrationClient(this.options));
  }

  #playlist: PlaylistClient | undefined;

  public get playlist(): PlaylistClient {
    return (this.#playlist ??= new PlaylistClient(this.options));
  }

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #submission: SubmissionClient | undefined;

  public get submission(): SubmissionClient {
    return (this.#submission ??= new SubmissionClient(this.options));
  }

  #sysprop: SyspropClient | undefined;

  public get sysprop(): SyspropClient {
    return (this.#sysprop ??= new SyspropClient(this.options));
  }

  #v2: V2Client | undefined;

  public get v2(): V2Client {
    return (this.#v2 ??= new V2Client(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
    if (basicAuth == null) {
      return undefined;
    }
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
                "name": "BasicAuth.ts",
                "type": "file",
              },
              Object {
                "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
    if (token == null) {
      return undefined;
    }
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
                "name": "BearerToken.ts",
                "type": "file",
              },
              Object {
                "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "auth",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
export * from \\"./auth\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const Environment = {
  Prod: \\"prod.trace.com\\",
  /**
   * i'm staging
   */
  Staging: \\"staging.trace.com\\",
} as const;

export type Environment = typeof Environment.Prod | typeof Environment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": "export * as TraceApi from \\"./resources\\";
export { TraceApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TestSubmissionStatus
  ): Promise<TraceApi.admin.updateTestSubmissionStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.updateTestSubmissionStatus.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.updateTestSubmissionStatus.Error._unknown(_response.error),
    };
  }

  public async sendTestSubmissionUpdate(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TestSubmissionUpdate
  ): Promise<TraceApi.admin.sendTestSubmissionUpdate.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status-v2/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.sendTestSubmissionUpdate.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.sendTestSubmissionUpdate.Error._unknown(_response.error),
    };
  }

  public async updateWorkspaceSubmissionStatus(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.WorkspaceSubmissionStatus
  ): Promise<TraceApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.updateWorkspaceSubmissionStatus.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._unknown(_response.error),
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.WorkspaceSubmissionUpdate
  ): Promise<TraceApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status-v2/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.sendWorkspaceSubmissionUpdate.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._unknown(_response.error),
    };
  }

  public async storeTracedTestCase(
    submissionId: TraceApi.SubmissionId,
    testCaseId: string,
    request: TraceApi.StoreTracedTestCaseRequest
  ): Promise<TraceApi.admin.storeTracedTestCase.Response> {
    const _queryParams = new URLSearchParams();
    if (request.someQueryParam != null) {
      _queryParams.append(\\"some-query-param\\", request.someQueryParam);
    }

    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace/submission/\${submissionId}/testCase/\${testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
      body: await serializers.admin.storeTracedTestCase.Request.json({
        result: request.result,
        traceResponses: request.traceResponses,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedTestCase.Error._unknown(_response.error),
    };
  }

  public async storeTracedTestCaseV2(
    submissionId: TraceApi.SubmissionId,
    testCaseId: TraceApi.v2.TestCaseId,
    request: TraceApi.TraceResponseV2[]
  ): Promise<TraceApi.admin.storeTracedTestCaseV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace-v2/submission/\${submissionId}/testCase/\${testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedTestCaseV2.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedTestCaseV2.Error._unknown(_response.error),
    };
  }

  public async storeTracedWorkspace(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.StoreTracedWorkspaceRequest
  ): Promise<TraceApi.admin.storeTracedWorkspace.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace/submission/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedWorkspace.Request.json({
        workspaceRunDetails: request.workspaceRunDetails,
        traceResponses: request.traceResponses,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedWorkspace.Error._unknown(_response.error),
    };
  }

  public async storeTracedWorkspaceV2(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TraceResponseV2[]
  ): Promise<TraceApi.admin.storeTracedWorkspaceV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace-v2/submission/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedWorkspaceV2.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedWorkspaceV2.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * from \\"./requests\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedTestCaseRequest {
  someQueryParam?: string;
  result: TraceApi.TestCaseResultWithStdout;
  traceResponses: TraceApi.TraceResponse[];
}
",
                        "name": "StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: TraceApi.WorkspaceRunDetails;
  traceResponses: TraceApi.TraceResponse[];
}
",
                        "name": "StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { StoreTracedTestCaseRequest } from \\"./StoreTracedTestCaseRequest\\";
export { StoreTracedWorkspaceRequest } from \\"./StoreTracedWorkspaceRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.sendTestSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown, visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) {
      return TraceApi.admin.sendTestSubmissionUpdate.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.sendTestSubmissionUpdate.Error,
    visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.sendWorkspaceSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown, visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) {
      return TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error,
    visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCase.Error>;
export type Error = TraceApi.admin.storeTracedTestCase.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCase.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedTestCase.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedTestCase.Error._Unknown, visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedTestCase.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedTestCase.Error,
    visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCaseV2.Error>;
export type Error = TraceApi.admin.storeTracedTestCaseV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCaseV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedTestCaseV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedTestCaseV2.Error._Unknown, visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedTestCaseV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedTestCaseV2.Error,
    visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspace.Error>;
export type Error = TraceApi.admin.storeTracedWorkspace.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspace.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedWorkspace.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedWorkspace.Error._Unknown, visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedWorkspace.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedWorkspace.Error,
    visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspaceV2.Error>;
export type Error = TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown, visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedWorkspaceV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedWorkspaceV2.Error,
    visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.updateTestSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateTestSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateTestSubmissionStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.updateTestSubmissionStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.updateTestSubmissionStatus.Error._Unknown, visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) {
      return TraceApi.admin.updateTestSubmissionStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.updateTestSubmissionStatus.Error,
    visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.updateWorkspaceSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown, visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) {
      return TraceApi.admin.updateWorkspaceSubmissionStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.updateWorkspaceSubmissionStatus.Error,
    visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<TraceApi.homepage.getHomepageProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.homepage.getHomepageProblems.Response.parse(
          _response.body as serializers.homepage.getHomepageProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.homepage.getHomepageProblems.Error._unknown(_response.error),
    };
  }

  public async setHomepageProblems(
    request: TraceApi.ProblemId[]
  ): Promise<TraceApi.homepage.setHomepageProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.homepage.setHomepageProblems.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.homepage.setHomepageProblems.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.ProblemId[], TraceApi.homepage.getHomepageProblems.Error>;
export type Error = TraceApi.homepage.getHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.getHomepageProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.homepage.getHomepageProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.homepage.getHomepageProblems.Error._Unknown, visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) {
      return TraceApi.homepage.getHomepageProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.homepage.getHomepageProblems.Error,
    visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.homepage.setHomepageProblems.Error>;
export type Error = TraceApi.homepage.setHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.setHomepageProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.homepage.setHomepageProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.homepage.setHomepageProblems.Error._Unknown, visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) {
      return TraceApi.homepage.setHomepageProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.homepage.setHomepageProblems.Error,
    visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as admin from \\"./admin\\";
export * from \\"./admin/client/requests\\";
export * as homepage from \\"./homepage\\";
export * from \\"./playlist/client/requests\\";
export * from \\"./problem/client/requests\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<TraceApi.migration.getAttemptedMigrations.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.migration.getAttemptedMigrations.Response.parse(
          _response.body as serializers.migration.getAttemptedMigrations.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.migration.getAttemptedMigrations.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Migration[], TraceApi.migration.getAttemptedMigrations.Error>;
export type Error = TraceApi.migration.getAttemptedMigrations.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.migration.getAttemptedMigrations.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.migration.getAttemptedMigrations.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.migration.getAttemptedMigrations.Error._Unknown, visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) {
      return TraceApi.migration.getAttemptedMigrations.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.migration.getAttemptedMigrations.Error,
    visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    serviceParam: number,
    request: TraceApi.PlaylistCreateRequestWrapper
  ): Promise<TraceApi.playlist.createPlaylist.Response> {
    const _queryParams = new URLSearchParams();
    if (Array.isArray(request.multiple)) {
      for (const _item of request.multiple) {
        _queryParams.append(\\"multiple\\", _item.toString());
      }
    } else {
      _queryParams.append(\\"multiple\\", request.multiple.toString());
    }

    if (request.multipleOptional != null) {
      if (Array.isArray(request.multipleOptional)) {
        for (const _item of request.multipleOptional) {
          _queryParams.append(\\"multipleOptional\\", _item.toString());
        }
      } else {
        _queryParams.append(\\"multipleOptional\\", request.multipleOptional.toString());
      }
    }

    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/v2/playlist/\${serviceParam}/create\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
      body: await serializers.playlist.createPlaylist.Request.json(request.body),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.createPlaylist.Response.parse(
          _response.body as serializers.playlist.createPlaylist.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.createPlaylist.Error._unknown(_response.error),
    };
  }

  public async getPlaylists(
    serviceParam: number,
    request: TraceApi.GetPlaylistsRequest
  ): Promise<TraceApi.playlist.getPlaylists.Response> {
    const _queryParams = new URLSearchParams();
    if (request.limit != null) {
      _queryParams.append(\\"limit\\", request.limit.toString());
    }

    _queryParams.append(\\"otherField\\", request.otherField);
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/v2/playlist/\${serviceParam}/all\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.getPlaylists.Response.parse(
          _response.body as serializers.playlist.getPlaylists.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.getPlaylists.Error._unknown(_response.error),
    };
  }

  public async getPlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId
  ): Promise<TraceApi.playlist.getPlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.getPlaylist.Response.parse(
          _response.body as serializers.playlist.getPlaylist.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.playlist.getPlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: await serializers.playlist.getPlaylist.Error.parse(
              _response.error.body as serializers.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: TraceApi.playlist.getPlaylist.Error._unknown(_response.error),
    };
  }

  public async updatePlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId,
    request?: TraceApi.UpdatePlaylistRequest
  ): Promise<TraceApi.playlist.updatePlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.playlist.updatePlaylist.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.updatePlaylist.Response.parse(
          _response.body as serializers.playlist.updatePlaylist.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.playlist.updatePlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: await serializers.playlist.updatePlaylist.Error.parse(
              _response.error.body as serializers.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: TraceApi.playlist.updatePlaylist.Error._unknown(_response.error),
    };
  }

  public async deletePlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId
  ): Promise<TraceApi.playlist.deletePlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.deletePlaylist.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.createPlaylist.Error>;
export type Error = TraceApi.playlist.createPlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.createPlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.createPlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.createPlaylist.Error._Unknown, visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.createPlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.createPlaylist.Error,
    visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.playlist.deletePlaylist.Error>;
export type Error = TraceApi.playlist.deletePlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.deletePlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.deletePlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.deletePlaylist.Error._Unknown, visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.deletePlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.deletePlaylist.Error,
    visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "deletePlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.getPlaylist.Error>;
export type Error =
  | TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.getPlaylist.Error.UnauthorizedError
  | TraceApi.playlist.getPlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    unauthorizedError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  unauthorizedError: (): TraceApi.playlist.getPlaylist.Error.UnauthorizedError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.UnauthorizedError, \\"_visit\\"> = {
      errorName: \\"UnauthorizedError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.UnauthorizedError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.playlist.getPlaylist.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error._Unknown, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.getPlaylist.Error,
    visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      case \\"UnauthorizedError\\":
        return visitor.unauthorizedError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist[], TraceApi.playlist.getPlaylists.Error>;
export type Error = TraceApi.playlist.getPlaylists.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylists.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.playlist.getPlaylists.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylists.Error._Unknown, visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylists.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.getPlaylists.Error,
    visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * from \\"./requests\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetPlaylistsRequest {
  limit?: number;
  otherField: string;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface PlaylistCreateRequestWrapper {
  multiple: number | number[];
  multipleOptional?: boolean | boolean[];
  body: TraceApi.PlaylistCreateRequest;
}
",
                        "name": "PlaylistCreateRequestWrapper.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { PlaylistCreateRequestWrapper } from \\"./PlaylistCreateRequestWrapper\\";
export { GetPlaylistsRequest } from \\"./GetPlaylistsRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist | undefined, TraceApi.playlist.updatePlaylist.Error>;
export type Error =
  | TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.updatePlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.updatePlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.updatePlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.updatePlaylist.Error._Unknown, visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.updatePlaylist.Error,
    visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type PlaylistIdNotFoundError = TraceApi.PlaylistIdNotFoundErrorBody;
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(request: TraceApi.CreateProblemRequest): Promise<TraceApi.problem.createProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.createProblem.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.createProblem.Response.parse(
          _response.body as serializers.problem.createProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.createProblem.Error._unknown(_response.error),
    };
  }

  public async updateProblem(
    problemId: TraceApi.ProblemId,
    request: TraceApi.CreateProblemRequest
  ): Promise<TraceApi.problem.updateProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problem-crud/update/\${problemId}\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.updateProblem.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.updateProblem.Response.parse(
          _response.body as serializers.problem.updateProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.updateProblem.Error._unknown(_response.error),
    };
  }

  public async deleteProblem(problemId: TraceApi.ProblemId): Promise<TraceApi.problem.deleteProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problem-crud/delete/\${problemId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.deleteProblem.Error._unknown(_response.error),
    };
  }

  public async getDefaultStarterFiles(
    request: TraceApi.GetDefaultStarterFilesRequest
  ): Promise<TraceApi.problem.getDefaultStarterFiles.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.getDefaultStarterFiles.Request.json({
        inputParams: request.inputParams,
        outputType: request.outputType,
        methodName: request.methodName,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.getDefaultStarterFiles.Response.parse(
          _response.body as serializers.problem.getDefaultStarterFiles.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.getDefaultStarterFiles.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.CreateProblemResponse, TraceApi.problem.createProblem.Error>;
export type Error = TraceApi.problem.createProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.createProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.createProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.createProblem.Error._Unknown, visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.createProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.createProblem.Error,
    visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.problem.deleteProblem.Error>;
export type Error = TraceApi.problem.deleteProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.deleteProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.deleteProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.deleteProblem.Error._Unknown, visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.deleteProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.deleteProblem.Error,
    visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "deleteProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetDefaultStarterFilesResponse,
  TraceApi.problem.getDefaultStarterFiles.Error
>;
export type Error = TraceApi.problem.getDefaultStarterFiles.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.getDefaultStarterFiles.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.problem.getDefaultStarterFiles.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.getDefaultStarterFiles.Error._Unknown, visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) {
      return TraceApi.problem.getDefaultStarterFiles.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.getDefaultStarterFiles.Error,
    visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
export * from \\"./requests\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  methodName: string;
}
",
                        "name": "GetDefaultStarterFilesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { GetDefaultStarterFilesRequest } from \\"./GetDefaultStarterFilesRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.UpdateProblemResponse, TraceApi.problem.updateProblem.Error>;
export type Error = TraceApi.problem.updateProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.updateProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.updateProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.updateProblem.Error._Unknown, visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.updateProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.updateProblem.Error,
    visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    language: TraceApi.Language
  ): Promise<TraceApi.submission.createExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/create-session/\${language}\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.createExecutionSession.Response.parse(
          _response.body as serializers.submission.createExecutionSession.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.createExecutionSession.Error._unknown(_response.error),
    };
  }

  public async getExecutionSession(sessionId: string): Promise<TraceApi.submission.getExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/\${sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.getExecutionSession.Response.parse(
          _response.body as serializers.submission.getExecutionSession.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.getExecutionSession.Error._unknown(_response.error),
    };
  }

  public async stopExecutionSession(sessionId: string): Promise<TraceApi.submission.stopExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/stop/\${sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.stopExecutionSession.Error._unknown(_response.error),
    };
  }

  public async getExecutionSessionsState(): Promise<TraceApi.submission.getExecutionSessionsState.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.getExecutionSessionsState.Response.parse(
          _response.body as serializers.submission.getExecutionSessionsState.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.getExecutionSessionsState.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse,
  TraceApi.submission.createExecutionSession.Error
>;
export type Error = TraceApi.submission.createExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.createExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.createExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.createExecutionSession.Error._Unknown, visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.createExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.createExecutionSession.Error,
    visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse | undefined,
  TraceApi.submission.getExecutionSession.Error
>;
export type Error = TraceApi.submission.getExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.getExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.getExecutionSession.Error._Unknown, visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.getExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.getExecutionSession.Error,
    visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetExecutionSessionStateResponse,
  TraceApi.submission.getExecutionSessionsState.Error
>;
export type Error = TraceApi.submission.getExecutionSessionsState.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSessionsState.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.getExecutionSessionsState.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.getExecutionSessionsState.Error._Unknown, visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) {
      return TraceApi.submission.getExecutionSessionsState.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.getExecutionSessionsState.Error,
    visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.submission.stopExecutionSession.Error>;
export type Error = TraceApi.submission.stopExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.stopExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.stopExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.stopExecutionSession.Error._Unknown, visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.stopExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.stopExecutionSession.Error,
    visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "stopExecutionSession.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    language: TraceApi.Language,
    numWarmInstances: number
  ): Promise<TraceApi.sysprop.setNumWarmInstances.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sysprop/num-warm-instances/\${language}/\${numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.sysprop.setNumWarmInstances.Error._unknown(_response.error),
    };
  }

  public async getNumWarmInstances(): Promise<TraceApi.sysprop.getNumWarmInstances.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.sysprop.getNumWarmInstances.Response.parse(
          _response.body as serializers.sysprop.getNumWarmInstances.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.sysprop.getNumWarmInstances.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<Record<TraceApi.Language, number>, TraceApi.sysprop.getNumWarmInstances.Error>;
export type Error = TraceApi.sysprop.getNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.getNumWarmInstances.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.sysprop.getNumWarmInstances.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.sysprop.getNumWarmInstances.Error._Unknown, visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) {
      return TraceApi.sysprop.getNumWarmInstances.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.sysprop.getNumWarmInstances.Error,
    visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.sysprop.setNumWarmInstances.Error>;
export type Error = TraceApi.sysprop.setNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.setNumWarmInstances.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.sysprop.setNumWarmInstances.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.sysprop.setNumWarmInstances.Error._Unknown, visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) {
      return TraceApi.sysprop.setNumWarmInstances.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.sysprop.setNumWarmInstances.Error,
    visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "setNumWarmInstances.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";
import { Client as V3Client } from \\"../resources/v3/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #v3: V3Client | undefined;

  public get v3(): V3Client {
    return (this.#v3 ??= new V3Client(this.options));
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {};
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.problem.getLightweightProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getLightweightProblems.Response.parse(
          _response.body as serializers.v2.problem.getLightweightProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getLightweightProblems.Error._unknown(_response.error),
    };
  }

  public async getProblems(): Promise<TraceApi.v2.problem.getProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getProblems.Response.parse(
          _response.body as serializers.v2.problem.getProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getProblems.Error._unknown(_response.error),
    };
  }

  public async getLatestProblem(problemId: TraceApi.ProblemId): Promise<TraceApi.v2.problem.getLatestProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problems-v2/problem-info/\${problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getLatestProblem.Response.parse(
          _response.body as serializers.v2.problem.getLatestProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getLatestProblem.Error._unknown(_response.error),
    };
  }

  public async getProblemVersion(
    problemId: TraceApi.ProblemId,
    problemVersion: number
  ): Promise<TraceApi.v2.problem.getProblemVersion.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${problemId}/version/\${problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getProblemVersion.Response.parse(
          _response.body as serializers.v2.problem.getProblemVersion.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getProblemVersion.Error._unknown(_response.error),
    };
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLatestProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getLatestProblem.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getLatestProblem.Error._Unknown, visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getLatestProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getLatestProblem.Error,
    visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.LightweightProblemInfoV2[],
  TraceApi.v2.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLightweightProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getLightweightProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getLightweightProblems.Error._Unknown, visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getLightweightProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getLightweightProblems.Error,
    visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblemVersion.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getProblemVersion.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getProblemVersion.Error._Unknown, visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getProblemVersion.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getProblemVersion.Error,
    visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2[], TraceApi.v2.problem.getProblems.Error>;
export type Error = TraceApi.v2.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.v2.problem.getProblems.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getProblems.Error._Unknown, visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getProblems.Error,
    visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export {};
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../../environments\\";
import * as core from \\"../../../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.v3.problem.getLightweightProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getLightweightProblems.Response.parse(
          _response.body as serializers.v2.v3.problem.getLightweightProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getLightweightProblems.Error._unknown(_response.error),
    };
  }

  public async getProblems(): Promise<TraceApi.v2.v3.problem.getProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getProblems.Response.parse(
          _response.body as serializers.v2.v3.problem.getProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getProblems.Error._unknown(_response.error),
    };
  }

  public async getLatestProblem(
    problemId: TraceApi.ProblemId
  ): Promise<TraceApi.v2.v3.problem.getLatestProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problems-v2/problem-info/\${problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getLatestProblem.Response.parse(
          _response.body as serializers.v2.v3.problem.getLatestProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getLatestProblem.Error._unknown(_response.error),
    };
  }

  public async getProblemVersion(
    problemId: TraceApi.ProblemId,
    problemVersion: number
  ): Promise<TraceApi.v2.v3.problem.getProblemVersion.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${problemId}/version/\${problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getProblemVersion.Response.parse(
          _response.body as serializers.v2.v3.problem.getProblemVersion.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getProblemVersion.Error._unknown(_response.error),
    };
  }
}
",
                                    "name": "Client.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown, visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getLatestProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getLatestProblem.Error,
    visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.v3.LightweightProblemInfoV2[],
  TraceApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown, visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getLightweightProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getLightweightProblems.Error,
    visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown, visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getProblemVersion.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getProblemVersion.Error,
    visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2[], TraceApi.v2.v3.problem.getProblems.Error>;
export type Error = TraceApi.v2.v3.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getProblems.Error._Unknown, visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getProblems.Error,
    visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.sendTestSubmissionUpdate.Request.Raw,
  TraceApi.TestSubmissionUpdate
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestSubmissionUpdate);

export declare namespace Request {
  type Raw = serializers.TestSubmissionUpdate.Raw;
}
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.sendWorkspaceSubmissionUpdate.Request.Raw,
  TraceApi.WorkspaceSubmissionUpdate
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmissionUpdate);

export declare namespace Request {
  type Raw = serializers.WorkspaceSubmissionUpdate.Raw;
}
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedTestCase.Request.Raw,
  Omit<TraceApi.StoreTracedTestCaseRequest, \\"someQueryParam\\">
> = core.schemas.object({
  result: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResultWithStdout),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponse)),
});

export declare namespace Request {
  interface Raw {
    result: serializers.TestCaseResultWithStdout.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedTestCaseV2.Request.Raw,
  TraceApi.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponseV2));

export declare namespace Request {
  type Raw = serializers.TraceResponseV2.Raw[];
}
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedWorkspace.Request.Raw,
  TraceApi.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponse)),
});

export declare namespace Request {
  interface Raw {
    workspaceRunDetails: serializers.WorkspaceRunDetails.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedWorkspaceV2.Request.Raw,
  TraceApi.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponseV2));

export declare namespace Request {
  type Raw = serializers.TraceResponseV2.Raw[];
}
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.updateTestSubmissionStatus.Request.Raw,
  TraceApi.TestSubmissionStatus
> = core.schemas.lazy(async () => (await import(\\"../..\\")).TestSubmissionStatus);

export declare namespace Request {
  type Raw = serializers.TestSubmissionStatus.Raw;
}
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.updateWorkspaceSubmissionStatus.Request.Raw,
  TraceApi.WorkspaceSubmissionStatus
> = core.schemas.lazy(async () => (await import(\\"../..\\")).WorkspaceSubmissionStatus);

export declare namespace Request {
  type Raw = serializers.WorkspaceSubmissionStatus.Raw;
}
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.homepage.getHomepageProblems.Response.Raw,
  TraceApi.ProblemId[]
> = core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId));

export declare namespace Response {
  type Raw = serializers.ProblemId.Raw[];
}
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.homepage.setHomepageProblems.Request.Raw, TraceApi.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId));

export declare namespace Request {
  type Raw = serializers.ProblemId.Raw[];
}
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.migration.getAttemptedMigrations.Response.Raw,
  TraceApi.Migration[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Migration));

export declare namespace Response {
  type Raw = serializers.Migration.Raw[];
}
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.playlist.createPlaylist.Request.Raw,
  TraceApi.PlaylistCreateRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).PlaylistCreateRequest);

export declare namespace Request {
  type Raw = serializers.PlaylistCreateRequest.Raw;
}

export const Response: core.schemas.Schema<serializers.playlist.createPlaylist.Response.Raw, TraceApi.Playlist> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist);

export declare namespace Response {
  type Raw = serializers.Playlist.Raw;
}
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.playlist.getPlaylist.Response.Raw, TraceApi.Playlist> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist);

export declare namespace Response {
  type Raw = serializers.Playlist.Raw;
}

export const Error: core.schemas.Schema<
  serializers.playlist.getPlaylist.Error.Raw,
  TraceApi.playlist.getPlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundError),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<TraceApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.getPlaylist.Error.playlistIdNotFoundError(value.content);
        case \\"UnauthorizedError\\":
          return TraceApi.playlist.getPlaylist.Error.unauthorizedError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.playlist.getPlaylists.Response.Raw, TraceApi.Playlist[]> =
  core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist));

export declare namespace Response {
  type Raw = serializers.Playlist.Raw[];
}
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Request.Raw,
  TraceApi.UpdatePlaylistRequest | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).UpdatePlaylistRequest).optional();

export declare namespace Request {
  type Raw = serializers.UpdatePlaylistRequest.Raw | null | undefined;
}

export const Response: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Response.Raw,
  TraceApi.Playlist | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist).optional();

export declare namespace Response {
  type Raw = serializers.Playlist.Raw | null | undefined;
}

export const Error: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Error.Raw,
  TraceApi.playlist.updatePlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundError),
    }),
  })
  .transform<TraceApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.updatePlaylist.Error.playlistIdNotFoundError(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }
}
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  serializers.PlaylistIdNotFoundError.Raw,
  TraceApi.PlaylistIdNotFoundError
> = core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundErrorBody);

export declare namespace PlaylistIdNotFoundError {
  type Raw = serializers.PlaylistIdNotFoundErrorBody.Raw;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.createProblem.Request.Raw,
  TraceApi.CreateProblemRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateProblemRequest);

export declare namespace Request {
  type Raw = serializers.CreateProblemRequest.Raw;
}

export const Response: core.schemas.Schema<
  serializers.problem.createProblem.Response.Raw,
  TraceApi.CreateProblemResponse
> = core.schemas.lazy(async () => (await import(\\"../..\\")).CreateProblemResponse);

export declare namespace Response {
  type Raw = serializers.CreateProblemResponse.Raw;
}
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.getDefaultStarterFiles.Request.Raw,
  TraceApi.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).VariableTypeAndName)),
  outputType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  methodName: core.schemas.string(),
});

export declare namespace Request {
  interface Raw {
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    methodName: string;
  }
}

export const Response: core.schemas.Schema<
  serializers.problem.getDefaultStarterFiles.Response.Raw,
  TraceApi.GetDefaultStarterFilesResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GetDefaultStarterFilesResponse);

export declare namespace Response {
  type Raw = serializers.GetDefaultStarterFilesResponse.Raw;
}
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.updateProblem.Request.Raw,
  TraceApi.CreateProblemRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateProblemRequest);

export declare namespace Request {
  type Raw = serializers.CreateProblemRequest.Raw;
}

export const Response: core.schemas.Schema<
  serializers.problem.updateProblem.Response.Raw,
  TraceApi.UpdateProblemResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).UpdateProblemResponse);

export declare namespace Response {
  type Raw = serializers.UpdateProblemResponse.Raw;
}
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.createExecutionSession.Response.Raw,
  TraceApi.ExecutionSessionResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExecutionSessionResponse);

export declare namespace Response {
  type Raw = serializers.ExecutionSessionResponse.Raw;
}
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.getExecutionSession.Response.Raw,
  TraceApi.ExecutionSessionResponse | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExecutionSessionResponse).optional();

export declare namespace Response {
  type Raw = serializers.ExecutionSessionResponse.Raw | null | undefined;
}
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.getExecutionSessionsState.Response.Raw,
  TraceApi.GetExecutionSessionStateResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GetExecutionSessionStateResponse);

export declare namespace Response {
  type Raw = serializers.GetExecutionSessionStateResponse.Raw;
}
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.sysprop.getNumWarmInstances.Response.Raw,
  Record<TraceApi.Language, number>
> = core.schemas.record(
  core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  core.schemas.number()
);

export declare namespace Response {
  type Raw = Record<serializers.Language.Raw, number>;
}
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./resources\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getLatestProblem.Response.Raw,
  TraceApi.v2.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw;
}
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getLightweightProblems.Response.Raw,
  TraceApi.v2.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.LightweightProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.LightweightProblemInfoV2.Raw[];
}
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getProblemVersion.Response.Raw,
  TraceApi.v2.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw;
}
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getProblems.Response.Raw,
  TraceApi.v2.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw[];
}
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./resources\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getLatestProblem.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw;
}
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getLightweightProblems.Response.Raw,
  TraceApi.v2.v3.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.LightweightProblemInfoV2)
);

export declare namespace Response {
  type Raw = serializers.v2.v3.LightweightProblemInfoV2.Raw[];
}
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getProblemVersion.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw;
}
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getProblems.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw[];
}
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-trace/api-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

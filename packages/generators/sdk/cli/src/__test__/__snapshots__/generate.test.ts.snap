// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator fiddle 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "tabWidth: 4
printWidth: 120
",
    "name": ".prettierrc.yml",
    "type": "file",
  },
  Object {
    "contents": "const { build } = require(\\"esbuild\\");

void main();

async function main() {
    await bundle({
        platform: \\"node\\",
        target: \\"node14\\",
        format: \\"cjs\\",
        outdir: \\"node\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"esm\\",
        outdir: \\"browser/esm\\",
    });
    await bundle({
        platform: \\"browser\\",
        format: \\"cjs\\",
        outdir: \\"browser/cjs\\",
    });
}

async function bundle({ platform, target, format, outdir }) {
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/index.ts\\",
        outfile: \`./dist/\${outdir}/index.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/core/index.ts\\",
        outfile: \`./dist/\${outdir}/core.js\`,
    });
    await runEsbuild({
        platform,
        target,
        format,
        entryPoint: \\"./src/serialization/index.ts\\",
        outfile: \`./dist/\${outdir}/serialization.js\`,
    });
}

async function runEsbuild({ platform, target, format, entryPoint, outfile }) {
    await build({
        platform,
        target,
        format,
        entryPoints: [entryPoint],
        outfile,
        bundle: true,
        alias: {
            // matches up with tsconfig paths
            \\"@fern-fern/fiddle-sdk\\": \\"./src\\",
        }
    }).catch(() => process.exit(1));
}
",
    "name": "build.js",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-fern/fiddle-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"dist\\",
        \\"types\\",
        \\"core.d.ts\\",
        \\"serialization.d.ts\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"node\\": \\"./dist/node/index.js\\",
            \\"import\\": \\"./dist/browser/esm/index.js\\",
            \\"require\\": \\"./dist/browser/cjs/index.js\\",
            \\"default\\": \\"./dist/browser/cjs/index.js\\",
            \\"types\\": \\"./types/index.d.ts\\"
        },
        \\"./core\\": {
            \\"node\\": \\"./dist/node/core.js\\",
            \\"import\\": \\"./dist/browser/esm/core.js\\",
            \\"require\\": \\"./dist/browser/cjs/core.js\\",
            \\"default\\": \\"./dist/browser/cjs/core.js\\",
            \\"types\\": \\"./types/core/index.d.ts\\"
        },
        \\"./serialization\\": {
            \\"node\\": \\"./dist/node/serialization.js\\",
            \\"import\\": \\"./dist/browser/esm/serialization.js\\",
            \\"require\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"default\\": \\"./dist/browser/cjs/serialization.js\\",
            \\"types\\": \\"./types/serialization/index.d.ts\\"
        }
    },
    \\"types\\": \\"./types/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write 'src/**/*.ts'\\",
        \\"compile\\": \\"tsc && tsc-alias\\",
        \\"bundle\\": \\"node build.js\\",
        \\"build\\": \\"yarn compile && yarn bundle\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.15\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Client as HealthClient } from \\"./api/resources/health/client/Client\\";
import { Client as RemoteGenClient } from \\"./api/resources/remoteGen/client/Client\\";

export declare namespace FiddleClient {
    interface Options {
        environment: string;
    }
}

export class FiddleClient {
    constructor(private readonly options: FiddleClient.Options) {}

    #health: HealthClient | undefined;

    public get health(): HealthClient {
        return (this.#health ??= new HealthClient(this.options));
    }

    #remoteGen: RemoteGenClient | undefined;

    public get remoteGen(): RemoteGenClient {
        return (this.#remoteGen ??= new RemoteGenClient(this.options));
    }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";
import urlJoin from \\"url-join\\";

export declare namespace Client {
    interface Options {
        environment: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async status(): Promise<core.APIResponse<void, Fiddle.health.status.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, \\"/api/health\\"),
            method: \\"GET\\",
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: Fiddle.health.status.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as status from \\"./status\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = Fiddle.health.status.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        error: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.health.status.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): Fiddle.health.status.Error._Unknown => {
        return {
            error: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: Fiddle.health.status.Error._Unknown,
                visitor: Fiddle.health.status.Error._Visitor<_Result>
            ) {
                return Fiddle.health.status.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.health.status.Error,
        visitor: Fiddle.health.status.Error._Visitor<_Result>
    ): _Result => {
        switch (value.error) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "status.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "health",
                "type": "directory",
              },
              Object {
                "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * as health from \\"./health\\";
export * from \\"./remoteGen/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async createJob(
        request: Fiddle.CreateJobRequest
    ): Promise<core.APIResponse<Fiddle.CreateJobResponse, Fiddle.remoteGen.createJob.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job\\"),
            method: \\"POST\\",
            body: await serializers.CreateJobRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.CreateJobResponse.parseOrThrow(
                    _response.body as serializers.CreateJobResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as serializers.remoteGen.createJob.Error.Raw)?.error) {
                case \\"IllegalApiNameError\\":
                case \\"GeneratorsDoNotExistError\\":
                case \\"CannotPublishToNpmScope\\":
                case \\"CannotPublishToMavenGroup\\":
                case \\"InsufficientPermissions\\":
                    return {
                        ok: false,
                        error: await serializers.remoteGen.createJob.Error.parseOrThrow(
                            _response.error.body as serializers.remoteGen.createJob.Error.Raw,
                            { allowUnknownKeys: true }
                        ),
                    };
            }
        }

        return {
            ok: false,
            error: Fiddle.remoteGen.createJob.Error._unknown(_response.error),
        };
    }

    public async createJobV2(
        request: Fiddle.CreateJobRequestV2
    ): Promise<core.APIResponse<Fiddle.CreateJobResponse, Fiddle.remoteGen.createJobV2.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job-v2\\"),
            method: \\"POST\\",
            body: await serializers.CreateJobRequestV2.jsonOrThrow(request),
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.CreateJobResponse.parseOrThrow(
                    _response.body as serializers.CreateJobResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as serializers.remoteGen.createJobV2.Error.Raw)?.error) {
                case \\"IllegalApiNameError\\":
                case \\"GeneratorsDoNotExistError\\":
                case \\"CannotPublishToNpmScope\\":
                case \\"CannotPublishToMavenGroup\\":
                case \\"InsufficientPermissions\\":
                    return {
                        ok: false,
                        error: await serializers.remoteGen.createJobV2.Error.parseOrThrow(
                            _response.error.body as serializers.remoteGen.createJobV2.Error.Raw,
                            { allowUnknownKeys: true }
                        ),
                    };
            }
        }

        return {
            ok: false,
            error: Fiddle.remoteGen.createJobV2.Error._unknown(_response.error),
        };
    }

    public async getJobStatus(
        jobId: Fiddle.RemoteGenJobId
    ): Promise<
        core.APIResponse<Record<Fiddle.RemoteGenTaskId, Fiddle.Task | undefined>, Fiddle.remoteGen.getJobStatus.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment,
                \`/api/remote-gen/jobs/\${await serializers.RemoteGenJobId.jsonOrThrow(jobId)}/status\`
            ),
            method: \\"POST\\",
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.remoteGen.getJobStatus.Response.parseOrThrow(
                    _response.body as serializers.remoteGen.getJobStatus.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: Fiddle.remoteGen.getJobStatus.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export type Error =
    | Fiddle.remoteGen.createJob.Error.IllegalApiNameError
    | Fiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError
    | Fiddle.remoteGen.createJob.Error.CannotPublishToNpmScope
    | Fiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup
    | Fiddle.remoteGen.createJob.Error.InsufficientPermissions
    | Fiddle.remoteGen.createJob.Error._Unknown;

export declare namespace Error {
    interface IllegalApiNameError extends _Utils {
        error: \\"IllegalApiNameError\\";
    }

    interface GeneratorsDoNotExistError extends _Utils {
        error: \\"GeneratorsDoNotExistError\\";
        content: Fiddle.GeneratorsDoNotExistErrorBodyType;
    }

    interface CannotPublishToNpmScope extends _Utils {
        error: \\"CannotPublishToNpmScope\\";
        content: Fiddle.CannotPublishToNpmScopeDetails;
    }

    interface CannotPublishToMavenGroup extends _Utils {
        error: \\"CannotPublishToMavenGroup\\";
        content: Fiddle.CannotPublishToMavenGroupDetails;
    }

    interface InsufficientPermissions extends _Utils {
        error: \\"InsufficientPermissions\\";
        content: Fiddle.InsufficientPermissionsDetails;
    }

    interface _Unknown extends _Utils {
        error: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        illegalApiNameError: () => _Result;
        generatorsDoNotExistError: (value: Fiddle.GeneratorsDoNotExistErrorBodyType) => _Result;
        cannotPublishToNpmScope: (value: Fiddle.CannotPublishToNpmScopeDetails) => _Result;
        cannotPublishToMavenGroup: (value: Fiddle.CannotPublishToMavenGroupDetails) => _Result;
        insufficientPermissions: (value: Fiddle.InsufficientPermissionsDetails) => _Result;
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    illegalApiNameError: (): Fiddle.remoteGen.createJob.Error.IllegalApiNameError => {
        return {
            error: \\"IllegalApiNameError\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error.IllegalApiNameError,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    generatorsDoNotExistError: (
        value: Fiddle.GeneratorsDoNotExistErrorBodyType
    ): Fiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError => {
        return {
            content: value,
            error: \\"GeneratorsDoNotExistError\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    cannotPublishToNpmScope: (
        value: Fiddle.CannotPublishToNpmScopeDetails
    ): Fiddle.remoteGen.createJob.Error.CannotPublishToNpmScope => {
        return {
            content: value,
            error: \\"CannotPublishToNpmScope\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error.CannotPublishToNpmScope,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    cannotPublishToMavenGroup: (
        value: Fiddle.CannotPublishToMavenGroupDetails
    ): Fiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup => {
        return {
            content: value,
            error: \\"CannotPublishToMavenGroup\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    insufficientPermissions: (
        value: Fiddle.InsufficientPermissionsDetails
    ): Fiddle.remoteGen.createJob.Error.InsufficientPermissions => {
        return {
            content: value,
            error: \\"InsufficientPermissions\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error.InsufficientPermissions,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    _unknown: (fetcherError: core.Fetcher.Error): Fiddle.remoteGen.createJob.Error._Unknown => {
        return {
            error: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJob.Error._Unknown,
                visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJob.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.remoteGen.createJob.Error,
        visitor: Fiddle.remoteGen.createJob.Error._Visitor<_Result>
    ): _Result => {
        switch (value.error) {
            case \\"IllegalApiNameError\\":
                return visitor.illegalApiNameError();
            case \\"GeneratorsDoNotExistError\\":
                return visitor.generatorsDoNotExistError(value.content);
            case \\"CannotPublishToNpmScope\\":
                return visitor.cannotPublishToNpmScope(value.content);
            case \\"CannotPublishToMavenGroup\\":
                return visitor.cannotPublishToMavenGroup(value.content);
            case \\"InsufficientPermissions\\":
                return visitor.insufficientPermissions(value.content);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "createJob.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export type Error =
    | Fiddle.remoteGen.createJobV2.Error.IllegalApiNameError
    | Fiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError
    | Fiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope
    | Fiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup
    | Fiddle.remoteGen.createJobV2.Error.InsufficientPermissions
    | Fiddle.remoteGen.createJobV2.Error._Unknown;

export declare namespace Error {
    interface IllegalApiNameError extends _Utils {
        error: \\"IllegalApiNameError\\";
    }

    interface GeneratorsDoNotExistError extends _Utils {
        error: \\"GeneratorsDoNotExistError\\";
        content: Fiddle.GeneratorsDoNotExistErrorBodyType;
    }

    interface CannotPublishToNpmScope extends _Utils {
        error: \\"CannotPublishToNpmScope\\";
        content: Fiddle.CannotPublishToNpmScopeDetails;
    }

    interface CannotPublishToMavenGroup extends _Utils {
        error: \\"CannotPublishToMavenGroup\\";
        content: Fiddle.CannotPublishToMavenGroupDetails;
    }

    interface InsufficientPermissions extends _Utils {
        error: \\"InsufficientPermissions\\";
        content: Fiddle.InsufficientPermissionsDetails;
    }

    interface _Unknown extends _Utils {
        error: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        illegalApiNameError: () => _Result;
        generatorsDoNotExistError: (value: Fiddle.GeneratorsDoNotExistErrorBodyType) => _Result;
        cannotPublishToNpmScope: (value: Fiddle.CannotPublishToNpmScopeDetails) => _Result;
        cannotPublishToMavenGroup: (value: Fiddle.CannotPublishToMavenGroupDetails) => _Result;
        insufficientPermissions: (value: Fiddle.InsufficientPermissionsDetails) => _Result;
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    illegalApiNameError: (): Fiddle.remoteGen.createJobV2.Error.IllegalApiNameError => {
        return {
            error: \\"IllegalApiNameError\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error.IllegalApiNameError,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    generatorsDoNotExistError: (
        value: Fiddle.GeneratorsDoNotExistErrorBodyType
    ): Fiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError => {
        return {
            content: value,
            error: \\"GeneratorsDoNotExistError\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    cannotPublishToNpmScope: (
        value: Fiddle.CannotPublishToNpmScopeDetails
    ): Fiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope => {
        return {
            content: value,
            error: \\"CannotPublishToNpmScope\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    cannotPublishToMavenGroup: (
        value: Fiddle.CannotPublishToMavenGroupDetails
    ): Fiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup => {
        return {
            content: value,
            error: \\"CannotPublishToMavenGroup\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    insufficientPermissions: (
        value: Fiddle.InsufficientPermissionsDetails
    ): Fiddle.remoteGen.createJobV2.Error.InsufficientPermissions => {
        return {
            content: value,
            error: \\"InsufficientPermissions\\",
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error.InsufficientPermissions,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    _unknown: (fetcherError: core.Fetcher.Error): Fiddle.remoteGen.createJobV2.Error._Unknown => {
        return {
            error: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: Fiddle.remoteGen.createJobV2.Error._Unknown,
                visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.createJobV2.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.remoteGen.createJobV2.Error,
        visitor: Fiddle.remoteGen.createJobV2.Error._Visitor<_Result>
    ): _Result => {
        switch (value.error) {
            case \\"IllegalApiNameError\\":
                return visitor.illegalApiNameError();
            case \\"GeneratorsDoNotExistError\\":
                return visitor.generatorsDoNotExistError(value.content);
            case \\"CannotPublishToNpmScope\\":
                return visitor.cannotPublishToNpmScope(value.content);
            case \\"CannotPublishToMavenGroup\\":
                return visitor.cannotPublishToMavenGroup(value.content);
            case \\"InsufficientPermissions\\":
                return visitor.insufficientPermissions(value.content);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "createJobV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = Fiddle.remoteGen.getJobStatus.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        error: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.remoteGen.getJobStatus.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): Fiddle.remoteGen.getJobStatus.Error._Unknown => {
        return {
            error: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: Fiddle.remoteGen.getJobStatus.Error._Unknown,
                visitor: Fiddle.remoteGen.getJobStatus.Error._Visitor<_Result>
            ) {
                return Fiddle.remoteGen.getJobStatus.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.remoteGen.getJobStatus.Error,
        visitor: Fiddle.remoteGen.getJobStatus.Error._Visitor<_Result>
    ): _Result => {
        switch (value.error) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getJobStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
export * as createJob from \\"./createJob\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequest {
    apiName: string;
    organizationName: string;
    version?: string;
    generators: Fiddle.GeneratorConfig[];
}
",
                            "name": "CreateJobRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequestV2 {
    apiName: string;
    organizationName: string;
    version?: string;
    generators: Fiddle.GeneratorConfigV2[];
    uploadToS3?: boolean;
}
",
                            "name": "CreateJobRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateJobRequest } from \\"./CreateJobRequest\\";
export { CreateJobRequestV2 } from \\"./CreateJobRequestV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CannotPublishToMavenGroupDetails {
    generatorId: string;
    invalidGroup: string;
    validGroup: string;
}
",
                        "name": "CannotPublishToMavenGroupDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CannotPublishToNpmScopeDetails {
    generatorId: string;
    invalidScope: string;
    validScope: string;
}
",
                        "name": "CannotPublishToNpmScopeDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobResponse {
    jobId: Fiddle.RemoteGenJobId;
    /** The order of this list corresponds to the order of the generators supplied in the request. */
    taskIds: Fiddle.RemoteGenTaskId[];
}
",
                        "name": "CreateJobResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FailedTaskStatus {
    message: string;
    /** Pre-signed URL that points to a zipfile containing generated code. */
    s3PreSignedReadUrl?: string;
}
",
                        "name": "FailedTaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FinishedTaskStatus {
    /** This field is deprecated. */
    hasFilesToDownload: boolean;
    /** Deprecated (use v2). Pre-signed URL that points to a zipfile containing generated code. */
    s3PreSignedReadUrl: string;
    /** Pre-signed URL that points to a zipfile containing generated code. */
    s3PreSignedReadUrlV2?: string;
}
",
                        "name": "FinishedTaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorConfig {
    id: string;
    version: string;
    customConfig?: unknown;
    willDownloadFiles: boolean;
    /** Npm and Maven outputs default to fern registries. */
    outputs: Fiddle.GeneratorOutputs;
}
",
                        "name": "GeneratorConfig.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorConfigV2 {
    id: string;
    version: string;
    customConfig?: unknown;
    outputMode: Fiddle.OutputMode;
}
",
                        "name": "GeneratorConfigV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GeneratorIdAndVersion {
    id: string;
    version: string;
}
",
                        "name": "GeneratorIdAndVersion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorOutputs {
    npm?: Fiddle.NpmOutput;
    maven?: Fiddle.MavenOutput;
}
",
                        "name": "GeneratorOutputs.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorsDoNotExistErrorBodyType {
    nonExistentGenerators: Fiddle.GeneratorIdAndVersion[];
}
",
                        "name": "GeneratorsDoNotExistErrorBodyType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GithubOutputMode {
    owner: string;
    repo: string;
    publishInfo?: Fiddle.GithubPublishInfo;
}
",
                        "name": "GithubOutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type GithubPublishInfo =
    | Fiddle.GithubPublishInfo.Npm
    | Fiddle.GithubPublishInfo.Maven
    | Fiddle.GithubPublishInfo.Postman
    | Fiddle.GithubPublishInfo._Unknown;

export declare namespace GithubPublishInfo {
    interface Npm extends Fiddle.NpmOutputWithOptionalToken, _Utils {
        type: \\"npm\\";
    }

    interface Maven extends Fiddle.MavenOutputWithOptionalCreds, _Utils {
        type: \\"maven\\";
    }

    interface Postman extends Fiddle.PostmanOutput, _Utils {
        type: \\"postman\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.GithubPublishInfo._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        npm: (value: Fiddle.NpmOutputWithOptionalToken) => _Result;
        maven: (value: Fiddle.MavenOutputWithOptionalCreds) => _Result;
        postman: (value: Fiddle.PostmanOutput) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const GithubPublishInfo = {
    npm: (value: Fiddle.NpmOutputWithOptionalToken): Fiddle.GithubPublishInfo.Npm => {
        return {
            ...value,
            type: \\"npm\\",
            _visit: function <_Result>(
                this: Fiddle.GithubPublishInfo.Npm,
                visitor: Fiddle.GithubPublishInfo._Visitor<_Result>
            ) {
                return Fiddle.GithubPublishInfo._visit(this, visitor);
            },
        };
    },

    maven: (value: Fiddle.MavenOutputWithOptionalCreds): Fiddle.GithubPublishInfo.Maven => {
        return {
            ...value,
            type: \\"maven\\",
            _visit: function <_Result>(
                this: Fiddle.GithubPublishInfo.Maven,
                visitor: Fiddle.GithubPublishInfo._Visitor<_Result>
            ) {
                return Fiddle.GithubPublishInfo._visit(this, visitor);
            },
        };
    },

    postman: (value: Fiddle.PostmanOutput): Fiddle.GithubPublishInfo.Postman => {
        return {
            ...value,
            type: \\"postman\\",
            _visit: function <_Result>(
                this: Fiddle.GithubPublishInfo.Postman,
                visitor: Fiddle.GithubPublishInfo._Visitor<_Result>
            ) {
                return Fiddle.GithubPublishInfo._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): Fiddle.GithubPublishInfo._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: Fiddle.GithubPublishInfo._Unknown,
                visitor: Fiddle.GithubPublishInfo._Visitor<_Result>
            ) {
                return Fiddle.GithubPublishInfo._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.GithubPublishInfo,
        visitor: Fiddle.GithubPublishInfo._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"npm\\":
                return visitor.npm(value);
            case \\"maven\\":
                return visitor.maven(value);
            case \\"postman\\":
                return visitor.postman(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "GithubPublishInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface InsufficientPermissionsDetails {
    dummy?: string;
}
",
                        "name": "InsufficientPermissionsDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type LogLevel = \\"DEBUG\\" | \\"INFO\\" | \\"WARN\\" | \\"ERROR\\";

export const LogLevel = {
    Debug: \\"DEBUG\\",
    Info: \\"INFO\\",
    Warn: \\"WARN\\",
    Error: \\"ERROR\\",
} as const;
",
                        "name": "LogLevel.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MavenCoordinate {
    group: string;
    artifact: string;
    version: string;
}
",
                        "name": "MavenCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MavenOutput {
    registryUrl: string;
    username: string;
    password: string;
    coordinate: string;
}
",
                        "name": "MavenOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface MavenOutputWithOptionalCreds {
    registryUrl: string;
    coordinate: string;
    credentials?: Fiddle.UsernamePassword;
}
",
                        "name": "MavenOutputWithOptionalCreds.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmCoordinate {
    name: string;
    version: string;
}
",
                        "name": "NpmCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmOutput {
    registryUrl: string;
    packageName: string;
    token: string;
}
",
                        "name": "NpmOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmOutputWithOptionalToken {
    registryUrl: string;
    packageName: string;
    token?: string;
}
",
                        "name": "NpmOutputWithOptionalToken.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type OutputMode =
    | Fiddle.OutputMode.Publish
    | Fiddle.OutputMode.PublishV2
    | Fiddle.OutputMode.DownloadFiles
    | Fiddle.OutputMode.Github
    | Fiddle.OutputMode._Unknown;

export declare namespace OutputMode {
    interface Publish extends Fiddle.PublishOutputMode, _Utils {
        type: \\"publish\\";
    }

    interface PublishV2 extends _Utils {
        type: \\"publishV2\\";
        publishV2: Fiddle.PublishOutputModeV2;
    }

    interface DownloadFiles extends _Utils {
        type: \\"downloadFiles\\";
    }

    interface Github extends Fiddle.GithubOutputMode, _Utils {
        type: \\"github\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.OutputMode._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        publish: (value: Fiddle.PublishOutputMode) => _Result;
        publishV2: (value: Fiddle.PublishOutputModeV2) => _Result;
        downloadFiles: () => _Result;
        github: (value: Fiddle.GithubOutputMode) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const OutputMode = {
    publish: (value: Fiddle.PublishOutputMode): Fiddle.OutputMode.Publish => {
        return {
            ...value,
            type: \\"publish\\",
            _visit: function <_Result>(this: Fiddle.OutputMode.Publish, visitor: Fiddle.OutputMode._Visitor<_Result>) {
                return Fiddle.OutputMode._visit(this, visitor);
            },
        };
    },

    publishV2: (value: Fiddle.PublishOutputModeV2): Fiddle.OutputMode.PublishV2 => {
        return {
            publishV2: value,
            type: \\"publishV2\\",
            _visit: function <_Result>(
                this: Fiddle.OutputMode.PublishV2,
                visitor: Fiddle.OutputMode._Visitor<_Result>
            ) {
                return Fiddle.OutputMode._visit(this, visitor);
            },
        };
    },

    downloadFiles: (): Fiddle.OutputMode.DownloadFiles => {
        return {
            type: \\"downloadFiles\\",
            _visit: function <_Result>(
                this: Fiddle.OutputMode.DownloadFiles,
                visitor: Fiddle.OutputMode._Visitor<_Result>
            ) {
                return Fiddle.OutputMode._visit(this, visitor);
            },
        };
    },

    github: (value: Fiddle.GithubOutputMode): Fiddle.OutputMode.Github => {
        return {
            ...value,
            type: \\"github\\",
            _visit: function <_Result>(this: Fiddle.OutputMode.Github, visitor: Fiddle.OutputMode._Visitor<_Result>) {
                return Fiddle.OutputMode._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): Fiddle.OutputMode._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(this: Fiddle.OutputMode._Unknown, visitor: Fiddle.OutputMode._Visitor<_Result>) {
                return Fiddle.OutputMode._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: Fiddle.OutputMode, visitor: Fiddle.OutputMode._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"publish\\":
                return visitor.publish(value);
            case \\"publishV2\\":
                return visitor.publishV2(value.publishV2);
            case \\"downloadFiles\\":
                return visitor.downloadFiles();
            case \\"github\\":
                return visitor.github(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "OutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface Package {
    coordinate: Fiddle.PackageCoordinate;
    status: Fiddle.PackagePublishStatus;
}
",
                        "name": "Package.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type PackageCoordinate =
    | Fiddle.PackageCoordinate.Npm
    | Fiddle.PackageCoordinate.Maven
    | Fiddle.PackageCoordinate.Pypi
    | Fiddle.PackageCoordinate._Unknown;

export declare namespace PackageCoordinate {
    interface Npm extends Fiddle.NpmCoordinate, _Utils {
        type: \\"npm\\";
    }

    interface Maven extends Fiddle.MavenCoordinate, _Utils {
        type: \\"maven\\";
    }

    interface Pypi extends Fiddle.PypiCoordinate, _Utils {
        type: \\"pypi\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.PackageCoordinate._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        npm: (value: Fiddle.NpmCoordinate) => _Result;
        maven: (value: Fiddle.MavenCoordinate) => _Result;
        pypi: (value: Fiddle.PypiCoordinate) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const PackageCoordinate = {
    npm: (value: Fiddle.NpmCoordinate): Fiddle.PackageCoordinate.Npm => {
        return {
            ...value,
            type: \\"npm\\",
            _visit: function <_Result>(
                this: Fiddle.PackageCoordinate.Npm,
                visitor: Fiddle.PackageCoordinate._Visitor<_Result>
            ) {
                return Fiddle.PackageCoordinate._visit(this, visitor);
            },
        };
    },

    maven: (value: Fiddle.MavenCoordinate): Fiddle.PackageCoordinate.Maven => {
        return {
            ...value,
            type: \\"maven\\",
            _visit: function <_Result>(
                this: Fiddle.PackageCoordinate.Maven,
                visitor: Fiddle.PackageCoordinate._Visitor<_Result>
            ) {
                return Fiddle.PackageCoordinate._visit(this, visitor);
            },
        };
    },

    pypi: (value: Fiddle.PypiCoordinate): Fiddle.PackageCoordinate.Pypi => {
        return {
            ...value,
            type: \\"pypi\\",
            _visit: function <_Result>(
                this: Fiddle.PackageCoordinate.Pypi,
                visitor: Fiddle.PackageCoordinate._Visitor<_Result>
            ) {
                return Fiddle.PackageCoordinate._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): Fiddle.PackageCoordinate._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: Fiddle.PackageCoordinate._Unknown,
                visitor: Fiddle.PackageCoordinate._Visitor<_Result>
            ) {
                return Fiddle.PackageCoordinate._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.PackageCoordinate,
        visitor: Fiddle.PackageCoordinate._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"npm\\":
                return visitor.npm(value);
            case \\"maven\\":
                return visitor.maven(value);
            case \\"pypi\\":
                return visitor.pypi(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "PackageCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PackagePublishStatus = \\"NOT_STARTED_PUBLISHING\\" | \\"PUBLISHING\\" | \\"PUBLISHED\\" | \\"FAILED_TO_PUBLISH\\";

export const PackagePublishStatus = {
    NotStartedPublishing: \\"NOT_STARTED_PUBLISHING\\",
    Publishing: \\"PUBLISHING\\",
    Published: \\"PUBLISHED\\",
    FailedToPublish: \\"FAILED_TO_PUBLISH\\",
} as const;
",
                        "name": "PackagePublishStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PostmanOutput {
    apiKey: string;
    workspaceId: string;
}
",
                        "name": "PostmanOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface PublishOutputMode {
    registryOverrides: Fiddle.RegistryOverrides;
}
",
                        "name": "PublishOutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type PublishOutputModeV2 =
    | Fiddle.PublishOutputModeV2.NpmOverride
    | Fiddle.PublishOutputModeV2.MavenOverride
    | Fiddle.PublishOutputModeV2.Postman
    | Fiddle.PublishOutputModeV2._Unknown;

export declare namespace PublishOutputModeV2 {
    interface NpmOverride extends _Utils {
        type: \\"npmOverride\\";
        npmOverride?: Fiddle.NpmOutput;
    }

    interface MavenOverride extends _Utils {
        type: \\"mavenOverride\\";
        mavenOverride?: Fiddle.MavenOutput;
    }

    interface Postman extends Fiddle.PostmanOutput, _Utils {
        type: \\"postman\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        npmOverride: (value: Fiddle.NpmOutput | undefined) => _Result;
        mavenOverride: (value: Fiddle.MavenOutput | undefined) => _Result;
        postman: (value: Fiddle.PostmanOutput) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const PublishOutputModeV2 = {
    npmOverride: (value?: Fiddle.NpmOutput): Fiddle.PublishOutputModeV2.NpmOverride => {
        return {
            npmOverride: value,
            type: \\"npmOverride\\",
            _visit: function <_Result>(
                this: Fiddle.PublishOutputModeV2.NpmOverride,
                visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>
            ) {
                return Fiddle.PublishOutputModeV2._visit(this, visitor);
            },
        };
    },

    mavenOverride: (value?: Fiddle.MavenOutput): Fiddle.PublishOutputModeV2.MavenOverride => {
        return {
            mavenOverride: value,
            type: \\"mavenOverride\\",
            _visit: function <_Result>(
                this: Fiddle.PublishOutputModeV2.MavenOverride,
                visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>
            ) {
                return Fiddle.PublishOutputModeV2._visit(this, visitor);
            },
        };
    },

    postman: (value: Fiddle.PostmanOutput): Fiddle.PublishOutputModeV2.Postman => {
        return {
            ...value,
            type: \\"postman\\",
            _visit: function <_Result>(
                this: Fiddle.PublishOutputModeV2.Postman,
                visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>
            ) {
                return Fiddle.PublishOutputModeV2._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): Fiddle.PublishOutputModeV2._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: Fiddle.PublishOutputModeV2._Unknown,
                visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>
            ) {
                return Fiddle.PublishOutputModeV2._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: Fiddle.PublishOutputModeV2,
        visitor: Fiddle.PublishOutputModeV2._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"npmOverride\\":
                return visitor.npmOverride(value.npmOverride);
            case \\"mavenOverride\\":
                return visitor.mavenOverride(value.mavenOverride);
            case \\"postman\\":
                return visitor.postman(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "PublishOutputModeV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PypiCoordinate {
    name: string;
    version: string;
}
",
                        "name": "PypiCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface RegistryOverrides {
    npm?: Fiddle.NpmOutput;
    maven?: Fiddle.MavenOutput;
}
",
                        "name": "RegistryOverrides.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type RemoteGenJobId = string & {
    RemoteGenJobId: void;
};

export function RemoteGenJobId(value: string): Fiddle.RemoteGenJobId {
    return value as unknown as Fiddle.RemoteGenJobId;
}
",
                        "name": "RemoteGenJobId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

/**
 * A remote gen job can be made up of several tasks.
 * A task corresponds to an instance of a generator (in .fernrc.yml).
 *
 */
export type RemoteGenTaskId = string & {
    RemoteGenTaskId: void;
};

export function RemoteGenTaskId(value: string): Fiddle.RemoteGenTaskId {
    return value as unknown as Fiddle.RemoteGenTaskId;
}
",
                        "name": "RemoteGenTaskId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface Task {
    status: Fiddle.TaskStatus;
    packages: Fiddle.Package[];
    logs: Fiddle.TaskLog[];
}
",
                        "name": "Task.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface TaskLog {
    level: Fiddle.LogLevel;
    message: string;
}
",
                        "name": "TaskLog.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";

export type TaskStatus =
    | Fiddle.TaskStatus.NotStarted
    | Fiddle.TaskStatus.Running
    | Fiddle.TaskStatus.Failed
    | Fiddle.TaskStatus.Finished
    | Fiddle.TaskStatus._Unknown;

export declare namespace TaskStatus {
    interface NotStarted extends _Utils {
        type: \\"notStarted\\";
    }

    interface Running extends _Utils {
        type: \\"running\\";
    }

    interface Failed extends Fiddle.FailedTaskStatus, _Utils {
        type: \\"failed\\";
    }

    interface Finished extends Fiddle.FinishedTaskStatus, _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: Fiddle.TaskStatus._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        notStarted: () => _Result;
        running: () => _Result;
        failed: (value: Fiddle.FailedTaskStatus) => _Result;
        finished: (value: Fiddle.FinishedTaskStatus) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TaskStatus = {
    notStarted: (): Fiddle.TaskStatus.NotStarted => {
        return {
            type: \\"notStarted\\",
            _visit: function <_Result>(
                this: Fiddle.TaskStatus.NotStarted,
                visitor: Fiddle.TaskStatus._Visitor<_Result>
            ) {
                return Fiddle.TaskStatus._visit(this, visitor);
            },
        };
    },

    running: (): Fiddle.TaskStatus.Running => {
        return {
            type: \\"running\\",
            _visit: function <_Result>(this: Fiddle.TaskStatus.Running, visitor: Fiddle.TaskStatus._Visitor<_Result>) {
                return Fiddle.TaskStatus._visit(this, visitor);
            },
        };
    },

    failed: (value: Fiddle.FailedTaskStatus): Fiddle.TaskStatus.Failed => {
        return {
            ...value,
            type: \\"failed\\",
            _visit: function <_Result>(this: Fiddle.TaskStatus.Failed, visitor: Fiddle.TaskStatus._Visitor<_Result>) {
                return Fiddle.TaskStatus._visit(this, visitor);
            },
        };
    },

    finished: (value: Fiddle.FinishedTaskStatus): Fiddle.TaskStatus.Finished => {
        return {
            ...value,
            type: \\"finished\\",
            _visit: function <_Result>(this: Fiddle.TaskStatus.Finished, visitor: Fiddle.TaskStatus._Visitor<_Result>) {
                return Fiddle.TaskStatus._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): Fiddle.TaskStatus._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(this: Fiddle.TaskStatus._Unknown, visitor: Fiddle.TaskStatus._Visitor<_Result>) {
                return Fiddle.TaskStatus._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: Fiddle.TaskStatus, visitor: Fiddle.TaskStatus._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"notStarted\\":
                return visitor.notStarted();
            case \\"running\\":
                return visitor.running();
            case \\"failed\\":
                return visitor.failed(value);
            case \\"finished\\":
                return visitor.finished(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UsernamePassword {
    username: string;
    password: string;
}
",
                        "name": "UsernamePassword.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./RemoteGenJobId\\";
export * from \\"./RemoteGenTaskId\\";
export * from \\"./GeneratorIdAndVersion\\";
export * from \\"./GeneratorConfig\\";
export * from \\"./GeneratorConfigV2\\";
export * from \\"./OutputMode\\";
export * from \\"./PublishOutputMode\\";
export * from \\"./PublishOutputModeV2\\";
export * from \\"./RegistryOverrides\\";
export * from \\"./GeneratorOutputs\\";
export * from \\"./NpmOutput\\";
export * from \\"./MavenOutput\\";
export * from \\"./PostmanOutput\\";
export * from \\"./GithubOutputMode\\";
export * from \\"./GithubPublishInfo\\";
export * from \\"./NpmOutputWithOptionalToken\\";
export * from \\"./MavenOutputWithOptionalCreds\\";
export * from \\"./UsernamePassword\\";
export * from \\"./Task\\";
export * from \\"./TaskStatus\\";
export * from \\"./FailedTaskStatus\\";
export * from \\"./FinishedTaskStatus\\";
export * from \\"./TaskLog\\";
export * from \\"./LogLevel\\";
export * from \\"./Package\\";
export * from \\"./PackagePublishStatus\\";
export * from \\"./PackageCoordinate\\";
export * from \\"./NpmCoordinate\\";
export * from \\"./MavenCoordinate\\";
export * from \\"./PypiCoordinate\\";
export * from \\"./CreateJobResponse\\";
export * from \\"./GeneratorsDoNotExistErrorBodyType\\";
export * from \\"./CannotPublishToNpmScopeDetails\\";
export * from \\"./CannotPublishToMavenGroupDetails\\";
export * from \\"./InsufficientPermissionsDetails\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "remoteGen",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
    fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: \\"status-code\\";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: \\"non-json\\";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: \\"timeout\\";
    }

    export interface UnknownError {
        reason: \\"unknown\\";
        errorMessage: string;
    }
}

export const fetcher: FetchFunction = async (args) => {
    const headers: Record<string, string> = {
        \\"Content-Type\\": \\"application/json\\",
    };

    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }

    try {
        const response = await axios({
            url: args.url,
            params: args.queryParameters,
            method: args.method,
            headers,
            data: args.body,
            validateStatus: () => true,
            transformResponse: (response) => response,
            timeout: args.timeoutMs ?? 60_000,
            transitional: {
                clarifyTimeoutError: true,
            },
            withCredentials: args.withCredentials,
        });

        let body: unknown;
        if (response.data != null && response.data.length > 0) {
            try {
                body = JSON.parse(response.data) ?? undefined;
            } catch {
                return {
                    ok: false,
                    error: {
                        reason: \\"non-json\\",
                        statusCode: response.status,
                        rawBody: response.data,
                    },
                };
            }
        }

        if (response.status >= 200 && response.status < 300) {
            return {
                ok: true,
                body,
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: \\"status-code\\",
                    statusCode: response.status,
                    body,
                },
            };
        }
    } catch (error) {
        if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
            return {
                ok: false,
                error: {
                    reason: \\"timeout\\",
                },
            };
        }

        return {
            ok: false,
            error: {
                reason: \\"unknown\\",
                errorMessage: (error as AxiosError).message,
            },
        };
    }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
    get: async <T>(supplier: Supplier<T>): Promise<T> => {
        if (typeof supplier === \\"function\\") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as serialization from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}

export const SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    OPTIONAL: \\"optional\\",
} as const;
export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

export type MaybeValid<T> = Valid<T> | Invalid;

export interface Valid<T> {
    ok: true;
    value: T;
}

export interface Invalid {
    ok: false;
    errors: ValidationError[];
}

export interface ValidationError {
    path: string[];
    message: string;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX =
    /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw) => {
            if (typeof raw === \\"string\\" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not an ISO 8601 date string\\",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Date object\\",
                        },
                    ],
                };
            }
        },
        getType: () => SchemaType.DATE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
    const validValues = new Set<string>(values);

    const schemaCreator = createIdentitySchemaCreator(SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === \\"string\\" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value as U,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \\"Not one of the allowed values\\",
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
    getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...constructLazyBaseSchema(getter),
        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => SchemaType.LIST,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformArray<Raw, Parsed>(
    value: unknown,
    transformItem: (item: Raw) => MaybePromise<MaybeValid<Parsed>>
): Promise<MaybeValid<Parsed[]>> {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: \\"Not a list\\",
                    path: [],
                },
            ],
        };
    }

    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));

    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
        (acc, item, index) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(
                    ...item.errors.map((error) => ({
                        path: [\`[\${index}]\`, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: [] }
    );
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to \\"\${literal}\\"\`,
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        _getRawProperties: () =>
            Promise.resolve(
                Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
            ),
        _getParsedProperties: () =>
            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

        parse: async (raw, opts) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey: parsedKey as string,
                    valueSchema,
                };

                rawKeyToProperty[rawKey] = property;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(rawKey);
                }
            }

            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        json: async (parsed, opts) => {
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(parsedKey as string);
                }
            }

            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (
                    parsedKey
                ):
                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }
                    | undefined => {
                    const property = schemas[parsedKey as keyof T];

                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }

                    if (isProperty(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        getType: () => SchemaType.OBJECT,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

async function validateAndTransformObject<Transformed>({
    value,
    requiredKeys,
    getProperty,
    allowUnknownKeys,
}: {
    value: unknown;
    requiredKeys: string[];
    getProperty: (
        preTransformedKey: string
    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;
    allowUnknownKeys: boolean;
}): Promise<MaybeValid<Transformed>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const missingRequiredKeys = new Set(requiredKeys);
    const errors: ValidationError[] = [];
    const transformed: Record<string | number | symbol, any> = {};

    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);

        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);

            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                errors.push(
                    ...value.errors.map((error) => ({
                        path: [preTransformedKey, ...error.path],
                        message: error.message,
                    }))
                );
            }
        } else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        } else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key \\"\${preTransformedKey}\\"\`,
            });
        }
    }

    errors.push(
        ...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
                path: [],
                message: \`Missing required key \\"\${key}\\"\`,
            }))
    );

    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed as Transformed,
        };
    } else {
        return {
            ok: false,
            errors,
        };
    }
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => SchemaType.OBJECT,
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}

async function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
    extensionKeys,
    value,
    transformBase,
    transformExtension,
}: {
    extensionKeys: (keyof PreTransformedExtension)[];
    value: unknown;
    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;
    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;
}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
        extensionPropertiesSet.has(key as keyof PreTransformedExtension)
    );

    const transformedBase = await transformBase(filterObject(value, baseProperties));
    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));

    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    } else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed> &
    ObjectUtils<Raw, Parsed> &
    SchemaUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }

            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value,
                    };
                },
                {}
            );

            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...(additionalProperties as Properties),
                },
            };
        },

        json: (parsed, opts) => {
            if (!isPlainObject(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }

            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = filterObject(
                parsed,
                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },

        getType: () => objectLike.getType(),
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export { type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const any = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({ ok: true, value }));
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const boolean = createIdentitySchemaCreator<boolean>(SchemaType.BOOLEAN, (value) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a boolean\\",
                },
            ],
        };
    }
});
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const number = createIdentitySchemaCreator<number>(SchemaType.NUMBER, (value) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a number\\",
                },
            ],
        };
    }
});
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const string = createIdentitySchemaCreator<string>(SchemaType.STRING, (value) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a string\\",
                },
            ],
        };
    }
});
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const unknown = createIdentitySchemaCreator<unknown>(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
export { type BaseRecordSchema, type RecordSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseRecordSchema, RecordSchema } from \\"./types\\";

export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => SchemaType.RECORD,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
    value,
    isKeyNumeric,
    transformKey,
    transformValue,
}: {
    value: unknown;
    isKeyNumeric: boolean;
    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;
    transformValue: (value: unknown) => MaybePromise<MaybeValid<TransformedValue>>;
}): Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    return entries(value).reduce<Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>>>(
        async (accPromise, [stringKey, value]) => {
            // skip nullish keys
            if (value == null) {
                return accPromise;
            }

            const acc = await accPromise;

            let key: string | number = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = await transformKey(key);

            const transformedValue = await transformValue(value);

            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: {
                        ...acc.value,
                        [transformedKey.value]: transformedValue.value,
                    },
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(
                    ...transformedKey.errors.map((error) => ({
                        path: [\`\${key} (key)\`, ...error.path],
                        message: error.message,
                    }))
                );
            }
            if (!transformedValue.ok) {
                errors.push(
                    ...transformedValue.errors.map((error) => ({
                        path: [stringKey, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        Promise.resolve({ ok: true, value: {} as OptionalRecord<TransformedKey, TransformedValue> })
    );
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { SchemaUtils } from \\"../schema-utils\\";

export type RecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
    SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;

export type BaseRecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class JsonError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
",
                        "name": "JsonError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class ParseError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
",
                        "name": "ParseError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaOptions, SchemaType } from \\"../../Schema\\";
import { JsonError } from \\"./JsonError\\";
import { ParseError } from \\"./ParseError\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}

export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError(raw.errors);
        },
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>
): Schema<Raw | null | undefined, Parsed | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<Raw, Parsed, Transformed>(
    schema: BaseSchema<Raw, Parsed>,
    transformer: SchemaTransformer<Parsed, Transformed>
): Schema<Raw, Transformed> {
    const baseSchema: BaseSchema<Raw, Transformed> = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";

export function stringifyValidationError(error: ValidationError): string {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
",
                        "name": "stringifyValidationErrors.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { list } from \\"../list\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const listSchema = list(schema);
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            } else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Set\\",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => SchemaType.SET,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, SchemaType } from \\"../../Schema\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { enum_ } from \\"../enum\\";
import { ObjectSchema } from \\"../object\\";
import { getObjectLikeUtils, ObjectLikeSchema } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const discriminantValueSchema = enum_(keys(union) as string[]);

    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(
                raw,
                rawDiscriminant,
                parsedDiscriminant,
                (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.parse(additionalProperties, opts)
            );
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(
                parsed,
                parsedDiscriminant,
                rawDiscriminant,
                (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.json(additionalProperties, opts)
            );
        },
        getType: () => SchemaType.UNION,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}

async function transformAndValidateUnion<
    TransformedDiscriminant extends string,
    TransformedDiscriminantValue extends string,
    TransformedAdditionalProperties
>(
    value: unknown,
    discriminant: string,
    transformedDiscriminant: TransformedDiscriminant,
    transformDiscriminantValue: (discriminantValue: unknown) => MaybePromise<MaybeValid<TransformedDiscriminantValue>>,
    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined,
    allowUnknownKeys: boolean,
    transformAdditionalProperties: (
        additionalProperties: unknown,
        additionalPropertiesSchema: ObjectSchema<any, any>
    ) => MaybePromise<MaybeValid<TransformedAdditionalProperties>>
): Promise<
    MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties>
> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const { [discriminant]: discriminantValue, ...additionalProperties } = value;

    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                },
            ],
        };
    }

    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }

    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);

    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: \\"Unrecognized discriminant value\\",
                    },
                ],
            };
        }
    }

    const transformedAdditionalProperties = await transformAdditionalProperties(
        additionalProperties,
        additionalPropertiesSchema
    );
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }

    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
    };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type MaybePromise<T> = T | Promise<T>;
",
                    "name": "MaybePromise.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                    "name": "OptionalRecord.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../builders/schema-utils\\";
import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";

export function createIdentitySchemaCreator<T>(
    schemaType: SchemaType,
    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>
): () => Schema<T, T> {
    return () => {
        const baseSchema: BaseSchema<T, T> = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };

        return {
            ...baseSchema,
            ...getSchemaUtils(baseSchema),
        };
    };
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key as K)) {
            acc[key as K] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export const NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";

// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
export function isPlainObject(value: unknown): value is Record<string, unknown> {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }

    if (Object.getPrototypeOf(value) === null) {
        return true;
    }

    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(value) === proto;
}
",
                    "name": "isPlainObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as Fiddle from \\"./api\\";
export { FiddleClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * from \\"./remoteGen/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const Error: core.serialization.Schema<
    serializers.remoteGen.createJob.Error.Raw,
    Fiddle.remoteGen.createJob.Error
> = core.serialization
    .union(\\"error\\", {
        IllegalApiNameError: core.serialization.object({}),
        GeneratorsDoNotExistError: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).GeneratorsDoNotExistErrorBodyType
            ),
        }),
        CannotPublishToNpmScope: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).CannotPublishToNpmScopeDetails
            ),
        }),
        CannotPublishToMavenGroup: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).CannotPublishToMavenGroupDetails
            ),
        }),
        InsufficientPermissions: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).InsufficientPermissionsDetails
            ),
        }),
    })
    .transform<Fiddle.remoteGen.createJob.Error>({
        transform: (value) => {
            switch (value.error) {
                case \\"IllegalApiNameError\\":
                    return Fiddle.remoteGen.createJob.Error.illegalApiNameError();
                case \\"GeneratorsDoNotExistError\\":
                    return Fiddle.remoteGen.createJob.Error.generatorsDoNotExistError(value.content);
                case \\"CannotPublishToNpmScope\\":
                    return Fiddle.remoteGen.createJob.Error.cannotPublishToNpmScope(value.content);
                case \\"CannotPublishToMavenGroup\\":
                    return Fiddle.remoteGen.createJob.Error.cannotPublishToMavenGroup(value.content);
                case \\"InsufficientPermissions\\":
                    return Fiddle.remoteGen.createJob.Error.insufficientPermissions(value.content);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace Error {
    type Raw =
        | Error.IllegalApiNameError
        | Error.GeneratorsDoNotExistError
        | Error.CannotPublishToNpmScope
        | Error.CannotPublishToMavenGroup
        | Error.InsufficientPermissions;

    interface IllegalApiNameError {
        error: \\"IllegalApiNameError\\";
    }

    interface GeneratorsDoNotExistError {
        error: \\"GeneratorsDoNotExistError\\";
        content: serializers.GeneratorsDoNotExistErrorBodyType.Raw;
    }

    interface CannotPublishToNpmScope {
        error: \\"CannotPublishToNpmScope\\";
        content: serializers.CannotPublishToNpmScopeDetails.Raw;
    }

    interface CannotPublishToMavenGroup {
        error: \\"CannotPublishToMavenGroup\\";
        content: serializers.CannotPublishToMavenGroupDetails.Raw;
    }

    interface InsufficientPermissions {
        error: \\"InsufficientPermissions\\";
        content: serializers.InsufficientPermissionsDetails.Raw;
    }
}
",
                        "name": "createJob.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const Error: core.serialization.Schema<
    serializers.remoteGen.createJobV2.Error.Raw,
    Fiddle.remoteGen.createJobV2.Error
> = core.serialization
    .union(\\"error\\", {
        IllegalApiNameError: core.serialization.object({}),
        GeneratorsDoNotExistError: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).GeneratorsDoNotExistErrorBodyType
            ),
        }),
        CannotPublishToNpmScope: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).CannotPublishToNpmScopeDetails
            ),
        }),
        CannotPublishToMavenGroup: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).CannotPublishToMavenGroupDetails
            ),
        }),
        InsufficientPermissions: core.serialization.object({
            content: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).InsufficientPermissionsDetails
            ),
        }),
    })
    .transform<Fiddle.remoteGen.createJobV2.Error>({
        transform: (value) => {
            switch (value.error) {
                case \\"IllegalApiNameError\\":
                    return Fiddle.remoteGen.createJobV2.Error.illegalApiNameError();
                case \\"GeneratorsDoNotExistError\\":
                    return Fiddle.remoteGen.createJobV2.Error.generatorsDoNotExistError(value.content);
                case \\"CannotPublishToNpmScope\\":
                    return Fiddle.remoteGen.createJobV2.Error.cannotPublishToNpmScope(value.content);
                case \\"CannotPublishToMavenGroup\\":
                    return Fiddle.remoteGen.createJobV2.Error.cannotPublishToMavenGroup(value.content);
                case \\"InsufficientPermissions\\":
                    return Fiddle.remoteGen.createJobV2.Error.insufficientPermissions(value.content);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace Error {
    type Raw =
        | Error.IllegalApiNameError
        | Error.GeneratorsDoNotExistError
        | Error.CannotPublishToNpmScope
        | Error.CannotPublishToMavenGroup
        | Error.InsufficientPermissions;

    interface IllegalApiNameError {
        error: \\"IllegalApiNameError\\";
    }

    interface GeneratorsDoNotExistError {
        error: \\"GeneratorsDoNotExistError\\";
        content: serializers.GeneratorsDoNotExistErrorBodyType.Raw;
    }

    interface CannotPublishToNpmScope {
        error: \\"CannotPublishToNpmScope\\";
        content: serializers.CannotPublishToNpmScopeDetails.Raw;
    }

    interface CannotPublishToMavenGroup {
        error: \\"CannotPublishToMavenGroup\\";
        content: serializers.CannotPublishToMavenGroupDetails.Raw;
    }

    interface InsufficientPermissions {
        error: \\"InsufficientPermissions\\";
        content: serializers.InsufficientPermissionsDetails.Raw;
    }
}
",
                        "name": "createJobV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.remoteGen.getJobStatus.Response.Raw,
    Record<Fiddle.RemoteGenTaskId, Fiddle.Task | undefined>
> = core.serialization.record(
    core.serialization.lazy(async () => (await import(\\"../../..\\")).RemoteGenTaskId),
    core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Task).optional()
);

export declare namespace Response {
    type Raw = Record<serializers.RemoteGenTaskId.Raw, serializers.Task.Raw | null | undefined>;
}
",
                        "name": "getJobStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as createJob from \\"./createJob\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../../core\\";

export const CreateJobRequest: core.serialization.Schema<serializers.CreateJobRequest.Raw, Fiddle.CreateJobRequest> =
    core.serialization.object({
        apiName: core.serialization.string(),
        organizationName: core.serialization.string(),
        version: core.serialization.string().optional(),
        generators: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).GeneratorConfig)
        ),
    });

export declare namespace CreateJobRequest {
    interface Raw {
        apiName: string;
        organizationName: string;
        version?: string | null;
        generators: serializers.GeneratorConfig.Raw[];
    }
}
",
                            "name": "CreateJobRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../../core\\";

export const CreateJobRequestV2: core.serialization.Schema<
    serializers.CreateJobRequestV2.Raw,
    Fiddle.CreateJobRequestV2
> = core.serialization.object({
    apiName: core.serialization.string(),
    organizationName: core.serialization.string(),
    version: core.serialization.string().optional(),
    generators: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).GeneratorConfigV2)
    ),
    uploadToS3: core.serialization.boolean().optional(),
});

export declare namespace CreateJobRequestV2 {
    interface Raw {
        apiName: string;
        organizationName: string;
        version?: string | null;
        generators: serializers.GeneratorConfigV2.Raw[];
        uploadToS3?: boolean | null;
    }
}
",
                            "name": "CreateJobRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateJobRequest } from \\"./CreateJobRequest\\";
export { CreateJobRequestV2 } from \\"./CreateJobRequestV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const CannotPublishToMavenGroupDetails: core.serialization.ObjectSchema<
    serializers.CannotPublishToMavenGroupDetails.Raw,
    Fiddle.CannotPublishToMavenGroupDetails
> = core.serialization.object({
    generatorId: core.serialization.string(),
    invalidGroup: core.serialization.string(),
    validGroup: core.serialization.string(),
});

export declare namespace CannotPublishToMavenGroupDetails {
    interface Raw {
        generatorId: string;
        invalidGroup: string;
        validGroup: string;
    }
}
",
                        "name": "CannotPublishToMavenGroupDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const CannotPublishToNpmScopeDetails: core.serialization.ObjectSchema<
    serializers.CannotPublishToNpmScopeDetails.Raw,
    Fiddle.CannotPublishToNpmScopeDetails
> = core.serialization.object({
    generatorId: core.serialization.string(),
    invalidScope: core.serialization.string(),
    validScope: core.serialization.string(),
});

export declare namespace CannotPublishToNpmScopeDetails {
    interface Raw {
        generatorId: string;
        invalidScope: string;
        validScope: string;
    }
}
",
                        "name": "CannotPublishToNpmScopeDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const CreateJobResponse: core.serialization.ObjectSchema<
    serializers.CreateJobResponse.Raw,
    Fiddle.CreateJobResponse
> = core.serialization.object({
    jobId: core.serialization.lazy(async () => (await import(\\"../../..\\")).RemoteGenJobId),
    taskIds: core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).RemoteGenTaskId)),
});

export declare namespace CreateJobResponse {
    interface Raw {
        jobId: serializers.RemoteGenJobId.Raw;
        taskIds: serializers.RemoteGenTaskId.Raw[];
    }
}
",
                        "name": "CreateJobResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const FailedTaskStatus: core.serialization.ObjectSchema<
    serializers.FailedTaskStatus.Raw,
    Fiddle.FailedTaskStatus
> = core.serialization.object({
    message: core.serialization.string(),
    s3PreSignedReadUrl: core.serialization.string().optional(),
});

export declare namespace FailedTaskStatus {
    interface Raw {
        message: string;
        s3PreSignedReadUrl?: string | null;
    }
}
",
                        "name": "FailedTaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const FinishedTaskStatus: core.serialization.ObjectSchema<
    serializers.FinishedTaskStatus.Raw,
    Fiddle.FinishedTaskStatus
> = core.serialization.object({
    hasFilesToDownload: core.serialization.boolean(),
    s3PreSignedReadUrl: core.serialization.string(),
    s3PreSignedReadUrlV2: core.serialization.string().optional(),
});

export declare namespace FinishedTaskStatus {
    interface Raw {
        hasFilesToDownload: boolean;
        s3PreSignedReadUrl: string;
        s3PreSignedReadUrlV2?: string | null;
    }
}
",
                        "name": "FinishedTaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GeneratorConfig: core.serialization.ObjectSchema<serializers.GeneratorConfig.Raw, Fiddle.GeneratorConfig> =
    core.serialization.object({
        id: core.serialization.string(),
        version: core.serialization.string(),
        customConfig: core.serialization.unknown(),
        willDownloadFiles: core.serialization.boolean(),
        outputs: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GeneratorOutputs),
    });

export declare namespace GeneratorConfig {
    interface Raw {
        id: string;
        version: string;
        customConfig?: unknown;
        willDownloadFiles: boolean;
        outputs: serializers.GeneratorOutputs.Raw;
    }
}
",
                        "name": "GeneratorConfig.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GeneratorConfigV2: core.serialization.ObjectSchema<
    serializers.GeneratorConfigV2.Raw,
    Fiddle.GeneratorConfigV2
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.string(),
    customConfig: core.serialization.unknown(),
    outputMode: core.serialization.lazy(async () => (await import(\\"../../..\\")).OutputMode),
});

export declare namespace GeneratorConfigV2 {
    interface Raw {
        id: string;
        version: string;
        customConfig?: unknown;
        outputMode: serializers.OutputMode.Raw;
    }
}
",
                        "name": "GeneratorConfigV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GeneratorIdAndVersion: core.serialization.ObjectSchema<
    serializers.GeneratorIdAndVersion.Raw,
    Fiddle.GeneratorIdAndVersion
> = core.serialization.object({
    id: core.serialization.string(),
    version: core.serialization.string(),
});

export declare namespace GeneratorIdAndVersion {
    interface Raw {
        id: string;
        version: string;
    }
}
",
                        "name": "GeneratorIdAndVersion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GeneratorOutputs: core.serialization.ObjectSchema<
    serializers.GeneratorOutputs.Raw,
    Fiddle.GeneratorOutputs
> = core.serialization.object({
    npm: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).NpmOutput).optional(),
    maven: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MavenOutput).optional(),
});

export declare namespace GeneratorOutputs {
    interface Raw {
        npm?: serializers.NpmOutput.Raw | null;
        maven?: serializers.MavenOutput.Raw | null;
    }
}
",
                        "name": "GeneratorOutputs.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GeneratorsDoNotExistErrorBodyType: core.serialization.ObjectSchema<
    serializers.GeneratorsDoNotExistErrorBodyType.Raw,
    Fiddle.GeneratorsDoNotExistErrorBodyType
> = core.serialization.object({
    nonExistentGenerators: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GeneratorIdAndVersion)
    ),
});

export declare namespace GeneratorsDoNotExistErrorBodyType {
    interface Raw {
        nonExistentGenerators: serializers.GeneratorIdAndVersion.Raw[];
    }
}
",
                        "name": "GeneratorsDoNotExistErrorBodyType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GithubOutputMode: core.serialization.ObjectSchema<
    serializers.GithubOutputMode.Raw,
    Fiddle.GithubOutputMode
> = core.serialization.object({
    owner: core.serialization.string(),
    repo: core.serialization.string(),
    publishInfo: core.serialization.lazy(async () => (await import(\\"../../..\\")).GithubPublishInfo).optional(),
});

export declare namespace GithubOutputMode {
    interface Raw {
        owner: string;
        repo: string;
        publishInfo?: serializers.GithubPublishInfo.Raw | null;
    }
}
",
                        "name": "GithubOutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const GithubPublishInfo: core.serialization.Schema<serializers.GithubPublishInfo.Raw, Fiddle.GithubPublishInfo> =
    core.serialization
        .union(\\"type\\", {
            npm: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).NpmOutputWithOptionalToken),
            maven: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MavenOutputWithOptionalCreds),
            postman: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PostmanOutput),
        })
        .transform<Fiddle.GithubPublishInfo>({
            transform: (value) => {
                switch (value.type) {
                    case \\"npm\\":
                        return Fiddle.GithubPublishInfo.npm(value);
                    case \\"maven\\":
                        return Fiddle.GithubPublishInfo.maven(value);
                    case \\"postman\\":
                        return Fiddle.GithubPublishInfo.postman(value);
                    default:
                        return Fiddle.GithubPublishInfo._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace GithubPublishInfo {
    type Raw = GithubPublishInfo.Npm | GithubPublishInfo.Maven | GithubPublishInfo.Postman;

    interface Npm extends serializers.NpmOutputWithOptionalToken.Raw {
        type: \\"npm\\";
    }

    interface Maven extends serializers.MavenOutputWithOptionalCreds.Raw {
        type: \\"maven\\";
    }

    interface Postman extends serializers.PostmanOutput.Raw {
        type: \\"postman\\";
    }
}
",
                        "name": "GithubPublishInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const InsufficientPermissionsDetails: core.serialization.ObjectSchema<
    serializers.InsufficientPermissionsDetails.Raw,
    Fiddle.InsufficientPermissionsDetails
> = core.serialization.object({
    dummy: core.serialization.string().optional(),
});

export declare namespace InsufficientPermissionsDetails {
    interface Raw {
        dummy?: string | null;
    }
}
",
                        "name": "InsufficientPermissionsDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const LogLevel: core.serialization.Schema<serializers.LogLevel.Raw, Fiddle.LogLevel> = core.serialization.enum_([
    \\"DEBUG\\",
    \\"INFO\\",
    \\"WARN\\",
    \\"ERROR\\",
]);

export declare namespace LogLevel {
    type Raw = \\"DEBUG\\" | \\"INFO\\" | \\"WARN\\" | \\"ERROR\\";
}
",
                        "name": "LogLevel.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const MavenCoordinate: core.serialization.ObjectSchema<serializers.MavenCoordinate.Raw, Fiddle.MavenCoordinate> =
    core.serialization.object({
        group: core.serialization.string(),
        artifact: core.serialization.string(),
        version: core.serialization.string(),
    });

export declare namespace MavenCoordinate {
    interface Raw {
        group: string;
        artifact: string;
        version: string;
    }
}
",
                        "name": "MavenCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const MavenOutput: core.serialization.ObjectSchema<serializers.MavenOutput.Raw, Fiddle.MavenOutput> =
    core.serialization.object({
        registryUrl: core.serialization.string(),
        username: core.serialization.string(),
        password: core.serialization.string(),
        coordinate: core.serialization.string(),
    });

export declare namespace MavenOutput {
    interface Raw {
        registryUrl: string;
        username: string;
        password: string;
        coordinate: string;
    }
}
",
                        "name": "MavenOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const MavenOutputWithOptionalCreds: core.serialization.ObjectSchema<
    serializers.MavenOutputWithOptionalCreds.Raw,
    Fiddle.MavenOutputWithOptionalCreds
> = core.serialization.object({
    registryUrl: core.serialization.string(),
    coordinate: core.serialization.string(),
    credentials: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).UsernamePassword).optional(),
});

export declare namespace MavenOutputWithOptionalCreds {
    interface Raw {
        registryUrl: string;
        coordinate: string;
        credentials?: serializers.UsernamePassword.Raw | null;
    }
}
",
                        "name": "MavenOutputWithOptionalCreds.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const NpmCoordinate: core.serialization.ObjectSchema<serializers.NpmCoordinate.Raw, Fiddle.NpmCoordinate> =
    core.serialization.object({
        name: core.serialization.string(),
        version: core.serialization.string(),
    });

export declare namespace NpmCoordinate {
    interface Raw {
        name: string;
        version: string;
    }
}
",
                        "name": "NpmCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const NpmOutput: core.serialization.ObjectSchema<serializers.NpmOutput.Raw, Fiddle.NpmOutput> =
    core.serialization.object({
        registryUrl: core.serialization.string(),
        packageName: core.serialization.string(),
        token: core.serialization.string(),
    });

export declare namespace NpmOutput {
    interface Raw {
        registryUrl: string;
        packageName: string;
        token: string;
    }
}
",
                        "name": "NpmOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const NpmOutputWithOptionalToken: core.serialization.ObjectSchema<
    serializers.NpmOutputWithOptionalToken.Raw,
    Fiddle.NpmOutputWithOptionalToken
> = core.serialization.object({
    registryUrl: core.serialization.string(),
    packageName: core.serialization.string(),
    token: core.serialization.string().optional(),
});

export declare namespace NpmOutputWithOptionalToken {
    interface Raw {
        registryUrl: string;
        packageName: string;
        token?: string | null;
    }
}
",
                        "name": "NpmOutputWithOptionalToken.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const OutputMode: core.serialization.Schema<serializers.OutputMode.Raw, Fiddle.OutputMode> = core.serialization
    .union(\\"type\\", {
        publish: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PublishOutputMode),
        publishV2: core.serialization.object({
            publishV2: core.serialization.lazy(async () => (await import(\\"../../..\\")).PublishOutputModeV2),
        }),
        downloadFiles: core.serialization.object({}),
        github: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GithubOutputMode),
    })
    .transform<Fiddle.OutputMode>({
        transform: (value) => {
            switch (value.type) {
                case \\"publish\\":
                    return Fiddle.OutputMode.publish(value);
                case \\"publishV2\\":
                    return Fiddle.OutputMode.publishV2(value.publishV2);
                case \\"downloadFiles\\":
                    return Fiddle.OutputMode.downloadFiles();
                case \\"github\\":
                    return Fiddle.OutputMode.github(value);
                default:
                    return Fiddle.OutputMode._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace OutputMode {
    type Raw = OutputMode.Publish | OutputMode.PublishV2 | OutputMode.DownloadFiles | OutputMode.Github;

    interface Publish extends serializers.PublishOutputMode.Raw {
        type: \\"publish\\";
    }

    interface PublishV2 {
        type: \\"publishV2\\";
        publishV2: serializers.PublishOutputModeV2.Raw;
    }

    interface DownloadFiles {
        type: \\"downloadFiles\\";
    }

    interface Github extends serializers.GithubOutputMode.Raw {
        type: \\"github\\";
    }
}
",
                        "name": "OutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const Package: core.serialization.ObjectSchema<serializers.Package.Raw, Fiddle.Package> =
    core.serialization.object({
        coordinate: core.serialization.lazy(async () => (await import(\\"../../..\\")).PackageCoordinate),
        status: core.serialization.lazy(async () => (await import(\\"../../..\\")).PackagePublishStatus),
    });

export declare namespace Package {
    interface Raw {
        coordinate: serializers.PackageCoordinate.Raw;
        status: serializers.PackagePublishStatus.Raw;
    }
}
",
                        "name": "Package.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PackageCoordinate: core.serialization.Schema<serializers.PackageCoordinate.Raw, Fiddle.PackageCoordinate> =
    core.serialization
        .union(core.serialization.discriminant(\\"type\\", \\"_type\\"), {
            npm: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).NpmCoordinate),
            maven: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MavenCoordinate),
            pypi: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PypiCoordinate),
        })
        .transform<Fiddle.PackageCoordinate>({
            transform: (value) => {
                switch (value.type) {
                    case \\"npm\\":
                        return Fiddle.PackageCoordinate.npm(value);
                    case \\"maven\\":
                        return Fiddle.PackageCoordinate.maven(value);
                    case \\"pypi\\":
                        return Fiddle.PackageCoordinate.pypi(value);
                    default:
                        return Fiddle.PackageCoordinate._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace PackageCoordinate {
    type Raw = PackageCoordinate.Npm | PackageCoordinate.Maven | PackageCoordinate.Pypi;

    interface Npm extends serializers.NpmCoordinate.Raw {
        _type: \\"npm\\";
    }

    interface Maven extends serializers.MavenCoordinate.Raw {
        _type: \\"maven\\";
    }

    interface Pypi extends serializers.PypiCoordinate.Raw {
        _type: \\"pypi\\";
    }
}
",
                        "name": "PackageCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PackagePublishStatus: core.serialization.Schema<
    serializers.PackagePublishStatus.Raw,
    Fiddle.PackagePublishStatus
> = core.serialization.enum_([\\"NOT_STARTED_PUBLISHING\\", \\"PUBLISHING\\", \\"PUBLISHED\\", \\"FAILED_TO_PUBLISH\\"]);

export declare namespace PackagePublishStatus {
    type Raw = \\"NOT_STARTED_PUBLISHING\\" | \\"PUBLISHING\\" | \\"PUBLISHED\\" | \\"FAILED_TO_PUBLISH\\";
}
",
                        "name": "PackagePublishStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PostmanOutput: core.serialization.ObjectSchema<serializers.PostmanOutput.Raw, Fiddle.PostmanOutput> =
    core.serialization.object({
        apiKey: core.serialization.string(),
        workspaceId: core.serialization.string(),
    });

export declare namespace PostmanOutput {
    interface Raw {
        apiKey: string;
        workspaceId: string;
    }
}
",
                        "name": "PostmanOutput.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PublishOutputMode: core.serialization.ObjectSchema<
    serializers.PublishOutputMode.Raw,
    Fiddle.PublishOutputMode
> = core.serialization.object({
    registryOverrides: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RegistryOverrides),
});

export declare namespace PublishOutputMode {
    interface Raw {
        registryOverrides: serializers.RegistryOverrides.Raw;
    }
}
",
                        "name": "PublishOutputMode.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PublishOutputModeV2: core.serialization.Schema<
    serializers.PublishOutputModeV2.Raw,
    Fiddle.PublishOutputModeV2
> = core.serialization
    .union(\\"type\\", {
        npmOverride: core.serialization.object({
            npmOverride: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).NpmOutput).optional(),
        }),
        mavenOverride: core.serialization.object({
            mavenOverride: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MavenOutput).optional(),
        }),
        postman: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PostmanOutput),
    })
    .transform<Fiddle.PublishOutputModeV2>({
        transform: (value) => {
            switch (value.type) {
                case \\"npmOverride\\":
                    return Fiddle.PublishOutputModeV2.npmOverride(value.npmOverride);
                case \\"mavenOverride\\":
                    return Fiddle.PublishOutputModeV2.mavenOverride(value.mavenOverride);
                case \\"postman\\":
                    return Fiddle.PublishOutputModeV2.postman(value);
                default:
                    return Fiddle.PublishOutputModeV2._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace PublishOutputModeV2 {
    type Raw = PublishOutputModeV2.NpmOverride | PublishOutputModeV2.MavenOverride | PublishOutputModeV2.Postman;

    interface NpmOverride {
        type: \\"npmOverride\\";
        npmOverride?: serializers.NpmOutput.Raw | null;
    }

    interface MavenOverride {
        type: \\"mavenOverride\\";
        mavenOverride?: serializers.MavenOutput.Raw | null;
    }

    interface Postman extends serializers.PostmanOutput.Raw {
        type: \\"postman\\";
    }
}
",
                        "name": "PublishOutputModeV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const PypiCoordinate: core.serialization.ObjectSchema<serializers.PypiCoordinate.Raw, Fiddle.PypiCoordinate> =
    core.serialization.object({
        name: core.serialization.string(),
        version: core.serialization.string(),
    });

export declare namespace PypiCoordinate {
    interface Raw {
        name: string;
        version: string;
    }
}
",
                        "name": "PypiCoordinate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const RegistryOverrides: core.serialization.ObjectSchema<
    serializers.RegistryOverrides.Raw,
    Fiddle.RegistryOverrides
> = core.serialization.object({
    npm: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).NpmOutput).optional(),
    maven: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MavenOutput).optional(),
});

export declare namespace RegistryOverrides {
    interface Raw {
        npm?: serializers.NpmOutput.Raw | null;
        maven?: serializers.MavenOutput.Raw | null;
    }
}
",
                        "name": "RegistryOverrides.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const RemoteGenJobId: core.serialization.Schema<serializers.RemoteGenJobId.Raw, Fiddle.RemoteGenJobId> =
    core.serialization.string().transform({
        transform: Fiddle.RemoteGenJobId,
        untransform: (value) => value,
    });

export declare namespace RemoteGenJobId {
    type Raw = string;
}
",
                        "name": "RemoteGenJobId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const RemoteGenTaskId: core.serialization.Schema<serializers.RemoteGenTaskId.Raw, Fiddle.RemoteGenTaskId> =
    core.serialization.string().transform({
        transform: Fiddle.RemoteGenTaskId,
        untransform: (value) => value,
    });

export declare namespace RemoteGenTaskId {
    type Raw = string;
}
",
                        "name": "RemoteGenTaskId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const Task: core.serialization.ObjectSchema<serializers.Task.Raw, Fiddle.Task> = core.serialization.object({
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).TaskStatus),
    packages: core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Package)),
    logs: core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TaskLog)),
});

export declare namespace Task {
    interface Raw {
        status: serializers.TaskStatus.Raw;
        packages: serializers.Package.Raw[];
        logs: serializers.TaskLog.Raw[];
    }
}
",
                        "name": "Task.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const TaskLog: core.serialization.ObjectSchema<serializers.TaskLog.Raw, Fiddle.TaskLog> =
    core.serialization.object({
        level: core.serialization.lazy(async () => (await import(\\"../../..\\")).LogLevel),
        message: core.serialization.string(),
    });

export declare namespace TaskLog {
    interface Raw {
        level: serializers.LogLevel.Raw;
        message: string;
    }
}
",
                        "name": "TaskLog.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const TaskStatus: core.serialization.Schema<serializers.TaskStatus.Raw, Fiddle.TaskStatus> = core.serialization
    .union(core.serialization.discriminant(\\"type\\", \\"_type\\"), {
        notStarted: core.serialization.object({}),
        running: core.serialization.object({}),
        failed: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FailedTaskStatus),
        finished: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FinishedTaskStatus),
    })
    .transform<Fiddle.TaskStatus>({
        transform: (value) => {
            switch (value.type) {
                case \\"notStarted\\":
                    return Fiddle.TaskStatus.notStarted();
                case \\"running\\":
                    return Fiddle.TaskStatus.running();
                case \\"failed\\":
                    return Fiddle.TaskStatus.failed(value);
                case \\"finished\\":
                    return Fiddle.TaskStatus.finished(value);
                default:
                    return Fiddle.TaskStatus._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TaskStatus {
    type Raw = TaskStatus.NotStarted | TaskStatus.Running | TaskStatus.Failed | TaskStatus.Finished;

    interface NotStarted {
        _type: \\"notStarted\\";
    }

    interface Running {
        _type: \\"running\\";
    }

    interface Failed extends serializers.FailedTaskStatus.Raw {
        _type: \\"failed\\";
    }

    interface Finished extends serializers.FinishedTaskStatus.Raw {
        _type: \\"finished\\";
    }
}
",
                        "name": "TaskStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { Fiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../../core\\";

export const UsernamePassword: core.serialization.ObjectSchema<
    serializers.UsernamePassword.Raw,
    Fiddle.UsernamePassword
> = core.serialization.object({
    username: core.serialization.string(),
    password: core.serialization.string(),
});

export declare namespace UsernamePassword {
    interface Raw {
        username: string;
        password: string;
    }
}
",
                        "name": "UsernamePassword.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./RemoteGenJobId\\";
export * from \\"./RemoteGenTaskId\\";
export * from \\"./GeneratorIdAndVersion\\";
export * from \\"./GeneratorConfig\\";
export * from \\"./GeneratorConfigV2\\";
export * from \\"./OutputMode\\";
export * from \\"./PublishOutputMode\\";
export * from \\"./PublishOutputModeV2\\";
export * from \\"./RegistryOverrides\\";
export * from \\"./GeneratorOutputs\\";
export * from \\"./NpmOutput\\";
export * from \\"./MavenOutput\\";
export * from \\"./PostmanOutput\\";
export * from \\"./GithubOutputMode\\";
export * from \\"./GithubPublishInfo\\";
export * from \\"./NpmOutputWithOptionalToken\\";
export * from \\"./MavenOutputWithOptionalCreds\\";
export * from \\"./UsernamePassword\\";
export * from \\"./Task\\";
export * from \\"./TaskStatus\\";
export * from \\"./FailedTaskStatus\\";
export * from \\"./FinishedTaskStatus\\";
export * from \\"./TaskLog\\";
export * from \\"./LogLevel\\";
export * from \\"./Package\\";
export * from \\"./PackagePublishStatus\\";
export * from \\"./PackageCoordinate\\";
export * from \\"./NpmCoordinate\\";
export * from \\"./MavenCoordinate\\";
export * from \\"./PypiCoordinate\\";
export * from \\"./CreateJobResponse\\";
export * from \\"./GeneratorsDoNotExistErrorBodyType\\";
export * from \\"./CannotPublishToNpmScopeDetails\\";
export * from \\"./CannotPublishToMavenGroupDetails\\";
export * from \\"./InsufficientPermissionsDetails\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "remoteGen",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-fern/fiddle-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator nursery-property-discriminant 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access restricted
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "tabWidth: 4
printWidth: 120
",
    "name": ".prettierrc.yml",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.1\\",
    \\"private\\": true,
    \\"repository\\": \\"https://github.com/fern/api}\\",
    \\"files\\": [
        \\"dist\\"
    ],
    \\"main\\": \\"./dist/index.js\\",
    \\"types\\": \\"./dist/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write 'src/**/*.ts'\\",
        \\"build\\": \\"tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"./core\\";
import * as serializers from \\"./serialization\\";
import * as errors from \\"./errors\\";
import { Client as OwnerClient } from \\"./api/resources/owner/client/Client\\";
import { Client as PackageClient } from \\"./api/resources/package/client/Client\\";
import { Client as TokenClient } from \\"./api/resources/token/client/Client\\";

export declare namespace FernApiClient {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class FernApiClient {
    constructor(private readonly options: FernApiClient.Options) {}

    public async getString(): Promise<FernApi.RootString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.RootString.parseOrThrow(_response.body as serializers.RootString.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    #owner: OwnerClient | undefined;

    public get owner(): OwnerClient {
        return (this.#owner ??= new OwnerClient(this.options));
    }

    #package: PackageClient | undefined;

    public get package(): PackageClient {
        return (this.#package ??= new PackageClient(this.options));
    }

    #token: TokenClient | undefined;

    public get token(): TokenClient {
        return (this.#token ??= new TokenClient(this.options));
    }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as package_ from \\"./package\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
export * from \\"./token/errors\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";
import * as core from \\"../../../../core\\";
import * as errors from \\"../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * @throws {FernApi.OwnerAlreadyExistsError}
     */
    public async create(request: FernApi.CreateOwnerRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin((this.options.environment ?? environments.FernApiEnvironment.Production).serverA, \\"/owner\\"),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.CreateOwnerRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"OwnerAlreadyExistsError\\":
                    throw new FernApi.OwnerAlreadyExistsError(
                        await serializers.OwnerId.parseOrThrow(_response.error.body as serializers.OwnerId.Raw, {
                            allowUnknownKeys: true,
                        })
                    );
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async get(ownerId: FernApi.OwnerId): Promise<FernApi.Owner> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
                \`/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.Owner.parseOrThrow(_response.body as serializers.Owner.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"OwnerNotFoundError\\":
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async update(ownerId: FernApi.OwnerId, request: FernApi.UpdateOwnerRequest): Promise<FernApi.Owner> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
                \`/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"PUT\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.UpdateOwnerRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.Owner.parseOrThrow(_response.body as serializers.Owner.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"OwnerNotFoundError\\":
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateOwnerRequest {
    ownerId: FernApi.OwnerId;
    data?: unknown;
}
",
                            "name": "CreateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
    data?: unknown;
}
",
                            "name": "UpdateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";
import { FernApi } from \\"@fern/api\\";

export class OwnerAlreadyExistsError extends errors.FernApiError {
    constructor(body: FernApi.OwnerId) {
        super({
            message: \\"OwnerAlreadyExistsError\\",
            statusCode: 400,
            body: body,
        });
        Object.setPrototypeOf(this, OwnerAlreadyExistsError.prototype);
    }
}
",
                        "name": "OwnerAlreadyExistsError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class OwnerNotFoundError extends errors.FernApiError {
    constructor() {
        super({
            message: \\"OwnerNotFoundError\\",
            statusCode: 404,
        });
        Object.setPrototypeOf(this, OwnerNotFoundError.prototype);
    }
}
",
                        "name": "OwnerNotFoundError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerAlreadyExistsError\\";
export * from \\"./OwnerNotFoundError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "errors",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface Owner {
    ownerId: FernApi.OwnerId;
    data?: unknown;
}
",
                        "name": "Owner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Unique id for an owner.
 */
export type OwnerId = string;
",
                        "name": "OwnerId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "owner",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";
import * as serializers from \\"../../../../serialization\\";
import * as errors from \\"../../../../errors\\";
import { Client as NestedClient } from \\"../resources/nested/client/Client\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getString(): Promise<FernApi.package_.PackageString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.package_.PackageString.parseOrThrow(
                _response.body as serializers.package_.PackageString.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    #nested: NestedClient | undefined;

    public get nested(): NestedClient {
        return (this.#nested ??= new NestedClient(this.options));
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export {};
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as nested from \\"./nested\\";
export * from \\"./nested/types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../../core\\";
import * as serializers from \\"../../../../../../serialization\\";
import * as errors from \\"../../../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getString(): Promise<FernApi.package_.NestedString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.package_.NestedString.parseOrThrow(
                _response.body as serializers.package_.NestedString.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                                "name": "Client.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export {};
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "client",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type NestedString = string;
",
                                "name": "NestedString.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./NestedString\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "nested",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PackageString = string;
",
                        "name": "PackageString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PackageString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "package",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";
import * as core from \\"../../../../core\\";
import * as errors from \\"../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async create(request: FernApi.CreateTokenRequest): Promise<FernApi.CreateTokenResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \\"/tokens/create\\"
            ),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.CreateTokenRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.CreateTokenResponse.parseOrThrow(
                _response.body as serializers.CreateTokenResponse.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"OwnerNotFoundError\\":
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.TokenNotFoundError}
     */
    public async getTokenMetadata(request: FernApi.GetTokenMetadataRequest): Promise<FernApi.TokenMetadata> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \\"/tokens/metadata\\"
            ),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.GetTokenMetadataRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.TokenMetadata.parseOrThrow(_response.body as serializers.TokenMetadata.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"TokenNotFoundError\\":
                    throw new FernApi.TokenNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     * @throws {FernApi.UnknownError}
     */
    public async getTokensForOwner(ownerId: FernApi.OwnerId): Promise<FernApi.TokenMetadata[]> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \`/tokens/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.token.getTokensForOwner.Response.parseOrThrow(
                _response.body as serializers.token.getTokensForOwner.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as any)?.[\\"errorName\\"]) {
                case \\"OwnerNotFoundError\\":
                    throw new FernApi.OwnerNotFoundError();
                case \\"UnknownError\\":
                    throw new FernApi.UnknownError(_response.error.body);
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenRequest {
    ownerId: FernApi.OwnerId;
    description?: string;
}
",
                            "name": "CreateTokenRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
    token: string;
}
",
                            "name": "GetTokenMetadataRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class TokenNotFoundError extends errors.FernApiError {
    constructor() {
        super({
            message: \\"TokenNotFoundError\\",
            statusCode: 404,
        });
        Object.setPrototypeOf(this, TokenNotFoundError.prototype);
    }
}
",
                        "name": "TokenNotFoundError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class UnknownError extends errors.FernApiError {
    constructor(body?: unknown) {
        super({
            message: \\"UnknownError\\",
            statusCode: 500,
            body: body,
        });
        Object.setPrototypeOf(this, UnknownError.prototype);
    }
}
",
                        "name": "UnknownError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenNotFoundError\\";
export * from \\"./UnknownError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "errors",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenResponse {
    token: string;
    tokenId: FernApi.TokenId;
}
",
                        "name": "CreateTokenResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type TokenId = string;
",
                        "name": "TokenId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface TokenMetadata {
    tokenId: FernApi.TokenId;
    ownerId: FernApi.OwnerId;
    description?: string;
    createdTime: Date;
    status: FernApi.TokenStatus;
}
",
                        "name": "TokenMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export type TokenStatus =
    | FernApi.TokenStatus.Active
    | FernApi.TokenStatus.Expired
    | FernApi.TokenStatus.Revoked
    | FernApi.TokenStatus._Unknown;

export declare namespace TokenStatus {
    interface Active extends _Utils {
        type: \\"active\\";
    }

    interface Expired extends _Utils {
        type: \\"expired\\";
    }

    interface Revoked extends _Utils {
        type: \\"revoked\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: FernApi.TokenStatus._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        active: () => _Result;
        expired: () => _Result;
        revoked: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TokenStatus = {
    active: (): FernApi.TokenStatus.Active => {
        return {
            type: \\"active\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Active,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    expired: (): FernApi.TokenStatus.Expired => {
        return {
            type: \\"expired\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Expired,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    revoked: (): FernApi.TokenStatus.Revoked => {
        return {
            type: \\"revoked\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Revoked,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): FernApi.TokenStatus._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: FernApi.TokenStatus._Unknown,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: FernApi.TokenStatus, visitor: FernApi.TokenStatus._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"active\\":
                return visitor.active();
            case \\"expired\\":
                return visitor.expired();
            case \\"revoked\\":
                return visitor.revoked();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TokenStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "token",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type RootString = string;
",
                "name": "RootString.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./RootString\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
    fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: \\"status-code\\";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: \\"non-json\\";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: \\"timeout\\";
    }

    export interface UnknownError {
        reason: \\"unknown\\";
        errorMessage: string;
    }
}

export const fetcher: FetchFunction = async (args) => {
    const headers: Record<string, string> = {
        \\"Content-Type\\": \\"application/json\\",
    };

    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }

    try {
        const response = await axios({
            url: args.url,
            params: args.queryParameters,
            method: args.method,
            headers,
            data: args.body,
            validateStatus: () => true,
            transformResponse: (response) => response,
            timeout: args.timeoutMs ?? 60_000,
            transitional: {
                clarifyTimeoutError: true,
            },
            withCredentials: args.withCredentials,
        });

        let body: unknown;
        if (response.data != null && response.data.length > 0) {
            try {
                body = JSON.parse(response.data) ?? undefined;
            } catch {
                return {
                    ok: false,
                    error: {
                        reason: \\"non-json\\",
                        statusCode: response.status,
                        rawBody: response.data,
                    },
                };
            }
        }

        if (response.status >= 200 && response.status < 300) {
            return {
                ok: true,
                body,
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: \\"status-code\\",
                    statusCode: response.status,
                    body,
                },
            };
        }
    } catch (error) {
        if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
            return {
                ok: false,
                error: {
                    reason: \\"timeout\\",
                },
            };
        }

        return {
            ok: false,
            error: {
                reason: \\"unknown\\",
                errorMessage: (error as AxiosError).message,
            },
        };
    }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
    get: async <T>(supplier: Supplier<T>): Promise<T> => {
        if (typeof supplier === \\"function\\") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as serialization from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}

export const SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    OPTIONAL: \\"optional\\",
} as const;
export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

export type MaybeValid<T> = Valid<T> | Invalid;

export interface Valid<T> {
    ok: true;
    value: T;
}

export interface Invalid {
    ok: false;
    errors: ValidationError[];
}

export interface ValidationError {
    path: string[];
    message: string;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX =
    /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw) => {
            if (typeof raw === \\"string\\" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not an ISO 8601 date string\\",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Date object\\",
                        },
                    ],
                };
            }
        },
        getType: () => SchemaType.DATE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
    const validValues = new Set<string>(values);

    const schemaCreator = createIdentitySchemaCreator(SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === \\"string\\" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value as U,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \\"Not one of the allowed values\\",
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
    getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...constructLazyBaseSchema(getter),
        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => SchemaType.LIST,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformArray<Raw, Parsed>(
    value: unknown,
    transformItem: (item: Raw) => MaybePromise<MaybeValid<Parsed>>
): Promise<MaybeValid<Parsed[]>> {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: \\"Not a list\\",
                    path: [],
                },
            ],
        };
    }

    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));

    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
        (acc, item, index) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(
                    ...item.errors.map((error) => ({
                        path: [\`[\${index}]\`, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: [] }
    );
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to \\"\${literal}\\"\`,
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        _getRawProperties: () =>
            Promise.resolve(
                Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
            ),
        _getParsedProperties: () =>
            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

        parse: async (raw, opts) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey: parsedKey as string,
                    valueSchema,
                };

                rawKeyToProperty[rawKey] = property;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(rawKey);
                }
            }

            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        json: async (parsed, opts) => {
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(parsedKey as string);
                }
            }

            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (
                    parsedKey
                ):
                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }
                    | undefined => {
                    const property = schemas[parsedKey as keyof T];

                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }

                    if (isProperty(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        getType: () => SchemaType.OBJECT,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

async function validateAndTransformObject<Transformed>({
    value,
    requiredKeys,
    getProperty,
    allowUnknownKeys,
}: {
    value: unknown;
    requiredKeys: string[];
    getProperty: (
        preTransformedKey: string
    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;
    allowUnknownKeys: boolean;
}): Promise<MaybeValid<Transformed>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const missingRequiredKeys = new Set(requiredKeys);
    const errors: ValidationError[] = [];
    const transformed: Record<string | number | symbol, any> = {};

    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);

        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);

            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                errors.push(
                    ...value.errors.map((error) => ({
                        path: [preTransformedKey, ...error.path],
                        message: error.message,
                    }))
                );
            }
        } else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        } else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key \\"\${preTransformedKey}\\"\`,
            });
        }
    }

    errors.push(
        ...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
                path: [],
                message: \`Missing required key \\"\${key}\\"\`,
            }))
    );

    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed as Transformed,
        };
    } else {
        return {
            ok: false,
            errors,
        };
    }
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => SchemaType.OBJECT,
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}

async function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
    extensionKeys,
    value,
    transformBase,
    transformExtension,
}: {
    extensionKeys: (keyof PreTransformedExtension)[];
    value: unknown;
    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;
    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;
}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
        extensionPropertiesSet.has(key as keyof PreTransformedExtension)
    );

    const transformedBase = await transformBase(filterObject(value, baseProperties));
    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));

    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    } else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed> &
    ObjectUtils<Raw, Parsed> &
    SchemaUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }

            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value,
                    };
                },
                {}
            );

            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...(additionalProperties as Properties),
                },
            };
        },

        json: (parsed, opts) => {
            if (!isPlainObject(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }

            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = filterObject(
                parsed,
                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },

        getType: () => objectLike.getType(),
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export { type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const any = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({ ok: true, value }));
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const boolean = createIdentitySchemaCreator<boolean>(SchemaType.BOOLEAN, (value) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a boolean\\",
                },
            ],
        };
    }
});
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const number = createIdentitySchemaCreator<number>(SchemaType.NUMBER, (value) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a number\\",
                },
            ],
        };
    }
});
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const string = createIdentitySchemaCreator<string>(SchemaType.STRING, (value) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a string\\",
                },
            ],
        };
    }
});
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const unknown = createIdentitySchemaCreator<unknown>(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
export { type BaseRecordSchema, type RecordSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseRecordSchema, RecordSchema } from \\"./types\\";

export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => SchemaType.RECORD,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
    value,
    isKeyNumeric,
    transformKey,
    transformValue,
}: {
    value: unknown;
    isKeyNumeric: boolean;
    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;
    transformValue: (value: unknown) => MaybePromise<MaybeValid<TransformedValue>>;
}): Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    return entries(value).reduce<Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>>>(
        async (accPromise, [stringKey, value]) => {
            // skip nullish keys
            if (value == null) {
                return accPromise;
            }

            const acc = await accPromise;

            let key: string | number = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = await transformKey(key);

            const transformedValue = await transformValue(value);

            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: {
                        ...acc.value,
                        [transformedKey.value]: transformedValue.value,
                    },
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(
                    ...transformedKey.errors.map((error) => ({
                        path: [\`\${key} (key)\`, ...error.path],
                        message: error.message,
                    }))
                );
            }
            if (!transformedValue.ok) {
                errors.push(
                    ...transformedValue.errors.map((error) => ({
                        path: [stringKey, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        Promise.resolve({ ok: true, value: {} as OptionalRecord<TransformedKey, TransformedValue> })
    );
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { SchemaUtils } from \\"../schema-utils\\";

export type RecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
    SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;

export type BaseRecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class JsonError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
",
                        "name": "JsonError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class ParseError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
",
                        "name": "ParseError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaOptions, SchemaType } from \\"../../Schema\\";
import { JsonError } from \\"./JsonError\\";
import { ParseError } from \\"./ParseError\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}

export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError(raw.errors);
        },
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>
): Schema<Raw | null | undefined, Parsed | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<Raw, Parsed, Transformed>(
    schema: BaseSchema<Raw, Parsed>,
    transformer: SchemaTransformer<Parsed, Transformed>
): Schema<Raw, Transformed> {
    const baseSchema: BaseSchema<Raw, Transformed> = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";

export function stringifyValidationError(error: ValidationError): string {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
",
                        "name": "stringifyValidationErrors.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { list } from \\"../list\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const listSchema = list(schema);
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            } else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Set\\",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => SchemaType.SET,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, SchemaType } from \\"../../Schema\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { enum_ } from \\"../enum\\";
import { ObjectSchema } from \\"../object\\";
import { getObjectLikeUtils, ObjectLikeSchema } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const discriminantValueSchema = enum_(keys(union) as string[]);

    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(
                raw,
                rawDiscriminant,
                parsedDiscriminant,
                (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.parse(additionalProperties, opts)
            );
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(
                parsed,
                parsedDiscriminant,
                rawDiscriminant,
                (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.json(additionalProperties, opts)
            );
        },
        getType: () => SchemaType.UNION,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}

async function transformAndValidateUnion<
    TransformedDiscriminant extends string,
    TransformedDiscriminantValue extends string,
    TransformedAdditionalProperties
>(
    value: unknown,
    discriminant: string,
    transformedDiscriminant: TransformedDiscriminant,
    transformDiscriminantValue: (discriminantValue: unknown) => MaybePromise<MaybeValid<TransformedDiscriminantValue>>,
    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined,
    allowUnknownKeys: boolean,
    transformAdditionalProperties: (
        additionalProperties: unknown,
        additionalPropertiesSchema: ObjectSchema<any, any>
    ) => MaybePromise<MaybeValid<TransformedAdditionalProperties>>
): Promise<
    MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties>
> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const { [discriminant]: discriminantValue, ...additionalProperties } = value;

    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                },
            ],
        };
    }

    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }

    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);

    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: \\"Unrecognized discriminant value\\",
                    },
                ],
            };
        }
    }

    const transformedAdditionalProperties = await transformAdditionalProperties(
        additionalProperties,
        additionalPropertiesSchema
    );
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }

    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
    };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type MaybePromise<T> = T | Promise<T>;
",
                    "name": "MaybePromise.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                    "name": "OptionalRecord.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../builders/schema-utils\\";
import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";

export function createIdentitySchemaCreator<T>(
    schemaType: SchemaType,
    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>
): () => Schema<T, T> {
    return () => {
        const baseSchema: BaseSchema<T, T> = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };

        return {
            ...baseSchema,
            ...getSchemaUtils(baseSchema),
        };
    };
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key as K)) {
            acc[key as K] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export const NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";

// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
export function isPlainObject(value: unknown): value is Record<string, unknown> {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }

    if (Object.getPrototypeOf(value) === null) {
        return true;
    }

    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(value) === proto;
}
",
                    "name": "isPlainObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FernApiEnvironmentUrls {
    serverA: string;
    serverB: string;
}

export const FernApiEnvironment = {
    Production: {
        serverA: \\"a.prod.com\\",
        serverB: \\"b.prod.com\\",
    },
    Staging: {
        serverA: \\"a.staging.com\\",
        serverB: \\"b.staging.com\\",
    },
} as const;

export type FernApiEnvironment = typeof FernApiEnvironment.Production | typeof FernApiEnvironment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class FernApiError extends Error {
    readonly statusCode?: number;
    readonly body?: unknown;

    constructor({ message, statusCode, body }: { message?: string; statusCode?: number; body?: unknown }) {
        super(message);
        Object.setPrototypeOf(this, FernApiError.prototype);
        if (statusCode != null) {
            this.statusCode = statusCode;
        }

        if (body !== undefined) {
            this.body = body;
        }
    }
}
",
            "name": "FernApiError.ts",
            "type": "file",
          },
          Object {
            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class FernApiTimeoutError extends Error {
    constructor() {
        super(\\"Timeout\\");
        Object.setPrototypeOf(this, FernApiTimeoutError.prototype);
    }
}
",
            "name": "FernApiTimeoutError.ts",
            "type": "file",
          },
          Object {
            "contents": "export { FernApiError } from \\"./FernApiError\\";
export { FernApiTimeoutError } from \\"./FernApiTimeoutError\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "errors",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./api\\";
export { FernApiClient } from \\"./Client\\";
export { FernApiEnvironment, FernApiEnvironmentUrls } from \\"./environments\\";
export { FernApiError, FernApiTimeoutError } from \\"./errors\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as package_ from \\"./package\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const CreateOwnerRequest: core.serialization.Schema<
    serializers.CreateOwnerRequest.Raw,
    FernApi.CreateOwnerRequest
> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../../..\\")).OwnerId),
    data: core.serialization.unknown(),
});

export declare namespace CreateOwnerRequest {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        data?: unknown;
    }
}
",
                            "name": "CreateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const UpdateOwnerRequest: core.serialization.Schema<
    serializers.UpdateOwnerRequest.Raw,
    FernApi.UpdateOwnerRequest
> = core.serialization.object({
    data: core.serialization.unknown(),
});

export declare namespace UpdateOwnerRequest {
    interface Raw {
        data?: unknown;
    }
}
",
                            "name": "UpdateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const Owner: core.serialization.ObjectSchema<serializers.Owner.Raw, FernApi.Owner> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../..\\")).OwnerId),
    data: core.serialization.unknown(),
});

export declare namespace Owner {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        data?: unknown;
    }
}
",
                        "name": "Owner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const OwnerId: core.serialization.Schema<serializers.OwnerId.Raw, FernApi.OwnerId> = core.serialization.string();

export declare namespace OwnerId {
    type Raw = string;
}
",
                        "name": "OwnerId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "owner",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as nested from \\"./nested\\";
export * from \\"./nested/types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * from \\"./types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../../core\\";

export const NestedString: core.serialization.Schema<
    serializers.package_.NestedString.Raw,
    FernApi.package_.NestedString
> = core.serialization.string();

export declare namespace NestedString {
    type Raw = string;
}
",
                                "name": "NestedString.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./NestedString\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "nested",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const PackageString: core.serialization.Schema<
    serializers.package_.PackageString.Raw,
    FernApi.package_.PackageString
> = core.serialization.string();

export declare namespace PackageString {
    type Raw = string;
}
",
                        "name": "PackageString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PackageString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "package",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.token.getTokensForOwner.Response.Raw,
    FernApi.TokenMetadata[]
> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TokenMetadata));

export declare namespace Response {
    type Raw = serializers.TokenMetadata.Raw[];
}
",
                        "name": "getTokensForOwner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getTokensForOwner from \\"./getTokensForOwner\\";
export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const CreateTokenRequest: core.serialization.Schema<
    serializers.CreateTokenRequest.Raw,
    FernApi.CreateTokenRequest
> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../../..\\")).OwnerId),
    description: core.serialization.string().optional(),
});

export declare namespace CreateTokenRequest {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        description?: string | null;
    }
}
",
                            "name": "CreateTokenRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const GetTokenMetadataRequest: core.serialization.Schema<
    serializers.GetTokenMetadataRequest.Raw,
    FernApi.GetTokenMetadataRequest
> = core.serialization.object({
    token: core.serialization.string(),
});

export declare namespace GetTokenMetadataRequest {
    interface Raw {
        token: string;
    }
}
",
                            "name": "GetTokenMetadataRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const CreateTokenResponse: core.serialization.ObjectSchema<
    serializers.CreateTokenResponse.Raw,
    FernApi.CreateTokenResponse
> = core.serialization.object({
    token: core.serialization.string(),
    tokenId: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenId),
});

export declare namespace CreateTokenResponse {
    interface Raw {
        token: string;
        tokenId: serializers.TokenId.Raw;
    }
}
",
                        "name": "CreateTokenResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenId: core.serialization.Schema<serializers.TokenId.Raw, FernApi.TokenId> = core.serialization.string();

export declare namespace TokenId {
    type Raw = string;
}
",
                        "name": "TokenId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenMetadata: core.serialization.ObjectSchema<serializers.TokenMetadata.Raw, FernApi.TokenMetadata> =
    core.serialization.object({
        tokenId: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenId),
        ownerId: core.serialization.lazy(async () => (await import(\\"../../..\\")).OwnerId),
        description: core.serialization.string().optional(),
        createdTime: core.serialization.date(),
        status: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenStatus),
    });

export declare namespace TokenMetadata {
    interface Raw {
        tokenId: serializers.TokenId.Raw;
        ownerId: serializers.OwnerId.Raw;
        description?: string | null;
        createdTime: string;
        status: serializers.TokenStatus.Raw;
    }
}
",
                        "name": "TokenMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenStatus: core.serialization.Schema<serializers.TokenStatus.Raw, FernApi.TokenStatus> =
    core.serialization
        .union(\\"type\\", {
            active: core.serialization.object({}),
            expired: core.serialization.object({}),
            revoked: core.serialization.object({}),
        })
        .transform<FernApi.TokenStatus>({
            transform: (value) => {
                switch (value.type) {
                    case \\"active\\":
                        return FernApi.TokenStatus.active();
                    case \\"expired\\":
                        return FernApi.TokenStatus.expired();
                    case \\"revoked\\":
                        return FernApi.TokenStatus.revoked();
                    default:
                        return FernApi.TokenStatus._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace TokenStatus {
    type Raw = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked;

    interface Active {
        type: \\"active\\";
    }

    interface Expired {
        type: \\"expired\\";
    }

    interface Revoked {
        type: \\"revoked\\";
    }
}
",
                        "name": "TokenStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "token",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../core\\";

export const RootString: core.serialization.Schema<serializers.RootString.Raw, FernApi.RootString> =
    core.serialization.string();

export declare namespace RootString {
    type Raw = string;
}
",
                "name": "RootString.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./RootString\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"extendedDiagnostics\\": true,
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"CommonJS\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"dist\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator nursery-status-code 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access restricted
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "tabWidth: 4
printWidth: 120
",
    "name": ".prettierrc.yml",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.1\\",
    \\"private\\": true,
    \\"repository\\": \\"https://github.com/fern/api}\\",
    \\"files\\": [
        \\"dist\\"
    ],
    \\"main\\": \\"./dist/index.js\\",
    \\"types\\": \\"./dist/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write 'src/**/*.ts'\\",
        \\"build\\": \\"tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"./core\\";
import * as serializers from \\"./serialization\\";
import * as errors from \\"./errors\\";
import { Client as OwnerClient } from \\"./api/resources/owner/client/Client\\";
import { Client as PackageClient } from \\"./api/resources/package/client/Client\\";
import { Client as TokenClient } from \\"./api/resources/token/client/Client\\";

export declare namespace FernApiClient {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class FernApiClient {
    constructor(private readonly options: FernApiClient.Options) {}

    public async getString(): Promise<FernApi.RootString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.RootString.parseOrThrow(_response.body as serializers.RootString.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    #owner: OwnerClient | undefined;

    public get owner(): OwnerClient {
        return (this.#owner ??= new OwnerClient(this.options));
    }

    #package: PackageClient | undefined;

    public get package(): PackageClient {
        return (this.#package ??= new PackageClient(this.options));
    }

    #token: TokenClient | undefined;

    public get token(): TokenClient {
        return (this.#token ??= new TokenClient(this.options));
    }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as package_ from \\"./package\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
export * from \\"./token/errors\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";
import * as core from \\"../../../../core\\";
import * as errors from \\"../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * @throws {FernApi.OwnerAlreadyExistsError}
     */
    public async create(request: FernApi.CreateOwnerRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin((this.options.environment ?? environments.FernApiEnvironment.Production).serverA, \\"/owner\\"),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.CreateOwnerRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new FernApi.OwnerAlreadyExistsError(
                        await serializers.OwnerId.parseOrThrow(_response.error.body as serializers.OwnerId.Raw, {
                            allowUnknownKeys: true,
                        })
                    );
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async get(ownerId: FernApi.OwnerId): Promise<FernApi.Owner> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
                \`/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.Owner.parseOrThrow(_response.body as serializers.Owner.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async update(ownerId: FernApi.OwnerId, request: FernApi.UpdateOwnerRequest): Promise<FernApi.Owner> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
                \`/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"PUT\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.UpdateOwnerRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.Owner.parseOrThrow(_response.body as serializers.Owner.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateOwnerRequest {
    ownerId: FernApi.OwnerId;
    data?: unknown;
}
",
                            "name": "CreateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
    data?: unknown;
}
",
                            "name": "UpdateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";
import { FernApi } from \\"@fern/api\\";

export class OwnerAlreadyExistsError extends errors.FernApiError {
    constructor(body: FernApi.OwnerId) {
        super({
            message: \\"OwnerAlreadyExistsError\\",
            statusCode: 400,
            body: body,
        });
        Object.setPrototypeOf(this, OwnerAlreadyExistsError.prototype);
    }
}
",
                        "name": "OwnerAlreadyExistsError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class OwnerNotFoundError extends errors.FernApiError {
    constructor() {
        super({
            message: \\"OwnerNotFoundError\\",
            statusCode: 404,
        });
        Object.setPrototypeOf(this, OwnerNotFoundError.prototype);
    }
}
",
                        "name": "OwnerNotFoundError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerAlreadyExistsError\\";
export * from \\"./OwnerNotFoundError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "errors",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface Owner {
    ownerId: FernApi.OwnerId;
    data?: unknown;
}
",
                        "name": "Owner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Unique id for an owner.
 */
export type OwnerId = string;
",
                        "name": "OwnerId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "owner",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";
import * as serializers from \\"../../../../serialization\\";
import * as errors from \\"../../../../errors\\";
import { Client as NestedClient } from \\"../resources/nested/client/Client\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getString(): Promise<FernApi.package_.PackageString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.package_.PackageString.parseOrThrow(
                _response.body as serializers.package_.PackageString.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    #nested: NestedClient | undefined;

    public get nested(): NestedClient {
        return (this.#nested ??= new NestedClient(this.options));
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export {};
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as nested from \\"./nested\\";
export * from \\"./nested/types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../../core\\";
import * as serializers from \\"../../../../../../serialization\\";
import * as errors from \\"../../../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getString(): Promise<FernApi.package_.NestedString> {
        const _response = await core.fetcher({
            url: (this.options.environment ?? environments.FernApiEnvironment.Production).serverA,
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.package_.NestedString.parseOrThrow(
                _response.body as serializers.package_.NestedString.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                                "name": "Client.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export {};
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "client",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type NestedString = string;
",
                                "name": "NestedString.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./NestedString\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "nested",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PackageString = string;
",
                        "name": "PackageString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PackageString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "package",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";
import * as core from \\"../../../../core\\";
import * as errors from \\"../../../../errors\\";

export declare namespace Client {
    interface Options {
        environment?: environments.FernApiEnvironment | environments.FernApiEnvironmentUrls;
        apiVersion: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * @throws {FernApi.OwnerNotFoundError}
     */
    public async create(request: FernApi.CreateTokenRequest): Promise<FernApi.CreateTokenResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \\"/tokens/create\\"
            ),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.CreateTokenRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.CreateTokenResponse.parseOrThrow(
                _response.body as serializers.CreateTokenResponse.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new FernApi.OwnerNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.TokenNotFoundError}
     */
    public async getTokenMetadata(request: FernApi.GetTokenMetadataRequest): Promise<FernApi.TokenMetadata> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \\"/tokens/metadata\\"
            ),
            method: \\"POST\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
            body: await serializers.GetTokenMetadataRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.TokenMetadata.parseOrThrow(_response.body as serializers.TokenMetadata.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new FernApi.TokenNotFoundError();
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * @throws {FernApi.OwnerNotFoundError}
     * @throws {FernApi.UnknownError}
     */
    public async getTokensForOwner(ownerId: FernApi.OwnerId): Promise<FernApi.TokenMetadata[]> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.FernApiEnvironment.Production).serverB,
                \`/tokens/owner/\${await serializers.OwnerId.jsonOrThrow(ownerId)}\`
            ),
            method: \\"GET\\",
            headers: {
                \\"X-API-Version\\": this.options.apiVersion,
            },
        });
        if (_response.ok) {
            return await serializers.token.getTokensForOwner.Response.parseOrThrow(
                _response.body as serializers.token.getTokensForOwner.Response.Raw,
                { allowUnknownKeys: true }
            );
        }

        if (_response.error.reason === \\"status-code\\") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new FernApi.OwnerNotFoundError();
                case 500:
                    throw new FernApi.UnknownError(_response.error.body);
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case \\"non-json\\":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case \\"timeout\\":
                throw new errors.FernApiTimeoutError();
            case \\"unknown\\":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenRequest {
    ownerId: FernApi.OwnerId;
    description?: string;
}
",
                            "name": "CreateTokenRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
    token: string;
}
",
                            "name": "GetTokenMetadataRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class TokenNotFoundError extends errors.FernApiError {
    constructor() {
        super({
            message: \\"TokenNotFoundError\\",
            statusCode: 404,
        });
        Object.setPrototypeOf(this, TokenNotFoundError.prototype);
    }
}
",
                        "name": "TokenNotFoundError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from \\"../../../../errors\\";

export class UnknownError extends errors.FernApiError {
    constructor(body?: unknown) {
        super({
            message: \\"UnknownError\\",
            statusCode: 500,
            body: body,
        });
        Object.setPrototypeOf(this, UnknownError.prototype);
    }
}
",
                        "name": "UnknownError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenNotFoundError\\";
export * from \\"./UnknownError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "errors",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenResponse {
    token: string;
    tokenId: FernApi.TokenId;
}
",
                        "name": "CreateTokenResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type TokenId = string;
",
                        "name": "TokenId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface TokenMetadata {
    tokenId: FernApi.TokenId;
    ownerId: FernApi.OwnerId;
    description?: string;
    createdTime: Date;
    status: FernApi.TokenStatus;
}
",
                        "name": "TokenMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export type TokenStatus =
    | FernApi.TokenStatus.Active
    | FernApi.TokenStatus.Expired
    | FernApi.TokenStatus.Revoked
    | FernApi.TokenStatus._Unknown;

export declare namespace TokenStatus {
    interface Active extends _Utils {
        type: \\"active\\";
    }

    interface Expired extends _Utils {
        type: \\"expired\\";
    }

    interface Revoked extends _Utils {
        type: \\"revoked\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: FernApi.TokenStatus._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        active: () => _Result;
        expired: () => _Result;
        revoked: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TokenStatus = {
    active: (): FernApi.TokenStatus.Active => {
        return {
            type: \\"active\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Active,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    expired: (): FernApi.TokenStatus.Expired => {
        return {
            type: \\"expired\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Expired,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    revoked: (): FernApi.TokenStatus.Revoked => {
        return {
            type: \\"revoked\\",
            _visit: function <_Result>(
                this: FernApi.TokenStatus.Revoked,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): FernApi.TokenStatus._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: FernApi.TokenStatus._Unknown,
                visitor: FernApi.TokenStatus._Visitor<_Result>
            ) {
                return FernApi.TokenStatus._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: FernApi.TokenStatus, visitor: FernApi.TokenStatus._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"active\\":
                return visitor.active();
            case \\"expired\\":
                return visitor.expired();
            case \\"revoked\\":
                return visitor.revoked();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TokenStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "token",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type RootString = string;
",
                "name": "RootString.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./RootString\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
    fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: \\"status-code\\";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: \\"non-json\\";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: \\"timeout\\";
    }

    export interface UnknownError {
        reason: \\"unknown\\";
        errorMessage: string;
    }
}

export const fetcher: FetchFunction = async (args) => {
    const headers: Record<string, string> = {
        \\"Content-Type\\": \\"application/json\\",
    };

    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }

    try {
        const response = await axios({
            url: args.url,
            params: args.queryParameters,
            method: args.method,
            headers,
            data: args.body,
            validateStatus: () => true,
            transformResponse: (response) => response,
            timeout: args.timeoutMs ?? 60_000,
            transitional: {
                clarifyTimeoutError: true,
            },
            withCredentials: args.withCredentials,
        });

        let body: unknown;
        if (response.data != null && response.data.length > 0) {
            try {
                body = JSON.parse(response.data) ?? undefined;
            } catch {
                return {
                    ok: false,
                    error: {
                        reason: \\"non-json\\",
                        statusCode: response.status,
                        rawBody: response.data,
                    },
                };
            }
        }

        if (response.status >= 200 && response.status < 300) {
            return {
                ok: true,
                body,
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: \\"status-code\\",
                    statusCode: response.status,
                    body,
                },
            };
        }
    } catch (error) {
        if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
            return {
                ok: false,
                error: {
                    reason: \\"timeout\\",
                },
            };
        }

        return {
            ok: false,
            error: {
                reason: \\"unknown\\",
                errorMessage: (error as AxiosError).message,
            },
        };
    }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
    get: async <T>(supplier: Supplier<T>): Promise<T> => {
        if (typeof supplier === \\"function\\") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as serialization from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}

export const SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    OPTIONAL: \\"optional\\",
} as const;
export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

export type MaybeValid<T> = Valid<T> | Invalid;

export interface Valid<T> {
    ok: true;
    value: T;
}

export interface Invalid {
    ok: false;
    errors: ValidationError[];
}

export interface ValidationError {
    path: string[];
    message: string;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX =
    /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw) => {
            if (typeof raw === \\"string\\" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not an ISO 8601 date string\\",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Date object\\",
                        },
                    ],
                };
            }
        },
        getType: () => SchemaType.DATE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
    const validValues = new Set<string>(values);

    const schemaCreator = createIdentitySchemaCreator(SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === \\"string\\" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value as U,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \\"Not one of the allowed values\\",
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
    getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...constructLazyBaseSchema(getter),
        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => SchemaType.LIST,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformArray<Raw, Parsed>(
    value: unknown,
    transformItem: (item: Raw) => MaybePromise<MaybeValid<Parsed>>
): Promise<MaybeValid<Parsed[]>> {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: \\"Not a list\\",
                    path: [],
                },
            ],
        };
    }

    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));

    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
        (acc, item, index) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(
                    ...item.errors.map((error) => ({
                        path: [\`[\${index}]\`, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: [] }
    );
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to \\"\${literal}\\"\`,
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        _getRawProperties: () =>
            Promise.resolve(
                Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
            ),
        _getParsedProperties: () =>
            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

        parse: async (raw, opts) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey: parsedKey as string,
                    valueSchema,
                };

                rawKeyToProperty[rawKey] = property;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(rawKey);
                }
            }

            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        json: async (parsed, opts) => {
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(parsedKey as string);
                }
            }

            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (
                    parsedKey
                ):
                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }
                    | undefined => {
                    const property = schemas[parsedKey as keyof T];

                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }

                    if (isProperty(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        getType: () => SchemaType.OBJECT,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

async function validateAndTransformObject<Transformed>({
    value,
    requiredKeys,
    getProperty,
    allowUnknownKeys,
}: {
    value: unknown;
    requiredKeys: string[];
    getProperty: (
        preTransformedKey: string
    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;
    allowUnknownKeys: boolean;
}): Promise<MaybeValid<Transformed>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const missingRequiredKeys = new Set(requiredKeys);
    const errors: ValidationError[] = [];
    const transformed: Record<string | number | symbol, any> = {};

    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);

        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);

            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                errors.push(
                    ...value.errors.map((error) => ({
                        path: [preTransformedKey, ...error.path],
                        message: error.message,
                    }))
                );
            }
        } else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        } else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key \\"\${preTransformedKey}\\"\`,
            });
        }
    }

    errors.push(
        ...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
                path: [],
                message: \`Missing required key \\"\${key}\\"\`,
            }))
    );

    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed as Transformed,
        };
    } else {
        return {
            ok: false,
            errors,
        };
    }
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => SchemaType.OBJECT,
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}

async function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
    extensionKeys,
    value,
    transformBase,
    transformExtension,
}: {
    extensionKeys: (keyof PreTransformedExtension)[];
    value: unknown;
    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;
    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;
}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
        extensionPropertiesSet.has(key as keyof PreTransformedExtension)
    );

    const transformedBase = await transformBase(filterObject(value, baseProperties));
    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));

    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    } else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed> &
    ObjectUtils<Raw, Parsed> &
    SchemaUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }

            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value,
                    };
                },
                {}
            );

            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...(additionalProperties as Properties),
                },
            };
        },

        json: (parsed, opts) => {
            if (!isPlainObject(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }

            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = filterObject(
                parsed,
                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },

        getType: () => objectLike.getType(),
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export { type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const any = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({ ok: true, value }));
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const boolean = createIdentitySchemaCreator<boolean>(SchemaType.BOOLEAN, (value) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a boolean\\",
                },
            ],
        };
    }
});
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const number = createIdentitySchemaCreator<number>(SchemaType.NUMBER, (value) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a number\\",
                },
            ],
        };
    }
});
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const string = createIdentitySchemaCreator<string>(SchemaType.STRING, (value) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a string\\",
                },
            ],
        };
    }
});
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const unknown = createIdentitySchemaCreator<unknown>(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
export { type BaseRecordSchema, type RecordSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseRecordSchema, RecordSchema } from \\"./types\\";

export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => SchemaType.RECORD,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
    value,
    isKeyNumeric,
    transformKey,
    transformValue,
}: {
    value: unknown;
    isKeyNumeric: boolean;
    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;
    transformValue: (value: unknown) => MaybePromise<MaybeValid<TransformedValue>>;
}): Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    return entries(value).reduce<Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>>>(
        async (accPromise, [stringKey, value]) => {
            // skip nullish keys
            if (value == null) {
                return accPromise;
            }

            const acc = await accPromise;

            let key: string | number = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = await transformKey(key);

            const transformedValue = await transformValue(value);

            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: {
                        ...acc.value,
                        [transformedKey.value]: transformedValue.value,
                    },
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(
                    ...transformedKey.errors.map((error) => ({
                        path: [\`\${key} (key)\`, ...error.path],
                        message: error.message,
                    }))
                );
            }
            if (!transformedValue.ok) {
                errors.push(
                    ...transformedValue.errors.map((error) => ({
                        path: [stringKey, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        Promise.resolve({ ok: true, value: {} as OptionalRecord<TransformedKey, TransformedValue> })
    );
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { SchemaUtils } from \\"../schema-utils\\";

export type RecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
    SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;

export type BaseRecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class JsonError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
",
                        "name": "JsonError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class ParseError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
",
                        "name": "ParseError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaOptions, SchemaType } from \\"../../Schema\\";
import { JsonError } from \\"./JsonError\\";
import { ParseError } from \\"./ParseError\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}

export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError(raw.errors);
        },
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>
): Schema<Raw | null | undefined, Parsed | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<Raw, Parsed, Transformed>(
    schema: BaseSchema<Raw, Parsed>,
    transformer: SchemaTransformer<Parsed, Transformed>
): Schema<Raw, Transformed> {
    const baseSchema: BaseSchema<Raw, Transformed> = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";

export function stringifyValidationError(error: ValidationError): string {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
",
                        "name": "stringifyValidationErrors.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { list } from \\"../list\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const listSchema = list(schema);
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            } else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Set\\",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => SchemaType.SET,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, SchemaType } from \\"../../Schema\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { enum_ } from \\"../enum\\";
import { ObjectSchema } from \\"../object\\";
import { getObjectLikeUtils, ObjectLikeSchema } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const discriminantValueSchema = enum_(keys(union) as string[]);

    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(
                raw,
                rawDiscriminant,
                parsedDiscriminant,
                (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.parse(additionalProperties, opts)
            );
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(
                parsed,
                parsedDiscriminant,
                rawDiscriminant,
                (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.json(additionalProperties, opts)
            );
        },
        getType: () => SchemaType.UNION,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}

async function transformAndValidateUnion<
    TransformedDiscriminant extends string,
    TransformedDiscriminantValue extends string,
    TransformedAdditionalProperties
>(
    value: unknown,
    discriminant: string,
    transformedDiscriminant: TransformedDiscriminant,
    transformDiscriminantValue: (discriminantValue: unknown) => MaybePromise<MaybeValid<TransformedDiscriminantValue>>,
    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined,
    allowUnknownKeys: boolean,
    transformAdditionalProperties: (
        additionalProperties: unknown,
        additionalPropertiesSchema: ObjectSchema<any, any>
    ) => MaybePromise<MaybeValid<TransformedAdditionalProperties>>
): Promise<
    MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties>
> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const { [discriminant]: discriminantValue, ...additionalProperties } = value;

    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                },
            ],
        };
    }

    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }

    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);

    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: \\"Unrecognized discriminant value\\",
                    },
                ],
            };
        }
    }

    const transformedAdditionalProperties = await transformAdditionalProperties(
        additionalProperties,
        additionalPropertiesSchema
    );
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }

    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
    };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type MaybePromise<T> = T | Promise<T>;
",
                    "name": "MaybePromise.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                    "name": "OptionalRecord.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../builders/schema-utils\\";
import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";

export function createIdentitySchemaCreator<T>(
    schemaType: SchemaType,
    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>
): () => Schema<T, T> {
    return () => {
        const baseSchema: BaseSchema<T, T> = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };

        return {
            ...baseSchema,
            ...getSchemaUtils(baseSchema),
        };
    };
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key as K)) {
            acc[key as K] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export const NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";

// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
export function isPlainObject(value: unknown): value is Record<string, unknown> {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }

    if (Object.getPrototypeOf(value) === null) {
        return true;
    }

    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(value) === proto;
}
",
                    "name": "isPlainObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FernApiEnvironmentUrls {
    serverA: string;
    serverB: string;
}

export const FernApiEnvironment = {
    Production: {
        serverA: \\"a.prod.com\\",
        serverB: \\"b.prod.com\\",
    },
    Staging: {
        serverA: \\"a.staging.com\\",
        serverB: \\"b.staging.com\\",
    },
} as const;

export type FernApiEnvironment = typeof FernApiEnvironment.Production | typeof FernApiEnvironment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class FernApiError extends Error {
    readonly statusCode?: number;
    readonly body?: unknown;

    constructor({ message, statusCode, body }: { message?: string; statusCode?: number; body?: unknown }) {
        super(message);
        Object.setPrototypeOf(this, FernApiError.prototype);
        if (statusCode != null) {
            this.statusCode = statusCode;
        }

        if (body !== undefined) {
            this.body = body;
        }
    }
}
",
            "name": "FernApiError.ts",
            "type": "file",
          },
          Object {
            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class FernApiTimeoutError extends Error {
    constructor() {
        super(\\"Timeout\\");
        Object.setPrototypeOf(this, FernApiTimeoutError.prototype);
    }
}
",
            "name": "FernApiTimeoutError.ts",
            "type": "file",
          },
          Object {
            "contents": "export { FernApiError } from \\"./FernApiError\\";
export { FernApiTimeoutError } from \\"./FernApiTimeoutError\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "errors",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./api\\";
export { FernApiClient } from \\"./Client\\";
export { FernApiEnvironment, FernApiEnvironmentUrls } from \\"./environments\\";
export { FernApiError, FernApiTimeoutError } from \\"./errors\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as package_ from \\"./package\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const CreateOwnerRequest: core.serialization.Schema<
    serializers.CreateOwnerRequest.Raw,
    FernApi.CreateOwnerRequest
> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../../..\\")).OwnerId),
    data: core.serialization.unknown(),
});

export declare namespace CreateOwnerRequest {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        data?: unknown;
    }
}
",
                            "name": "CreateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const UpdateOwnerRequest: core.serialization.Schema<
    serializers.UpdateOwnerRequest.Raw,
    FernApi.UpdateOwnerRequest
> = core.serialization.object({
    data: core.serialization.unknown(),
});

export declare namespace UpdateOwnerRequest {
    interface Raw {
        data?: unknown;
    }
}
",
                            "name": "UpdateOwnerRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const Owner: core.serialization.ObjectSchema<serializers.Owner.Raw, FernApi.Owner> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../..\\")).OwnerId),
    data: core.serialization.unknown(),
});

export declare namespace Owner {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        data?: unknown;
    }
}
",
                        "name": "Owner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const OwnerId: core.serialization.Schema<serializers.OwnerId.Raw, FernApi.OwnerId> = core.serialization.string();

export declare namespace OwnerId {
    type Raw = string;
}
",
                        "name": "OwnerId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "owner",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./resources\\";
export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as nested from \\"./nested\\";
export * from \\"./nested/types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * from \\"./types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../../core\\";

export const NestedString: core.serialization.Schema<
    serializers.package_.NestedString.Raw,
    FernApi.package_.NestedString
> = core.serialization.string();

export declare namespace NestedString {
    type Raw = string;
}
",
                                "name": "NestedString.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./NestedString\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "nested",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const PackageString: core.serialization.Schema<
    serializers.package_.PackageString.Raw,
    FernApi.package_.PackageString
> = core.serialization.string();

export declare namespace PackageString {
    type Raw = string;
}
",
                        "name": "PackageString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PackageString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "package",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.token.getTokensForOwner.Response.Raw,
    FernApi.TokenMetadata[]
> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TokenMetadata));

export declare namespace Response {
    type Raw = serializers.TokenMetadata.Raw[];
}
",
                        "name": "getTokensForOwner.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getTokensForOwner from \\"./getTokensForOwner\\";
export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const CreateTokenRequest: core.serialization.Schema<
    serializers.CreateTokenRequest.Raw,
    FernApi.CreateTokenRequest
> = core.serialization.object({
    ownerId: core.serialization.lazy(async () => (await import(\\"../../../..\\")).OwnerId),
    description: core.serialization.string().optional(),
});

export declare namespace CreateTokenRequest {
    interface Raw {
        ownerId: serializers.OwnerId.Raw;
        description?: string | null;
    }
}
",
                            "name": "CreateTokenRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../../core\\";

export const GetTokenMetadataRequest: core.serialization.Schema<
    serializers.GetTokenMetadataRequest.Raw,
    FernApi.GetTokenMetadataRequest
> = core.serialization.object({
    token: core.serialization.string(),
});

export declare namespace GetTokenMetadataRequest {
    interface Raw {
        token: string;
    }
}
",
                            "name": "GetTokenMetadataRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const CreateTokenResponse: core.serialization.ObjectSchema<
    serializers.CreateTokenResponse.Raw,
    FernApi.CreateTokenResponse
> = core.serialization.object({
    token: core.serialization.string(),
    tokenId: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenId),
});

export declare namespace CreateTokenResponse {
    interface Raw {
        token: string;
        tokenId: serializers.TokenId.Raw;
    }
}
",
                        "name": "CreateTokenResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenId: core.serialization.Schema<serializers.TokenId.Raw, FernApi.TokenId> = core.serialization.string();

export declare namespace TokenId {
    type Raw = string;
}
",
                        "name": "TokenId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenMetadata: core.serialization.ObjectSchema<serializers.TokenMetadata.Raw, FernApi.TokenMetadata> =
    core.serialization.object({
        tokenId: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenId),
        ownerId: core.serialization.lazy(async () => (await import(\\"../../..\\")).OwnerId),
        description: core.serialization.string().optional(),
        createdTime: core.serialization.date(),
        status: core.serialization.lazy(async () => (await import(\\"../../..\\")).TokenStatus),
    });

export declare namespace TokenMetadata {
    interface Raw {
        tokenId: serializers.TokenId.Raw;
        ownerId: serializers.OwnerId.Raw;
        description?: string | null;
        createdTime: string;
        status: serializers.TokenStatus.Raw;
    }
}
",
                        "name": "TokenMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../../core\\";

export const TokenStatus: core.serialization.Schema<serializers.TokenStatus.Raw, FernApi.TokenStatus> =
    core.serialization
        .union(\\"type\\", {
            active: core.serialization.object({}),
            expired: core.serialization.object({}),
            revoked: core.serialization.object({}),
        })
        .transform<FernApi.TokenStatus>({
            transform: (value) => {
                switch (value.type) {
                    case \\"active\\":
                        return FernApi.TokenStatus.active();
                    case \\"expired\\":
                        return FernApi.TokenStatus.expired();
                    case \\"revoked\\":
                        return FernApi.TokenStatus.revoked();
                    default:
                        return FernApi.TokenStatus._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace TokenStatus {
    type Raw = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked;

    interface Active {
        type: \\"active\\";
    }

    interface Expired {
        type: \\"expired\\";
    }

    interface Revoked {
        type: \\"revoked\\";
    }
}
",
                        "name": "TokenStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "token",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../core\\";

export const RootString: core.serialization.Schema<serializers.RootString.Raw, FernApi.RootString> =
    core.serialization.string();

export declare namespace RootString {
    type Raw = string;
}
",
                "name": "RootString.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./RootString\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"extendedDiagnostics\\": true,
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"CommonJS\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"dist\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./resources\\"), exports);
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.package_ = void 0;
exports.package_ = __importStar(require(\\"./package\\"));
__exportStar(require(\\"./package/types\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./types\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export interface Package {
    name: string;
}
",
                    "name": "Package.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "Package.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./Package\\"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * as serialization from \\"./schemas\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.serialization = void 0;
exports.serialization = __importStar(require(\\"./schemas\\"));
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";
export declare type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export declare type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export declare type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;
export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}
export declare const SchemaType: {
    readonly DATE: \\"date\\";
    readonly ENUM: \\"enum\\";
    readonly LIST: \\"list\\";
    readonly STRING_LITERAL: \\"stringLiteral\\";
    readonly OBJECT: \\"object\\";
    readonly ANY: \\"any\\";
    readonly BOOLEAN: \\"boolean\\";
    readonly NUMBER: \\"number\\";
    readonly STRING: \\"string\\";
    readonly UNKNOWN: \\"unknown\\";
    readonly RECORD: \\"record\\";
    readonly SET: \\"set\\";
    readonly UNION: \\"union\\";
    readonly OPTIONAL: \\"optional\\";
};
export declare type SchemaType = typeof SchemaType[keyof typeof SchemaType];
export declare type MaybeValid<T> = Valid<T> | Invalid;
export interface Valid<T> {
    ok: true;
    value: T;
}
export interface Invalid {
    ok: false;
    errors: ValidationError[];
}
export interface ValidationError {
    path: string[];
    message: string;
}
export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
            "name": "Schema.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.SchemaType = void 0;
exports.SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    OPTIONAL: \\"optional\\",
};
",
            "name": "Schema.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function date(): Schema<string, Date>;
",
                    "name": "date.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.date = void 0;
const Schema_1 = require(\\"../../Schema\\");
const schema_utils_1 = require(\\"../schema-utils\\");
// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX = /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;
function date() {
    const baseSchema = {
        parse: (raw) => {
            if (typeof raw === \\"string\\" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not an ISO 8601 date string\\",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Date object\\",
                        },
                    ],
                };
            }
        },
        getType: () => Schema_1.SchemaType.DATE,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.date = date;
",
                    "name": "date.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.date = void 0;
var date_1 = require(\\"./date\\");
Object.defineProperty(exports, \\"date\\", { enumerable: true, get: function () { return date_1.date; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]>;
",
                    "name": "enum.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.enum_ = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
function enum_(values) {
    const validValues = new Set(values);
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === \\"string\\" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value,
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \\"Not one of the allowed values\\",
                    },
                ],
            };
        }
    });
    return schemaCreator();
}
exports.enum_ = enum_;
",
                    "name": "enum.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.enum_ = void 0;
var enum_1 = require(\\"./enum\\");
Object.defineProperty(exports, \\"enum_\\", { enumerable: true, get: function () { return enum_1.enum_; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./date\\"), exports);
__exportStar(require(\\"./enum\\"), exports);
__exportStar(require(\\"./lazy\\"), exports);
__exportStar(require(\\"./list\\"), exports);
__exportStar(require(\\"./literals\\"), exports);
__exportStar(require(\\"./object\\"), exports);
__exportStar(require(\\"./object-like\\"), exports);
__exportStar(require(\\"./primitives\\"), exports);
__exportStar(require(\\"./record\\"), exports);
__exportStar(require(\\"./schema-utils\\"), exports);
__exportStar(require(\\"./set\\"), exports);
__exportStar(require(\\"./union\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.lazyObject = exports.lazy = void 0;
var lazy_1 = require(\\"./lazy\\");
Object.defineProperty(exports, \\"lazy\\", { enumerable: true, get: function () { return lazy_1.lazy; } });
var lazyObject_1 = require(\\"./lazyObject\\");
Object.defineProperty(exports, \\"lazyObject\\", { enumerable: true, get: function () { return lazyObject_1.lazyObject; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
export declare type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;
export declare function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed>;
export declare function constructLazyBaseSchema<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): BaseSchema<Raw, Parsed>;
export declare function getMemoizedSchema<SchemaType extends Schema<any, any>>(getter: SchemaGetter<SchemaType>): Promise<SchemaType>;
",
                    "name": "lazy.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.getMemoizedSchema = exports.constructLazyBaseSchema = exports.lazy = void 0;
const schema_utils_1 = require(\\"../schema-utils\\");
function lazy(getter) {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.lazy = lazy;
function constructLazyBaseSchema(getter) {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}
exports.constructLazyBaseSchema = constructLazyBaseSchema;
async function getMemoizedSchema(getter) {
    const castedGetter = getter;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
exports.getMemoizedSchema = getMemoizedSchema;
",
                    "name": "lazy.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ObjectSchema } from \\"../object/types\\";
import { SchemaGetter } from \\"./lazy\\";
export declare function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed>;
",
                    "name": "lazyObject.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.lazyObject = void 0;
const object_1 = require(\\"../object\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
const lazy_1 = require(\\"./lazy\\");
function lazyObject(getter) {
    const baseSchema = {
        ...(0, lazy_1.constructLazyBaseSchema)(getter),
        _getRawProperties: async () => (await (0, lazy_1.getMemoizedSchema)(getter))._getRawProperties(),
        _getParsedProperties: async () => (await (0, lazy_1.getMemoizedSchema)(getter))._getParsedProperties(),
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
        ...(0, object_1.getObjectUtils)(baseSchema),
    };
}
exports.lazyObject = lazyObject;
",
                    "name": "lazyObject.js",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.list = void 0;
var list_1 = require(\\"./list\\");
Object.defineProperty(exports, \\"list\\", { enumerable: true, get: function () { return list_1.list; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]>;
",
                    "name": "list.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.list = void 0;
const Schema_1 = require(\\"../../Schema\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function list(schema) {
    const baseSchema = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => Schema_1.SchemaType.LIST,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.list = list;
async function validateAndTransformArray(value, transformItem) {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: \\"Not a list\\",
                    path: [],
                },
            ],
        };
    }
    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));
    return maybeValidItems.reduce((acc, item, index) => {
        if (acc.ok && item.ok) {
            return {
                ok: true,
                value: [...acc.value, item.value],
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!item.ok) {
            errors.push(...item.errors.map((error) => ({
                path: [\`[\${index}]\`, ...error.path],
                message: error.message,
            })));
        }
        return {
            ok: false,
            errors,
        };
    }, { ok: true, value: [] });
}
",
                    "name": "list.js",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringLiteral = void 0;
var stringLiteral_1 = require(\\"./stringLiteral\\");
Object.defineProperty(exports, \\"stringLiteral\\", { enumerable: true, get: function () { return stringLiteral_1.stringLiteral; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function stringLiteral<V extends string>(literal: V): Schema<V, V>;
",
                    "name": "stringLiteral.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringLiteral = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
function stringLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to \\"\${literal}\\"\`,
                    },
                ],
            };
        }
    });
    return schemaCreator();
}
exports.stringLiteral = stringLiteral;
",
                    "name": "stringLiteral.js",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export { type BaseObjectSchema, type inferObjectSchemaFromPropertySchemas, type inferParsedObject, type inferParsedObjectFromPropertySchemas, type inferParsedPropertySchema, type inferRawKey, type inferRawObject, type inferRawObjectFromPropertySchemas, type inferRawPropertySchema, type ObjectSchema, type ObjectUtils, type PropertySchemas, } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.property = exports.isProperty = exports.object = exports.getObjectUtils = void 0;
var object_1 = require(\\"./object\\");
Object.defineProperty(exports, \\"getObjectUtils\\", { enumerable: true, get: function () { return object_1.getObjectUtils; } });
Object.defineProperty(exports, \\"object\\", { enumerable: true, get: function () { return object_1.object; } });
var property_1 = require(\\"./property\\");
Object.defineProperty(exports, \\"isProperty\\", { enumerable: true, get: function () { return property_1.isProperty; } });
Object.defineProperty(exports, \\"property\\", { enumerable: true, get: function () { return property_1.property; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseObjectSchema, inferObjectSchemaFromPropertySchemas, ObjectUtils, PropertySchemas } from \\"./types\\";
export declare function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(schemas: T): inferObjectSchemaFromPropertySchemas<T>;
export declare function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed>;
",
                    "name": "object.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.getObjectUtils = exports.object = void 0;
const Schema_1 = require(\\"../../Schema\\");
const entries_1 = require(\\"../../utils/entries\\");
const filterObject_1 = require(\\"../../utils/filterObject\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const keys_1 = require(\\"../../utils/keys\\");
const partition_1 = require(\\"../../utils/partition\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
const property_1 = require(\\"./property\\");
function object(schemas) {
    const baseSchema = {
        _getRawProperties: () => Promise.resolve(Object.entries(schemas).map(([parsedKey, propertySchema]) => (0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey)),
        _getParsedProperties: () => Promise.resolve((0, keys_1.keys)(schemas)),
        parse: async (raw, opts) => {
            const rawKeyToProperty = {};
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                const property = {
                    rawKey,
                    parsedKey: parsedKey,
                    valueSchema,
                };
                rawKeyToProperty[rawKey] = property;
                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(rawKey);
                }
            }
            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },
        json: async (parsed, opts) => {
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(parsedKey);
                }
            }
            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (parsedKey) => {
                    const property = schemas[parsedKey];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }
                    if ((0, property_1.isProperty)(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    }
                    else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },
        getType: () => Schema_1.SchemaType.OBJECT,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
exports.object = object;
async function validateAndTransformObject({ value, requiredKeys, getProperty, allowUnknownKeys, }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    const missingRequiredKeys = new Set(requiredKeys);
    const errors = [];
    const transformed = {};
    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);
        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);
            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            }
            else {
                errors.push(...value.errors.map((error) => ({
                    path: [preTransformedKey, ...error.path],
                    message: error.message,
                })));
            }
        }
        else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        }
        else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key \\"\${preTransformedKey}\\"\`,
            });
        }
    }
    errors.push(...requiredKeys
        .filter((key) => missingRequiredKeys.has(key))
        .map((key) => ({
        path: [],
        message: \`Missing required key \\"\${key}\\"\`,
    })));
    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed,
        };
    }
    else {
        return {
            ok: false,
            errors,
        };
    }
}
function getObjectUtils(schema) {
    return {
        extend: (extension) => {
            const baseSchema = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => Schema_1.SchemaType.OBJECT,
            };
            return {
                ...baseSchema,
                ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
                ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}
exports.getObjectUtils = getObjectUtils;
async function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension, }) {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key) => extensionPropertiesSet.has(key));
    const transformedBase = await transformBase((0, filterObject_1.filterObject)(value, baseProperties));
    const transformedExtension = await transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    }
    else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                    "name": "object.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function property<RawKey extends string, RawValue, ParsedValue>(rawKey: RawKey, valueSchema: Schema<RawValue, ParsedValue>): Property<RawKey, RawValue, ParsedValue>;
export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}
export declare function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O;
",
                    "name": "property.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.isProperty = exports.property = void 0;
function property(rawKey, valueSchema) {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}
exports.property = property;
function isProperty(maybeProperty) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return maybeProperty.isProperty;
}
exports.isProperty = isProperty;
",
                    "name": "property.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";
export declare type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed> & ObjectUtils<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}
export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(schemas: ObjectSchema<RawExtension, ParsedExtension>) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}
export declare type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;
export declare type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed> ? Parsed : never;
export declare type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>>;
export declare type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
}>;
export declare type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
}>;
export declare type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<ParsedKeys, Property<any, any, any> | Schema<any, any>>;
export declare type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, infer Raw, any> ? Raw : P extends Schema<any, any> ? inferRaw<P> : never;
export declare type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, any, infer Parsed> ? Parsed : P extends Schema<any, any> ? inferParsed<P> : never;
export declare type inferRawKey<ParsedKey extends string | number | symbol, P extends Property<any, any, any> | Schema<any, any>> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema } from \\"../../Schema\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
export declare function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed>;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
export declare function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>, properties: {
    [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]);
}): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties>;
",
                    "name": "getObjectLikeUtils.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
const filterObject_1 = require(\\"../../utils/filterObject\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function getObjectLikeUtils(schema) {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}
exports.getObjectLikeUtils = getObjectLikeUtils;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
function withParsedProperties(objectLike, properties) {
    const objectSchema = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }
            const additionalProperties = Object.entries(properties).reduce((processed, [key, value]) => {
                return {
                    ...processed,
                    [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value,
                };
            }, {});
            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...additionalProperties,
                },
            };
        },
        json: (parsed, opts) => {
            if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)));
            return objectLike.json(parsedWithoutAddedProperties, opts);
        },
        getType: () => objectLike.getType(),
    };
    return {
        ...objectSchema,
        ...(0, schema_utils_1.getSchemaUtils)(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
exports.withParsedProperties = withParsedProperties;
",
                    "name": "getObjectLikeUtils.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export { type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
var getObjectLikeUtils_1 = require(\\"./getObjectLikeUtils\\");
Object.defineProperty(exports, \\"getObjectLikeUtils\\", { enumerable: true, get: function () { return getObjectLikeUtils_1.getObjectLikeUtils; } });
Object.defineProperty(exports, \\"withParsedProperties\\", { enumerable: true, get: function () { return getObjectLikeUtils_1.withParsedProperties; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
export declare type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> & BaseSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed>;
export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export declare const any: () => import(\\"../../Schema\\").Schema<any, any>;
",
                    "name": "any.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.any = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value) => ({ ok: true, value }));
",
                    "name": "any.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const boolean: () => import(\\"../../Schema\\").Schema<boolean, boolean>;
",
                    "name": "boolean.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.boolean = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a boolean\\",
                },
            ],
        };
    }
});
",
                    "name": "boolean.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.unknown = exports.string = exports.number = exports.boolean = exports.any = void 0;
var any_1 = require(\\"./any\\");
Object.defineProperty(exports, \\"any\\", { enumerable: true, get: function () { return any_1.any; } });
var boolean_1 = require(\\"./boolean\\");
Object.defineProperty(exports, \\"boolean\\", { enumerable: true, get: function () { return boolean_1.boolean; } });
var number_1 = require(\\"./number\\");
Object.defineProperty(exports, \\"number\\", { enumerable: true, get: function () { return number_1.number; } });
var string_1 = require(\\"./string\\");
Object.defineProperty(exports, \\"string\\", { enumerable: true, get: function () { return string_1.string; } });
var unknown_1 = require(\\"./unknown\\");
Object.defineProperty(exports, \\"unknown\\", { enumerable: true, get: function () { return unknown_1.unknown; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const number: () => import(\\"../../Schema\\").Schema<number, number>;
",
                    "name": "number.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.number = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a number\\",
                },
            ],
        };
    }
});
",
                    "name": "number.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const string: () => import(\\"../../Schema\\").Schema<string, string>;
",
                    "name": "string.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.string = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a string\\",
                },
            ],
        };
    }
});
",
                    "name": "string.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const unknown: () => import(\\"../../Schema\\").Schema<unknown, unknown>;
",
                    "name": "unknown.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.unknown = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                    "name": "unknown.js",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
export { type BaseRecordSchema, type RecordSchema } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.record = void 0;
var record_1 = require(\\"./record\\");
Object.defineProperty(exports, \\"record\\", { enumerable: true, get: function () { return record_1.record; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { RecordSchema } from \\"./types\\";
export declare function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(keySchema: Schema<RawKey, ParsedKey>, valueSchema: Schema<RawValue, ParsedValue>): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue>;
",
                    "name": "record.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.record = void 0;
const Schema_1 = require(\\"../../Schema\\");
const entries_1 = require(\\"../../utils/entries\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function record(keySchema, valueSchema) {
    const baseSchema = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => Schema_1.SchemaType.RECORD,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.record = record;
async function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    return (0, entries_1.entries)(value).reduce(async (accPromise, [stringKey, value]) => {
        // skip nullish keys
        if (value == null) {
            return accPromise;
        }
        const acc = await accPromise;
        let key = stringKey;
        if (isKeyNumeric) {
            const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
            if (!isNaN(numberKey)) {
                key = numberKey;
            }
        }
        const transformedKey = await transformKey(key);
        const transformedValue = await transformValue(value);
        if (acc.ok && transformedKey.ok && transformedValue.ok) {
            return {
                ok: true,
                value: {
                    ...acc.value,
                    [transformedKey.value]: transformedValue.value,
                },
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!transformedKey.ok) {
            errors.push(...transformedKey.errors.map((error) => ({
                path: [\`\${key} (key)\`, ...error.path],
                message: error.message,
            })));
        }
        if (!transformedValue.ok) {
            errors.push(...transformedValue.errors.map((error) => ({
                path: [stringKey, ...error.path],
                message: error.message,
            })));
        }
        return {
            ok: false,
            errors,
        };
    }, Promise.resolve({ ok: true, value: {} }));
}
",
                    "name": "record.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema } from \\"../../Schema\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { SchemaUtils } from \\"../schema-utils\\";
export declare type RecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> & SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
export declare type BaseRecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare class JsonError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                    "name": "JsonError.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.JsonError = void 0;
const stringifyValidationErrors_1 = require(\\"./stringifyValidationErrors\\");
class JsonError extends Error {
    errors;
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join(\\"; \\"));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
exports.JsonError = JsonError;
",
                    "name": "JsonError.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare class ParseError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                    "name": "ParseError.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.ParseError = void 0;
const stringifyValidationErrors_1 = require(\\"./stringifyValidationErrors\\");
class ParseError extends Error {
    errors;
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join(\\"; \\"));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
exports.ParseError = ParseError;
",
                    "name": "ParseError.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema, SchemaOptions } from \\"../../Schema\\";
export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}
export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}
export declare function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed>;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
export declare function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): Schema<Raw | null | undefined, Parsed | undefined>;
export declare function transform<Raw, Parsed, Transformed>(schema: BaseSchema<Raw, Parsed>, transformer: SchemaTransformer<Parsed, Transformed>): Schema<Raw, Transformed>;
",
                    "name": "getSchemaUtils.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.transform = exports.optional = exports.getSchemaUtils = void 0;
const Schema_1 = require(\\"../../Schema\\");
const JsonError_1 = require(\\"./JsonError\\");
const ParseError_1 = require(\\"./ParseError\\");
function getSchemaUtils(schema) {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError_1.ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError_1.JsonError(raw.errors);
        },
    };
}
exports.getSchemaUtils = getSchemaUtils;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
function optional(schema) {
    const baseSchema = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => Schema_1.SchemaType.OPTIONAL,
    };
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
exports.optional = optional;
function transform(schema, transformer) {
    const baseSchema = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
exports.transform = transform;
",
                    "name": "getSchemaUtils.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
var getSchemaUtils_1 = require(\\"./getSchemaUtils\\");
Object.defineProperty(exports, \\"getSchemaUtils\\", { enumerable: true, get: function () { return getSchemaUtils_1.getSchemaUtils; } });
Object.defineProperty(exports, \\"optional\\", { enumerable: true, get: function () { return getSchemaUtils_1.optional; } });
Object.defineProperty(exports, \\"transform\\", { enumerable: true, get: function () { return getSchemaUtils_1.transform; } });
var JsonError_1 = require(\\"./JsonError\\");
Object.defineProperty(exports, \\"JsonError\\", { enumerable: true, get: function () { return JsonError_1.JsonError; } });
var ParseError_1 = require(\\"./ParseError\\");
Object.defineProperty(exports, \\"ParseError\\", { enumerable: true, get: function () { return ParseError_1.ParseError; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare function stringifyValidationError(error: ValidationError): string;
",
                    "name": "stringifyValidationErrors.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringifyValidationError = void 0;
function stringifyValidationError(error) {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
exports.stringifyValidationError = stringifyValidationError;
",
                    "name": "stringifyValidationErrors.js",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.set = void 0;
var set_1 = require(\\"./set\\");
Object.defineProperty(exports, \\"set\\", { enumerable: true, get: function () { return set_1.set; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>>;
",
                    "name": "set.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.set = void 0;
const Schema_1 = require(\\"../../Schema\\");
const list_1 = require(\\"../list\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function set(schema) {
    const listSchema = (0, list_1.list)(schema);
    const baseSchema = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            }
            else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Set\\",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => Schema_1.SchemaType.SET,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.set = set;
",
                    "name": "set.js",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export declare function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(parsedDiscriminant: ParsedDiscriminant, rawDiscriminant: RawDiscriminant): Discriminant<RawDiscriminant, ParsedDiscriminant>;
export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.discriminant = void 0;
function discriminant(parsedDiscriminant, rawDiscriminant) {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}
exports.discriminant = discriminant;
",
                    "name": "discriminant.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export { type inferParsedDiscriminant, type inferParsedUnion, type inferRawDiscriminant, type inferRawUnion, type UnionSubtypes, } from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.union = exports.discriminant = void 0;
var discriminant_1 = require(\\"./discriminant\\");
Object.defineProperty(exports, \\"discriminant\\", { enumerable: true, get: function () { return discriminant_1.discriminant; } });
var union_1 = require(\\"./union\\");
Object.defineProperty(exports, \\"union\\", { enumerable: true, get: function () { return union_1.union; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";
export declare type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};
export declare type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];
export declare type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];
export declare type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<infer Raw, any> ? Raw : never;
export declare type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<any, infer Parsed> ? Parsed : never;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ObjectLikeSchema } from \\"../object-like\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedUnion, inferRawUnion, UnionSubtypes } from \\"./types\\";
export declare function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(discriminant: D, union: U): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>>;
",
                    "name": "union.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.union = void 0;
const Schema_1 = require(\\"../../Schema\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const keys_1 = require(\\"../../utils/keys\\");
const enum_1 = require(\\"../enum\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function union(discriminant, union) {
    const rawDiscriminant = typeof discriminant === \\"string\\" ? discriminant : discriminant.rawDiscriminant;
    const parsedDiscriminant = typeof discriminant === \\"string\\"
        ? discriminant
        : discriminant.parsedDiscriminant;
    const discriminantValueSchema = (0, enum_1.enum_)((0, keys_1.keys)(union));
    const baseSchema = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(raw, rawDiscriminant, parsedDiscriminant, (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts), (discriminantValue) => union[discriminantValue], opts?.allowUnknownKeys ?? false, (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts));
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(parsed, parsedDiscriminant, rawDiscriminant, (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts), (discriminantValue) => union[discriminantValue], opts?.allowUnknownKeys ?? false, (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts));
        },
        getType: () => Schema_1.SchemaType.UNION,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
    };
}
exports.union = union;
async function transformAndValidateUnion(value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnknownKeys, transformAdditionalProperties) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    const { [discriminant]: discriminantValue, ...additionalProperties } = value;
    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                },
            ],
        };
    }
    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }
    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                },
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: \\"Unrecognized discriminant value\\",
                    },
                ],
            };
        }
    }
    const transformedAdditionalProperties = await transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }
    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        },
    };
}
",
                    "name": "union.js",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./builders\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export declare type MaybePromise<T> = T | Promise<T>;
",
                "name": "MaybePromise.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                "name": "MaybePromise.js",
                "type": "file",
              },
              Object {
                "contents": "export declare type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                "name": "OptionalRecord.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                "name": "OptionalRecord.js",
                "type": "file",
              },
              Object {
                "contents": "export declare type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;
export declare type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];
export declare type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                "name": "addQuestionMarksToNullableProperties.js",
                "type": "file",
              },
              Object {
                "contents": "import { MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";
export declare function createIdentitySchemaCreator<T>(schemaType: SchemaType, validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>): () => Schema<T, T>;
",
                "name": "createIdentitySchemaCreator.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.createIdentitySchemaCreator = void 0;
const schema_utils_1 = require(\\"../builders/schema-utils\\");
function createIdentitySchemaCreator(schemaType, validate) {
    return () => {
        const baseSchema = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };
        return {
            ...baseSchema,
            ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        };
    };
}
exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
",
                "name": "createIdentitySchemaCreator.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function entries<T>(object: T): [keyof T, T[keyof T]][];
",
                "name": "entries.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.entries = void 0;
function entries(object) {
    return Object.entries(object);
}
exports.entries = entries;
",
                "name": "entries.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K>;
",
                "name": "filterObject.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.filterObject = void 0;
function filterObject(obj, keysToInclude) {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key)) {
            acc[key] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {});
}
exports.filterObject = filterObject;
",
                "name": "filterObject.js",
                "type": "file",
              },
              Object {
                "contents": "export declare const NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";
export declare function isPlainObject(value: unknown): value is Record<string, unknown>;
",
                "name": "isPlainObject.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.isPlainObject = exports.NOT_AN_OBJECT_ERROR_MESSAGE = void 0;
exports.NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
function isPlainObject(value) {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
exports.isPlainObject = isPlainObject;
",
                "name": "isPlainObject.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function keys<T>(object: T): (keyof T)[];
",
                "name": "keys.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.keys = void 0;
function keys(object) {
    return Object.keys(object);
}
exports.keys = keys;
",
                "name": "keys.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]];
",
                "name": "partition.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.partition = void 0;
function partition(items, predicate) {
    const trueItems = [], falseItems = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        }
        else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
exports.partition = partition;
",
                "name": "partition.js",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as FernApi from \\"./api\\";
",
    "name": "index.d.ts",
    "type": "file",
  },
  Object {
    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.FernApi = void 0;
exports.FernApi = __importStar(require(\\"./api\\"));
",
    "name": "index.js",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./resources\\"), exports);
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.package_ = void 0;
exports.package_ = __importStar(require(\\"./package\\"));
__exportStar(require(\\"./package/types\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./types\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from \\"../../..\\";
import { FernApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
export declare const Package: core.serialization.ObjectSchema<serializers.Package.Raw, FernApi.Package>;
export declare namespace Package {
    interface Raw {
        name: string;
    }
}
",
                    "name": "Package.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Package = void 0;
const core = __importStar(require(\\"../../../../core\\"));
exports.Package = core.serialization.object({
    name: core.serialization.string(),
});
",
                    "name": "Package.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./Package\\"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "serialization",
    "type": "directory",
  },
]
`;

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
dist/

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "tabWidth: 4
printWidth: 120
",
    "name": ".prettierrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"dist\\"
    ],
    \\"main\\": \\"./dist/index.js\\",
    \\"types\\": \\"./dist/index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write 'src/**/*.ts'\\",
        \\"build\\": \\"tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"buffer\\": \\"^6.0.3\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import * as core from \\"./core\\";
import { Client as AdminClient } from \\"./api/resources/admin/client/Client\\";
import { Client as HomepageClient } from \\"./api/resources/homepage/client/Client\\";
import { Client as MigrationClient } from \\"./api/resources/migration/client/Client\\";
import { Client as PlaylistClient } from \\"./api/resources/playlist/client/Client\\";
import { Client as ProblemClient } from \\"./api/resources/problem/client/Client\\";
import { Client as SubmissionClient } from \\"./api/resources/submission/client/Client\\";
import { Client as SyspropClient } from \\"./api/resources/sysprop/client/Client\\";
import { Client as V2Client } from \\"./api/resources/v2/client/Client\\";

export declare namespace TraceApiClient {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class TraceApiClient {
    constructor(private readonly options: TraceApiClient.Options) {}

    #admin: AdminClient | undefined;

    public get admin(): AdminClient {
        return (this.#admin ??= new AdminClient(this.options));
    }

    #homepage: HomepageClient | undefined;

    public get homepage(): HomepageClient {
        return (this.#homepage ??= new HomepageClient(this.options));
    }

    #migration: MigrationClient | undefined;

    public get migration(): MigrationClient {
        return (this.#migration ??= new MigrationClient(this.options));
    }

    #playlist: PlaylistClient | undefined;

    public get playlist(): PlaylistClient {
        return (this.#playlist ??= new PlaylistClient(this.options));
    }

    #problem: ProblemClient | undefined;

    public get problem(): ProblemClient {
        return (this.#problem ??= new ProblemClient(this.options));
    }

    #submission: SubmissionClient | undefined;

    public get submission(): SubmissionClient {
        return (this.#submission ??= new SubmissionClient(this.options));
    }

    #sysprop: SyspropClient | undefined;

    public get sysprop(): SyspropClient {
        return (this.#sysprop ??= new SyspropClient(this.options));
    }

    #v2: V2Client | undefined;

    public get v2(): V2Client {
        return (this.#v2 ??= new V2Client(this.options));
    }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as serializers from \\"../../../../serialization\\";
import urlJoin from \\"url-join\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async updateTestSubmissionStatus(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.TestSubmissionStatus
    ): Promise<core.APIResponse<void, TraceApi.admin.updateTestSubmissionStatus.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-test-submission-status/\${await serializers.SubmissionId.jsonOrThrow(submissionId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.TestSubmissionStatus.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.updateTestSubmissionStatus.Error._unknown(_response.error),
        };
    }

    public async sendTestSubmissionUpdate(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.TestSubmissionUpdate
    ): Promise<core.APIResponse<void, TraceApi.admin.sendTestSubmissionUpdate.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-test-submission-status-v2/\${await serializers.SubmissionId.jsonOrThrow(submissionId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.TestSubmissionUpdate.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.sendTestSubmissionUpdate.Error._unknown(_response.error),
        };
    }

    public async updateWorkspaceSubmissionStatus(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.WorkspaceSubmissionStatus
    ): Promise<core.APIResponse<void, TraceApi.admin.updateWorkspaceSubmissionStatus.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-workspace-submission-status/\${await serializers.SubmissionId.jsonOrThrow(submissionId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.WorkspaceSubmissionStatus.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._unknown(_response.error),
        };
    }

    public async sendWorkspaceSubmissionUpdate(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.WorkspaceSubmissionUpdate
    ): Promise<core.APIResponse<void, TraceApi.admin.sendWorkspaceSubmissionUpdate.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-workspace-submission-status-v2/\${await serializers.SubmissionId.jsonOrThrow(
                    submissionId
                )}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.WorkspaceSubmissionUpdate.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._unknown(_response.error),
        };
    }

    public async storeTracedTestCase(
        submissionId: TraceApi.SubmissionId,
        testCaseId: string,
        request: TraceApi.StoreTracedTestCaseRequest
    ): Promise<core.APIResponse<void, TraceApi.admin.storeTracedTestCase.Error>> {
        const { someQueryParam, referenceToOptionalString, ..._body } = request;
        const _queryParams = new URLSearchParams();
        if (someQueryParam != null) {
            _queryParams.append(\\"some-query-param\\", someQueryParam);
        }

        if (referenceToOptionalString != null) {
            _queryParams.append(\\"reference-to-optional-string\\", referenceToOptionalString);
        }

        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-test-trace/submission/\${await serializers.SubmissionId.jsonOrThrow(
                    submissionId
                )}/testCase/\${testCaseId}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
            body: await serializers.StoreTracedTestCaseRequest.jsonOrThrow(_body),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.storeTracedTestCase.Error._unknown(_response.error),
        };
    }

    public async storeTracedTestCaseV2(
        submissionId: TraceApi.SubmissionId,
        testCaseId: TraceApi.v2.TestCaseId,
        request: TraceApi.TraceResponseV2[]
    ): Promise<core.APIResponse<void, TraceApi.admin.storeTracedTestCaseV2.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-test-trace-v2/submission/\${await serializers.SubmissionId.jsonOrThrow(
                    submissionId
                )}/testCase/\${await serializers.v2.TestCaseId.jsonOrThrow(testCaseId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.admin.storeTracedTestCaseV2.Request.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.storeTracedTestCaseV2.Error._unknown(_response.error),
        };
    }

    public async storeTracedWorkspace(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.StoreTracedWorkspaceRequest
    ): Promise<core.APIResponse<void, TraceApi.admin.storeTracedWorkspace.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-workspace-trace/submission/\${await serializers.SubmissionId.jsonOrThrow(submissionId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.StoreTracedWorkspaceRequest.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.storeTracedWorkspace.Error._unknown(_response.error),
        };
    }

    public async storeTracedWorkspaceV2(
        submissionId: TraceApi.SubmissionId,
        request: TraceApi.TraceResponseV2[]
    ): Promise<core.APIResponse<void, TraceApi.admin.storeTracedWorkspaceV2.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/admin/store-workspace-trace-v2/submission/\${await serializers.SubmissionId.jsonOrThrow(submissionId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.admin.storeTracedWorkspaceV2.Request.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.admin.storeTracedWorkspaceV2.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedTestCaseRequest {
    someQueryParam?: string;
    referenceToOptionalString?: TraceApi.OptionalString;
    result: TraceApi.TestCaseResultWithStdout;
    traceResponses: TraceApi.TraceResponse[];
}
",
                            "name": "StoreTracedTestCaseRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: TraceApi.WorkspaceRunDetails;
    traceResponses: TraceApi.TraceResponse[];
}
",
                            "name": "StoreTracedWorkspaceRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { StoreTracedTestCaseRequest } from \\"./StoreTracedTestCaseRequest\\";
export { StoreTracedWorkspaceRequest } from \\"./StoreTracedWorkspaceRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown,
                visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.sendTestSubmissionUpdate.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.sendTestSubmissionUpdate.Error,
        visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "sendTestSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown,
                visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error,
        visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "sendWorkspaceSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.storeTracedTestCase.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCase.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.storeTracedTestCase.Error._Unknown,
                visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.storeTracedTestCase.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.storeTracedTestCase.Error,
        visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "storeTracedTestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.storeTracedTestCaseV2.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCaseV2.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.storeTracedTestCaseV2.Error._Unknown,
                visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.storeTracedTestCaseV2.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.storeTracedTestCaseV2.Error,
        visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "storeTracedTestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.storeTracedWorkspace.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspace.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.storeTracedWorkspace.Error._Unknown,
                visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.storeTracedWorkspace.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.storeTracedWorkspace.Error,
        visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "storeTracedWorkspace.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown,
                visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.storeTracedWorkspaceV2.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.storeTracedWorkspaceV2.Error,
        visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "storeTracedWorkspaceV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.updateTestSubmissionStatus.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateTestSubmissionStatus.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.updateTestSubmissionStatus.Error._Unknown,
                visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.updateTestSubmissionStatus.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.updateTestSubmissionStatus.Error,
        visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "updateTestSubmissionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown,
                visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>
            ) {
                return TraceApi.admin.updateWorkspaceSubmissionStatus.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.admin.updateWorkspaceSubmissionStatus.Error,
        visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "updateWorkspaceSubmissionStatus.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type OptionalString = string | undefined;
",
                        "name": "OptionalString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OptionalString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "admin",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: TraceApi.NodeId;
    fullTree: TraceApi.BinaryTreeValue;
}
",
                        "name": "BinaryTreeNodeAndTreeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeNodeValue {
    nodeId: TraceApi.NodeId;
    val: number;
    right?: TraceApi.NodeId;
    left?: TraceApi.NodeId;
}
",
                        "name": "BinaryTreeNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeValue {
    root?: TraceApi.NodeId;
    nodes: Record<TraceApi.NodeId, TraceApi.BinaryTreeNodeValue | undefined>;
}
",
                        "name": "BinaryTreeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * ISO 8601 date; formatted YYYY-MM-DD (i.e. 2012-02-01)
 */
export type Date = string & {
    Date: void;
};

export function Date(value: string): TraceApi.Date {
    return value as unknown as TraceApi.Date;
}
",
                        "name": "Date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DebugKeyValuePairs {
    key: TraceApi.DebugVariableValue;
    value: TraceApi.DebugVariableValue;
}
",
                        "name": "DebugKeyValuePairs.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DebugMapValue {
    keyValuePairs: TraceApi.DebugKeyValuePairs[];
}
",
                        "name": "DebugMapValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type DebugVariableValue =
    | TraceApi.DebugVariableValue.IntegerValue
    | TraceApi.DebugVariableValue.BooleanValue
    | TraceApi.DebugVariableValue.DoubleValue
    | TraceApi.DebugVariableValue.StringValue
    | TraceApi.DebugVariableValue.CharValue
    | TraceApi.DebugVariableValue.MapValue
    | TraceApi.DebugVariableValue.ListValue
    | TraceApi.DebugVariableValue.BinaryTreeNodeValue
    | TraceApi.DebugVariableValue.SinglyLinkedListNodeValue
    | TraceApi.DebugVariableValue.DoublyLinkedListNodeValue
    | TraceApi.DebugVariableValue.UndefinedValue
    | TraceApi.DebugVariableValue.NullValue
    | TraceApi.DebugVariableValue.GenericValue
    | TraceApi.DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
    interface IntegerValue extends _Utils {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue extends _Utils {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue extends _Utils {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue extends _Utils {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue extends _Utils {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends TraceApi.DebugMapValue, _Utils {
        type: \\"mapValue\\";
    }

    interface ListValue extends _Utils {
        type: \\"listValue\\";
        value: TraceApi.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends TraceApi.BinaryTreeNodeAndTreeValue, _Utils {
        type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends TraceApi.SinglyLinkedListNodeAndListValue, _Utils {
        type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends TraceApi.DoublyLinkedListNodeAndListValue, _Utils {
        type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue extends _Utils {
        type: \\"undefinedValue\\";
    }

    interface NullValue extends _Utils {
        type: \\"nullValue\\";
    }

    interface GenericValue extends TraceApi.GenericValue, _Utils {
        type: \\"genericValue\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.DebugVariableValue._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        integerValue: (value: number) => _Result;
        booleanValue: (value: boolean) => _Result;
        doubleValue: (value: number) => _Result;
        stringValue: (value: string) => _Result;
        charValue: (value: string) => _Result;
        mapValue: (value: TraceApi.DebugMapValue) => _Result;
        listValue: (value: TraceApi.DebugVariableValue[]) => _Result;
        binaryTreeNodeValue: (value: TraceApi.BinaryTreeNodeAndTreeValue) => _Result;
        singlyLinkedListNodeValue: (value: TraceApi.SinglyLinkedListNodeAndListValue) => _Result;
        doublyLinkedListNodeValue: (value: TraceApi.DoublyLinkedListNodeAndListValue) => _Result;
        undefinedValue: () => _Result;
        nullValue: () => _Result;
        genericValue: (value: TraceApi.GenericValue) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const DebugVariableValue = {
    integerValue: (value: number): TraceApi.DebugVariableValue.IntegerValue => {
        return {
            value: value,
            type: \\"integerValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.IntegerValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    booleanValue: (value: boolean): TraceApi.DebugVariableValue.BooleanValue => {
        return {
            value: value,
            type: \\"booleanValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.BooleanValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    doubleValue: (value: number): TraceApi.DebugVariableValue.DoubleValue => {
        return {
            value: value,
            type: \\"doubleValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.DoubleValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    stringValue: (value: string): TraceApi.DebugVariableValue.StringValue => {
        return {
            value: value,
            type: \\"stringValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.StringValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    charValue: (value: string): TraceApi.DebugVariableValue.CharValue => {
        return {
            value: value,
            type: \\"charValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.CharValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    mapValue: (value: TraceApi.DebugMapValue): TraceApi.DebugVariableValue.MapValue => {
        return {
            ...value,
            type: \\"mapValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.MapValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    listValue: (value: TraceApi.DebugVariableValue[]): TraceApi.DebugVariableValue.ListValue => {
        return {
            value: value,
            type: \\"listValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.ListValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    binaryTreeNodeValue: (
        value: TraceApi.BinaryTreeNodeAndTreeValue
    ): TraceApi.DebugVariableValue.BinaryTreeNodeValue => {
        return {
            ...value,
            type: \\"binaryTreeNodeValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.BinaryTreeNodeValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    singlyLinkedListNodeValue: (
        value: TraceApi.SinglyLinkedListNodeAndListValue
    ): TraceApi.DebugVariableValue.SinglyLinkedListNodeValue => {
        return {
            ...value,
            type: \\"singlyLinkedListNodeValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.SinglyLinkedListNodeValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    doublyLinkedListNodeValue: (
        value: TraceApi.DoublyLinkedListNodeAndListValue
    ): TraceApi.DebugVariableValue.DoublyLinkedListNodeValue => {
        return {
            ...value,
            type: \\"doublyLinkedListNodeValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.DoublyLinkedListNodeValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    undefinedValue: (): TraceApi.DebugVariableValue.UndefinedValue => {
        return {
            type: \\"undefinedValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.UndefinedValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    nullValue: (): TraceApi.DebugVariableValue.NullValue => {
        return {
            type: \\"nullValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.NullValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    genericValue: (value: TraceApi.GenericValue): TraceApi.DebugVariableValue.GenericValue => {
        return {
            ...value,
            type: \\"genericValue\\",
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue.GenericValue,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.DebugVariableValue._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.DebugVariableValue._Unknown,
                visitor: TraceApi.DebugVariableValue._Visitor<_Result>
            ) {
                return TraceApi.DebugVariableValue._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.DebugVariableValue,
        visitor: TraceApi.DebugVariableValue._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"integerValue\\":
                return visitor.integerValue(value.value);
            case \\"booleanValue\\":
                return visitor.booleanValue(value.value);
            case \\"doubleValue\\":
                return visitor.doubleValue(value.value);
            case \\"stringValue\\":
                return visitor.stringValue(value.value);
            case \\"charValue\\":
                return visitor.charValue(value.value);
            case \\"mapValue\\":
                return visitor.mapValue(value);
            case \\"listValue\\":
                return visitor.listValue(value.value);
            case \\"binaryTreeNodeValue\\":
                return visitor.binaryTreeNodeValue(value);
            case \\"singlyLinkedListNodeValue\\":
                return visitor.singlyLinkedListNodeValue(value);
            case \\"doublyLinkedListNodeValue\\":
                return visitor.doublyLinkedListNodeValue(value);
            case \\"undefinedValue\\":
                return visitor.undefinedValue();
            case \\"nullValue\\":
                return visitor.nullValue();
            case \\"genericValue\\":
                return visitor.genericValue(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "DebugVariableValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: TraceApi.NodeId;
    fullList: TraceApi.DoublyLinkedListValue;
}
",
                        "name": "DoublyLinkedListNodeAndListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListNodeValue {
    nodeId: TraceApi.NodeId;
    val: number;
    next?: TraceApi.NodeId;
    prev?: TraceApi.NodeId;
}
",
                        "name": "DoublyLinkedListNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListValue {
    head?: TraceApi.NodeId;
    nodes: Record<TraceApi.NodeId, TraceApi.DoublyLinkedListNodeValue | undefined>;
}
",
                        "name": "DoublyLinkedListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfo {
    filename: string;
    contents: string;
}
",
                        "name": "FileInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GenericValue {
    stringifiedType?: string;
    stringifiedValue: string;
}
",
                        "name": "GenericValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface KeyValuePair {
    key: TraceApi.VariableValue;
    value: TraceApi.VariableValue;
}
",
                        "name": "KeyValuePair.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     TraceApi.Language.Java
 */
export type Language = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";

export const Language = {
    Java: \\"JAVA\\",
    Javascript: \\"JAVASCRIPT\\",
    Python: \\"PYTHON\\",
} as const;
",
                        "name": "Language.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ListType {
    valueType: TraceApi.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength?: boolean;
}
",
                        "name": "ListType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface MapType {
    keyType: TraceApi.VariableType;
    valueType: TraceApi.VariableType;
}
",
                        "name": "MapType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface MapValue {
    keyValuePairs: TraceApi.KeyValuePair[];
}
",
                        "name": "MapValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type NodeId = string & {
    NodeId: void;
};

export function NodeId(value: string): TraceApi.NodeId {
    return value as unknown as TraceApi.NodeId;
}
",
                        "name": "NodeId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ProblemId = string & {
    ProblemId: void;
};

export function ProblemId(value: string): TraceApi.ProblemId {
    return value as unknown as TraceApi.ProblemId;
}
",
                        "name": "ProblemId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         \\"foo\\": \\"hello\\",
 *         \\"bar\\": {
 *             \\"yo\\": 123
 *         }
 *     }
 */
export type RandomUnknownType = unknown;
",
                        "name": "RandomUnknownType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: TraceApi.NodeId;
    fullList: TraceApi.SinglyLinkedListValue;
}
",
                        "name": "SinglyLinkedListNodeAndListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListNodeValue {
    nodeId: TraceApi.NodeId;
    val: number;
    next?: TraceApi.NodeId;
}
",
                        "name": "SinglyLinkedListNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListValue {
    head?: TraceApi.NodeId;
    nodes: Record<TraceApi.NodeId, TraceApi.SinglyLinkedListNodeValue | undefined>;
}
",
                        "name": "SinglyLinkedListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCase {
    id: string;
    params: TraceApi.VariableValue[];
}
",
                        "name": "TestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithExpectedResult {
    testCase: TraceApi.TestCase;
    expectedResult: TraceApi.VariableValue;
}
",
                        "name": "TestCaseWithExpectedResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     TraceApi.UserId(\\"user12345\\")
 */
export type UserId = string & {
    UserId: void;
};

export function UserId(value: string): TraceApi.UserId {
    return value as unknown as TraceApi.UserId;
}
",
                        "name": "UserId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type VariableType =
    | TraceApi.VariableType.IntegerType
    | TraceApi.VariableType.DoubleType
    | TraceApi.VariableType.BooleanType
    | TraceApi.VariableType.StringType
    | TraceApi.VariableType.CharType
    | TraceApi.VariableType.ListType
    | TraceApi.VariableType.MapType
    | TraceApi.VariableType.BinaryTreeType
    | TraceApi.VariableType.SinglyLinkedListType
    | TraceApi.VariableType.DoublyLinkedListType
    | TraceApi.VariableType._Unknown;

export declare namespace VariableType {
    interface IntegerType extends _Utils {
        type: \\"integerType\\";
    }

    interface DoubleType extends _Utils {
        type: \\"doubleType\\";
    }

    interface BooleanType extends _Utils {
        type: \\"booleanType\\";
    }

    interface StringType extends _Utils {
        type: \\"stringType\\";
    }

    interface CharType extends _Utils {
        type: \\"charType\\";
    }

    interface ListType extends TraceApi.ListType, _Utils {
        type: \\"listType\\";
    }

    interface MapType extends TraceApi.MapType, _Utils {
        type: \\"mapType\\";
    }

    interface BinaryTreeType extends _Utils {
        type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType extends _Utils {
        type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType extends _Utils {
        type: \\"doublyLinkedListType\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.VariableType._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        integerType: () => _Result;
        doubleType: () => _Result;
        booleanType: () => _Result;
        stringType: () => _Result;
        charType: () => _Result;
        listType: (value: TraceApi.ListType) => _Result;
        mapType: (value: TraceApi.MapType) => _Result;
        binaryTreeType: () => _Result;
        singlyLinkedListType: () => _Result;
        doublyLinkedListType: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const VariableType = {
    integerType: (): TraceApi.VariableType.IntegerType => {
        return {
            type: \\"integerType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.IntegerType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    doubleType: (): TraceApi.VariableType.DoubleType => {
        return {
            type: \\"doubleType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.DoubleType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    booleanType: (): TraceApi.VariableType.BooleanType => {
        return {
            type: \\"booleanType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.BooleanType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    stringType: (): TraceApi.VariableType.StringType => {
        return {
            type: \\"stringType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.StringType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    charType: (): TraceApi.VariableType.CharType => {
        return {
            type: \\"charType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.CharType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    listType: (value: TraceApi.ListType): TraceApi.VariableType.ListType => {
        return {
            ...value,
            type: \\"listType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.ListType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    mapType: (value: TraceApi.MapType): TraceApi.VariableType.MapType => {
        return {
            ...value,
            type: \\"mapType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.MapType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    binaryTreeType: (): TraceApi.VariableType.BinaryTreeType => {
        return {
            type: \\"binaryTreeType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.BinaryTreeType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    singlyLinkedListType: (): TraceApi.VariableType.SinglyLinkedListType => {
        return {
            type: \\"singlyLinkedListType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.SinglyLinkedListType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    doublyLinkedListType: (): TraceApi.VariableType.DoublyLinkedListType => {
        return {
            type: \\"doublyLinkedListType\\",
            _visit: function <_Result>(
                this: TraceApi.VariableType.DoublyLinkedListType,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.VariableType._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.VariableType._Unknown,
                visitor: TraceApi.VariableType._Visitor<_Result>
            ) {
                return TraceApi.VariableType._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.VariableType, visitor: TraceApi.VariableType._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"integerType\\":
                return visitor.integerType();
            case \\"doubleType\\":
                return visitor.doubleType();
            case \\"booleanType\\":
                return visitor.booleanType();
            case \\"stringType\\":
                return visitor.stringType();
            case \\"charType\\":
                return visitor.charType();
            case \\"listType\\":
                return visitor.listType(value);
            case \\"mapType\\":
                return visitor.mapType(value);
            case \\"binaryTreeType\\":
                return visitor.binaryTreeType();
            case \\"singlyLinkedListType\\":
                return visitor.singlyLinkedListType();
            case \\"doublyLinkedListType\\":
                return visitor.doublyLinkedListType();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "VariableType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type VariableValue =
    | TraceApi.VariableValue.IntegerValue
    | TraceApi.VariableValue.BooleanValue
    | TraceApi.VariableValue.DoubleValue
    | TraceApi.VariableValue.StringValue
    | TraceApi.VariableValue.CharValue
    | TraceApi.VariableValue.MapValue
    | TraceApi.VariableValue.ListValue
    | TraceApi.VariableValue.BinaryTreeValue
    | TraceApi.VariableValue.SinglyLinkedListValue
    | TraceApi.VariableValue.DoublyLinkedListValue
    | TraceApi.VariableValue.NullValue
    | TraceApi.VariableValue._Unknown;

export declare namespace VariableValue {
    interface IntegerValue extends _Utils {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue extends _Utils {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue extends _Utils {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue extends _Utils {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue extends _Utils {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends TraceApi.MapValue, _Utils {
        type: \\"mapValue\\";
    }

    interface ListValue extends _Utils {
        type: \\"listValue\\";
        value: TraceApi.VariableValue[];
    }

    interface BinaryTreeValue extends TraceApi.BinaryTreeValue, _Utils {
        type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends TraceApi.SinglyLinkedListValue, _Utils {
        type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends TraceApi.DoublyLinkedListValue, _Utils {
        type: \\"doublyLinkedListValue\\";
    }

    interface NullValue extends _Utils {
        type: \\"nullValue\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.VariableValue._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        integerValue: (value: number) => _Result;
        booleanValue: (value: boolean) => _Result;
        doubleValue: (value: number) => _Result;
        stringValue: (value: string) => _Result;
        charValue: (value: string) => _Result;
        mapValue: (value: TraceApi.MapValue) => _Result;
        listValue: (value: TraceApi.VariableValue[]) => _Result;
        binaryTreeValue: (value: TraceApi.BinaryTreeValue) => _Result;
        singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue) => _Result;
        doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue) => _Result;
        nullValue: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const VariableValue = {
    integerValue: (value: number): TraceApi.VariableValue.IntegerValue => {
        return {
            value: value,
            type: \\"integerValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.IntegerValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    booleanValue: (value: boolean): TraceApi.VariableValue.BooleanValue => {
        return {
            value: value,
            type: \\"booleanValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.BooleanValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    doubleValue: (value: number): TraceApi.VariableValue.DoubleValue => {
        return {
            value: value,
            type: \\"doubleValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.DoubleValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    stringValue: (value: string): TraceApi.VariableValue.StringValue => {
        return {
            value: value,
            type: \\"stringValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.StringValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    charValue: (value: string): TraceApi.VariableValue.CharValue => {
        return {
            value: value,
            type: \\"charValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.CharValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    mapValue: (value: TraceApi.MapValue): TraceApi.VariableValue.MapValue => {
        return {
            ...value,
            type: \\"mapValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.MapValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    listValue: (value: TraceApi.VariableValue[]): TraceApi.VariableValue.ListValue => {
        return {
            value: value,
            type: \\"listValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.ListValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    binaryTreeValue: (value: TraceApi.BinaryTreeValue): TraceApi.VariableValue.BinaryTreeValue => {
        return {
            ...value,
            type: \\"binaryTreeValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.BinaryTreeValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue): TraceApi.VariableValue.SinglyLinkedListValue => {
        return {
            ...value,
            type: \\"singlyLinkedListValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.SinglyLinkedListValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue): TraceApi.VariableValue.DoublyLinkedListValue => {
        return {
            ...value,
            type: \\"doublyLinkedListValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.DoublyLinkedListValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    nullValue: (): TraceApi.VariableValue.NullValue => {
        return {
            type: \\"nullValue\\",
            _visit: function <_Result>(
                this: TraceApi.VariableValue.NullValue,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.VariableValue._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.VariableValue._Unknown,
                visitor: TraceApi.VariableValue._Visitor<_Result>
            ) {
                return TraceApi.VariableValue._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.VariableValue, visitor: TraceApi.VariableValue._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"integerValue\\":
                return visitor.integerValue(value.value);
            case \\"booleanValue\\":
                return visitor.booleanValue(value.value);
            case \\"doubleValue\\":
                return visitor.doubleValue(value.value);
            case \\"stringValue\\":
                return visitor.stringValue(value.value);
            case \\"charValue\\":
                return visitor.charValue(value.value);
            case \\"mapValue\\":
                return visitor.mapValue(value);
            case \\"listValue\\":
                return visitor.listValue(value.value);
            case \\"binaryTreeValue\\":
                return visitor.binaryTreeValue(value);
            case \\"singlyLinkedListValue\\":
                return visitor.singlyLinkedListValue(value);
            case \\"doublyLinkedListValue\\":
                return visitor.doublyLinkedListValue(value);
            case \\"nullValue\\":
                return visitor.nullValue();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "VariableValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
export * from \\"./RandomUnknownType\\";
export * from \\"./Date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "commons",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getHomepageProblems(): Promise<
        core.APIResponse<TraceApi.ProblemId[], TraceApi.homepage.getHomepageProblems.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.TraceApiEnvironment.Prod, \\"/homepage-problems\\"),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.homepage.getHomepageProblems.Response.parseOrThrow(
                    _response.body as serializers.homepage.getHomepageProblems.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.homepage.getHomepageProblems.Error._unknown(_response.error),
        };
    }

    public async setHomepageProblems(
        request: TraceApi.ProblemId[]
    ): Promise<core.APIResponse<void, TraceApi.homepage.setHomepageProblems.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.TraceApiEnvironment.Prod, \\"/homepage-problems\\"),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.homepage.setHomepageProblems.Request.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.homepage.setHomepageProblems.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.homepage.getHomepageProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.getHomepageProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.homepage.getHomepageProblems.Error._Unknown,
                visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.homepage.getHomepageProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.homepage.getHomepageProblems.Error,
        visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getHomepageProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.homepage.setHomepageProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.setHomepageProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.homepage.setHomepageProblems.Error._Unknown,
                visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.homepage.setHomepageProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.homepage.setHomepageProblems.Error,
        visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "setHomepageProblems.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "homepage",
                "type": "directory",
              },
              Object {
                "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./admin/client/requests\\";
export * from \\"./playlist/client/requests\\";
export * from \\"./problem/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LangServerRequest {
    request?: unknown;
}
",
                        "name": "LangServerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LangServerResponse {
    response?: unknown;
}
",
                        "name": "LangServerResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "langServer",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async getAttemptedMigrations(): Promise<
        core.APIResponse<TraceApi.Migration[], TraceApi.migration.getAttemptedMigrations.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.TraceApiEnvironment.Prod, \\"/migration-info/all\\"),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.migration.getAttemptedMigrations.Response.parseOrThrow(
                    _response.body as serializers.migration.getAttemptedMigrations.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.migration.getAttemptedMigrations.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.migration.getAttemptedMigrations.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.migration.getAttemptedMigrations.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.migration.getAttemptedMigrations.Error._Unknown,
                visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>
            ) {
                return TraceApi.migration.getAttemptedMigrations.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.migration.getAttemptedMigrations.Error,
        visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getAttemptedMigrations.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Migration {
    name: string;
    status: TraceApi.MigrationStatus;
}
",
                        "name": "Migration.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type MigrationStatus = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";

export const MigrationStatus = {
    Running: \\"RUNNING\\",
    Failed: \\"FAILED\\",
    Finished: \\"FINISHED\\",
} as const;
",
                        "name": "MigrationStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "migration",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Create a new playlist
     */
    public async createPlaylist(
        serviceParam: number,
        request: TraceApi.PlaylistCreateRequestWrapper
    ): Promise<core.APIResponse<TraceApi.Playlist, TraceApi.playlist.createPlaylist.Error>> {
        const { multiple, multipleOptional, aliasQueryParam, body: _body } = request;
        const _queryParams = new URLSearchParams();
        if (Array.isArray(multiple)) {
            for (const _item of multiple) {
                _queryParams.append(\\"multiple\\", _item.toString());
            }
        } else {
            _queryParams.append(\\"multiple\\", multiple.toString());
        }

        if (multipleOptional != null) {
            if (Array.isArray(multipleOptional)) {
                for (const _item of multipleOptional) {
                    _queryParams.append(\\"multipleOptional\\", _item.toString());
                }
            } else {
                _queryParams.append(\\"multipleOptional\\", multipleOptional.toString());
            }
        }

        _queryParams.append(\\"aliasQueryParam\\", aliasQueryParam.toString());
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/v2/playlist/\${serviceParam}/create\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
            body: await serializers.PlaylistCreateRequest.jsonOrThrow(_body),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.Playlist.parseOrThrow(_response.body as serializers.Playlist.Raw, {
                    allowUnknownKeys: true,
                }),
            };
        }

        return {
            ok: false,
            error: TraceApi.playlist.createPlaylist.Error._unknown(_response.error),
        };
    }

    /**
     * Returns the user's playlists
     */
    public async getPlaylists(
        serviceParam: number,
        request: TraceApi.GetPlaylistsRequest
    ): Promise<core.APIResponse<TraceApi.Playlist[], TraceApi.playlist.getPlaylists.Error>> {
        const { limit, otherField } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append(\\"limit\\", limit.toString());
        }

        _queryParams.append(\\"otherField\\", otherField);
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/v2/playlist/\${serviceParam}/all\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.playlist.getPlaylists.Response.parseOrThrow(
                    _response.body as serializers.playlist.getPlaylists.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.playlist.getPlaylists.Error._unknown(_response.error),
        };
    }

    /**
     * Returns a playlist
     */
    public async getPlaylist(
        serviceParam: number,
        playlistId: TraceApi.PlaylistId,
        request: TraceApi.GetPlaylistRequest = {}
    ): Promise<core.APIResponse<TraceApi.Playlist, TraceApi.playlist.getPlaylist.Error>> {
        const { optionalQueryParam } = request;
        const _queryParams = new URLSearchParams();
        if (optionalQueryParam != null) {
            _queryParams.append(\\"optionalQueryParam\\", optionalQueryParam.toString());
        }

        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/v2/playlist/\${serviceParam}/\${await serializers.PlaylistId.jsonOrThrow(playlistId)}\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.Playlist.parseOrThrow(_response.body as serializers.Playlist.Raw, {
                    allowUnknownKeys: true,
                }),
            };
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as serializers.playlist.getPlaylist.Error.Raw)?.errorName) {
                case \\"PlaylistIdNotFoundError\\":
                case \\"UnauthorizedError\\":
                    return {
                        ok: false,
                        error: await serializers.playlist.getPlaylist.Error.parseOrThrow(
                            _response.error.body as serializers.playlist.getPlaylist.Error.Raw,
                            { allowUnknownKeys: true }
                        ),
                    };
            }
        }

        return {
            ok: false,
            error: TraceApi.playlist.getPlaylist.Error._unknown(_response.error),
        };
    }

    /**
     * Updates a playlist
     */
    public async updatePlaylist(
        serviceParam: number,
        playlistId: TraceApi.PlaylistId,
        request?: TraceApi.UpdatePlaylistRequest
    ): Promise<core.APIResponse<TraceApi.Playlist | undefined, TraceApi.playlist.updatePlaylist.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/v2/playlist/\${serviceParam}/\${await serializers.PlaylistId.jsonOrThrow(playlistId)}\`
            ),
            method: \\"PUT\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.playlist.updatePlaylist.Request.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.playlist.updatePlaylist.Response.parseOrThrow(
                    _response.body as serializers.playlist.updatePlaylist.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        if (_response.error.reason === \\"status-code\\") {
            switch ((_response.error.body as serializers.playlist.updatePlaylist.Error.Raw)?.errorName) {
                case \\"PlaylistIdNotFoundError\\":
                    return {
                        ok: false,
                        error: await serializers.playlist.updatePlaylist.Error.parseOrThrow(
                            _response.error.body as serializers.playlist.updatePlaylist.Error.Raw,
                            { allowUnknownKeys: true }
                        ),
                    };
            }
        }

        return {
            ok: false,
            error: TraceApi.playlist.updatePlaylist.Error._unknown(_response.error),
        };
    }

    /**
     * Deletes a playlist
     */
    public async deletePlaylist(
        serviceParam: number,
        playlistId: TraceApi.PlaylistId
    ): Promise<core.APIResponse<void, TraceApi.playlist.deletePlaylist.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/v2/playlist/\${serviceParam}/\${await serializers.PlaylistId.jsonOrThrow(playlistId)}\`
            ),
            method: \\"DELETE\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.playlist.deletePlaylist.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.playlist.createPlaylist.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.createPlaylist.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.playlist.createPlaylist.Error._Unknown,
                visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.createPlaylist.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.playlist.createPlaylist.Error,
        visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "createPlaylist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.playlist.deletePlaylist.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.deletePlaylist.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.playlist.deletePlaylist.Error._Unknown,
                visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.deletePlaylist.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.playlist.deletePlaylist.Error,
        visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "deletePlaylist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error =
    | TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError
    | TraceApi.playlist.getPlaylist.Error.UnauthorizedError
    | TraceApi.playlist.getPlaylist.Error._Unknown;

export declare namespace Error {
    interface PlaylistIdNotFoundError extends _Utils {
        errorName: \\"PlaylistIdNotFoundError\\";
        content: TraceApi.PlaylistIdNotFoundErrorBody;
    }

    interface UnauthorizedError extends _Utils {
        errorName: \\"UnauthorizedError\\";
    }

    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundErrorBody) => _Result;
        unauthorizedError: () => _Result;
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    playlistIdNotFoundError: (
        value: TraceApi.PlaylistIdNotFoundErrorBody
    ): TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError => {
        return {
            content: value,
            errorName: \\"PlaylistIdNotFoundError\\",
            _visit: function <_Result>(
                this: TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError,
                visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
            },
        };
    },

    unauthorizedError: (): TraceApi.playlist.getPlaylist.Error.UnauthorizedError => {
        return {
            errorName: \\"UnauthorizedError\\",
            _visit: function <_Result>(
                this: TraceApi.playlist.getPlaylist.Error.UnauthorizedError,
                visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
            },
        };
    },

    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylist.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.playlist.getPlaylist.Error._Unknown,
                visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.playlist.getPlaylist.Error,
        visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            case \\"PlaylistIdNotFoundError\\":
                return visitor.playlistIdNotFoundError(value.content);
            case \\"UnauthorizedError\\":
                return visitor.unauthorizedError();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getPlaylist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.playlist.getPlaylists.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylists.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.playlist.getPlaylists.Error._Unknown,
                visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.getPlaylists.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.playlist.getPlaylists.Error,
        visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getPlaylists.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetPlaylistRequest {
    optionalQueryParam?: number;
}
",
                            "name": "GetPlaylistRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetPlaylistsRequest {
    limit?: number;
    otherField: string;
}
",
                            "name": "GetPlaylistsRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface PlaylistCreateRequestWrapper {
    multiple: number | number[];
    multipleOptional?: boolean | boolean[];
    aliasQueryParam: TraceApi.PlaylistId;
    body: TraceApi.PlaylistCreateRequest;
}
",
                            "name": "PlaylistCreateRequestWrapper.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { PlaylistCreateRequestWrapper } from \\"./PlaylistCreateRequestWrapper\\";
export { GetPlaylistsRequest } from \\"./GetPlaylistsRequest\\";
export { GetPlaylistRequest } from \\"./GetPlaylistRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error =
    | TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError
    | TraceApi.playlist.updatePlaylist.Error._Unknown;

export declare namespace Error {
    interface PlaylistIdNotFoundError extends _Utils {
        errorName: \\"PlaylistIdNotFoundError\\";
        content: TraceApi.PlaylistIdNotFoundErrorBody;
    }

    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundErrorBody) => _Result;
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    playlistIdNotFoundError: (
        value: TraceApi.PlaylistIdNotFoundErrorBody
    ): TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError => {
        return {
            content: value,
            errorName: \\"PlaylistIdNotFoundError\\",
            _visit: function <_Result>(
                this: TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError,
                visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
            },
        };
    },

    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.updatePlaylist.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.playlist.updatePlaylist.Error._Unknown,
                visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
            ) {
                return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.playlist.updatePlaylist.Error,
        visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            case \\"PlaylistIdNotFoundError\\":
                return visitor.playlistIdNotFoundError(value.content);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "updatePlaylist.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type Color = \\"RED\\" | \\"BLUE\\";

export const Color = {
    Red: \\"RED\\",
    Blue: \\"BLUE\\",
} as const;
",
                        "name": "Color.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type DateUnion = TraceApi.DateUnion.Date_ | TraceApi.DateUnion.Datetime | TraceApi.DateUnion._Unknown;

export declare namespace DateUnion {
    interface Date_ extends _Utils {
        type: \\"date\\";
        value: TraceApi.Date;
    }

    interface Datetime extends _Utils {
        type: \\"datetime\\";
        value: Date;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.DateUnion._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        date: (value: TraceApi.Date) => _Result;
        datetime: (value: Date) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const DateUnion = {
    date: (value: TraceApi.Date): TraceApi.DateUnion.Date_ => {
        return {
            value: value,
            type: \\"date\\",
            _visit: function <_Result>(this: TraceApi.DateUnion.Date_, visitor: TraceApi.DateUnion._Visitor<_Result>) {
                return TraceApi.DateUnion._visit(this, visitor);
            },
        };
    },

    datetime: (value: Date): TraceApi.DateUnion.Datetime => {
        return {
            value: value,
            type: \\"datetime\\",
            _visit: function <_Result>(
                this: TraceApi.DateUnion.Datetime,
                visitor: TraceApi.DateUnion._Visitor<_Result>
            ) {
                return TraceApi.DateUnion._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.DateUnion._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.DateUnion._Unknown,
                visitor: TraceApi.DateUnion._Visitor<_Result>
            ) {
                return TraceApi.DateUnion._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.DateUnion, visitor: TraceApi.DateUnion._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"date\\":
                return visitor.date(value.value);
            case \\"datetime\\":
                return visitor.datetime(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "DateUnion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     {
 *         [TraceApi.Color.Red]: true
 *     }
 */
export type MapWithEnumKey = Record<TraceApi.Color, boolean | undefined>;
",
                        "name": "MapWithEnumKey.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     {
 *         [TraceApi.Color.Red]: true
 *     }
 */
export type MapWithEnumKeyAndOptionalValue = Record<TraceApi.Color, boolean | undefined>;
",
                        "name": "MapWithEnumKeyAndOptionalValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Playlist extends TraceApi.PlaylistCreateRequest {
    playlistId: TraceApi.PlaylistId;
    ownerId: TraceApi.UserId;
}
",
                        "name": "Playlist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: TraceApi.ProblemId[];
}
",
                        "name": "PlaylistCreateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PlaylistId = number;
",
                        "name": "PlaylistId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type PlaylistIdNotFoundErrorBody =
    | TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId
    | TraceApi.PlaylistIdNotFoundErrorBody._Unknown;

export declare namespace PlaylistIdNotFoundErrorBody {
    interface PlaylistId extends _Utils {
        type: \\"playlistId\\";
        value: TraceApi.PlaylistId;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        playlistId: (value: TraceApi.PlaylistId) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const PlaylistIdNotFoundErrorBody = {
    playlistId: (value: TraceApi.PlaylistId): TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId => {
        return {
            value: value,
            type: \\"playlistId\\",
            _visit: function <_Result>(
                this: TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId,
                visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>
            ) {
                return TraceApi.PlaylistIdNotFoundErrorBody._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.PlaylistIdNotFoundErrorBody._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.PlaylistIdNotFoundErrorBody._Unknown,
                visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>
            ) {
                return TraceApi.PlaylistIdNotFoundErrorBody._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.PlaylistIdNotFoundErrorBody,
        visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"playlistId\\":
                return visitor.playlistId(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "PlaylistIdNotFoundErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ReservedKeywordEnum = \\"is\\" | \\"as\\" | \\"date\\";

export const ReservedKeywordEnum = {
    Is: \\"is\\",
    As: \\"as\\",
    Date: \\"date\\",
} as const;
",
                        "name": "ReservedKeywordEnum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: TraceApi.ProblemId[];
}
",
                        "name": "UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./DateUnion\\";
export * from \\"./ReservedKeywordEnum\\";
export * from \\"./MapWithEnumKey\\";
export * from \\"./MapWithEnumKeyAndOptionalValue\\";
export * from \\"./Color\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "playlist",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Creates a problem
     */
    public async createProblem(
        request: TraceApi.CreateProblemRequest
    ): Promise<core.APIResponse<TraceApi.CreateProblemResponse, TraceApi.problem.createProblem.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.TraceApiEnvironment.Prod, \\"/problem-crud/create\\"),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.CreateProblemRequest.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.CreateProblemResponse.parseOrThrow(
                    _response.body as serializers.CreateProblemResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.problem.createProblem.Error._unknown(_response.error),
        };
    }

    /**
     * Updates a problem
     */
    public async updateProblem(
        problemId: TraceApi.ProblemId,
        request: TraceApi.CreateProblemRequest
    ): Promise<core.APIResponse<TraceApi.UpdateProblemResponse, TraceApi.problem.updateProblem.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problem-crud/update/\${await serializers.ProblemId.jsonOrThrow(problemId)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.CreateProblemRequest.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.UpdateProblemResponse.parseOrThrow(
                    _response.body as serializers.UpdateProblemResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.problem.updateProblem.Error._unknown(_response.error),
        };
    }

    /**
     * Soft deletes a problem
     */
    public async deleteProblem(
        problemId: TraceApi.ProblemId
    ): Promise<core.APIResponse<void, TraceApi.problem.deleteProblem.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problem-crud/delete/\${await serializers.ProblemId.jsonOrThrow(problemId)}\`
            ),
            method: \\"DELETE\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.problem.deleteProblem.Error._unknown(_response.error),
        };
    }

    /**
     * Returns default starter files for problem
     */
    public async getDefaultStarterFiles(
        request: TraceApi.GetDefaultStarterFilesRequest
    ): Promise<
        core.APIResponse<TraceApi.GetDefaultStarterFilesResponse, TraceApi.problem.getDefaultStarterFiles.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/problem-crud/default-starter-files\\"
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.GetDefaultStarterFilesRequest.jsonOrThrow(request),
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.GetDefaultStarterFilesResponse.parseOrThrow(
                    _response.body as serializers.GetDefaultStarterFilesResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.problem.getDefaultStarterFiles.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.problem.createProblem.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.createProblem.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.problem.createProblem.Error._Unknown,
                visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>
            ) {
                return TraceApi.problem.createProblem.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.problem.createProblem.Error,
        visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "createProblem.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.problem.deleteProblem.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.deleteProblem.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.problem.deleteProblem.Error._Unknown,
                visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>
            ) {
                return TraceApi.problem.deleteProblem.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.problem.deleteProblem.Error,
        visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "deleteProblem.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.problem.getDefaultStarterFiles.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.getDefaultStarterFiles.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.problem.getDefaultStarterFiles.Error._Unknown,
                visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>
            ) {
                return TraceApi.problem.getDefaultStarterFiles.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.problem.getDefaultStarterFiles.Error,
        visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getDefaultStarterFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./requests\\";
export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: TraceApi.VariableTypeAndName[];
    outputType: TraceApi.VariableType;
    methodName: string;
}
",
                            "name": "GetDefaultStarterFilesRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { GetDefaultStarterFilesRequest } from \\"./GetDefaultStarterFilesRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.problem.updateProblem.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.updateProblem.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.problem.updateProblem.Error._Unknown,
                visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>
            ) {
                return TraceApi.problem.updateProblem.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.problem.updateProblem.Error,
        visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "updateProblem.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type CreateProblemError = TraceApi.CreateProblemError.Generic | TraceApi.CreateProblemError._Unknown;

export declare namespace CreateProblemError {
    interface Generic extends TraceApi.GenericCreateProblemError, _Utils {
        errorType: \\"generic\\";
    }

    interface _Unknown extends _Utils {
        errorType: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.CreateProblemError._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        generic: (value: TraceApi.GenericCreateProblemError) => _Result;
        _other: (value: { errorType: string }) => _Result;
    }
}

export const CreateProblemError = {
    generic: (value: TraceApi.GenericCreateProblemError): TraceApi.CreateProblemError.Generic => {
        return {
            ...value,
            errorType: \\"generic\\",
            _visit: function <_Result>(
                this: TraceApi.CreateProblemError.Generic,
                visitor: TraceApi.CreateProblemError._Visitor<_Result>
            ) {
                return TraceApi.CreateProblemError._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { errorType: string }): TraceApi.CreateProblemError._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.CreateProblemError._Unknown,
                visitor: TraceApi.CreateProblemError._Visitor<_Result>
            ) {
                return TraceApi.CreateProblemError._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.CreateProblemError,
        visitor: TraceApi.CreateProblemError._Visitor<_Result>
    ): _Result => {
        switch (value.errorType) {
            case \\"generic\\":
                return visitor.generic(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "CreateProblemError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: TraceApi.ProblemDescription;
    files: Record<TraceApi.Language, TraceApi.ProblemFiles | undefined>;
    inputParams: TraceApi.VariableTypeAndName[];
    outputType: TraceApi.VariableType;
    testcases: TraceApi.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                        "name": "CreateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type CreateProblemResponse =
    | TraceApi.CreateProblemResponse.Success
    | TraceApi.CreateProblemResponse.Error_
    | TraceApi.CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
    interface Success extends _Utils {
        type: \\"success\\";
        value: TraceApi.ProblemId;
    }

    interface Error_ extends _Utils {
        type: \\"error\\";
        value: TraceApi.CreateProblemError;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        success: (value: TraceApi.ProblemId) => _Result;
        error: (value: TraceApi.CreateProblemError) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const CreateProblemResponse = {
    success: (value: TraceApi.ProblemId): TraceApi.CreateProblemResponse.Success => {
        return {
            value: value,
            type: \\"success\\",
            _visit: function <_Result>(
                this: TraceApi.CreateProblemResponse.Success,
                visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
            ) {
                return TraceApi.CreateProblemResponse._visit(this, visitor);
            },
        };
    },

    error: (value: TraceApi.CreateProblemError): TraceApi.CreateProblemResponse.Error_ => {
        return {
            value: value,
            type: \\"error\\",
            _visit: function <_Result>(
                this: TraceApi.CreateProblemResponse.Error_,
                visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
            ) {
                return TraceApi.CreateProblemResponse._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.CreateProblemResponse._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.CreateProblemResponse._Unknown,
                visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
            ) {
                return TraceApi.CreateProblemResponse._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.CreateProblemResponse,
        visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"success\\":
                return visitor.success(value.value);
            case \\"error\\":
                return visitor.error(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                        "name": "GenericCreateProblemError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<TraceApi.Language, TraceApi.ProblemFiles | undefined>;
}
",
                        "name": "GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemDescription {
    boards: TraceApi.ProblemDescriptionBoard[];
}
",
                        "name": "ProblemDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     TraceApi.ProblemDescriptionBoard.html(\\"<div>hello world</div>\\")
 *
 * @example
 *     TraceApi.ProblemDescriptionBoard.testCaseId(\\"test-case-id-1\\")
 */
export type ProblemDescriptionBoard =
    | TraceApi.ProblemDescriptionBoard.Html
    | TraceApi.ProblemDescriptionBoard.Variable
    | TraceApi.ProblemDescriptionBoard.TestCaseId
    | TraceApi.ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface Variable extends _Utils {
        type: \\"variable\\";
        value: TraceApi.VariableValue;
    }

    interface TestCaseId extends _Utils {
        type: \\"testCaseId\\";
        value: string;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        html: (value: string) => _Result;
        variable: (value: TraceApi.VariableValue) => _Result;
        testCaseId: (value: string) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const ProblemDescriptionBoard = {
    html: (value: string): TraceApi.ProblemDescriptionBoard.Html => {
        return {
            value: value,
            type: \\"html\\",
            _visit: function <_Result>(
                this: TraceApi.ProblemDescriptionBoard.Html,
                visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
            },
        };
    },

    variable: (value: TraceApi.VariableValue): TraceApi.ProblemDescriptionBoard.Variable => {
        return {
            value: value,
            type: \\"variable\\",
            _visit: function <_Result>(
                this: TraceApi.ProblemDescriptionBoard.Variable,
                visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
            },
        };
    },

    testCaseId: (value: string): TraceApi.ProblemDescriptionBoard.TestCaseId => {
        return {
            value: value,
            type: \\"testCaseId\\",
            _visit: function <_Result>(
                this: TraceApi.ProblemDescriptionBoard.TestCaseId,
                visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.ProblemDescriptionBoard._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.ProblemDescriptionBoard._Unknown,
                visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.ProblemDescriptionBoard,
        visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"html\\":
                return visitor.html(value.value);
            case \\"variable\\":
                return visitor.variable(value.value);
            case \\"testCaseId\\":
                return visitor.testCaseId(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "ProblemDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     {
 *         solutionFile: {
 *             filename: \\"hello.txt\\",
 *             contents: \\"I'm some file content\\"
 *         },
 *         readOnlyFiles: []
 *     }
 */
export interface ProblemFiles {
    solutionFile: TraceApi.FileInfo;
    readOnlyFiles: TraceApi.FileInfo[];
}
",
                        "name": "ProblemFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfo {
    problemId: TraceApi.ProblemId;
    problemDescription: TraceApi.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<TraceApi.Language, TraceApi.ProblemFiles | undefined>;
    inputParams: TraceApi.VariableTypeAndName[];
    outputType: TraceApi.VariableType;
    testcases: TraceApi.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                        "name": "ProblemInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemsMap {
    problemsById: Record<TraceApi.ProblemId, TraceApi.ProblemInfo | undefined>;
}
",
                        "name": "ProblemsMap.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                        "name": "UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VariableTypeAndName {
    variableType: TraceApi.VariableType;
    name: string;
}
",
                        "name": "VariableTypeAndName.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as serializers from \\"../../../../serialization\\";
import urlJoin from \\"url-join\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Returns sessionId and execution server URL for session. Spins up server.
     */
    public async createExecutionSession(
        language: TraceApi.Language
    ): Promise<core.APIResponse<TraceApi.ExecutionSessionResponse, TraceApi.submission.createExecutionSession.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/sessions/create-session/\${await serializers.Language.jsonOrThrow(language)}\`
            ),
            method: \\"POST\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.ExecutionSessionResponse.parseOrThrow(
                    _response.body as serializers.ExecutionSessionResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.submission.createExecutionSession.Error._unknown(_response.error),
        };
    }

    /**
     * Returns execution server URL for session. Returns empty if session isn't registered.
     */
    public async getExecutionSession(
        sessionId: string
    ): Promise<
        core.APIResponse<TraceApi.ExecutionSessionResponse | undefined, TraceApi.submission.getExecutionSession.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.TraceApiEnvironment.Prod, \`/sessions/\${sessionId}\`),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.submission.getExecutionSession.Response.parseOrThrow(
                    _response.body as serializers.submission.getExecutionSession.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.submission.getExecutionSession.Error._unknown(_response.error),
        };
    }

    /**
     * Stops execution session.
     */
    public async stopExecutionSession(
        sessionId: string
    ): Promise<core.APIResponse<void, TraceApi.submission.stopExecutionSession.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/sessions/stop/\${sessionId}\`
            ),
            method: \\"DELETE\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.submission.stopExecutionSession.Error._unknown(_response.error),
        };
    }

    public async getExecutionSessionsState(): Promise<
        core.APIResponse<TraceApi.GetExecutionSessionStateResponse, TraceApi.submission.getExecutionSessionsState.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/sessions/execution-sessions-state\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.GetExecutionSessionStateResponse.parseOrThrow(
                    _response.body as serializers.GetExecutionSessionStateResponse.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.submission.getExecutionSessionsState.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.submission.createExecutionSession.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.createExecutionSession.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.submission.createExecutionSession.Error._Unknown,
                visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>
            ) {
                return TraceApi.submission.createExecutionSession.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.submission.createExecutionSession.Error,
        visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "createExecutionSession.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.submission.getExecutionSession.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSession.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.submission.getExecutionSession.Error._Unknown,
                visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>
            ) {
                return TraceApi.submission.getExecutionSession.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.submission.getExecutionSession.Error,
        visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getExecutionSession.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.submission.getExecutionSessionsState.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSessionsState.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.submission.getExecutionSessionsState.Error._Unknown,
                visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>
            ) {
                return TraceApi.submission.getExecutionSessionsState.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.submission.getExecutionSessionsState.Error,
        visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getExecutionSessionsState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.submission.stopExecutionSession.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.stopExecutionSession.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.submission.stopExecutionSession.Error._Unknown,
                visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>
            ) {
                return TraceApi.submission.stopExecutionSession.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.submission.stopExecutionSession.Error,
        visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "stopExecutionSession.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ActualResult =
    | TraceApi.ActualResult.Value
    | TraceApi.ActualResult.Exception
    | TraceApi.ActualResult.ExceptionV2
    | TraceApi.ActualResult._Unknown;

export declare namespace ActualResult {
    interface Value extends _Utils {
        type: \\"value\\";
        value: TraceApi.VariableValue;
    }

    interface Exception extends TraceApi.ExceptionInfo, _Utils {
        type: \\"exception\\";
    }

    interface ExceptionV2 extends _Utils {
        type: \\"exceptionV2\\";
        value: TraceApi.ExceptionV2;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.ActualResult._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        value: (value: TraceApi.VariableValue) => _Result;
        exception: (value: TraceApi.ExceptionInfo) => _Result;
        exceptionV2: (value: TraceApi.ExceptionV2) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const ActualResult = {
    value: (value: TraceApi.VariableValue): TraceApi.ActualResult.Value => {
        return {
            value: value,
            type: \\"value\\",
            _visit: function <_Result>(
                this: TraceApi.ActualResult.Value,
                visitor: TraceApi.ActualResult._Visitor<_Result>
            ) {
                return TraceApi.ActualResult._visit(this, visitor);
            },
        };
    },

    exception: (value: TraceApi.ExceptionInfo): TraceApi.ActualResult.Exception => {
        return {
            ...value,
            type: \\"exception\\",
            _visit: function <_Result>(
                this: TraceApi.ActualResult.Exception,
                visitor: TraceApi.ActualResult._Visitor<_Result>
            ) {
                return TraceApi.ActualResult._visit(this, visitor);
            },
        };
    },

    exceptionV2: (value: TraceApi.ExceptionV2): TraceApi.ActualResult.ExceptionV2 => {
        return {
            value: value,
            type: \\"exceptionV2\\",
            _visit: function <_Result>(
                this: TraceApi.ActualResult.ExceptionV2,
                visitor: TraceApi.ActualResult._Visitor<_Result>
            ) {
                return TraceApi.ActualResult._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.ActualResult._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.ActualResult._Unknown,
                visitor: TraceApi.ActualResult._Visitor<_Result>
            ) {
                return TraceApi.ActualResult._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.ActualResult, visitor: TraceApi.ActualResult._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"value\\":
                return visitor.value(value.value);
            case \\"exception\\":
                return visitor.exception(value);
            case \\"exceptionV2\\":
                return visitor.exceptionV2(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "ActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BuildingExecutorResponse {
    submissionId: TraceApi.SubmissionId;
    status: TraceApi.ExecutionSessionStatus;
}
",
                        "name": "BuildingExecutorResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type CodeExecutionUpdate =
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | TraceApi.CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | TraceApi.CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | TraceApi.CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | TraceApi.CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | TraceApi.CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | TraceApi.CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | TraceApi.CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | TraceApi.CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | TraceApi.CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | TraceApi.CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | TraceApi.CodeExecutionUpdate.Finished
    | TraceApi.CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends TraceApi.BuildingExecutorResponse, _Utils {
        type: \\"buildingExecutor\\";
    }

    interface Running extends TraceApi.RunningResponse, _Utils {
        type: \\"running\\";
    }

    interface Errored extends TraceApi.ErroredResponse, _Utils {
        type: \\"errored\\";
    }

    interface Stopped extends TraceApi.StoppedResponse, _Utils {
        type: \\"stopped\\";
    }

    interface Graded extends TraceApi.GradedResponse, _Utils {
        type: \\"graded\\";
    }

    interface GradedV2 extends TraceApi.GradedResponseV2, _Utils {
        type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends TraceApi.WorkspaceRanResponse, _Utils {
        type: \\"workspaceRan\\";
    }

    interface Recording extends TraceApi.RecordingResponseNotification, _Utils {
        type: \\"recording\\";
    }

    interface Recorded extends TraceApi.RecordedResponseNotification, _Utils {
        type: \\"recorded\\";
    }

    interface InvalidRequest extends TraceApi.InvalidRequestResponse, _Utils {
        type: \\"invalidRequest\\";
    }

    interface Finished extends TraceApi.FinishedResponse, _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        buildingExecutor: (value: TraceApi.BuildingExecutorResponse) => _Result;
        running: (value: TraceApi.RunningResponse) => _Result;
        errored: (value: TraceApi.ErroredResponse) => _Result;
        stopped: (value: TraceApi.StoppedResponse) => _Result;
        graded: (value: TraceApi.GradedResponse) => _Result;
        gradedV2: (value: TraceApi.GradedResponseV2) => _Result;
        workspaceRan: (value: TraceApi.WorkspaceRanResponse) => _Result;
        recording: (value: TraceApi.RecordingResponseNotification) => _Result;
        recorded: (value: TraceApi.RecordedResponseNotification) => _Result;
        invalidRequest: (value: TraceApi.InvalidRequestResponse) => _Result;
        finished: (value: TraceApi.FinishedResponse) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const CodeExecutionUpdate = {
    buildingExecutor: (value: TraceApi.BuildingExecutorResponse): TraceApi.CodeExecutionUpdate.BuildingExecutor => {
        return {
            ...value,
            type: \\"buildingExecutor\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.BuildingExecutor,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    running: (value: TraceApi.RunningResponse): TraceApi.CodeExecutionUpdate.Running => {
        return {
            ...value,
            type: \\"running\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Running,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    errored: (value: TraceApi.ErroredResponse): TraceApi.CodeExecutionUpdate.Errored => {
        return {
            ...value,
            type: \\"errored\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Errored,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    stopped: (value: TraceApi.StoppedResponse): TraceApi.CodeExecutionUpdate.Stopped => {
        return {
            ...value,
            type: \\"stopped\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Stopped,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    graded: (value: TraceApi.GradedResponse): TraceApi.CodeExecutionUpdate.Graded => {
        return {
            ...value,
            type: \\"graded\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Graded,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    gradedV2: (value: TraceApi.GradedResponseV2): TraceApi.CodeExecutionUpdate.GradedV2 => {
        return {
            ...value,
            type: \\"gradedV2\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.GradedV2,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    workspaceRan: (value: TraceApi.WorkspaceRanResponse): TraceApi.CodeExecutionUpdate.WorkspaceRan => {
        return {
            ...value,
            type: \\"workspaceRan\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.WorkspaceRan,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    recording: (value: TraceApi.RecordingResponseNotification): TraceApi.CodeExecutionUpdate.Recording => {
        return {
            ...value,
            type: \\"recording\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Recording,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    recorded: (value: TraceApi.RecordedResponseNotification): TraceApi.CodeExecutionUpdate.Recorded => {
        return {
            ...value,
            type: \\"recorded\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Recorded,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    invalidRequest: (value: TraceApi.InvalidRequestResponse): TraceApi.CodeExecutionUpdate.InvalidRequest => {
        return {
            ...value,
            type: \\"invalidRequest\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.InvalidRequest,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    finished: (value: TraceApi.FinishedResponse): TraceApi.CodeExecutionUpdate.Finished => {
        return {
            ...value,
            type: \\"finished\\",
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate.Finished,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.CodeExecutionUpdate._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.CodeExecutionUpdate._Unknown,
                visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
            ) {
                return TraceApi.CodeExecutionUpdate._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.CodeExecutionUpdate,
        visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"buildingExecutor\\":
                return visitor.buildingExecutor(value);
            case \\"running\\":
                return visitor.running(value);
            case \\"errored\\":
                return visitor.errored(value);
            case \\"stopped\\":
                return visitor.stopped(value);
            case \\"graded\\":
                return visitor.graded(value);
            case \\"gradedV2\\":
                return visitor.gradedV2(value);
            case \\"workspaceRan\\":
                return visitor.workspaceRan(value);
            case \\"recording\\":
                return visitor.recording(value);
            case \\"recorded\\":
                return visitor.recorded(value);
            case \\"invalidRequest\\":
                return visitor.invalidRequest(value);
            case \\"finished\\":
                return visitor.finished(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "CodeExecutionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CompileError {
    message: string;
}
",
                        "name": "CompileError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CustomTestCasesUnsupported {
    problemId: TraceApi.ProblemId;
    submissionId: TraceApi.SubmissionId;
}
",
                        "name": "CustomTestCasesUnsupported.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ErrorInfo =
    | TraceApi.ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | TraceApi.ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | TraceApi.ErrorInfo.InternalError
    | TraceApi.ErrorInfo._Unknown;

export declare namespace ErrorInfo {
    interface CompileError extends TraceApi.CompileError, _Utils {
        type: \\"compileError\\";
    }

    interface RuntimeError extends TraceApi.RuntimeError, _Utils {
        type: \\"runtimeError\\";
    }

    interface InternalError extends TraceApi.InternalError, _Utils {
        type: \\"internalError\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.ErrorInfo._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        compileError: (value: TraceApi.CompileError) => _Result;
        runtimeError: (value: TraceApi.RuntimeError) => _Result;
        internalError: (value: TraceApi.InternalError) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const ErrorInfo = {
    compileError: (value: TraceApi.CompileError): TraceApi.ErrorInfo.CompileError => {
        return {
            ...value,
            type: \\"compileError\\",
            _visit: function <_Result>(
                this: TraceApi.ErrorInfo.CompileError,
                visitor: TraceApi.ErrorInfo._Visitor<_Result>
            ) {
                return TraceApi.ErrorInfo._visit(this, visitor);
            },
        };
    },

    runtimeError: (value: TraceApi.RuntimeError): TraceApi.ErrorInfo.RuntimeError => {
        return {
            ...value,
            type: \\"runtimeError\\",
            _visit: function <_Result>(
                this: TraceApi.ErrorInfo.RuntimeError,
                visitor: TraceApi.ErrorInfo._Visitor<_Result>
            ) {
                return TraceApi.ErrorInfo._visit(this, visitor);
            },
        };
    },

    internalError: (value: TraceApi.InternalError): TraceApi.ErrorInfo.InternalError => {
        return {
            ...value,
            type: \\"internalError\\",
            _visit: function <_Result>(
                this: TraceApi.ErrorInfo.InternalError,
                visitor: TraceApi.ErrorInfo._Visitor<_Result>
            ) {
                return TraceApi.ErrorInfo._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.ErrorInfo._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.ErrorInfo._Unknown,
                visitor: TraceApi.ErrorInfo._Visitor<_Result>
            ) {
                return TraceApi.ErrorInfo._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.ErrorInfo, visitor: TraceApi.ErrorInfo._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"compileError\\":
                return visitor.compileError(value);
            case \\"runtimeError\\":
                return visitor.runtimeError(value);
            case \\"internalError\\":
                return visitor.internalError(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "ErrorInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ErroredResponse {
    submissionId: TraceApi.SubmissionId;
    errorInfo: TraceApi.ErrorInfo;
}
",
                        "name": "ErroredResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                        "name": "ExceptionInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ExceptionV2 = TraceApi.ExceptionV2.Generic | TraceApi.ExceptionV2.Timeout | TraceApi.ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
    interface Generic extends TraceApi.ExceptionInfo, _Utils {
        type: \\"generic\\";
    }

    interface Timeout extends _Utils {
        type: \\"timeout\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.ExceptionV2._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        generic: (value: TraceApi.ExceptionInfo) => _Result;
        timeout: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const ExceptionV2 = {
    generic: (value: TraceApi.ExceptionInfo): TraceApi.ExceptionV2.Generic => {
        return {
            ...value,
            type: \\"generic\\",
            _visit: function <_Result>(
                this: TraceApi.ExceptionV2.Generic,
                visitor: TraceApi.ExceptionV2._Visitor<_Result>
            ) {
                return TraceApi.ExceptionV2._visit(this, visitor);
            },
        };
    },

    timeout: (): TraceApi.ExceptionV2.Timeout => {
        return {
            type: \\"timeout\\",
            _visit: function <_Result>(
                this: TraceApi.ExceptionV2.Timeout,
                visitor: TraceApi.ExceptionV2._Visitor<_Result>
            ) {
                return TraceApi.ExceptionV2._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.ExceptionV2._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.ExceptionV2._Unknown,
                visitor: TraceApi.ExceptionV2._Visitor<_Result>
            ) {
                return TraceApi.ExceptionV2._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.ExceptionV2, visitor: TraceApi.ExceptionV2._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"generic\\":
                return visitor.generic(value);
            case \\"timeout\\":
                return visitor.timeout();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "ExceptionV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl?: string;
    language: TraceApi.Language;
    status: TraceApi.ExecutionSessionStatus;
}
",
                        "name": "ExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExecutionSessionState {
    lastTimeContacted?: string;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string;
    language: TraceApi.Language;
    status: TraceApi.ExecutionSessionStatus;
}
",
                        "name": "ExecutionSessionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ExecutionSessionStatus =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
    CreatingContainer: \\"CREATING_CONTAINER\\",
    ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
    PendingContainer: \\"PENDING_CONTAINER\\",
    RunningContainer: \\"RUNNING_CONTAINER\\",
    LiveContainer: \\"LIVE_CONTAINER\\",
    FailedToLaunch: \\"FAILED_TO_LAUNCH\\",
} as const;
",
                        "name": "ExecutionSessionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExistingSubmissionExecuting {
    submissionId: TraceApi.SubmissionId;
}
",
                        "name": "ExistingSubmissionExecuting.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                        "name": "ExpressionLocation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FinishedResponse {
    submissionId: TraceApi.SubmissionId;
}
",
                        "name": "FinishedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, TraceApi.ExecutionSessionState | undefined>;
    numWarmingInstances?: number;
    warmingSessionIds: string[];
}
",
                        "name": "GetExecutionSessionStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetSubmissionStateResponse {
    timeSubmitted?: Date;
    submission: string;
    language: TraceApi.Language;
    submissionTypeState: TraceApi.SubmissionTypeState;
}
",
                        "name": "GetSubmissionStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTraceResponsesPageRequest {
    offset?: number;
}
",
                        "name": "GetTraceResponsesPageRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedResponse {
    submissionId: TraceApi.SubmissionId;
    testCases: Record<string, TraceApi.TestCaseResultWithStdout | undefined>;
}
",
                        "name": "GradedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedResponseV2 {
    submissionId: TraceApi.SubmissionId;
    testCases: Record<TraceApi.v2.TestCaseId, TraceApi.TestCaseGrade | undefined>;
}
",
                        "name": "GradedResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedTestCaseUpdate {
    testCaseId: TraceApi.v2.TestCaseId;
    grade: TraceApi.TestCaseGrade;
}
",
                        "name": "GradedTestCaseUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InitializeProblemRequest {
    problemId: TraceApi.ProblemId;
    problemVersion?: number;
}
",
                        "name": "InitializeProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InternalError {
    exceptionInfo: TraceApi.ExceptionInfo;
}
",
                        "name": "InternalError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type InvalidRequestCause =
    /**
     * The submission request references a submission id that doesn't exist. */
    | TraceApi.InvalidRequestCause.SubmissionIdNotFound
    | TraceApi.InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | TraceApi.InvalidRequestCause.UnexpectedLanguage
    | TraceApi.InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends TraceApi.SubmissionIdNotFound, _Utils {
        type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends TraceApi.CustomTestCasesUnsupported, _Utils {
        type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends TraceApi.UnexpectedLanguageError, _Utils {
        type: \\"unexpectedLanguage\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound) => _Result;
        customTestCasesUnsupported: (value: TraceApi.CustomTestCasesUnsupported) => _Result;
        unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const InvalidRequestCause = {
    submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound): TraceApi.InvalidRequestCause.SubmissionIdNotFound => {
        return {
            ...value,
            type: \\"submissionIdNotFound\\",
            _visit: function <_Result>(
                this: TraceApi.InvalidRequestCause.SubmissionIdNotFound,
                visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
            ) {
                return TraceApi.InvalidRequestCause._visit(this, visitor);
            },
        };
    },

    customTestCasesUnsupported: (
        value: TraceApi.CustomTestCasesUnsupported
    ): TraceApi.InvalidRequestCause.CustomTestCasesUnsupported => {
        return {
            ...value,
            type: \\"customTestCasesUnsupported\\",
            _visit: function <_Result>(
                this: TraceApi.InvalidRequestCause.CustomTestCasesUnsupported,
                visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
            ) {
                return TraceApi.InvalidRequestCause._visit(this, visitor);
            },
        };
    },

    unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError): TraceApi.InvalidRequestCause.UnexpectedLanguage => {
        return {
            ...value,
            type: \\"unexpectedLanguage\\",
            _visit: function <_Result>(
                this: TraceApi.InvalidRequestCause.UnexpectedLanguage,
                visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
            ) {
                return TraceApi.InvalidRequestCause._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.InvalidRequestCause._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.InvalidRequestCause._Unknown,
                visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
            ) {
                return TraceApi.InvalidRequestCause._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.InvalidRequestCause,
        visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"submissionIdNotFound\\":
                return visitor.submissionIdNotFound(value);
            case \\"customTestCasesUnsupported\\":
                return visitor.customTestCasesUnsupported(value);
            case \\"unexpectedLanguage\\":
                return visitor.unexpectedLanguage(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "InvalidRequestCause.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InvalidRequestResponse {
    request: TraceApi.SubmissionRequest;
    cause: TraceApi.InvalidRequestCause;
}
",
                        "name": "InvalidRequestResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                        "name": "LightweightStackframeInformation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordedResponseNotification {
    submissionId: TraceApi.SubmissionId;
    traceResponsesSize: number;
    testCaseId?: string;
}
",
                        "name": "RecordedResponseNotification.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordedTestCaseUpdate {
    testCaseId: TraceApi.v2.TestCaseId;
    traceResponsesSize: number;
}
",
                        "name": "RecordedTestCaseUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordingResponseNotification {
    submissionId: TraceApi.SubmissionId;
    testCaseId?: string;
    lineNumber: number;
    lightweightStackInfo: TraceApi.LightweightStackframeInformation;
    tracedFile?: TraceApi.TracedFile;
}
",
                        "name": "RecordingResponseNotification.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RunningResponse {
    submissionId: TraceApi.SubmissionId;
    state: TraceApi.RunningSubmissionState;
}
",
                        "name": "RunningResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type RunningSubmissionState =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
    QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
    KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
    CompilingSubmission: \\"COMPILING_SUBMISSION\\",
    RunningSubmission: \\"RUNNING_SUBMISSION\\",
} as const;
",
                        "name": "RunningSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RuntimeError {
    message: string;
}
",
                        "name": "RuntimeError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Scope {
    variables: Record<string, TraceApi.DebugVariableValue | undefined>;
}
",
                        "name": "Scope.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ShareId = string & {
    ShareId: void;
};

export function ShareId(value: string): TraceApi.ShareId {
    return value as unknown as TraceApi.ShareId;
}
",
                        "name": "ShareId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: TraceApi.Scope[];
}
",
                        "name": "StackFrame.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame?: TraceApi.StackFrame;
}
",
                        "name": "StackInformation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StderrResponse {
    submissionId: TraceApi.SubmissionId;
    stderr: string;
}
",
                        "name": "StderrResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StdoutResponse {
    submissionId: TraceApi.SubmissionId;
    stdout: string;
}
",
                        "name": "StdoutResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StopRequest {
    submissionId: TraceApi.SubmissionId;
}
",
                        "name": "StopRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoppedResponse {
    submissionId: TraceApi.SubmissionId;
}
",
                        "name": "StoppedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                        "name": "SubmissionFileInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionId = string & {
    SubmissionId: void;
};

export function SubmissionId(value: string): TraceApi.SubmissionId {
    return value as unknown as TraceApi.SubmissionId;
}
",
                        "name": "SubmissionId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: TraceApi.SubmissionId;
}
",
                        "name": "SubmissionIdNotFound.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionRequest =
    | TraceApi.SubmissionRequest.InitializeProblemRequest
    | TraceApi.SubmissionRequest.InitializeWorkspaceRequest
    | TraceApi.SubmissionRequest.SubmitV2
    | TraceApi.SubmissionRequest.WorkspaceSubmit
    | TraceApi.SubmissionRequest.Stop
    | TraceApi.SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends TraceApi.InitializeProblemRequest, _Utils {
        type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest extends _Utils {
        type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends TraceApi.SubmitRequestV2, _Utils {
        type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends TraceApi.WorkspaceSubmitRequest, _Utils {
        type: \\"workspaceSubmit\\";
    }

    interface Stop extends TraceApi.StopRequest, _Utils {
        type: \\"stop\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.SubmissionRequest._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        initializeProblemRequest: (value: TraceApi.InitializeProblemRequest) => _Result;
        initializeWorkspaceRequest: () => _Result;
        submitV2: (value: TraceApi.SubmitRequestV2) => _Result;
        workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest) => _Result;
        stop: (value: TraceApi.StopRequest) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const SubmissionRequest = {
    initializeProblemRequest: (
        value: TraceApi.InitializeProblemRequest
    ): TraceApi.SubmissionRequest.InitializeProblemRequest => {
        return {
            ...value,
            type: \\"initializeProblemRequest\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest.InitializeProblemRequest,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    initializeWorkspaceRequest: (): TraceApi.SubmissionRequest.InitializeWorkspaceRequest => {
        return {
            type: \\"initializeWorkspaceRequest\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest.InitializeWorkspaceRequest,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    submitV2: (value: TraceApi.SubmitRequestV2): TraceApi.SubmissionRequest.SubmitV2 => {
        return {
            ...value,
            type: \\"submitV2\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest.SubmitV2,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest): TraceApi.SubmissionRequest.WorkspaceSubmit => {
        return {
            ...value,
            type: \\"workspaceSubmit\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest.WorkspaceSubmit,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    stop: (value: TraceApi.StopRequest): TraceApi.SubmissionRequest.Stop => {
        return {
            ...value,
            type: \\"stop\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest.Stop,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.SubmissionRequest._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.SubmissionRequest._Unknown,
                visitor: TraceApi.SubmissionRequest._Visitor<_Result>
            ) {
                return TraceApi.SubmissionRequest._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.SubmissionRequest,
        visitor: TraceApi.SubmissionRequest._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"initializeProblemRequest\\":
                return visitor.initializeProblemRequest(value);
            case \\"initializeWorkspaceRequest\\":
                return visitor.initializeWorkspaceRequest();
            case \\"submitV2\\":
                return visitor.submitV2(value);
            case \\"workspaceSubmit\\":
                return visitor.workspaceSubmit(value);
            case \\"stop\\":
                return visitor.stop(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "SubmissionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionResponse =
    | TraceApi.SubmissionResponse.ServerInitialized
    | TraceApi.SubmissionResponse.ProblemInitialized
    | TraceApi.SubmissionResponse.WorkspaceInitialized
    | TraceApi.SubmissionResponse.ServerErrored
    | TraceApi.SubmissionResponse.CodeExecutionUpdate
    | TraceApi.SubmissionResponse.Terminated
    | TraceApi.SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
    interface ServerInitialized extends _Utils {
        type: \\"serverInitialized\\";
    }

    interface ProblemInitialized extends _Utils {
        type: \\"problemInitialized\\";
        value: TraceApi.ProblemId;
    }

    interface WorkspaceInitialized extends _Utils {
        type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends TraceApi.ExceptionInfo, _Utils {
        type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate extends _Utils {
        type: \\"codeExecutionUpdate\\";
        value: TraceApi.CodeExecutionUpdate;
    }

    interface Terminated extends TraceApi.TerminatedResponse, _Utils {
        type: \\"terminated\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.SubmissionResponse._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        serverInitialized: () => _Result;
        problemInitialized: (value: TraceApi.ProblemId) => _Result;
        workspaceInitialized: () => _Result;
        serverErrored: (value: TraceApi.ExceptionInfo) => _Result;
        codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate) => _Result;
        terminated: (value: TraceApi.TerminatedResponse) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const SubmissionResponse = {
    serverInitialized: (): TraceApi.SubmissionResponse.ServerInitialized => {
        return {
            type: \\"serverInitialized\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.ServerInitialized,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    problemInitialized: (value: TraceApi.ProblemId): TraceApi.SubmissionResponse.ProblemInitialized => {
        return {
            value: value,
            type: \\"problemInitialized\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.ProblemInitialized,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    workspaceInitialized: (): TraceApi.SubmissionResponse.WorkspaceInitialized => {
        return {
            type: \\"workspaceInitialized\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.WorkspaceInitialized,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    serverErrored: (value: TraceApi.ExceptionInfo): TraceApi.SubmissionResponse.ServerErrored => {
        return {
            ...value,
            type: \\"serverErrored\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.ServerErrored,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate): TraceApi.SubmissionResponse.CodeExecutionUpdate => {
        return {
            value: value,
            type: \\"codeExecutionUpdate\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.CodeExecutionUpdate,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    terminated: (value: TraceApi.TerminatedResponse): TraceApi.SubmissionResponse.Terminated => {
        return {
            ...value,
            type: \\"terminated\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse.Terminated,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.SubmissionResponse._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.SubmissionResponse._Unknown,
                visitor: TraceApi.SubmissionResponse._Visitor<_Result>
            ) {
                return TraceApi.SubmissionResponse._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.SubmissionResponse,
        visitor: TraceApi.SubmissionResponse._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"serverInitialized\\":
                return visitor.serverInitialized();
            case \\"problemInitialized\\":
                return visitor.problemInitialized(value.value);
            case \\"workspaceInitialized\\":
                return visitor.workspaceInitialized();
            case \\"serverErrored\\":
                return visitor.serverErrored(value);
            case \\"codeExecutionUpdate\\":
                return visitor.codeExecutionUpdate(value.value);
            case \\"terminated\\":
                return visitor.terminated(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "SubmissionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionStatusForTestCase =
    | TraceApi.SubmissionStatusForTestCase.Graded
    | TraceApi.SubmissionStatusForTestCase.GradedV2
    | TraceApi.SubmissionStatusForTestCase.Traced
    | TraceApi.SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends TraceApi.TestCaseResultWithStdout, _Utils {
        type: \\"graded\\";
    }

    interface GradedV2 extends _Utils {
        type: \\"gradedV2\\";
        value: TraceApi.TestCaseGrade;
    }

    interface Traced extends TraceApi.TracedTestCase, _Utils {
        type: \\"traced\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        graded: (value: TraceApi.TestCaseResultWithStdout) => _Result;
        gradedV2: (value: TraceApi.TestCaseGrade) => _Result;
        traced: (value: TraceApi.TracedTestCase) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const SubmissionStatusForTestCase = {
    graded: (value: TraceApi.TestCaseResultWithStdout): TraceApi.SubmissionStatusForTestCase.Graded => {
        return {
            ...value,
            type: \\"graded\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusForTestCase.Graded,
                visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
            },
        };
    },

    gradedV2: (value: TraceApi.TestCaseGrade): TraceApi.SubmissionStatusForTestCase.GradedV2 => {
        return {
            value: value,
            type: \\"gradedV2\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusForTestCase.GradedV2,
                visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
            },
        };
    },

    traced: (value: TraceApi.TracedTestCase): TraceApi.SubmissionStatusForTestCase.Traced => {
        return {
            ...value,
            type: \\"traced\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusForTestCase.Traced,
                visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.SubmissionStatusForTestCase._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusForTestCase._Unknown,
                visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.SubmissionStatusForTestCase,
        visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"graded\\":
                return visitor.graded(value);
            case \\"gradedV2\\":
                return visitor.gradedV2(value.value);
            case \\"traced\\":
                return visitor.traced(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "SubmissionStatusForTestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionStatusV2 =
    | TraceApi.SubmissionStatusV2.Test
    | TraceApi.SubmissionStatusV2.Workspace
    | TraceApi.SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
    interface Test extends TraceApi.TestSubmissionStatusV2, _Utils {
        type: \\"test\\";
    }

    interface Workspace extends TraceApi.WorkspaceSubmissionStatusV2, _Utils {
        type: \\"workspace\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        test: (value: TraceApi.TestSubmissionStatusV2) => _Result;
        workspace: (value: TraceApi.WorkspaceSubmissionStatusV2) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const SubmissionStatusV2 = {
    test: (value: TraceApi.TestSubmissionStatusV2): TraceApi.SubmissionStatusV2.Test => {
        return {
            ...value,
            type: \\"test\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusV2.Test,
                visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusV2._visit(this, visitor);
            },
        };
    },

    workspace: (value: TraceApi.WorkspaceSubmissionStatusV2): TraceApi.SubmissionStatusV2.Workspace => {
        return {
            ...value,
            type: \\"workspace\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusV2.Workspace,
                visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusV2._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.SubmissionStatusV2._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.SubmissionStatusV2._Unknown,
                visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
            ) {
                return TraceApi.SubmissionStatusV2._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.SubmissionStatusV2,
        visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"test\\":
                return visitor.test(value);
            case \\"workspace\\":
                return visitor.workspace(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "SubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum = \\"TEST\\";

export const SubmissionTypeEnum = {
    Test: \\"TEST\\",
} as const;
",
                        "name": "SubmissionTypeEnum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionTypeState =
    | TraceApi.SubmissionTypeState.Test
    | TraceApi.SubmissionTypeState.Workspace
    | TraceApi.SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
    interface Test extends TraceApi.TestSubmissionState, _Utils {
        type: \\"test\\";
    }

    interface Workspace extends TraceApi.WorkspaceSubmissionState, _Utils {
        type: \\"workspace\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        test: (value: TraceApi.TestSubmissionState) => _Result;
        workspace: (value: TraceApi.WorkspaceSubmissionState) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const SubmissionTypeState = {
    test: (value: TraceApi.TestSubmissionState): TraceApi.SubmissionTypeState.Test => {
        return {
            ...value,
            type: \\"test\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionTypeState.Test,
                visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
            ) {
                return TraceApi.SubmissionTypeState._visit(this, visitor);
            },
        };
    },

    workspace: (value: TraceApi.WorkspaceSubmissionState): TraceApi.SubmissionTypeState.Workspace => {
        return {
            ...value,
            type: \\"workspace\\",
            _visit: function <_Result>(
                this: TraceApi.SubmissionTypeState.Workspace,
                visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
            ) {
                return TraceApi.SubmissionTypeState._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.SubmissionTypeState._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.SubmissionTypeState._Unknown,
                visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
            ) {
                return TraceApi.SubmissionTypeState._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.SubmissionTypeState,
        visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"test\\":
                return visitor.test(value);
            case \\"workspace\\":
                return visitor.workspace(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "SubmissionTypeState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SubmitRequestV2 {
    submissionId: TraceApi.SubmissionId;
    language: TraceApi.Language;
    submissionFiles: TraceApi.SubmissionFileInfo[];
    problemId: TraceApi.ProblemId;
    problemVersion?: number;
    userId?: string;
}
",
                        "name": "SubmitRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TerminatedResponse {}
",
                        "name": "TerminatedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseGrade =
    | TraceApi.TestCaseGrade.Hidden
    | TraceApi.TestCaseGrade.NonHidden
    | TraceApi.TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
    interface Hidden extends TraceApi.TestCaseHiddenGrade, _Utils {
        type: \\"hidden\\";
    }

    interface NonHidden extends TraceApi.TestCaseNonHiddenGrade, _Utils {
        type: \\"nonHidden\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.TestCaseGrade._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        hidden: (value: TraceApi.TestCaseHiddenGrade) => _Result;
        nonHidden: (value: TraceApi.TestCaseNonHiddenGrade) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseGrade = {
    hidden: (value: TraceApi.TestCaseHiddenGrade): TraceApi.TestCaseGrade.Hidden => {
        return {
            ...value,
            type: \\"hidden\\",
            _visit: function <_Result>(
                this: TraceApi.TestCaseGrade.Hidden,
                visitor: TraceApi.TestCaseGrade._Visitor<_Result>
            ) {
                return TraceApi.TestCaseGrade._visit(this, visitor);
            },
        };
    },

    nonHidden: (value: TraceApi.TestCaseNonHiddenGrade): TraceApi.TestCaseGrade.NonHidden => {
        return {
            ...value,
            type: \\"nonHidden\\",
            _visit: function <_Result>(
                this: TraceApi.TestCaseGrade.NonHidden,
                visitor: TraceApi.TestCaseGrade._Visitor<_Result>
            ) {
                return TraceApi.TestCaseGrade._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.TestCaseGrade._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.TestCaseGrade._Unknown,
                visitor: TraceApi.TestCaseGrade._Visitor<_Result>
            ) {
                return TraceApi.TestCaseGrade._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.TestCaseGrade, visitor: TraceApi.TestCaseGrade._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"hidden\\":
                return visitor.hidden(value);
            case \\"nonHidden\\":
                return visitor.nonHidden(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TestCaseGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                        "name": "TestCaseHiddenGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult?: TraceApi.VariableValue;
    exception?: TraceApi.ExceptionV2;
    stdout: string;
}
",
                        "name": "TestCaseNonHiddenGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseResult {
    expectedResult: TraceApi.VariableValue;
    actualResult: TraceApi.ActualResult;
    passed: boolean;
}
",
                        "name": "TestCaseResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseResultWithStdout {
    result: TraceApi.TestCaseResult;
    stdout: string;
}
",
                        "name": "TestCaseResultWithStdout.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionState {
    problemId: TraceApi.ProblemId;
    defaultTestCases: TraceApi.TestCase[];
    customTestCases: TraceApi.TestCase[];
    status: TraceApi.TestSubmissionStatus;
}
",
                        "name": "TestSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestSubmissionStatus =
    | TraceApi.TestSubmissionStatus.Stopped
    | TraceApi.TestSubmissionStatus.Errored
    | TraceApi.TestSubmissionStatus.Running
    | TraceApi.TestSubmissionStatus.TestCaseIdToState
    | TraceApi.TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: TraceApi.ErrorInfo;
    }

    interface Running extends _Utils {
        type: \\"running\\";
        value: TraceApi.RunningSubmissionState;
    }

    interface TestCaseIdToState extends _Utils {
        type: \\"testCaseIdToState\\";
        value: Record<string, TraceApi.SubmissionStatusForTestCase | undefined>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        stopped: () => _Result;
        errored: (value: TraceApi.ErrorInfo) => _Result;
        running: (value: TraceApi.RunningSubmissionState) => _Result;
        testCaseIdToState: (value: Record<string, TraceApi.SubmissionStatusForTestCase | undefined>) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestSubmissionStatus = {
    stopped: (): TraceApi.TestSubmissionStatus.Stopped => {
        return {
            type: \\"stopped\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionStatus.Stopped,
                visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionStatus._visit(this, visitor);
            },
        };
    },

    errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionStatus.Errored => {
        return {
            value: value,
            type: \\"errored\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionStatus.Errored,
                visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionStatus._visit(this, visitor);
            },
        };
    },

    running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionStatus.Running => {
        return {
            value: value,
            type: \\"running\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionStatus.Running,
                visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionStatus._visit(this, visitor);
            },
        };
    },

    testCaseIdToState: (
        value: Record<string, TraceApi.SubmissionStatusForTestCase | undefined>
    ): TraceApi.TestSubmissionStatus.TestCaseIdToState => {
        return {
            value: value,
            type: \\"testCaseIdToState\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionStatus.TestCaseIdToState,
                visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionStatus._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.TestSubmissionStatus._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionStatus._Unknown,
                visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionStatus._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.TestSubmissionStatus,
        visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"stopped\\":
                return visitor.stopped();
            case \\"errored\\":
                return visitor.errored(value.value);
            case \\"running\\":
                return visitor.running(value.value);
            case \\"testCaseIdToState\\":
                return visitor.testCaseIdToState(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TestSubmissionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionStatusV2 {
    updates: TraceApi.TestSubmissionUpdate[];
    problemId: TraceApi.ProblemId;
    problemVersion: number;
    problemInfo: TraceApi.v2.ProblemInfoV2;
}
",
                        "name": "TestSubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionUpdate {
    updateTime: Date;
    updateInfo: TraceApi.TestSubmissionUpdateInfo;
}
",
                        "name": "TestSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestSubmissionUpdateInfo =
    | TraceApi.TestSubmissionUpdateInfo.Running
    | TraceApi.TestSubmissionUpdateInfo.Stopped
    | TraceApi.TestSubmissionUpdateInfo.Errored
    | TraceApi.TestSubmissionUpdateInfo.GradedTestCase
    | TraceApi.TestSubmissionUpdateInfo.RecordedTestCase
    | TraceApi.TestSubmissionUpdateInfo.Finished
    | TraceApi.TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
    interface Running extends _Utils {
        type: \\"running\\";
        value: TraceApi.RunningSubmissionState;
    }

    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: TraceApi.ErrorInfo;
    }

    interface GradedTestCase extends TraceApi.GradedTestCaseUpdate, _Utils {
        type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends TraceApi.RecordedTestCaseUpdate, _Utils {
        type: \\"recordedTestCase\\";
    }

    interface Finished extends _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        running: (value: TraceApi.RunningSubmissionState) => _Result;
        stopped: () => _Result;
        errored: (value: TraceApi.ErrorInfo) => _Result;
        gradedTestCase: (value: TraceApi.GradedTestCaseUpdate) => _Result;
        recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate) => _Result;
        finished: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestSubmissionUpdateInfo = {
    running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionUpdateInfo.Running => {
        return {
            value: value,
            type: \\"running\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.Running,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    stopped: (): TraceApi.TestSubmissionUpdateInfo.Stopped => {
        return {
            type: \\"stopped\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.Stopped,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionUpdateInfo.Errored => {
        return {
            value: value,
            type: \\"errored\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.Errored,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    gradedTestCase: (value: TraceApi.GradedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.GradedTestCase => {
        return {
            ...value,
            type: \\"gradedTestCase\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.GradedTestCase,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.RecordedTestCase => {
        return {
            ...value,
            type: \\"recordedTestCase\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.RecordedTestCase,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    finished: (): TraceApi.TestSubmissionUpdateInfo.Finished => {
        return {
            type: \\"finished\\",
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo.Finished,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.TestSubmissionUpdateInfo._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.TestSubmissionUpdateInfo._Unknown,
                visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.TestSubmissionUpdateInfo,
        visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"running\\":
                return visitor.running(value.value);
            case \\"stopped\\":
                return visitor.stopped();
            case \\"errored\\":
                return visitor.errored(value.value);
            case \\"gradedTestCase\\":
                return visitor.gradedTestCase(value);
            case \\"recordedTestCase\\":
                return visitor.recordedTestCase(value);
            case \\"finished\\":
                return visitor.finished();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "TestSubmissionUpdateInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponse {
    submissionId: TraceApi.SubmissionId;
    lineNumber: number;
    returnValue?: TraceApi.DebugVariableValue;
    expressionLocation?: TraceApi.ExpressionLocation;
    stack: TraceApi.StackInformation;
    stdout?: string;
}
",
                        "name": "TraceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponseV2 {
    submissionId: TraceApi.SubmissionId;
    lineNumber: number;
    file: TraceApi.TracedFile;
    returnValue?: TraceApi.DebugVariableValue;
    expressionLocation?: TraceApi.ExpressionLocation;
    stack: TraceApi.StackInformation;
    stdout?: string;
}
",
                        "name": "TraceResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: TraceApi.TraceResponse[];
}
",
                        "name": "TraceResponsesPage.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: TraceApi.TraceResponseV2[];
}
",
                        "name": "TraceResponsesPageV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TracedFile {
    filename: string;
    directory: string;
}
",
                        "name": "TracedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TracedTestCase {
    result: TraceApi.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                        "name": "TracedTestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface UnexpectedLanguageError {
    expectedLanguage: TraceApi.Language;
    actualLanguage: TraceApi.Language;
}
",
                        "name": "UnexpectedLanguageError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceFiles {
    mainFile: TraceApi.FileInfo;
    readOnlyFiles: TraceApi.FileInfo[];
}
",
                        "name": "WorkspaceFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceRanResponse {
    submissionId: TraceApi.SubmissionId;
    runDetails: TraceApi.WorkspaceRunDetails;
}
",
                        "name": "WorkspaceRanResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceRunDetails {
    exceptionV2?: TraceApi.ExceptionV2;
    exception?: TraceApi.ExceptionInfo;
    stdout: string;
}
",
                        "name": "WorkspaceRunDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<TraceApi.Language, TraceApi.WorkspaceFiles | undefined>;
}
",
                        "name": "WorkspaceStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
}
",
                        "name": "WorkspaceStarterFilesResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionState {
    status: TraceApi.WorkspaceSubmissionStatus;
}
",
                        "name": "WorkspaceSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type WorkspaceSubmissionStatus =
    | TraceApi.WorkspaceSubmissionStatus.Stopped
    | TraceApi.WorkspaceSubmissionStatus.Errored
    | TraceApi.WorkspaceSubmissionStatus.Running
    | TraceApi.WorkspaceSubmissionStatus.Ran
    | TraceApi.WorkspaceSubmissionStatus.Traced
    | TraceApi.WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: TraceApi.ErrorInfo;
    }

    interface Running extends _Utils {
        type: \\"running\\";
        value: TraceApi.RunningSubmissionState;
    }

    interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
        type: \\"ran\\";
    }

    interface Traced extends TraceApi.WorkspaceRunDetails, _Utils {
        type: \\"traced\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        stopped: () => _Result;
        errored: (value: TraceApi.ErrorInfo) => _Result;
        running: (value: TraceApi.RunningSubmissionState) => _Result;
        ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
        traced: (value: TraceApi.WorkspaceRunDetails) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const WorkspaceSubmissionStatus = {
    stopped: (): TraceApi.WorkspaceSubmissionStatus.Stopped => {
        return {
            type: \\"stopped\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus.Stopped,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionStatus.Errored => {
        return {
            value: value,
            type: \\"errored\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus.Errored,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionStatus.Running => {
        return {
            value: value,
            type: \\"running\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus.Running,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Ran => {
        return {
            ...value,
            type: \\"ran\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus.Ran,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    traced: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Traced => {
        return {
            ...value,
            type: \\"traced\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus.Traced,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.WorkspaceSubmissionStatus._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionStatus._Unknown,
                visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.WorkspaceSubmissionStatus,
        visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"stopped\\":
                return visitor.stopped();
            case \\"errored\\":
                return visitor.errored(value.value);
            case \\"running\\":
                return visitor.running(value.value);
            case \\"ran\\":
                return visitor.ran(value);
            case \\"traced\\":
                return visitor.traced(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "WorkspaceSubmissionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: TraceApi.WorkspaceSubmissionUpdate[];
}
",
                        "name": "WorkspaceSubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: Date;
    updateInfo: TraceApi.WorkspaceSubmissionUpdateInfo;
}
",
                        "name": "WorkspaceSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type WorkspaceSubmissionUpdateInfo =
    | TraceApi.WorkspaceSubmissionUpdateInfo.Running
    | TraceApi.WorkspaceSubmissionUpdateInfo.Ran
    | TraceApi.WorkspaceSubmissionUpdateInfo.Stopped
    | TraceApi.WorkspaceSubmissionUpdateInfo.Traced
    | TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2
    | TraceApi.WorkspaceSubmissionUpdateInfo.Errored
    | TraceApi.WorkspaceSubmissionUpdateInfo.Finished
    | TraceApi.WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running extends _Utils {
        type: \\"running\\";
        value: TraceApi.RunningSubmissionState;
    }

    interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
        type: \\"ran\\";
    }

    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Traced extends _Utils {
        type: \\"traced\\";
    }

    interface TracedV2 extends TraceApi.WorkspaceTracedUpdate, _Utils {
        type: \\"tracedV2\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: TraceApi.ErrorInfo;
    }

    interface Finished extends _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        running: (value: TraceApi.RunningSubmissionState) => _Result;
        ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
        stopped: () => _Result;
        traced: () => _Result;
        tracedV2: (value: TraceApi.WorkspaceTracedUpdate) => _Result;
        errored: (value: TraceApi.ErrorInfo) => _Result;
        finished: () => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
    running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionUpdateInfo.Running => {
        return {
            value: value,
            type: \\"running\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Running,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionUpdateInfo.Ran => {
        return {
            ...value,
            type: \\"ran\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Ran,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    stopped: (): TraceApi.WorkspaceSubmissionUpdateInfo.Stopped => {
        return {
            type: \\"stopped\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Stopped,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    traced: (): TraceApi.WorkspaceSubmissionUpdateInfo.Traced => {
        return {
            type: \\"traced\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Traced,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    tracedV2: (value: TraceApi.WorkspaceTracedUpdate): TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2 => {
        return {
            ...value,
            type: \\"tracedV2\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionUpdateInfo.Errored => {
        return {
            value: value,
            type: \\"errored\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Errored,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    finished: (): TraceApi.WorkspaceSubmissionUpdateInfo.Finished => {
        return {
            type: \\"finished\\",
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo.Finished,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.WorkspaceSubmissionUpdateInfo._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.WorkspaceSubmissionUpdateInfo._Unknown,
                visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
            ) {
                return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.WorkspaceSubmissionUpdateInfo,
        visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"running\\":
                return visitor.running(value.value);
            case \\"ran\\":
                return visitor.ran(value);
            case \\"stopped\\":
                return visitor.stopped();
            case \\"traced\\":
                return visitor.traced();
            case \\"tracedV2\\":
                return visitor.tracedV2(value);
            case \\"errored\\":
                return visitor.errored(value.value);
            case \\"finished\\":
                return visitor.finished();
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "WorkspaceSubmissionUpdateInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmitRequest {
    submissionId: TraceApi.SubmissionId;
    language: TraceApi.Language;
    submissionFiles: TraceApi.SubmissionFileInfo[];
    userId?: string;
}
",
                        "name": "WorkspaceSubmitRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                        "name": "WorkspaceTracedUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "submission",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as serializers from \\"../../../../serialization\\";
import urlJoin from \\"url-join\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    public async setNumWarmInstances(
        language: TraceApi.Language,
        numWarmInstances: number
    ): Promise<core.APIResponse<void, TraceApi.sysprop.setNumWarmInstances.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/sysprop/num-warm-instances/\${await serializers.Language.jsonOrThrow(language)}/\${numWarmInstances}\`
            ),
            method: \\"PUT\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: undefined,
            };
        }

        return {
            ok: false,
            error: TraceApi.sysprop.setNumWarmInstances.Error._unknown(_response.error),
        };
    }

    public async getNumWarmInstances(): Promise<
        core.APIResponse<Record<TraceApi.Language, number | undefined>, TraceApi.sysprop.getNumWarmInstances.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/sysprop/num-warm-instances\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.sysprop.getNumWarmInstances.Response.parseOrThrow(
                    _response.body as serializers.sysprop.getNumWarmInstances.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.sysprop.getNumWarmInstances.Error._unknown(_response.error),
        };
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.sysprop.getNumWarmInstances.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.getNumWarmInstances.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.sysprop.getNumWarmInstances.Error._Unknown,
                visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>
            ) {
                return TraceApi.sysprop.getNumWarmInstances.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.sysprop.getNumWarmInstances.Error,
        visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "getNumWarmInstances.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export type Error = TraceApi.sysprop.setNumWarmInstances.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.setNumWarmInstances.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.sysprop.setNumWarmInstances.Error._Unknown,
                visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>
            ) {
                return TraceApi.sysprop.setNumWarmInstances.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.sysprop.setNumWarmInstances.Error,
        visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                        "name": "setNumWarmInstances.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "sysprop",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../environments\\";
import * as core from \\"../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";
import { Client as V3Client } from \\"../resources/v3/client/Client\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    #problem: ProblemClient | undefined;

    public get problem(): ProblemClient {
        return (this.#problem ??= new ProblemClient(this.options));
    }

    #v3: V3Client | undefined;

    public get v3(): V3Client {
        return (this.#v3 ??= new V3Client(this.options));
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export {};
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../environments\\";
import * as core from \\"../../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Returns lightweight versions of all problems
     */
    public async getLightweightProblems(): Promise<
        core.APIResponse<TraceApi.v2.LightweightProblemInfoV2[], TraceApi.v2.problem.getLightweightProblems.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/problems-v2/lightweight-problem-info\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.problem.getLightweightProblems.Response.parseOrThrow(
                    _response.body as serializers.v2.problem.getLightweightProblems.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.problem.getLightweightProblems.Error._unknown(_response.error),
        };
    }

    /**
     * Returns latest versions of all problems
     */
    public async getProblems(): Promise<
        core.APIResponse<TraceApi.v2.ProblemInfoV2[], TraceApi.v2.problem.getProblems.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/problems-v2/problem-info\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.problem.getProblems.Response.parseOrThrow(
                    _response.body as serializers.v2.problem.getProblems.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.problem.getProblems.Error._unknown(_response.error),
        };
    }

    /**
     * Returns latest version of a problem
     */
    public async getLatestProblem(
        problemId: TraceApi.ProblemId
    ): Promise<core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getLatestProblem.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problems-v2/problem-info/\${await serializers.ProblemId.jsonOrThrow(problemId)}\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.ProblemInfoV2.parseOrThrow(
                    _response.body as serializers.v2.ProblemInfoV2.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.problem.getLatestProblem.Error._unknown(_response.error),
        };
    }

    /**
     * Returns requested version of a problem
     */
    public async getProblemVersion(
        problemId: TraceApi.ProblemId,
        problemVersion: number
    ): Promise<core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getProblemVersion.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problems-v2/problem-info/\${await serializers.ProblemId.jsonOrThrow(
                    problemId
                )}/version/\${problemVersion}\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.ProblemInfoV2.parseOrThrow(
                    _response.body as serializers.v2.ProblemInfoV2.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.problem.getProblemVersion.Error._unknown(_response.error),
        };
    }
}
",
                                "name": "Client.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export type Error = TraceApi.v2.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLatestProblem.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.problem.getLatestProblem.Error._Unknown,
                visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.problem.getLatestProblem.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.problem.getLatestProblem.Error,
        visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "getLatestProblem.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export type Error = TraceApi.v2.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLightweightProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.problem.getLightweightProblems.Error._Unknown,
                visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.problem.getLightweightProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.problem.getLightweightProblems.Error,
        visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "getLightweightProblems.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export type Error = TraceApi.v2.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblemVersion.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.problem.getProblemVersion.Error._Unknown,
                visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.problem.getProblemVersion.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.problem.getProblemVersion.Error,
        visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "getProblemVersion.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export type Error = TraceApi.v2.problem.getProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.problem.getProblems.Error._Unknown,
                visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.problem.getProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.problem.getProblems.Error,
        visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "getProblems.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "client",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type AssertCorrectnessCheck =
    | TraceApi.v2.AssertCorrectnessCheck.DeepEquality
    | TraceApi.v2.AssertCorrectnessCheck.Custom
    | TraceApi.v2.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends TraceApi.v2.DeepEqualityCorrectnessCheck, _Utils {
        type: \\"deepEquality\\";
    }

    interface Custom extends TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        deepEquality: (value: TraceApi.v2.DeepEqualityCorrectnessCheck) => _Result;
        custom: (value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (
        value: TraceApi.v2.DeepEqualityCorrectnessCheck
    ): TraceApi.v2.AssertCorrectnessCheck.DeepEquality => {
        return {
            ...value,
            type: \\"deepEquality\\",
            _visit: function <_Result>(
                this: TraceApi.v2.AssertCorrectnessCheck.DeepEquality,
                visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    custom: (
        value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
    ): TraceApi.v2.AssertCorrectnessCheck.Custom => {
        return {
            ...value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.AssertCorrectnessCheck.Custom,
                visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.AssertCorrectnessCheck._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.AssertCorrectnessCheck._Unknown,
                visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.AssertCorrectnessCheck,
        visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"deepEquality\\":
                return visitor.deepEquality(value);
            case \\"custom\\":
                return visitor.custom(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "AssertCorrectnessCheck.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: TraceApi.v2.NonVoidFunctionSignature;
    additionalFiles: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
    basicTestCaseTemplate: TraceApi.v2.BasicTestCaseTemplate;
}
",
                                "name": "BasicCustomFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicTestCaseTemplate {
    templateId: TraceApi.v2.TestCaseTemplateId;
    name: string;
    description: TraceApi.v2.TestCaseImplementationDescription;
    expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                                "name": "BasicTestCaseTemplate.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: TraceApi.ProblemDescription;
    customFiles: TraceApi.v2.CustomFiles;
    customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
    testcases: TraceApi.v2.TestCaseV2[];
    supportedLanguages: TraceApi.Language[];
    isPublic: boolean;
}
",
                                "name": "CreateProblemRequestV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type CustomFiles =
    | TraceApi.v2.CustomFiles.Basic
    | TraceApi.v2.CustomFiles.Custom
    | TraceApi.v2.CustomFiles._Unknown;

export declare namespace CustomFiles {
    interface Basic extends TraceApi.v2.BasicCustomFiles, _Utils {
        type: \\"basic\\";
    }

    interface Custom extends _Utils {
        type: \\"custom\\";
        value: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        basic: (value: TraceApi.v2.BasicCustomFiles) => _Result;
        custom: (value: Record<TraceApi.Language, TraceApi.v2.Files | undefined>) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const CustomFiles = {
    basic: (value: TraceApi.v2.BasicCustomFiles): TraceApi.v2.CustomFiles.Basic => {
        return {
            ...value,
            type: \\"basic\\",
            _visit: function <_Result>(
                this: TraceApi.v2.CustomFiles.Basic,
                visitor: TraceApi.v2.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.CustomFiles._visit(this, visitor);
            },
        };
    },

    custom: (value: Record<TraceApi.Language, TraceApi.v2.Files | undefined>): TraceApi.v2.CustomFiles.Custom => {
        return {
            value: value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.CustomFiles.Custom,
                visitor: TraceApi.v2.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.CustomFiles._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.CustomFiles._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.CustomFiles._Unknown,
                visitor: TraceApi.v2.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.CustomFiles._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(value: TraceApi.v2.CustomFiles, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>): _Result => {
        switch (value.type) {
            case \\"basic\\":
                return visitor.basic(value);
            case \\"custom\\":
                return visitor.custom(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "CustomFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                                "name": "DeepEqualityCorrectnessCheck.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DefaultProvidedFile {
    file: TraceApi.v2.FileInfoV2;
    relatedTypes: TraceApi.VariableType[];
}
",
                                "name": "DefaultProvidedFile.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                                "name": "FileInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Files {
    files: TraceApi.v2.FileInfoV2[];
}
",
                                "name": "Files.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                                "name": "FunctionImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<TraceApi.Language, TraceApi.v2.FunctionImplementation | undefined>;
}
",
                                "name": "FunctionImplementationForMultipleLanguages.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type FunctionSignature =
    | TraceApi.v2.FunctionSignature.Void
    | TraceApi.v2.FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | TraceApi.v2.FunctionSignature.VoidThatTakesActualResult
    | TraceApi.v2.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
    interface Void extends TraceApi.v2.VoidFunctionSignature, _Utils {
        type: \\"void\\";
    }

    interface NonVoid extends TraceApi.v2.NonVoidFunctionSignature, _Utils {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends TraceApi.v2.VoidFunctionSignatureThatTakesActualResult, _Utils {
        type: \\"voidThatTakesActualResult\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        void: (value: TraceApi.v2.VoidFunctionSignature) => _Result;
        nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature) => _Result;
        voidThatTakesActualResult: (value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const FunctionSignature = {
    void: (value: TraceApi.v2.VoidFunctionSignature): TraceApi.v2.FunctionSignature.Void => {
        return {
            ...value,
            type: \\"void\\",
            _visit: function <_Result>(
                this: TraceApi.v2.FunctionSignature.Void,
                visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.FunctionSignature._visit(this, visitor);
            },
        };
    },

    nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature): TraceApi.v2.FunctionSignature.NonVoid => {
        return {
            ...value,
            type: \\"nonVoid\\",
            _visit: function <_Result>(
                this: TraceApi.v2.FunctionSignature.NonVoid,
                visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.FunctionSignature._visit(this, visitor);
            },
        };
    },

    voidThatTakesActualResult: (
        value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
    ): TraceApi.v2.FunctionSignature.VoidThatTakesActualResult => {
        return {
            ...value,
            type: \\"voidThatTakesActualResult\\",
            _visit: function <_Result>(
                this: TraceApi.v2.FunctionSignature.VoidThatTakesActualResult,
                visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.FunctionSignature._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.FunctionSignature._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.FunctionSignature._Unknown,
                visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.FunctionSignature._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.FunctionSignature,
        visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"void\\":
                return visitor.void(value);
            case \\"nonVoid\\":
                return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\":
                return visitor.voidThatTakesActualResult(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "FunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
    generatedTemplateFiles: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
    other: Record<TraceApi.Language, TraceApi.v2.Files | undefined>;
}
",
                                "name": "GeneratedFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: TraceApi.v2.NonVoidFunctionSignature;
}
",
                                "name": "GetBasicSolutionFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<TraceApi.Language, TraceApi.v2.FileInfoV2 | undefined>;
}
",
                                "name": "GetBasicSolutionFileResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureRequest {
    functionSignature: TraceApi.v2.FunctionSignature;
}
",
                                "name": "GetFunctionSignatureRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<TraceApi.Language, string | undefined>;
}
",
                                "name": "GetFunctionSignatureResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: TraceApi.v2.TestCaseTemplate;
    testCase: TraceApi.v2.TestCaseV2;
}
",
                                "name": "GetGeneratedTestCaseFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: TraceApi.v2.TestCaseTemplate;
}
",
                                "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface LightweightProblemInfoV2 {
    problemId: TraceApi.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: TraceApi.VariableType[];
}
",
                                "name": "LightweightProblemInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionDefinition {
    signature: TraceApi.v2.NonVoidFunctionSignature;
    code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                                "name": "NonVoidFunctionDefinition.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionSignature {
    parameters: TraceApi.v2.Parameter[];
    returnType: TraceApi.VariableType;
}
",
                                "name": "NonVoidFunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Parameter {
    parameterId: TraceApi.v2.ParameterId;
    name: string;
    variableType: TraceApi.VariableType;
}
",
                                "name": "Parameter.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ParameterId = string & {
    v2_ParameterId: void;
};

export function ParameterId(value: string): TraceApi.v2.ParameterId {
    return value as unknown as TraceApi.v2.ParameterId;
}
",
                                "name": "ParameterId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfoV2 {
    problemId: TraceApi.ProblemId;
    problemDescription: TraceApi.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: TraceApi.Language[];
    customFiles: TraceApi.v2.CustomFiles;
    generatedFiles: TraceApi.v2.GeneratedFiles;
    customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
    testcases: TraceApi.v2.TestCaseV2[];
    isPublic: boolean;
}
",
                                "name": "ProblemInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                                "name": "TestCaseExpects.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseFunction =
    | TraceApi.v2.TestCaseFunction.WithActualResult
    | TraceApi.v2.TestCaseFunction.Custom
    | TraceApi.v2.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
    interface WithActualResult extends TraceApi.v2.TestCaseWithActualResultImplementation, _Utils {
        type: \\"withActualResult\\";
    }

    interface Custom extends TraceApi.v2.VoidFunctionDefinition, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        withActualResult: (value: TraceApi.v2.TestCaseWithActualResultImplementation) => _Result;
        custom: (value: TraceApi.v2.VoidFunctionDefinition) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (
        value: TraceApi.v2.TestCaseWithActualResultImplementation
    ): TraceApi.v2.TestCaseFunction.WithActualResult => {
        return {
            ...value,
            type: \\"withActualResult\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseFunction.WithActualResult,
                visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    custom: (value: TraceApi.v2.VoidFunctionDefinition): TraceApi.v2.TestCaseFunction.Custom => {
        return {
            ...value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseFunction.Custom,
                visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.TestCaseFunction._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseFunction._Unknown,
                visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.TestCaseFunction,
        visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"withActualResult\\":
                return visitor.withActualResult(value);
            case \\"custom\\":
                return visitor.custom(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "TestCaseFunction.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseId = string & {
    v2_TestCaseId: void;
};

export function TestCaseId(value: string): TraceApi.v2.TestCaseId {
    return value as unknown as TraceApi.v2.TestCaseId;
}
",
                                "name": "TestCaseId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementation {
    description: TraceApi.v2.TestCaseImplementationDescription;
    function: TraceApi.v2.TestCaseFunction;
}
",
                                "name": "TestCaseImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementationDescription {
    boards: TraceApi.v2.TestCaseImplementationDescriptionBoard[];
}
",
                                "name": "TestCaseImplementationDescription.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseImplementationDescriptionBoard =
    | TraceApi.v2.TestCaseImplementationDescriptionBoard.Html
    | TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId
    | TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface ParamId extends _Utils {
        type: \\"paramId\\";
        value: TraceApi.v2.ParameterId;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        html: (value: string) => _Result;
        paramId: (value: TraceApi.v2.ParameterId) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TraceApi.v2.TestCaseImplementationDescriptionBoard.Html => {
        return {
            value: value,
            type: \\"html\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationDescriptionBoard.Html,
                visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    paramId: (value: TraceApi.v2.ParameterId): TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId => {
        return {
            value: value,
            type: \\"paramId\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId,
                visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown,
                visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.TestCaseImplementationDescriptionBoard,
        visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"html\\":
                return visitor.html(value.value);
            case \\"paramId\\":
                return visitor.paramId(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "TestCaseImplementationDescriptionBoard.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseImplementationReference =
    | TraceApi.v2.TestCaseImplementationReference.TemplateId
    | TraceApi.v2.TestCaseImplementationReference.Implementation
    | TraceApi.v2.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
    interface TemplateId extends _Utils {
        type: \\"templateId\\";
        value: TraceApi.v2.TestCaseTemplateId;
    }

    interface Implementation extends TraceApi.v2.TestCaseImplementation, _Utils {
        type: \\"implementation\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        templateId: (value: TraceApi.v2.TestCaseTemplateId) => _Result;
        implementation: (value: TraceApi.v2.TestCaseImplementation) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: TraceApi.v2.TestCaseTemplateId): TraceApi.v2.TestCaseImplementationReference.TemplateId => {
        return {
            value: value,
            type: \\"templateId\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationReference.TemplateId,
                visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    implementation: (
        value: TraceApi.v2.TestCaseImplementation
    ): TraceApi.v2.TestCaseImplementationReference.Implementation => {
        return {
            ...value,
            type: \\"implementation\\",
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationReference.Implementation,
                visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.TestCaseImplementationReference._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.TestCaseImplementationReference._Unknown,
                visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.TestCaseImplementationReference,
        visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"templateId\\":
                return visitor.templateId(value.value);
            case \\"implementation\\":
                return visitor.implementation(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                "name": "TestCaseImplementationReference.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseMetadata {
    id: TraceApi.v2.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                                "name": "TestCaseMetadata.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseTemplate {
    templateId: TraceApi.v2.TestCaseTemplateId;
    name: string;
    implementation: TraceApi.v2.TestCaseImplementation;
}
",
                                "name": "TestCaseTemplate.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseTemplateId = string & {
    v2_TestCaseTemplateId: void;
};

export function TestCaseTemplateId(value: string): TraceApi.v2.TestCaseTemplateId {
    return value as unknown as TraceApi.v2.TestCaseTemplateId;
}
",
                                "name": "TestCaseTemplateId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseV2 {
    metadata: TraceApi.v2.TestCaseMetadata;
    implementation: TraceApi.v2.TestCaseImplementationReference;
    arguments: Record<TraceApi.v2.ParameterId, TraceApi.VariableValue | undefined>;
    expects?: TraceApi.v2.TestCaseExpects;
}
",
                                "name": "TestCaseV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: TraceApi.v2.NonVoidFunctionDefinition;
    assertCorrectnessCheck: TraceApi.v2.AssertCorrectnessCheck;
}
",
                                "name": "TestCaseWithActualResultImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionDefinition {
    parameters: TraceApi.v2.Parameter[];
    code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                                "name": "VoidFunctionDefinition.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: TraceApi.v2.Parameter[];
    code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                                "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignature {
    parameters: TraceApi.v2.Parameter[];
}
",
                                "name": "VoidFunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: TraceApi.v2.Parameter[];
    actualResultType: TraceApi.VariableType;
}
",
                                "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "problem",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../environments\\";
import * as core from \\"../../../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    #problem: ProblemClient | undefined;

    public get problem(): ProblemClient {
        return (this.#problem ??= new ProblemClient(this.options));
    }
}
",
                                "name": "Client.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export {};
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "client",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": Array [
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../../../environments\\";
import * as core from \\"../../../../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../../../serialization\\";

export declare namespace Client {
    interface Options {
        environment?: environments.TraceApiEnvironment | string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Returns lightweight versions of all problems
     */
    public async getLightweightProblems(): Promise<
        core.APIResponse<TraceApi.v2.v3.LightweightProblemInfoV2[], TraceApi.v2.v3.problem.getLightweightProblems.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/problems-v2/lightweight-problem-info\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.v3.problem.getLightweightProblems.Response.parseOrThrow(
                    _response.body as serializers.v2.v3.problem.getLightweightProblems.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.v3.problem.getLightweightProblems.Error._unknown(_response.error),
        };
    }

    /**
     * Returns latest versions of all problems
     */
    public async getProblems(): Promise<
        core.APIResponse<TraceApi.v2.v3.ProblemInfoV2[], TraceApi.v2.v3.problem.getProblems.Error>
    > {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \\"/problems-v2/problem-info\\"
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.v3.problem.getProblems.Response.parseOrThrow(
                    _response.body as serializers.v2.v3.problem.getProblems.Response.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.v3.problem.getProblems.Error._unknown(_response.error),
        };
    }

    /**
     * Returns latest version of a problem
     */
    public async getLatestProblem(
        problemId: TraceApi.ProblemId
    ): Promise<core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getLatestProblem.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problems-v2/problem-info/\${await serializers.ProblemId.jsonOrThrow(problemId)}\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.v3.ProblemInfoV2.parseOrThrow(
                    _response.body as serializers.v2.v3.ProblemInfoV2.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.v3.problem.getLatestProblem.Error._unknown(_response.error),
        };
    }

    /**
     * Returns requested version of a problem
     */
    public async getProblemVersion(
        problemId: TraceApi.ProblemId,
        problemVersion: number
    ): Promise<core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getProblemVersion.Error>> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.TraceApiEnvironment.Prod,
                \`/problems-v2/problem-info/\${await serializers.ProblemId.jsonOrThrow(
                    problemId
                )}/version/\${problemVersion}\`
            ),
            method: \\"GET\\",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            withCredentials: true,
        });
        if (_response.ok) {
            return {
                ok: true,
                body: await serializers.v2.v3.ProblemInfoV2.parseOrThrow(
                    _response.body as serializers.v2.v3.ProblemInfoV2.Raw,
                    { allowUnknownKeys: true }
                ),
            };
        }

        return {
            ok: false,
            error: TraceApi.v2.v3.problem.getProblemVersion.Error._unknown(_response.error),
        };
    }
}
",
                                        "name": "Client.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export type Error = TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown,
                visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.problem.getLatestProblem.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.problem.getLatestProblem.Error,
        visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "getLatestProblem.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export type Error = TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown,
                visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.problem.getLightweightProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.problem.getLightweightProblems.Error,
        visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "getLightweightProblems.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export type Error = TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown,
                visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.problem.getProblemVersion.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.problem.getProblemVersion.Error,
        visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "getProblemVersion.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export type Error = TraceApi.v2.v3.problem.getProblems.Error._Unknown;

export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}

export const Error = {
    _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblems.Error._Unknown => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function <_Result>(
                this: TraceApi.v2.v3.problem.getProblems.Error._Unknown,
                visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.problem.getProblems.Error._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.problem.getProblems.Error,
        visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>
    ): _Result => {
        switch (value.errorName) {
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "getProblems.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                        "name": "index.ts",
                                        "type": "file",
                                      },
                                    ],
                                    "name": "client",
                                    "type": "directory",
                                  },
                                  Object {
                                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": Array [
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type AssertCorrectnessCheck =
    | TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality
    | TraceApi.v2.v3.AssertCorrectnessCheck.Custom
    | TraceApi.v2.v3.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends TraceApi.v2.v3.DeepEqualityCorrectnessCheck, _Utils {
        type: \\"deepEquality\\";
    }

    interface Custom extends TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        deepEquality: (value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck) => _Result;
        custom: (value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (
        value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck
    ): TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality => {
        return {
            ...value,
            type: \\"deepEquality\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality,
                visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    custom: (
        value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
    ): TraceApi.v2.v3.AssertCorrectnessCheck.Custom => {
        return {
            ...value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.AssertCorrectnessCheck.Custom,
                visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.AssertCorrectnessCheck._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.AssertCorrectnessCheck._Unknown,
                visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.AssertCorrectnessCheck,
        visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"deepEquality\\":
                return visitor.deepEquality(value);
            case \\"custom\\":
                return visitor.custom(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "AssertCorrectnessCheck.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: TraceApi.v2.v3.NonVoidFunctionSignature;
    additionalFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>;
    basicTestCaseTemplate: TraceApi.v2.v3.BasicTestCaseTemplate;
}
",
                                        "name": "BasicCustomFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicTestCaseTemplate {
    templateId: TraceApi.v2.v3.TestCaseTemplateId;
    name: string;
    description: TraceApi.v2.v3.TestCaseImplementationDescription;
    expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                        "name": "BasicTestCaseTemplate.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: TraceApi.ProblemDescription;
    customFiles: TraceApi.v2.v3.CustomFiles;
    customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
    testcases: TraceApi.v2.v3.TestCaseV2[];
    supportedLanguages: TraceApi.Language[];
    isPublic: boolean;
}
",
                                        "name": "CreateProblemRequestV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type CustomFiles =
    | TraceApi.v2.v3.CustomFiles.Basic
    | TraceApi.v2.v3.CustomFiles.Custom
    | TraceApi.v2.v3.CustomFiles._Unknown;

export declare namespace CustomFiles {
    interface Basic extends TraceApi.v2.v3.BasicCustomFiles, _Utils {
        type: \\"basic\\";
    }

    interface Custom extends _Utils {
        type: \\"custom\\";
        value: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        basic: (value: TraceApi.v2.v3.BasicCustomFiles) => _Result;
        custom: (value: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const CustomFiles = {
    basic: (value: TraceApi.v2.v3.BasicCustomFiles): TraceApi.v2.v3.CustomFiles.Basic => {
        return {
            ...value,
            type: \\"basic\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.CustomFiles.Basic,
                visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
            },
        };
    },

    custom: (value: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>): TraceApi.v2.v3.CustomFiles.Custom => {
        return {
            value: value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.CustomFiles.Custom,
                visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.CustomFiles._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.CustomFiles._Unknown,
                visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.CustomFiles,
        visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"basic\\":
                return visitor.basic(value);
            case \\"custom\\":
                return visitor.custom(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "CustomFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                        "name": "DeepEqualityCorrectnessCheck.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DefaultProvidedFile {
    file: TraceApi.v2.v3.FileInfoV2;
    relatedTypes: TraceApi.VariableType[];
}
",
                                        "name": "DefaultProvidedFile.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                                        "name": "FileInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Files {
    files: TraceApi.v2.v3.FileInfoV2[];
}
",
                                        "name": "Files.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                                        "name": "FunctionImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<TraceApi.Language, TraceApi.v2.v3.FunctionImplementation | undefined>;
}
",
                                        "name": "FunctionImplementationForMultipleLanguages.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type FunctionSignature =
    | TraceApi.v2.v3.FunctionSignature.Void
    | TraceApi.v2.v3.FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult
    | TraceApi.v2.v3.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
    interface Void extends TraceApi.v2.v3.VoidFunctionSignature, _Utils {
        type: \\"void\\";
    }

    interface NonVoid extends TraceApi.v2.v3.NonVoidFunctionSignature, _Utils {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult, _Utils {
        type: \\"voidThatTakesActualResult\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        void: (value: TraceApi.v2.v3.VoidFunctionSignature) => _Result;
        nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature) => _Result;
        voidThatTakesActualResult: (value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const FunctionSignature = {
    void: (value: TraceApi.v2.v3.VoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.Void => {
        return {
            ...value,
            type: \\"void\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.FunctionSignature.Void,
                visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
            },
        };
    },

    nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.NonVoid => {
        return {
            ...value,
            type: \\"nonVoid\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.FunctionSignature.NonVoid,
                visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
            },
        };
    },

    voidThatTakesActualResult: (
        value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
    ): TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult => {
        return {
            ...value,
            type: \\"voidThatTakesActualResult\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult,
                visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.FunctionSignature._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.FunctionSignature._Unknown,
                visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.FunctionSignature,
        visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"void\\":
                return visitor.void(value);
            case \\"nonVoid\\":
                return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\":
                return visitor.voidThatTakesActualResult(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "FunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>;
    generatedTemplateFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>;
    other: Record<TraceApi.Language, TraceApi.v2.v3.Files | undefined>;
}
",
                                        "name": "GeneratedFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: TraceApi.v2.v3.NonVoidFunctionSignature;
}
",
                                        "name": "GetBasicSolutionFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<TraceApi.Language, TraceApi.v2.v3.FileInfoV2 | undefined>;
}
",
                                        "name": "GetBasicSolutionFileResponse.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureRequest {
    functionSignature: TraceApi.v2.v3.FunctionSignature;
}
",
                                        "name": "GetFunctionSignatureRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<TraceApi.Language, string | undefined>;
}
",
                                        "name": "GetFunctionSignatureResponse.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: TraceApi.v2.v3.TestCaseTemplate;
    testCase: TraceApi.v2.v3.TestCaseV2;
}
",
                                        "name": "GetGeneratedTestCaseFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: TraceApi.v2.v3.TestCaseTemplate;
}
",
                                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface LightweightProblemInfoV2 {
    problemId: TraceApi.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: TraceApi.VariableType[];
}
",
                                        "name": "LightweightProblemInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionDefinition {
    signature: TraceApi.v2.v3.NonVoidFunctionSignature;
    code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                        "name": "NonVoidFunctionDefinition.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionSignature {
    parameters: TraceApi.v2.v3.Parameter[];
    returnType: TraceApi.VariableType;
}
",
                                        "name": "NonVoidFunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Parameter {
    parameterId: TraceApi.v2.v3.ParameterId;
    name: string;
    variableType: TraceApi.VariableType;
}
",
                                        "name": "Parameter.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ParameterId = string & {
    v2_v3_ParameterId: void;
};

export function ParameterId(value: string): TraceApi.v2.v3.ParameterId {
    return value as unknown as TraceApi.v2.v3.ParameterId;
}
",
                                        "name": "ParameterId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfoV2 {
    problemId: TraceApi.ProblemId;
    problemDescription: TraceApi.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: TraceApi.Language[];
    customFiles: TraceApi.v2.v3.CustomFiles;
    generatedFiles: TraceApi.v2.v3.GeneratedFiles;
    customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
    testcases: TraceApi.v2.v3.TestCaseV2[];
    isPublic: boolean;
}
",
                                        "name": "ProblemInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                                        "name": "TestCaseExpects.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseFunction =
    | TraceApi.v2.v3.TestCaseFunction.WithActualResult
    | TraceApi.v2.v3.TestCaseFunction.Custom
    | TraceApi.v2.v3.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
    interface WithActualResult extends TraceApi.v2.v3.TestCaseWithActualResultImplementation, _Utils {
        type: \\"withActualResult\\";
    }

    interface Custom extends TraceApi.v2.v3.VoidFunctionDefinition, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        withActualResult: (value: TraceApi.v2.v3.TestCaseWithActualResultImplementation) => _Result;
        custom: (value: TraceApi.v2.v3.VoidFunctionDefinition) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (
        value: TraceApi.v2.v3.TestCaseWithActualResultImplementation
    ): TraceApi.v2.v3.TestCaseFunction.WithActualResult => {
        return {
            ...value,
            type: \\"withActualResult\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseFunction.WithActualResult,
                visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    custom: (value: TraceApi.v2.v3.VoidFunctionDefinition): TraceApi.v2.v3.TestCaseFunction.Custom => {
        return {
            ...value,
            type: \\"custom\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseFunction.Custom,
                visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseFunction._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseFunction._Unknown,
                visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.TestCaseFunction,
        visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"withActualResult\\":
                return visitor.withActualResult(value);
            case \\"custom\\":
                return visitor.custom(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "TestCaseFunction.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseId = string & {
    v2_v3_TestCaseId: void;
};

export function TestCaseId(value: string): TraceApi.v2.v3.TestCaseId {
    return value as unknown as TraceApi.v2.v3.TestCaseId;
}
",
                                        "name": "TestCaseId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementation {
    description: TraceApi.v2.v3.TestCaseImplementationDescription;
    function: TraceApi.v2.v3.TestCaseFunction;
}
",
                                        "name": "TestCaseImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementationDescription {
    boards: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard[];
}
",
                                        "name": "TestCaseImplementationDescription.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseImplementationDescriptionBoard =
    | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html
    | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId
    | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface ParamId extends _Utils {
        type: \\"paramId\\";
        value: TraceApi.v2.v3.ParameterId;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        html: (value: string) => _Result;
        paramId: (value: TraceApi.v2.v3.ParameterId) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html => {
        return {
            value: value,
            type: \\"html\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html,
                visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    paramId: (value: TraceApi.v2.v3.ParameterId): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId => {
        return {
            value: value,
            type: \\"paramId\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId,
                visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown,
                visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard,
        visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"html\\":
                return visitor.html(value.value);
            case \\"paramId\\":
                return visitor.paramId(value.value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "TestCaseImplementationDescriptionBoard.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseImplementationReference =
    | TraceApi.v2.v3.TestCaseImplementationReference.TemplateId
    | TraceApi.v2.v3.TestCaseImplementationReference.Implementation
    | TraceApi.v2.v3.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
    interface TemplateId extends _Utils {
        type: \\"templateId\\";
        value: TraceApi.v2.v3.TestCaseTemplateId;
    }

    interface Implementation extends TraceApi.v2.v3.TestCaseImplementation, _Utils {
        type: \\"implementation\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) => _Result;
    }

    interface _Visitor<_Result> {
        templateId: (value: TraceApi.v2.v3.TestCaseTemplateId) => _Result;
        implementation: (value: TraceApi.v2.v3.TestCaseImplementation) => _Result;
        _other: (value: { type: string }) => _Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (
        value: TraceApi.v2.v3.TestCaseTemplateId
    ): TraceApi.v2.v3.TestCaseImplementationReference.TemplateId => {
        return {
            value: value,
            type: \\"templateId\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationReference.TemplateId,
                visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    implementation: (
        value: TraceApi.v2.v3.TestCaseImplementation
    ): TraceApi.v2.v3.TestCaseImplementationReference.Implementation => {
        return {
            ...value,
            type: \\"implementation\\",
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationReference.Implementation,
                visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseImplementationReference._Unknown => {
        return {
            ...(value as any),
            _visit: function <_Result>(
                this: TraceApi.v2.v3.TestCaseImplementationReference._Unknown,
                visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
            ) {
                return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
            },
        };
    },

    _visit: <_Result>(
        value: TraceApi.v2.v3.TestCaseImplementationReference,
        visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
    ): _Result => {
        switch (value.type) {
            case \\"templateId\\":
                return visitor.templateId(value.value);
            case \\"implementation\\":
                return visitor.implementation(value);
            default:
                return visitor._other(value as any);
        }
    },
} as const;
",
                                        "name": "TestCaseImplementationReference.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseMetadata {
    id: TraceApi.v2.v3.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                                        "name": "TestCaseMetadata.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseTemplate {
    templateId: TraceApi.v2.v3.TestCaseTemplateId;
    name: string;
    implementation: TraceApi.v2.v3.TestCaseImplementation;
}
",
                                        "name": "TestCaseTemplate.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseTemplateId = string & {
    v2_v3_TestCaseTemplateId: void;
};

export function TestCaseTemplateId(value: string): TraceApi.v2.v3.TestCaseTemplateId {
    return value as unknown as TraceApi.v2.v3.TestCaseTemplateId;
}
",
                                        "name": "TestCaseTemplateId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseV2 {
    metadata: TraceApi.v2.v3.TestCaseMetadata;
    implementation: TraceApi.v2.v3.TestCaseImplementationReference;
    arguments: Record<TraceApi.v2.v3.ParameterId, TraceApi.VariableValue | undefined>;
    expects?: TraceApi.v2.v3.TestCaseExpects;
}
",
                                        "name": "TestCaseV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: TraceApi.v2.v3.NonVoidFunctionDefinition;
    assertCorrectnessCheck: TraceApi.v2.v3.AssertCorrectnessCheck;
}
",
                                        "name": "TestCaseWithActualResultImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionDefinition {
    parameters: TraceApi.v2.v3.Parameter[];
    code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                        "name": "VoidFunctionDefinition.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: TraceApi.v2.v3.Parameter[];
    code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignature {
    parameters: TraceApi.v2.v3.Parameter[];
}
",
                                        "name": "VoidFunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: TraceApi.v2.v3.Parameter[];
    actualResultType: TraceApi.VariableType;
}
",
                                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                        "name": "index.ts",
                                        "type": "file",
                                      },
                                    ],
                                    "name": "types",
                                    "type": "directory",
                                  },
                                ],
                                "name": "problem",
                                "type": "directory",
                              },
                            ],
                            "name": "resources",
                            "type": "directory",
                          },
                        ],
                        "name": "v3",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                ],
                "name": "v2",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
    username: string;
    password: string;
}

export const BasicAuth = {
    toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
        if (basicAuth == null) {
            return undefined;
        }
        const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
        return \`Basic \${token}\`;
    },
    fromAuthorizationHeader: (header: string): BasicAuth => {
        const parsed = parse(header);
        if (parsed == null) {
            throw new Error(\\"Invalid basic auth\\");
        }
        return {
            username: parsed.name,
            password: parsed.pass,
        };
    },
};
",
                "name": "BasicAuth.ts",
                "type": "file",
              },
              Object {
                "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
    toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
        if (token == null) {
            return undefined;
        }
        return \`Bearer \${token}\`;
    },
    fromAuthorizationHeader: (header: string): BearerToken => {
        return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
    },
};
",
                "name": "BearerToken.ts",
                "type": "file",
              },
              Object {
                "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "auth",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}

export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
    fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
    export interface Args {
        url: string;
        method: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
    }

    export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

    export interface FailedStatusCodeError {
        reason: \\"status-code\\";
        statusCode: number;
        body: unknown;
    }

    export interface NonJsonError {
        reason: \\"non-json\\";
        statusCode: number;
        rawBody: string;
    }

    export interface TimeoutError {
        reason: \\"timeout\\";
    }

    export interface UnknownError {
        reason: \\"unknown\\";
        errorMessage: string;
    }
}

export const fetcher: FetchFunction = async (args) => {
    const headers: Record<string, string> = {
        \\"Content-Type\\": \\"application/json\\",
    };

    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }

    try {
        const response = await axios({
            url: args.url,
            params: args.queryParameters,
            method: args.method,
            headers,
            data: args.body,
            validateStatus: () => true,
            transformResponse: (response) => response,
            timeout: args.timeoutMs ?? 60_000,
            transitional: {
                clarifyTimeoutError: true,
            },
            withCredentials: args.withCredentials,
        });

        let body: unknown;
        if (response.data != null && response.data.length > 0) {
            try {
                body = JSON.parse(response.data) ?? undefined;
            } catch {
                return {
                    ok: false,
                    error: {
                        reason: \\"non-json\\",
                        statusCode: response.status,
                        rawBody: response.data,
                    },
                };
            }
        }

        if (response.status >= 200 && response.status < 300) {
            return {
                ok: true,
                body,
            };
        } else {
            return {
                ok: false,
                error: {
                    reason: \\"status-code\\",
                    statusCode: response.status,
                    body,
                },
            };
        }
    } catch (error) {
        if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
            return {
                ok: false,
                error: {
                    reason: \\"timeout\\",
                },
            };
        }

        return {
            ok: false,
            error: {
                reason: \\"unknown\\",
                errorMessage: (error as AxiosError).message,
            },
        };
    }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
    get: async <T>(supplier: Supplier<T>): Promise<T> => {
        if (typeof supplier === \\"function\\") {
            return (supplier as () => T)();
        } else {
            return supplier;
        }
    },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as serialization from \\"./schemas\\";
export * from \\"./auth\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}

export const SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    OPTIONAL: \\"optional\\",
} as const;
export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

export type MaybeValid<T> = Valid<T> | Invalid;

export interface Valid<T> {
    ok: true;
    value: T;
}

export interface Invalid {
    ok: false;
    errors: ValidationError[];
}

export interface ValidationError {
    path: string[];
    message: string;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX =
    /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw) => {
            if (typeof raw === \\"string\\" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not an ISO 8601 date string\\",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Date object\\",
                        },
                    ],
                };
            }
        },
        getType: () => SchemaType.DATE,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {
    const validValues = new Set<string>(values);

    const schemaCreator = createIdentitySchemaCreator(SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === \\"string\\" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value as U,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \\"Not one of the allowed values\\",
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
    getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...constructLazyBaseSchema(getter),
        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => SchemaType.LIST,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformArray<Raw, Parsed>(
    value: unknown,
    transformItem: (item: Raw) => MaybePromise<MaybeValid<Parsed>>
): Promise<MaybeValid<Parsed[]>> {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: \\"Not a list\\",
                    path: [],
                },
            ],
        };
    }

    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));

    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(
        (acc, item, index) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(
                    ...item.errors.map((error) => ({
                        path: [\`[\${index}]\`, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        { ok: true, value: [] }
    );
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema, SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export function stringLiteral<V extends string>(literal: V): Schema<V, V> {
    const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to \\"\${literal}\\"\`,
                    },
                ],
            };
        }
    });

    return schemaCreator();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        _getRawProperties: () =>
            Promise.resolve(
                Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
            ),
        _getParsedProperties: () =>
            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

        parse: async (raw, opts) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey: parsedKey as string,
                    valueSchema,
                };

                rawKeyToProperty[rawKey] = property;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(rawKey);
                }
            }

            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        json: async (parsed, opts) => {
            const requiredKeys: string[] = [];

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;

                if ((await valueSchema.getType()) !== \\"optional\\") {
                    requiredKeys.push(parsedKey as string);
                }
            }

            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (
                    parsedKey
                ):
                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }
                    | undefined => {
                    const property = schemas[parsedKey as keyof T];

                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }

                    if (isProperty(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },

        getType: () => SchemaType.OBJECT,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

async function validateAndTransformObject<Transformed>({
    value,
    requiredKeys,
    getProperty,
    allowUnknownKeys,
}: {
    value: unknown;
    requiredKeys: string[];
    getProperty: (
        preTransformedKey: string
    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;
    allowUnknownKeys: boolean;
}): Promise<MaybeValid<Transformed>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const missingRequiredKeys = new Set(requiredKeys);
    const errors: ValidationError[] = [];
    const transformed: Record<string | number | symbol, any> = {};

    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);

        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);

            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                errors.push(
                    ...value.errors.map((error) => ({
                        path: [preTransformedKey, ...error.path],
                        message: error.message,
                    }))
                );
            }
        } else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        } else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key \\"\${preTransformedKey}\\"\`,
            });
        }
    }

    errors.push(
        ...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
                path: [],
                message: \`Missing required key \\"\${key}\\"\`,
            }))
    );

    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed as Transformed,
        };
    } else {
        return {
            ok: false,
            errors,
        };
    }
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => SchemaType.OBJECT,
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}

async function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({
    extensionKeys,
    value,
    transformBase,
    transformExtension,
}: {
    extensionKeys: (keyof PreTransformedExtension)[];
    value: unknown;
    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;
    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;
}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>
        extensionPropertiesSet.has(key as keyof PreTransformedExtension)
    );

    const transformedBase = await transformBase(filterObject(value, baseProperties));
    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));

    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    } else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed> &
    ObjectUtils<Raw, Parsed> &
    SchemaUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }

            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value,
                    };
                },
                {}
            );

            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...(additionalProperties as Properties),
                },
            };
        },

        json: (parsed, opts) => {
            if (!isPlainObject(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }

            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = filterObject(
                parsed,
                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },

        getType: () => objectLike.getType(),
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export { type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const any = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({ ok: true, value }));
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const boolean = createIdentitySchemaCreator<boolean>(SchemaType.BOOLEAN, (value) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a boolean\\",
                },
            ],
        };
    }
});
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const number = createIdentitySchemaCreator<number>(SchemaType.NUMBER, (value) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a number\\",
                },
            ],
        };
    }
});
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const string = createIdentitySchemaCreator<string>(SchemaType.STRING, (value) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \\"Not a string\\",
                },
            ],
        };
    }
});
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { SchemaType } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../../utils/createIdentitySchemaCreator\\";

export const unknown = createIdentitySchemaCreator<unknown>(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
export { type BaseRecordSchema, type RecordSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MaybeValid, Schema, SchemaType, ValidationError } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseRecordSchema, RecordSchema } from \\"./types\\";

export function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {
    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => SchemaType.RECORD,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

async function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({
    value,
    isKeyNumeric,
    transformKey,
    transformValue,
}: {
    value: unknown;
    isKeyNumeric: boolean;
    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;
    transformValue: (value: unknown) => MaybePromise<MaybeValid<TransformedValue>>;
}): Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    return entries(value).reduce<Promise<MaybeValid<OptionalRecord<TransformedKey, TransformedValue>>>>(
        async (accPromise, [stringKey, value]) => {
            // skip nullish keys
            if (value == null) {
                return accPromise;
            }

            const acc = await accPromise;

            let key: string | number = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = await transformKey(key);

            const transformedValue = await transformValue(value);

            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: {
                        ...acc.value,
                        [transformedKey.value]: transformedValue.value,
                    },
                };
            }

            const errors: ValidationError[] = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(
                    ...transformedKey.errors.map((error) => ({
                        path: [\`\${key} (key)\`, ...error.path],
                        message: error.message,
                    }))
                );
            }
            if (!transformedValue.ok) {
                errors.push(
                    ...transformedValue.errors.map((error) => ({
                        path: [stringKey, ...error.path],
                        message: error.message,
                    }))
                );
            }

            return {
                ok: false,
                errors,
            };
        },
        Promise.resolve({ ok: true, value: {} as OptionalRecord<TransformedKey, TransformedValue> })
    );
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema } from \\"../../Schema\\";
import { OptionalRecord } from \\"../../utils/OptionalRecord\\";
import { SchemaUtils } from \\"../schema-utils\\";

export type RecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> &
    SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;

export type BaseRecordSchema<
    RawKey extends string | number,
    RawValue,
    ParsedKey extends string | number,
    ParsedValue
> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class JsonError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
",
                        "name": "JsonError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";
import { stringifyValidationError } from \\"./stringifyValidationErrors\\";

export class ParseError extends Error {
    constructor(public readonly errors: ValidationError[]) {
        super(errors.map(stringifyValidationError).join(\\"; \\"));
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
",
                        "name": "ParseError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaOptions, SchemaType } from \\"../../Schema\\";
import { JsonError } from \\"./JsonError\\";
import { ParseError } from \\"./ParseError\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}

export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError(raw.errors);
        },
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
    schema: BaseSchema<Raw, Parsed>
): Schema<Raw | null | undefined, Parsed | undefined> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => SchemaType.OPTIONAL,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<Raw, Parsed, Transformed>(
    schema: BaseSchema<Raw, Parsed>,
    transformer: SchemaTransformer<Parsed, Transformed>
): Schema<Raw, Transformed> {
    const baseSchema: BaseSchema<Raw, Transformed> = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { ValidationError } from \\"../../Schema\\";

export function stringifyValidationError(error: ValidationError): string {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
",
                        "name": "stringifyValidationErrors.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema, SchemaType } from \\"../../Schema\\";
import { list } from \\"../list\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const listSchema = list(schema);
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            } else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: \\"Not a Set\\",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => SchemaType.SET,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, MaybeValid, SchemaType } from \\"../../Schema\\";
import { isPlainObject, NOT_AN_OBJECT_ERROR_MESSAGE } from \\"../../utils/isPlainObject\\";
import { keys } from \\"../../utils/keys\\";
import { MaybePromise } from \\"../../utils/MaybePromise\\";
import { enum_ } from \\"../enum\\";
import { ObjectSchema } from \\"../object\\";
import { getObjectLikeUtils, ObjectLikeSchema } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const discriminantValueSchema = enum_(keys(union) as string[]);

    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(
                raw,
                rawDiscriminant,
                parsedDiscriminant,
                (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.parse(additionalProperties, opts)
            );
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(
                parsed,
                parsedDiscriminant,
                rawDiscriminant,
                (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts),
                (discriminantValue) => union[discriminantValue],
                opts?.allowUnknownKeys ?? false,
                (additionalProperties, additionalPropertiesSchema) =>
                    additionalPropertiesSchema.json(additionalProperties, opts)
            );
        },
        getType: () => SchemaType.UNION,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}

async function transformAndValidateUnion<
    TransformedDiscriminant extends string,
    TransformedDiscriminantValue extends string,
    TransformedAdditionalProperties
>(
    value: unknown,
    discriminant: string,
    transformedDiscriminant: TransformedDiscriminant,
    transformDiscriminantValue: (discriminantValue: unknown) => MaybePromise<MaybeValid<TransformedDiscriminantValue>>,
    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined,
    allowUnknownKeys: boolean,
    transformAdditionalProperties: (
        additionalProperties: unknown,
        additionalPropertiesSchema: ObjectSchema<any, any>
    ) => MaybePromise<MaybeValid<TransformedAdditionalProperties>>
): Promise<
    MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties>
> {
    if (!isPlainObject(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }

    const { [discriminant]: discriminantValue, ...additionalProperties } = value;

    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                },
            ],
        };
    }

    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }

    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);

    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: \\"Unrecognized discriminant value\\",
                    },
                ],
            };
        }
    }

    const transformedAdditionalProperties = await transformAdditionalProperties(
        additionalProperties,
        additionalPropertiesSchema
    );
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }

    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,
    };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type MaybePromise<T> = T | Promise<T>;
",
                    "name": "MaybePromise.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                    "name": "OptionalRecord.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../builders/schema-utils\\";
import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";

export function createIdentitySchemaCreator<T>(
    schemaType: SchemaType,
    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>
): () => Schema<T, T> {
    return () => {
        const baseSchema: BaseSchema<T, T> = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };

        return {
            ...baseSchema,
            ...getSchemaUtils(baseSchema),
        };
    };
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key as K)) {
            acc[key as K] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export const NOT_AN_OBJECT_ERROR_MESSAGE = \\"Not an object\\";

// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
export function isPlainObject(value: unknown): value is Record<string, unknown> {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }

    if (Object.getPrototypeOf(value) === null) {
        return true;
    }

    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(value) === proto;
}
",
                    "name": "isPlainObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const TraceApiEnvironment = {
    Prod: \\"prod.trace.com\\",
    /**
     * i'm staging
     */
    Staging: \\"staging.trace.com\\",
} as const;

export type TraceApiEnvironment = typeof TraceApiEnvironment.Prod | typeof TraceApiEnvironment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": "export * as TraceApi from \\"./api\\";
export { TraceApiClient } from \\"./Client\\";
export { TraceApiEnvironment } from \\"./environments\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./resources\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const StoreTracedTestCaseRequest: core.serialization.Schema<
    serializers.StoreTracedTestCaseRequest.Raw,
    Omit<TraceApi.StoreTracedTestCaseRequest, \\"someQueryParam\\" | \\"referenceToOptionalString\\">
> = core.serialization.object({
    result: core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).TestCaseResultWithStdout),
    traceResponses: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).TraceResponse)
    ),
});

export declare namespace StoreTracedTestCaseRequest {
    interface Raw {
        result: serializers.TestCaseResultWithStdout.Raw;
        traceResponses: serializers.TraceResponse.Raw[];
    }
}
",
                            "name": "StoreTracedTestCaseRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const StoreTracedWorkspaceRequest: core.serialization.Schema<
    serializers.StoreTracedWorkspaceRequest.Raw,
    TraceApi.StoreTracedWorkspaceRequest
> = core.serialization.object({
    workspaceRunDetails: core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).WorkspaceRunDetails),
    traceResponses: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).TraceResponse)
    ),
});

export declare namespace StoreTracedWorkspaceRequest {
    interface Raw {
        workspaceRunDetails: serializers.WorkspaceRunDetails.Raw;
        traceResponses: serializers.TraceResponse.Raw[];
    }
}
",
                            "name": "StoreTracedWorkspaceRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { StoreTracedTestCaseRequest } from \\"./StoreTracedTestCaseRequest\\";
export { StoreTracedWorkspaceRequest } from \\"./StoreTracedWorkspaceRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Request: core.serialization.Schema<
    serializers.admin.storeTracedTestCaseV2.Request.Raw,
    TraceApi.TraceResponseV2[]
> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TraceResponseV2));

export declare namespace Request {
    type Raw = serializers.TraceResponseV2.Raw[];
}
",
                        "name": "storeTracedTestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Request: core.serialization.Schema<
    serializers.admin.storeTracedWorkspaceV2.Request.Raw,
    TraceApi.TraceResponseV2[]
> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TraceResponseV2));

export declare namespace Request {
    type Raw = serializers.TraceResponseV2.Raw[];
}
",
                        "name": "storeTracedWorkspaceV2.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const OptionalString: core.serialization.Schema<serializers.OptionalString.Raw, TraceApi.OptionalString> =
    core.serialization.string().optional();

export declare namespace OptionalString {
    type Raw = string | null | undefined;
}
",
                        "name": "OptionalString.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./OptionalString\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "admin",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const BinaryTreeNodeAndTreeValue: core.serialization.ObjectSchema<
    serializers.BinaryTreeNodeAndTreeValue.Raw,
    TraceApi.BinaryTreeNodeAndTreeValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    fullTree: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        fullTree: serializers.BinaryTreeValue.Raw;
    }
}
",
                        "name": "BinaryTreeNodeAndTreeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const BinaryTreeNodeValue: core.serialization.ObjectSchema<
    serializers.BinaryTreeNodeValue.Raw,
    TraceApi.BinaryTreeNodeValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    val: core.serialization.number(),
    right: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
    left: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
});

export declare namespace BinaryTreeNodeValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        val: number;
        right?: serializers.NodeId.Raw | null;
        left?: serializers.NodeId.Raw | null;
    }
}
",
                        "name": "BinaryTreeNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const BinaryTreeValue: core.serialization.ObjectSchema<
    serializers.BinaryTreeValue.Raw,
    TraceApi.BinaryTreeValue
> = core.serialization.object({
    root: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
    nodes: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BinaryTreeNodeValue).optional()
    ),
});

export declare namespace BinaryTreeValue {
    interface Raw {
        root?: serializers.NodeId.Raw | null;
        nodes: Record<serializers.NodeId.Raw, serializers.BinaryTreeNodeValue.Raw | null | undefined>;
    }
}
",
                        "name": "BinaryTreeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Date: core.serialization.Schema<serializers.Date.Raw, TraceApi.Date> = core.serialization
    .string()
    .transform({
        transform: TraceApi.Date,
        untransform: (value) => value,
    });

export declare namespace Date {
    type Raw = string;
}
",
                        "name": "Date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DebugKeyValuePairs: core.serialization.ObjectSchema<
    serializers.DebugKeyValuePairs.Raw,
    TraceApi.DebugKeyValuePairs
> = core.serialization.object({
    key: core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue),
    value: core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue),
});

export declare namespace DebugKeyValuePairs {
    interface Raw {
        key: serializers.DebugVariableValue.Raw;
        value: serializers.DebugVariableValue.Raw;
    }
}
",
                        "name": "DebugKeyValuePairs.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DebugMapValue: core.serialization.ObjectSchema<serializers.DebugMapValue.Raw, TraceApi.DebugMapValue> =
    core.serialization.object({
        keyValuePairs: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).DebugKeyValuePairs)
        ),
    });

export declare namespace DebugMapValue {
    interface Raw {
        keyValuePairs: serializers.DebugKeyValuePairs.Raw[];
    }
}
",
                        "name": "DebugMapValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DebugVariableValue: core.serialization.Schema<
    serializers.DebugVariableValue.Raw,
    TraceApi.DebugVariableValue
> = core.serialization
    .union(\\"type\\", {
        integerValue: core.serialization.object({
            value: core.serialization.number(),
        }),
        booleanValue: core.serialization.object({
            value: core.serialization.boolean(),
        }),
        doubleValue: core.serialization.object({
            value: core.serialization.number(),
        }),
        stringValue: core.serialization.object({
            value: core.serialization.string(),
        }),
        charValue: core.serialization.object({
            value: core.serialization.string(),
        }),
        mapValue: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).DebugMapValue),
        listValue: core.serialization.object({
            value: core.serialization.list(
                core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue)
            ),
        }),
        binaryTreeNodeValue: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).BinaryTreeNodeAndTreeValue
        ),
        singlyLinkedListNodeValue: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).SinglyLinkedListNodeAndListValue
        ),
        doublyLinkedListNodeValue: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).DoublyLinkedListNodeAndListValue
        ),
        undefinedValue: core.serialization.object({}),
        nullValue: core.serialization.object({}),
        genericValue: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GenericValue),
    })
    .transform<TraceApi.DebugVariableValue>({
        transform: (value) => {
            switch (value.type) {
                case \\"integerValue\\":
                    return TraceApi.DebugVariableValue.integerValue(value.value);
                case \\"booleanValue\\":
                    return TraceApi.DebugVariableValue.booleanValue(value.value);
                case \\"doubleValue\\":
                    return TraceApi.DebugVariableValue.doubleValue(value.value);
                case \\"stringValue\\":
                    return TraceApi.DebugVariableValue.stringValue(value.value);
                case \\"charValue\\":
                    return TraceApi.DebugVariableValue.charValue(value.value);
                case \\"mapValue\\":
                    return TraceApi.DebugVariableValue.mapValue(value);
                case \\"listValue\\":
                    return TraceApi.DebugVariableValue.listValue(value.value);
                case \\"binaryTreeNodeValue\\":
                    return TraceApi.DebugVariableValue.binaryTreeNodeValue(value);
                case \\"singlyLinkedListNodeValue\\":
                    return TraceApi.DebugVariableValue.singlyLinkedListNodeValue(value);
                case \\"doublyLinkedListNodeValue\\":
                    return TraceApi.DebugVariableValue.doublyLinkedListNodeValue(value);
                case \\"undefinedValue\\":
                    return TraceApi.DebugVariableValue.undefinedValue();
                case \\"nullValue\\":
                    return TraceApi.DebugVariableValue.nullValue();
                case \\"genericValue\\":
                    return TraceApi.DebugVariableValue.genericValue(value);
                default:
                    return TraceApi.DebugVariableValue._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace DebugVariableValue {
    type Raw =
        | DebugVariableValue.IntegerValue
        | DebugVariableValue.BooleanValue
        | DebugVariableValue.DoubleValue
        | DebugVariableValue.StringValue
        | DebugVariableValue.CharValue
        | DebugVariableValue.MapValue
        | DebugVariableValue.ListValue
        | DebugVariableValue.BinaryTreeNodeValue
        | DebugVariableValue.SinglyLinkedListNodeValue
        | DebugVariableValue.DoublyLinkedListNodeValue
        | DebugVariableValue.UndefinedValue
        | DebugVariableValue.NullValue
        | DebugVariableValue.GenericValue;

    interface IntegerValue {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends serializers.DebugMapValue.Raw {
        type: \\"mapValue\\";
    }

    interface ListValue {
        type: \\"listValue\\";
        value: serializers.DebugVariableValue.Raw[];
    }

    interface BinaryTreeNodeValue extends serializers.BinaryTreeNodeAndTreeValue.Raw {
        type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends serializers.SinglyLinkedListNodeAndListValue.Raw {
        type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends serializers.DoublyLinkedListNodeAndListValue.Raw {
        type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        type: \\"undefinedValue\\";
    }

    interface NullValue {
        type: \\"nullValue\\";
    }

    interface GenericValue extends serializers.GenericValue.Raw {
        type: \\"genericValue\\";
    }
}
",
                        "name": "DebugVariableValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DoublyLinkedListNodeAndListValue: core.serialization.ObjectSchema<
    serializers.DoublyLinkedListNodeAndListValue.Raw,
    TraceApi.DoublyLinkedListNodeAndListValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    fullList: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).DoublyLinkedListValue),
});

export declare namespace DoublyLinkedListNodeAndListValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        fullList: serializers.DoublyLinkedListValue.Raw;
    }
}
",
                        "name": "DoublyLinkedListNodeAndListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DoublyLinkedListNodeValue: core.serialization.ObjectSchema<
    serializers.DoublyLinkedListNodeValue.Raw,
    TraceApi.DoublyLinkedListNodeValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    val: core.serialization.number(),
    next: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
    prev: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        val: number;
        next?: serializers.NodeId.Raw | null;
        prev?: serializers.NodeId.Raw | null;
    }
}
",
                        "name": "DoublyLinkedListNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DoublyLinkedListValue: core.serialization.ObjectSchema<
    serializers.DoublyLinkedListValue.Raw,
    TraceApi.DoublyLinkedListValue
> = core.serialization.object({
    head: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
    nodes: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).DoublyLinkedListNodeValue).optional()
    ),
});

export declare namespace DoublyLinkedListValue {
    interface Raw {
        head?: serializers.NodeId.Raw | null;
        nodes: Record<serializers.NodeId.Raw, serializers.DoublyLinkedListNodeValue.Raw | null | undefined>;
    }
}
",
                        "name": "DoublyLinkedListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const FileInfo: core.serialization.ObjectSchema<serializers.FileInfo.Raw, TraceApi.FileInfo> =
    core.serialization.object({
        filename: core.serialization.string(),
        contents: core.serialization.string(),
    });

export declare namespace FileInfo {
    interface Raw {
        filename: string;
        contents: string;
    }
}
",
                        "name": "FileInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GenericValue: core.serialization.ObjectSchema<serializers.GenericValue.Raw, TraceApi.GenericValue> =
    core.serialization.object({
        stringifiedType: core.serialization.string().optional(),
        stringifiedValue: core.serialization.string(),
    });

export declare namespace GenericValue {
    interface Raw {
        stringifiedType?: string | null;
        stringifiedValue: string;
    }
}
",
                        "name": "GenericValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const KeyValuePair: core.serialization.ObjectSchema<serializers.KeyValuePair.Raw, TraceApi.KeyValuePair> =
    core.serialization.object({
        key: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
        value: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
    });

export declare namespace KeyValuePair {
    interface Raw {
        key: serializers.VariableValue.Raw;
        value: serializers.VariableValue.Raw;
    }
}
",
                        "name": "KeyValuePair.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Language: core.serialization.Schema<serializers.Language.Raw, TraceApi.Language> =
    core.serialization.enum_([\\"JAVA\\", \\"JAVASCRIPT\\", \\"PYTHON\\"]);

export declare namespace Language {
    type Raw = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";
}
",
                        "name": "Language.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ListType: core.serialization.ObjectSchema<serializers.ListType.Raw, TraceApi.ListType> =
    core.serialization.object({
        valueType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
        isFixedLength: core.serialization.boolean().optional(),
    });

export declare namespace ListType {
    interface Raw {
        valueType: serializers.VariableType.Raw;
        isFixedLength?: boolean | null;
    }
}
",
                        "name": "ListType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const MapType: core.serialization.ObjectSchema<serializers.MapType.Raw, TraceApi.MapType> =
    core.serialization.object({
        keyType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
        valueType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
    });

export declare namespace MapType {
    interface Raw {
        keyType: serializers.VariableType.Raw;
        valueType: serializers.VariableType.Raw;
    }
}
",
                        "name": "MapType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const MapValue: core.serialization.ObjectSchema<serializers.MapValue.Raw, TraceApi.MapValue> =
    core.serialization.object({
        keyValuePairs: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).KeyValuePair)
        ),
    });

export declare namespace MapValue {
    interface Raw {
        keyValuePairs: serializers.KeyValuePair.Raw[];
    }
}
",
                        "name": "MapValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const NodeId: core.serialization.Schema<serializers.NodeId.Raw, TraceApi.NodeId> = core.serialization
    .string()
    .transform({
        transform: TraceApi.NodeId,
        untransform: (value) => value,
    });

export declare namespace NodeId {
    type Raw = string;
}
",
                        "name": "NodeId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemId: core.serialization.Schema<serializers.ProblemId.Raw, TraceApi.ProblemId> = core.serialization
    .string()
    .transform({
        transform: TraceApi.ProblemId,
        untransform: (value) => value,
    });

export declare namespace ProblemId {
    type Raw = string;
}
",
                        "name": "ProblemId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RandomUnknownType: core.serialization.Schema<
    serializers.RandomUnknownType.Raw,
    TraceApi.RandomUnknownType
> = core.serialization.unknown();

export declare namespace RandomUnknownType {
    type Raw = unknown;
}
",
                        "name": "RandomUnknownType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SinglyLinkedListNodeAndListValue: core.serialization.ObjectSchema<
    serializers.SinglyLinkedListNodeAndListValue.Raw,
    TraceApi.SinglyLinkedListNodeAndListValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    fullList: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SinglyLinkedListValue),
});

export declare namespace SinglyLinkedListNodeAndListValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        fullList: serializers.SinglyLinkedListValue.Raw;
    }
}
",
                        "name": "SinglyLinkedListNodeAndListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SinglyLinkedListNodeValue: core.serialization.ObjectSchema<
    serializers.SinglyLinkedListNodeValue.Raw,
    TraceApi.SinglyLinkedListNodeValue
> = core.serialization.object({
    nodeId: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
    val: core.serialization.number(),
    next: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
    interface Raw {
        nodeId: serializers.NodeId.Raw;
        val: number;
        next?: serializers.NodeId.Raw | null;
    }
}
",
                        "name": "SinglyLinkedListNodeValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SinglyLinkedListValue: core.serialization.ObjectSchema<
    serializers.SinglyLinkedListValue.Raw,
    TraceApi.SinglyLinkedListValue
> = core.serialization.object({
    head: core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId).optional(),
    nodes: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).NodeId),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SinglyLinkedListNodeValue).optional()
    ),
});

export declare namespace SinglyLinkedListValue {
    interface Raw {
        head?: serializers.NodeId.Raw | null;
        nodes: Record<serializers.NodeId.Raw, serializers.SinglyLinkedListNodeValue.Raw | null | undefined>;
    }
}
",
                        "name": "SinglyLinkedListValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCase: core.serialization.ObjectSchema<serializers.TestCase.Raw, TraceApi.TestCase> =
    core.serialization.object({
        id: core.serialization.string(),
        params: core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue)),
    });

export declare namespace TestCase {
    interface Raw {
        id: string;
        params: serializers.VariableValue.Raw[];
    }
}
",
                        "name": "TestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseWithExpectedResult: core.serialization.ObjectSchema<
    serializers.TestCaseWithExpectedResult.Raw,
    TraceApi.TestCaseWithExpectedResult
> = core.serialization.object({
    testCase: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCase),
    expectedResult: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
    interface Raw {
        testCase: serializers.TestCase.Raw;
        expectedResult: serializers.VariableValue.Raw;
    }
}
",
                        "name": "TestCaseWithExpectedResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const UserId: core.serialization.Schema<serializers.UserId.Raw, TraceApi.UserId> = core.serialization
    .string()
    .transform({
        transform: TraceApi.UserId,
        untransform: (value) => value,
    });

export declare namespace UserId {
    type Raw = string;
}
",
                        "name": "UserId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const VariableType: core.serialization.Schema<serializers.VariableType.Raw, TraceApi.VariableType> =
    core.serialization
        .union(\\"type\\", {
            integerType: core.serialization.object({}),
            doubleType: core.serialization.object({}),
            booleanType: core.serialization.object({}),
            stringType: core.serialization.object({}),
            charType: core.serialization.object({}),
            listType: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ListType),
            mapType: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MapType),
            binaryTreeType: core.serialization.object({}),
            singlyLinkedListType: core.serialization.object({}),
            doublyLinkedListType: core.serialization.object({}),
        })
        .transform<TraceApi.VariableType>({
            transform: (value) => {
                switch (value.type) {
                    case \\"integerType\\":
                        return TraceApi.VariableType.integerType();
                    case \\"doubleType\\":
                        return TraceApi.VariableType.doubleType();
                    case \\"booleanType\\":
                        return TraceApi.VariableType.booleanType();
                    case \\"stringType\\":
                        return TraceApi.VariableType.stringType();
                    case \\"charType\\":
                        return TraceApi.VariableType.charType();
                    case \\"listType\\":
                        return TraceApi.VariableType.listType(value);
                    case \\"mapType\\":
                        return TraceApi.VariableType.mapType(value);
                    case \\"binaryTreeType\\":
                        return TraceApi.VariableType.binaryTreeType();
                    case \\"singlyLinkedListType\\":
                        return TraceApi.VariableType.singlyLinkedListType();
                    case \\"doublyLinkedListType\\":
                        return TraceApi.VariableType.doublyLinkedListType();
                    default:
                        return TraceApi.VariableType._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace VariableType {
    type Raw =
        | VariableType.IntegerType
        | VariableType.DoubleType
        | VariableType.BooleanType
        | VariableType.StringType
        | VariableType.CharType
        | VariableType.ListType
        | VariableType.MapType
        | VariableType.BinaryTreeType
        | VariableType.SinglyLinkedListType
        | VariableType.DoublyLinkedListType;

    interface IntegerType {
        type: \\"integerType\\";
    }

    interface DoubleType {
        type: \\"doubleType\\";
    }

    interface BooleanType {
        type: \\"booleanType\\";
    }

    interface StringType {
        type: \\"stringType\\";
    }

    interface CharType {
        type: \\"charType\\";
    }

    interface ListType extends serializers.ListType.Raw {
        type: \\"listType\\";
    }

    interface MapType extends serializers.MapType.Raw {
        type: \\"mapType\\";
    }

    interface BinaryTreeType {
        type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        type: \\"doublyLinkedListType\\";
    }
}
",
                        "name": "VariableType.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const VariableValue: core.serialization.Schema<serializers.VariableValue.Raw, TraceApi.VariableValue> =
    core.serialization
        .union(\\"type\\", {
            integerValue: core.serialization.object({
                value: core.serialization.number(),
            }),
            booleanValue: core.serialization.object({
                value: core.serialization.boolean(),
            }),
            doubleValue: core.serialization.object({
                value: core.serialization.number(),
            }),
            stringValue: core.serialization.object({
                value: core.serialization.string(),
            }),
            charValue: core.serialization.object({
                value: core.serialization.string(),
            }),
            mapValue: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).MapValue),
            listValue: core.serialization.object({
                value: core.serialization.list(
                    core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue)
                ),
            }),
            binaryTreeValue: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BinaryTreeValue),
            singlyLinkedListValue: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).SinglyLinkedListValue
            ),
            doublyLinkedListValue: core.serialization.lazyObject(
                async () => (await import(\\"../../..\\")).DoublyLinkedListValue
            ),
            nullValue: core.serialization.object({}),
        })
        .transform<TraceApi.VariableValue>({
            transform: (value) => {
                switch (value.type) {
                    case \\"integerValue\\":
                        return TraceApi.VariableValue.integerValue(value.value);
                    case \\"booleanValue\\":
                        return TraceApi.VariableValue.booleanValue(value.value);
                    case \\"doubleValue\\":
                        return TraceApi.VariableValue.doubleValue(value.value);
                    case \\"stringValue\\":
                        return TraceApi.VariableValue.stringValue(value.value);
                    case \\"charValue\\":
                        return TraceApi.VariableValue.charValue(value.value);
                    case \\"mapValue\\":
                        return TraceApi.VariableValue.mapValue(value);
                    case \\"listValue\\":
                        return TraceApi.VariableValue.listValue(value.value);
                    case \\"binaryTreeValue\\":
                        return TraceApi.VariableValue.binaryTreeValue(value);
                    case \\"singlyLinkedListValue\\":
                        return TraceApi.VariableValue.singlyLinkedListValue(value);
                    case \\"doublyLinkedListValue\\":
                        return TraceApi.VariableValue.doublyLinkedListValue(value);
                    case \\"nullValue\\":
                        return TraceApi.VariableValue.nullValue();
                    default:
                        return TraceApi.VariableValue._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace VariableValue {
    type Raw =
        | VariableValue.IntegerValue
        | VariableValue.BooleanValue
        | VariableValue.DoubleValue
        | VariableValue.StringValue
        | VariableValue.CharValue
        | VariableValue.MapValue
        | VariableValue.ListValue
        | VariableValue.BinaryTreeValue
        | VariableValue.SinglyLinkedListValue
        | VariableValue.DoublyLinkedListValue
        | VariableValue.NullValue;

    interface IntegerValue {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends serializers.MapValue.Raw {
        type: \\"mapValue\\";
    }

    interface ListValue {
        type: \\"listValue\\";
        value: serializers.VariableValue.Raw[];
    }

    interface BinaryTreeValue extends serializers.BinaryTreeValue.Raw {
        type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends serializers.SinglyLinkedListValue.Raw {
        type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends serializers.DoublyLinkedListValue.Raw {
        type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        type: \\"nullValue\\";
    }
}
",
                        "name": "VariableValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
export * from \\"./RandomUnknownType\\";
export * from \\"./Date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "commons",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.homepage.getHomepageProblems.Response.Raw,
    TraceApi.ProblemId[]
> = core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId));

export declare namespace Response {
    type Raw = serializers.ProblemId.Raw[];
}
",
                        "name": "getHomepageProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Request: core.serialization.Schema<
    serializers.homepage.setHomepageProblems.Request.Raw,
    TraceApi.ProblemId[]
> = core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId));

export declare namespace Request {
    type Raw = serializers.ProblemId.Raw[];
}
",
                        "name": "setHomepageProblems.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "homepage",
                "type": "directory",
              },
              Object {
                "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./admin/client/requests\\";
export * from \\"./problem/client/requests\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const LangServerRequest: core.serialization.ObjectSchema<
    serializers.LangServerRequest.Raw,
    TraceApi.LangServerRequest
> = core.serialization.object({
    request: core.serialization.unknown(),
});

export declare namespace LangServerRequest {
    interface Raw {
        request?: unknown;
    }
}
",
                        "name": "LangServerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const LangServerResponse: core.serialization.ObjectSchema<
    serializers.LangServerResponse.Raw,
    TraceApi.LangServerResponse
> = core.serialization.object({
    response: core.serialization.unknown(),
});

export declare namespace LangServerResponse {
    interface Raw {
        response?: unknown;
    }
}
",
                        "name": "LangServerResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "langServer",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.migration.getAttemptedMigrations.Response.Raw,
    TraceApi.Migration[]
> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Migration));

export declare namespace Response {
    type Raw = serializers.Migration.Raw[];
}
",
                        "name": "getAttemptedMigrations.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Migration: core.serialization.ObjectSchema<serializers.Migration.Raw, TraceApi.Migration> =
    core.serialization.object({
        name: core.serialization.string(),
        status: core.serialization.lazy(async () => (await import(\\"../../..\\")).MigrationStatus),
    });

export declare namespace Migration {
    interface Raw {
        name: string;
        status: serializers.MigrationStatus.Raw;
    }
}
",
                        "name": "Migration.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const MigrationStatus: core.serialization.Schema<serializers.MigrationStatus.Raw, TraceApi.MigrationStatus> =
    core.serialization.enum_([\\"RUNNING\\", \\"FAILED\\", \\"FINISHED\\"]);

export declare namespace MigrationStatus {
    type Raw = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";
}
",
                        "name": "MigrationStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "migration",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Error: core.serialization.Schema<
    serializers.playlist.getPlaylist.Error.Raw,
    TraceApi.playlist.getPlaylist.Error
> = core.serialization
    .union(\\"errorName\\", {
        PlaylistIdNotFoundError: core.serialization.object({
            content: core.serialization.lazy(async () => (await import(\\"../../..\\")).PlaylistIdNotFoundErrorBody),
        }),
        UnauthorizedError: core.serialization.object({}),
    })
    .transform<TraceApi.playlist.getPlaylist.Error>({
        transform: (value) => {
            switch (value.errorName) {
                case \\"PlaylistIdNotFoundError\\":
                    return TraceApi.playlist.getPlaylist.Error.playlistIdNotFoundError(value.content);
                case \\"UnauthorizedError\\":
                    return TraceApi.playlist.getPlaylist.Error.unauthorizedError();
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace Error {
    type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

    interface PlaylistIdNotFoundError {
        errorName: \\"PlaylistIdNotFoundError\\";
        content: serializers.PlaylistIdNotFoundErrorBody.Raw;
    }

    interface UnauthorizedError {
        errorName: \\"UnauthorizedError\\";
    }
}
",
                        "name": "getPlaylist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.playlist.getPlaylists.Response.Raw, TraceApi.Playlist[]> =
    core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Playlist));

export declare namespace Response {
    type Raw = serializers.Playlist.Raw[];
}
",
                        "name": "getPlaylists.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Request: core.serialization.Schema<
    serializers.playlist.updatePlaylist.Request.Raw,
    TraceApi.UpdatePlaylistRequest | undefined
> = core.serialization.lazyObject(async () => (await import(\\"../../..\\")).UpdatePlaylistRequest).optional();

export declare namespace Request {
    type Raw = serializers.UpdatePlaylistRequest.Raw | null | undefined;
}

export const Response: core.serialization.Schema<
    serializers.playlist.updatePlaylist.Response.Raw,
    TraceApi.Playlist | undefined
> = core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Playlist).optional();

export declare namespace Response {
    type Raw = serializers.Playlist.Raw | null | undefined;
}

export const Error: core.serialization.Schema<
    serializers.playlist.updatePlaylist.Error.Raw,
    TraceApi.playlist.updatePlaylist.Error
> = core.serialization
    .union(\\"errorName\\", {
        PlaylistIdNotFoundError: core.serialization.object({
            content: core.serialization.lazy(async () => (await import(\\"../../..\\")).PlaylistIdNotFoundErrorBody),
        }),
    })
    .transform<TraceApi.playlist.updatePlaylist.Error>({
        transform: (value) => {
            switch (value.errorName) {
                case \\"PlaylistIdNotFoundError\\":
                    return TraceApi.playlist.updatePlaylist.Error.playlistIdNotFoundError(value.content);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace Error {
    type Raw = Error.PlaylistIdNotFoundError;

    interface PlaylistIdNotFoundError {
        errorName: \\"PlaylistIdNotFoundError\\";
        content: serializers.PlaylistIdNotFoundErrorBody.Raw;
    }
}
",
                        "name": "updatePlaylist.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Color: core.serialization.Schema<serializers.Color.Raw, TraceApi.Color> = core.serialization.enum_([
    \\"RED\\",
    \\"BLUE\\",
]);

export declare namespace Color {
    type Raw = \\"RED\\" | \\"BLUE\\";
}
",
                        "name": "Color.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const DateUnion: core.serialization.Schema<serializers.DateUnion.Raw, TraceApi.DateUnion> = core.serialization
    .union(\\"type\\", {
        date: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).Date),
        }),
        datetime: core.serialization.object({
            value: core.serialization.date(),
        }),
    })
    .transform<TraceApi.DateUnion>({
        transform: (value) => {
            switch (value.type) {
                case \\"date\\":
                    return TraceApi.DateUnion.date(value.value);
                case \\"datetime\\":
                    return TraceApi.DateUnion.datetime(value.value);
                default:
                    return TraceApi.DateUnion._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace DateUnion {
    type Raw = DateUnion.Date | DateUnion.Datetime;

    interface Date {
        type: \\"date\\";
        value: serializers.Date.Raw;
    }

    interface Datetime {
        type: \\"datetime\\";
        value: string;
    }
}
",
                        "name": "DateUnion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const MapWithEnumKey: core.serialization.Schema<serializers.MapWithEnumKey.Raw, TraceApi.MapWithEnumKey> =
    core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).Color),
        core.serialization.boolean().optional()
    );

export declare namespace MapWithEnumKey {
    type Raw = Record<serializers.Color.Raw, boolean | null | undefined>;
}
",
                        "name": "MapWithEnumKey.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const MapWithEnumKeyAndOptionalValue: core.serialization.Schema<
    serializers.MapWithEnumKeyAndOptionalValue.Raw,
    TraceApi.MapWithEnumKeyAndOptionalValue
> = core.serialization.record(
    core.serialization.lazy(async () => (await import(\\"../../..\\")).Color),
    core.serialization.boolean().optional()
);

export declare namespace MapWithEnumKeyAndOptionalValue {
    type Raw = Record<serializers.Color.Raw, boolean | null | undefined>;
}
",
                        "name": "MapWithEnumKeyAndOptionalValue.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Playlist: core.serialization.ObjectSchema<serializers.Playlist.Raw, TraceApi.Playlist> = core.serialization
    .object({
        playlistId: core.serialization.property(
            \\"playlist_id\\",
            core.serialization.lazy(async () => (await import(\\"../../..\\")).PlaylistId)
        ),
        ownerId: core.serialization.property(
            \\"owner-id\\",
            core.serialization.lazy(async () => (await import(\\"../../..\\")).UserId)
        ),
    })
    .extend(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PlaylistCreateRequest));

export declare namespace Playlist {
    interface Raw extends serializers.PlaylistCreateRequest.Raw {
        playlist_id: serializers.PlaylistId.Raw;
        \\"owner-id\\": serializers.UserId.Raw;
    }
}
",
                        "name": "Playlist.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const PlaylistCreateRequest: core.serialization.ObjectSchema<
    serializers.PlaylistCreateRequest.Raw,
    TraceApi.PlaylistCreateRequest
> = core.serialization.object({
    name: core.serialization.string(),
    problems: core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId)),
});

export declare namespace PlaylistCreateRequest {
    interface Raw {
        name: string;
        problems: serializers.ProblemId.Raw[];
    }
}
",
                        "name": "PlaylistCreateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const PlaylistId: core.serialization.Schema<serializers.PlaylistId.Raw, TraceApi.PlaylistId> =
    core.serialization.number();

export declare namespace PlaylistId {
    type Raw = number;
}
",
                        "name": "PlaylistId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const PlaylistIdNotFoundErrorBody: core.serialization.Schema<
    serializers.PlaylistIdNotFoundErrorBody.Raw,
    TraceApi.PlaylistIdNotFoundErrorBody
> = core.serialization
    .union(\\"type\\", {
        playlistId: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).PlaylistId),
        }),
    })
    .transform<TraceApi.PlaylistIdNotFoundErrorBody>({
        transform: (value) => {
            switch (value.type) {
                case \\"playlistId\\":
                    return TraceApi.PlaylistIdNotFoundErrorBody.playlistId(value.value);
                default:
                    return TraceApi.PlaylistIdNotFoundErrorBody._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace PlaylistIdNotFoundErrorBody {
    type Raw = PlaylistIdNotFoundErrorBody.PlaylistId;

    interface PlaylistId {
        type: \\"playlistId\\";
        value: serializers.PlaylistId.Raw;
    }
}
",
                        "name": "PlaylistIdNotFoundErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ReservedKeywordEnum: core.serialization.Schema<
    serializers.ReservedKeywordEnum.Raw,
    TraceApi.ReservedKeywordEnum
> = core.serialization.enum_([\\"is\\", \\"as\\", \\"date\\"]);

export declare namespace ReservedKeywordEnum {
    type Raw = \\"is\\" | \\"as\\" | \\"date\\";
}
",
                        "name": "ReservedKeywordEnum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const UpdatePlaylistRequest: core.serialization.ObjectSchema<
    serializers.UpdatePlaylistRequest.Raw,
    TraceApi.UpdatePlaylistRequest
> = core.serialization.object({
    name: core.serialization.string(),
    problems: core.serialization.list(core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId)),
});

export declare namespace UpdatePlaylistRequest {
    interface Raw {
        name: string;
        problems: serializers.ProblemId.Raw[];
    }
}
",
                        "name": "UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./DateUnion\\";
export * from \\"./ReservedKeywordEnum\\";
export * from \\"./MapWithEnumKey\\";
export * from \\"./MapWithEnumKeyAndOptionalValue\\";
export * from \\"./Color\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "playlist",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./requests\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetDefaultStarterFilesRequest: core.serialization.Schema<
    serializers.GetDefaultStarterFilesRequest.Raw,
    TraceApi.GetDefaultStarterFilesRequest
> = core.serialization.object({
    inputParams: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../..\\")).VariableTypeAndName)
    ),
    outputType: core.serialization.lazy(async () => (await import(\\"../../../..\\")).VariableType),
    methodName: core.serialization.string(),
});

export declare namespace GetDefaultStarterFilesRequest {
    interface Raw {
        inputParams: serializers.VariableTypeAndName.Raw[];
        outputType: serializers.VariableType.Raw;
        methodName: string;
    }
}
",
                            "name": "GetDefaultStarterFilesRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export { GetDefaultStarterFilesRequest } from \\"./GetDefaultStarterFilesRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "requests",
                        "type": "directory",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CreateProblemError: core.serialization.Schema<
    serializers.CreateProblemError.Raw,
    TraceApi.CreateProblemError
> = core.serialization
    .union(core.serialization.discriminant(\\"errorType\\", \\"_type\\"), {
        generic: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GenericCreateProblemError),
    })
    .transform<TraceApi.CreateProblemError>({
        transform: (value) => {
            switch (value.errorType) {
                case \\"generic\\":
                    return TraceApi.CreateProblemError.generic(value);
                default:
                    return TraceApi.CreateProblemError._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace CreateProblemError {
    type Raw = CreateProblemError.Generic;

    interface Generic extends serializers.GenericCreateProblemError.Raw {
        _type: \\"generic\\";
    }
}
",
                        "name": "CreateProblemError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CreateProblemRequest: core.serialization.ObjectSchema<
    serializers.CreateProblemRequest.Raw,
    TraceApi.CreateProblemRequest
> = core.serialization.object({
    problemName: core.serialization.string(),
    problemDescription: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemDescription),
    files: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemFiles).optional()
    ),
    inputParams: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).VariableTypeAndName)
    ),
    outputType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
    testcases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseWithExpectedResult)
    ),
    methodName: core.serialization.string(),
});

export declare namespace CreateProblemRequest {
    interface Raw {
        problemName: string;
        problemDescription: serializers.ProblemDescription.Raw;
        files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw | null | undefined>;
        inputParams: serializers.VariableTypeAndName.Raw[];
        outputType: serializers.VariableType.Raw;
        testcases: serializers.TestCaseWithExpectedResult.Raw[];
        methodName: string;
    }
}
",
                        "name": "CreateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CreateProblemResponse: core.serialization.Schema<
    serializers.CreateProblemResponse.Raw,
    TraceApi.CreateProblemResponse
> = core.serialization
    .union(\\"type\\", {
        success: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
        }),
        error: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).CreateProblemError),
        }),
    })
    .transform<TraceApi.CreateProblemResponse>({
        transform: (value) => {
            switch (value.type) {
                case \\"success\\":
                    return TraceApi.CreateProblemResponse.success(value.value);
                case \\"error\\":
                    return TraceApi.CreateProblemResponse.error(value.value);
                default:
                    return TraceApi.CreateProblemResponse._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace CreateProblemResponse {
    type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

    interface Success {
        type: \\"success\\";
        value: serializers.ProblemId.Raw;
    }

    interface Error {
        type: \\"error\\";
        value: serializers.CreateProblemError.Raw;
    }
}
",
                        "name": "CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GenericCreateProblemError: core.serialization.ObjectSchema<
    serializers.GenericCreateProblemError.Raw,
    TraceApi.GenericCreateProblemError
> = core.serialization.object({
    message: core.serialization.string(),
    type: core.serialization.string(),
    stacktrace: core.serialization.string(),
});

export declare namespace GenericCreateProblemError {
    interface Raw {
        message: string;
        type: string;
        stacktrace: string;
    }
}
",
                        "name": "GenericCreateProblemError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GetDefaultStarterFilesResponse: core.serialization.ObjectSchema<
    serializers.GetDefaultStarterFilesResponse.Raw,
    TraceApi.GetDefaultStarterFilesResponse
> = core.serialization.object({
    files: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemFiles).optional()
    ),
});

export declare namespace GetDefaultStarterFilesResponse {
    interface Raw {
        files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw | null | undefined>;
    }
}
",
                        "name": "GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemDescription: core.serialization.ObjectSchema<
    serializers.ProblemDescription.Raw,
    TraceApi.ProblemDescription
> = core.serialization.object({
    boards: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemDescriptionBoard)
    ),
});

export declare namespace ProblemDescription {
    interface Raw {
        boards: serializers.ProblemDescriptionBoard.Raw[];
    }
}
",
                        "name": "ProblemDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemDescriptionBoard: core.serialization.Schema<
    serializers.ProblemDescriptionBoard.Raw,
    TraceApi.ProblemDescriptionBoard
> = core.serialization
    .union(\\"type\\", {
        html: core.serialization.object({
            value: core.serialization.string(),
        }),
        variable: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
        }),
        testCaseId: core.serialization.object({
            value: core.serialization.string(),
        }),
    })
    .transform<TraceApi.ProblemDescriptionBoard>({
        transform: (value) => {
            switch (value.type) {
                case \\"html\\":
                    return TraceApi.ProblemDescriptionBoard.html(value.value);
                case \\"variable\\":
                    return TraceApi.ProblemDescriptionBoard.variable(value.value);
                case \\"testCaseId\\":
                    return TraceApi.ProblemDescriptionBoard.testCaseId(value.value);
                default:
                    return TraceApi.ProblemDescriptionBoard._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace ProblemDescriptionBoard {
    type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

    interface Html {
        type: \\"html\\";
        value: string;
    }

    interface Variable {
        type: \\"variable\\";
        value: serializers.VariableValue.Raw;
    }

    interface TestCaseId {
        type: \\"testCaseId\\";
        value: string;
    }
}
",
                        "name": "ProblemDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemFiles: core.serialization.ObjectSchema<serializers.ProblemFiles.Raw, TraceApi.ProblemFiles> =
    core.serialization.object({
        solutionFile: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FileInfo),
        readOnlyFiles: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FileInfo)
        ),
    });

export declare namespace ProblemFiles {
    interface Raw {
        solutionFile: serializers.FileInfo.Raw;
        readOnlyFiles: serializers.FileInfo.Raw[];
    }
}
",
                        "name": "ProblemFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemInfo: core.serialization.ObjectSchema<serializers.ProblemInfo.Raw, TraceApi.ProblemInfo> =
    core.serialization.object({
        problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
        problemDescription: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemDescription),
        problemName: core.serialization.string(),
        problemVersion: core.serialization.number(),
        files: core.serialization.record(
            core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemFiles).optional()
        ),
        inputParams: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).VariableTypeAndName)
        ),
        outputType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
        testcases: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseWithExpectedResult)
        ),
        methodName: core.serialization.string(),
        supportsCustomTestCases: core.serialization.boolean(),
    });

export declare namespace ProblemInfo {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemDescription: serializers.ProblemDescription.Raw;
        problemName: string;
        problemVersion: number;
        files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw | null | undefined>;
        inputParams: serializers.VariableTypeAndName.Raw[];
        outputType: serializers.VariableType.Raw;
        testcases: serializers.TestCaseWithExpectedResult.Raw[];
        methodName: string;
        supportsCustomTestCases: boolean;
    }
}
",
                        "name": "ProblemInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ProblemsMap: core.serialization.ObjectSchema<serializers.ProblemsMap.Raw, TraceApi.ProblemsMap> =
    core.serialization.object({
        problemsById: core.serialization.record(
            core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ProblemInfo).optional()
        ),
    });

export declare namespace ProblemsMap {
    interface Raw {
        problemsById: Record<serializers.ProblemId.Raw, serializers.ProblemInfo.Raw | null | undefined>;
    }
}
",
                        "name": "ProblemsMap.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const UpdateProblemResponse: core.serialization.ObjectSchema<
    serializers.UpdateProblemResponse.Raw,
    TraceApi.UpdateProblemResponse
> = core.serialization.object({
    problemVersion: core.serialization.number(),
});

export declare namespace UpdateProblemResponse {
    interface Raw {
        problemVersion: number;
    }
}
",
                        "name": "UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const VariableTypeAndName: core.serialization.ObjectSchema<
    serializers.VariableTypeAndName.Raw,
    TraceApi.VariableTypeAndName
> = core.serialization.object({
    variableType: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableType),
    name: core.serialization.string(),
});

export declare namespace VariableTypeAndName {
    interface Raw {
        variableType: serializers.VariableType.Raw;
        name: string;
    }
}
",
                        "name": "VariableTypeAndName.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.submission.getExecutionSession.Response.Raw,
    TraceApi.ExecutionSessionResponse | undefined
> = core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExecutionSessionResponse).optional();

export declare namespace Response {
    type Raw = serializers.ExecutionSessionResponse.Raw | null | undefined;
}
",
                        "name": "getExecutionSession.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ActualResult: core.serialization.Schema<serializers.ActualResult.Raw, TraceApi.ActualResult> =
    core.serialization
        .union(\\"type\\", {
            value: core.serialization.object({
                value: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
            }),
            exception: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExceptionInfo),
            exceptionV2: core.serialization.object({
                value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExceptionV2),
            }),
        })
        .transform<TraceApi.ActualResult>({
            transform: (value) => {
                switch (value.type) {
                    case \\"value\\":
                        return TraceApi.ActualResult.value(value.value);
                    case \\"exception\\":
                        return TraceApi.ActualResult.exception(value);
                    case \\"exceptionV2\\":
                        return TraceApi.ActualResult.exceptionV2(value.value);
                    default:
                        return TraceApi.ActualResult._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace ActualResult {
    type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

    interface Value {
        type: \\"value\\";
        value: serializers.VariableValue.Raw;
    }

    interface Exception extends serializers.ExceptionInfo.Raw {
        type: \\"exception\\";
    }

    interface ExceptionV2 {
        type: \\"exceptionV2\\";
        value: serializers.ExceptionV2.Raw;
    }
}
",
                        "name": "ActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const BuildingExecutorResponse: core.serialization.ObjectSchema<
    serializers.BuildingExecutorResponse.Raw,
    TraceApi.BuildingExecutorResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        status: serializers.ExecutionSessionStatus.Raw;
    }
}
",
                        "name": "BuildingExecutorResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CodeExecutionUpdate: core.serialization.Schema<
    serializers.CodeExecutionUpdate.Raw,
    TraceApi.CodeExecutionUpdate
> = core.serialization
    .union(\\"type\\", {
        buildingExecutor: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).BuildingExecutorResponse
        ),
        running: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RunningResponse),
        errored: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ErroredResponse),
        stopped: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).StoppedResponse),
        graded: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GradedResponse),
        gradedV2: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GradedResponseV2),
        workspaceRan: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceRanResponse),
        recording: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RecordingResponseNotification),
        recorded: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RecordedResponseNotification),
        invalidRequest: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).InvalidRequestResponse),
        finished: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FinishedResponse),
    })
    .transform<TraceApi.CodeExecutionUpdate>({
        transform: (value) => {
            switch (value.type) {
                case \\"buildingExecutor\\":
                    return TraceApi.CodeExecutionUpdate.buildingExecutor(value);
                case \\"running\\":
                    return TraceApi.CodeExecutionUpdate.running(value);
                case \\"errored\\":
                    return TraceApi.CodeExecutionUpdate.errored(value);
                case \\"stopped\\":
                    return TraceApi.CodeExecutionUpdate.stopped(value);
                case \\"graded\\":
                    return TraceApi.CodeExecutionUpdate.graded(value);
                case \\"gradedV2\\":
                    return TraceApi.CodeExecutionUpdate.gradedV2(value);
                case \\"workspaceRan\\":
                    return TraceApi.CodeExecutionUpdate.workspaceRan(value);
                case \\"recording\\":
                    return TraceApi.CodeExecutionUpdate.recording(value);
                case \\"recorded\\":
                    return TraceApi.CodeExecutionUpdate.recorded(value);
                case \\"invalidRequest\\":
                    return TraceApi.CodeExecutionUpdate.invalidRequest(value);
                case \\"finished\\":
                    return TraceApi.CodeExecutionUpdate.finished(value);
                default:
                    return TraceApi.CodeExecutionUpdate._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace CodeExecutionUpdate {
    type Raw =
        | CodeExecutionUpdate.BuildingExecutor
        | CodeExecutionUpdate.Running
        | CodeExecutionUpdate.Errored
        | CodeExecutionUpdate.Stopped
        | CodeExecutionUpdate.Graded
        | CodeExecutionUpdate.GradedV2
        | CodeExecutionUpdate.WorkspaceRan
        | CodeExecutionUpdate.Recording
        | CodeExecutionUpdate.Recorded
        | CodeExecutionUpdate.InvalidRequest
        | CodeExecutionUpdate.Finished;

    interface BuildingExecutor extends serializers.BuildingExecutorResponse.Raw {
        type: \\"buildingExecutor\\";
    }

    interface Running extends serializers.RunningResponse.Raw {
        type: \\"running\\";
    }

    interface Errored extends serializers.ErroredResponse.Raw {
        type: \\"errored\\";
    }

    interface Stopped extends serializers.StoppedResponse.Raw {
        type: \\"stopped\\";
    }

    interface Graded extends serializers.GradedResponse.Raw {
        type: \\"graded\\";
    }

    interface GradedV2 extends serializers.GradedResponseV2.Raw {
        type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends serializers.WorkspaceRanResponse.Raw {
        type: \\"workspaceRan\\";
    }

    interface Recording extends serializers.RecordingResponseNotification.Raw {
        type: \\"recording\\";
    }

    interface Recorded extends serializers.RecordedResponseNotification.Raw {
        type: \\"recorded\\";
    }

    interface InvalidRequest extends serializers.InvalidRequestResponse.Raw {
        type: \\"invalidRequest\\";
    }

    interface Finished extends serializers.FinishedResponse.Raw {
        type: \\"finished\\";
    }
}
",
                        "name": "CodeExecutionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CompileError: core.serialization.ObjectSchema<serializers.CompileError.Raw, TraceApi.CompileError> =
    core.serialization.object({
        message: core.serialization.string(),
    });

export declare namespace CompileError {
    interface Raw {
        message: string;
    }
}
",
                        "name": "CompileError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const CustomTestCasesUnsupported: core.serialization.ObjectSchema<
    serializers.CustomTestCasesUnsupported.Raw,
    TraceApi.CustomTestCasesUnsupported
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        submissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "CustomTestCasesUnsupported.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ErrorInfo: core.serialization.Schema<serializers.ErrorInfo.Raw, TraceApi.ErrorInfo> = core.serialization
    .union(\\"type\\", {
        compileError: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).CompileError),
        runtimeError: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RuntimeError),
        internalError: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).InternalError),
    })
    .transform<TraceApi.ErrorInfo>({
        transform: (value) => {
            switch (value.type) {
                case \\"compileError\\":
                    return TraceApi.ErrorInfo.compileError(value);
                case \\"runtimeError\\":
                    return TraceApi.ErrorInfo.runtimeError(value);
                case \\"internalError\\":
                    return TraceApi.ErrorInfo.internalError(value);
                default:
                    return TraceApi.ErrorInfo._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace ErrorInfo {
    type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

    interface CompileError extends serializers.CompileError.Raw {
        type: \\"compileError\\";
    }

    interface RuntimeError extends serializers.RuntimeError.Raw {
        type: \\"runtimeError\\";
    }

    interface InternalError extends serializers.InternalError.Raw {
        type: \\"internalError\\";
    }
}
",
                        "name": "ErrorInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ErroredResponse: core.serialization.ObjectSchema<
    serializers.ErroredResponse.Raw,
    TraceApi.ErroredResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    errorInfo: core.serialization.lazy(async () => (await import(\\"../../..\\")).ErrorInfo),
});

export declare namespace ErroredResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        errorInfo: serializers.ErrorInfo.Raw;
    }
}
",
                        "name": "ErroredResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExceptionInfo: core.serialization.ObjectSchema<serializers.ExceptionInfo.Raw, TraceApi.ExceptionInfo> =
    core.serialization.object({
        exceptionType: core.serialization.string(),
        exceptionMessage: core.serialization.string(),
        exceptionStacktrace: core.serialization.string(),
    });

export declare namespace ExceptionInfo {
    interface Raw {
        exceptionType: string;
        exceptionMessage: string;
        exceptionStacktrace: string;
    }
}
",
                        "name": "ExceptionInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExceptionV2: core.serialization.Schema<serializers.ExceptionV2.Raw, TraceApi.ExceptionV2> =
    core.serialization
        .union(\\"type\\", {
            generic: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExceptionInfo),
            timeout: core.serialization.object({}),
        })
        .transform<TraceApi.ExceptionV2>({
            transform: (value) => {
                switch (value.type) {
                    case \\"generic\\":
                        return TraceApi.ExceptionV2.generic(value);
                    case \\"timeout\\":
                        return TraceApi.ExceptionV2.timeout();
                    default:
                        return TraceApi.ExceptionV2._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace ExceptionV2 {
    type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

    interface Generic extends serializers.ExceptionInfo.Raw {
        type: \\"generic\\";
    }

    interface Timeout {
        type: \\"timeout\\";
    }
}
",
                        "name": "ExceptionV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExecutionSessionResponse: core.serialization.ObjectSchema<
    serializers.ExecutionSessionResponse.Raw,
    TraceApi.ExecutionSessionResponse
> = core.serialization.object({
    sessionId: core.serialization.string(),
    executionSessionUrl: core.serialization.string().optional(),
    language: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
    interface Raw {
        sessionId: string;
        executionSessionUrl?: string | null;
        language: serializers.Language.Raw;
        status: serializers.ExecutionSessionStatus.Raw;
    }
}
",
                        "name": "ExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExecutionSessionState: core.serialization.ObjectSchema<
    serializers.ExecutionSessionState.Raw,
    TraceApi.ExecutionSessionState
> = core.serialization.object({
    lastTimeContacted: core.serialization.string().optional(),
    sessionId: core.serialization.string(),
    isWarmInstance: core.serialization.boolean(),
    awsTaskId: core.serialization.string().optional(),
    language: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
    interface Raw {
        lastTimeContacted?: string | null;
        sessionId: string;
        isWarmInstance: boolean;
        awsTaskId?: string | null;
        language: serializers.Language.Raw;
        status: serializers.ExecutionSessionStatus.Raw;
    }
}
",
                        "name": "ExecutionSessionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExecutionSessionStatus: core.serialization.Schema<
    serializers.ExecutionSessionStatus.Raw,
    TraceApi.ExecutionSessionStatus
> = core.serialization.enum_([
    \\"CREATING_CONTAINER\\",
    \\"PROVISIONING_CONTAINER\\",
    \\"PENDING_CONTAINER\\",
    \\"RUNNING_CONTAINER\\",
    \\"LIVE_CONTAINER\\",
    \\"FAILED_TO_LAUNCH\\",
]);

export declare namespace ExecutionSessionStatus {
    type Raw =
        | \\"CREATING_CONTAINER\\"
        | \\"PROVISIONING_CONTAINER\\"
        | \\"PENDING_CONTAINER\\"
        | \\"RUNNING_CONTAINER\\"
        | \\"LIVE_CONTAINER\\"
        | \\"FAILED_TO_LAUNCH\\";
}
",
                        "name": "ExecutionSessionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExistingSubmissionExecuting: core.serialization.ObjectSchema<
    serializers.ExistingSubmissionExecuting.Raw,
    TraceApi.ExistingSubmissionExecuting
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "ExistingSubmissionExecuting.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ExpressionLocation: core.serialization.ObjectSchema<
    serializers.ExpressionLocation.Raw,
    TraceApi.ExpressionLocation
> = core.serialization.object({
    start: core.serialization.number(),
    offset: core.serialization.number(),
});

export declare namespace ExpressionLocation {
    interface Raw {
        start: number;
        offset: number;
    }
}
",
                        "name": "ExpressionLocation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const FinishedResponse: core.serialization.ObjectSchema<
    serializers.FinishedResponse.Raw,
    TraceApi.FinishedResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
});

export declare namespace FinishedResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "FinishedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GetExecutionSessionStateResponse: core.serialization.ObjectSchema<
    serializers.GetExecutionSessionStateResponse.Raw,
    TraceApi.GetExecutionSessionStateResponse
> = core.serialization.object({
    states: core.serialization.record(
        core.serialization.string(),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExecutionSessionState).optional()
    ),
    numWarmingInstances: core.serialization.number().optional(),
    warmingSessionIds: core.serialization.list(core.serialization.string()),
});

export declare namespace GetExecutionSessionStateResponse {
    interface Raw {
        states: Record<string, serializers.ExecutionSessionState.Raw | null | undefined>;
        numWarmingInstances?: number | null;
        warmingSessionIds: string[];
    }
}
",
                        "name": "GetExecutionSessionStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GetSubmissionStateResponse: core.serialization.ObjectSchema<
    serializers.GetSubmissionStateResponse.Raw,
    TraceApi.GetSubmissionStateResponse
> = core.serialization.object({
    timeSubmitted: core.serialization.date().optional(),
    submission: core.serialization.string(),
    language: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    submissionTypeState: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionTypeState),
});

export declare namespace GetSubmissionStateResponse {
    interface Raw {
        timeSubmitted?: string | null;
        submission: string;
        language: serializers.Language.Raw;
        submissionTypeState: serializers.SubmissionTypeState.Raw;
    }
}
",
                        "name": "GetSubmissionStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GetTraceResponsesPageRequest: core.serialization.ObjectSchema<
    serializers.GetTraceResponsesPageRequest.Raw,
    TraceApi.GetTraceResponsesPageRequest
> = core.serialization.object({
    offset: core.serialization.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
    interface Raw {
        offset?: number | null;
    }
}
",
                        "name": "GetTraceResponsesPageRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GradedResponse: core.serialization.ObjectSchema<serializers.GradedResponse.Raw, TraceApi.GradedResponse> =
    core.serialization.object({
        submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
        testCases: core.serialization.record(
            core.serialization.string(),
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseResultWithStdout).optional()
        ),
    });

export declare namespace GradedResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        testCases: Record<string, serializers.TestCaseResultWithStdout.Raw | null | undefined>;
    }
}
",
                        "name": "GradedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GradedResponseV2: core.serialization.ObjectSchema<
    serializers.GradedResponseV2.Raw,
    TraceApi.GradedResponseV2
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    testCases: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).v2.TestCaseId),
        core.serialization.lazy(async () => (await import(\\"../../..\\")).TestCaseGrade).optional()
    ),
});

export declare namespace GradedResponseV2 {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        testCases: Record<serializers.v2.TestCaseId.Raw, serializers.TestCaseGrade.Raw | null | undefined>;
    }
}
",
                        "name": "GradedResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const GradedTestCaseUpdate: core.serialization.ObjectSchema<
    serializers.GradedTestCaseUpdate.Raw,
    TraceApi.GradedTestCaseUpdate
> = core.serialization.object({
    testCaseId: core.serialization.lazy(async () => (await import(\\"../../..\\")).v2.TestCaseId),
    grade: core.serialization.lazy(async () => (await import(\\"../../..\\")).TestCaseGrade),
});

export declare namespace GradedTestCaseUpdate {
    interface Raw {
        testCaseId: serializers.v2.TestCaseId.Raw;
        grade: serializers.TestCaseGrade.Raw;
    }
}
",
                        "name": "GradedTestCaseUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const InitializeProblemRequest: core.serialization.ObjectSchema<
    serializers.InitializeProblemRequest.Raw,
    TraceApi.InitializeProblemRequest
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
    problemVersion: core.serialization.number().optional(),
});

export declare namespace InitializeProblemRequest {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemVersion?: number | null;
    }
}
",
                        "name": "InitializeProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const InternalError: core.serialization.ObjectSchema<serializers.InternalError.Raw, TraceApi.InternalError> =
    core.serialization.object({
        exceptionInfo: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExceptionInfo),
    });

export declare namespace InternalError {
    interface Raw {
        exceptionInfo: serializers.ExceptionInfo.Raw;
    }
}
",
                        "name": "InternalError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const InvalidRequestCause: core.serialization.Schema<
    serializers.InvalidRequestCause.Raw,
    TraceApi.InvalidRequestCause
> = core.serialization
    .union(\\"type\\", {
        submissionIdNotFound: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).SubmissionIdNotFound
        ),
        customTestCasesUnsupported: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).CustomTestCasesUnsupported
        ),
        unexpectedLanguage: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).UnexpectedLanguageError
        ),
    })
    .transform<TraceApi.InvalidRequestCause>({
        transform: (value) => {
            switch (value.type) {
                case \\"submissionIdNotFound\\":
                    return TraceApi.InvalidRequestCause.submissionIdNotFound(value);
                case \\"customTestCasesUnsupported\\":
                    return TraceApi.InvalidRequestCause.customTestCasesUnsupported(value);
                case \\"unexpectedLanguage\\":
                    return TraceApi.InvalidRequestCause.unexpectedLanguage(value);
                default:
                    return TraceApi.InvalidRequestCause._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace InvalidRequestCause {
    type Raw =
        | InvalidRequestCause.SubmissionIdNotFound
        | InvalidRequestCause.CustomTestCasesUnsupported
        | InvalidRequestCause.UnexpectedLanguage;

    interface SubmissionIdNotFound extends serializers.SubmissionIdNotFound.Raw {
        type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends serializers.CustomTestCasesUnsupported.Raw {
        type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends serializers.UnexpectedLanguageError.Raw {
        type: \\"unexpectedLanguage\\";
    }
}
",
                        "name": "InvalidRequestCause.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const InvalidRequestResponse: core.serialization.ObjectSchema<
    serializers.InvalidRequestResponse.Raw,
    TraceApi.InvalidRequestResponse
> = core.serialization.object({
    request: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionRequest),
    cause: core.serialization.lazy(async () => (await import(\\"../../..\\")).InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
    interface Raw {
        request: serializers.SubmissionRequest.Raw;
        cause: serializers.InvalidRequestCause.Raw;
    }
}
",
                        "name": "InvalidRequestResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const LightweightStackframeInformation: core.serialization.ObjectSchema<
    serializers.LightweightStackframeInformation.Raw,
    TraceApi.LightweightStackframeInformation
> = core.serialization.object({
    numStackFrames: core.serialization.number(),
    topStackFrameMethodName: core.serialization.string(),
});

export declare namespace LightweightStackframeInformation {
    interface Raw {
        numStackFrames: number;
        topStackFrameMethodName: string;
    }
}
",
                        "name": "LightweightStackframeInformation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RecordedResponseNotification: core.serialization.ObjectSchema<
    serializers.RecordedResponseNotification.Raw,
    TraceApi.RecordedResponseNotification
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    traceResponsesSize: core.serialization.number(),
    testCaseId: core.serialization.string().optional(),
});

export declare namespace RecordedResponseNotification {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        traceResponsesSize: number;
        testCaseId?: string | null;
    }
}
",
                        "name": "RecordedResponseNotification.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RecordedTestCaseUpdate: core.serialization.ObjectSchema<
    serializers.RecordedTestCaseUpdate.Raw,
    TraceApi.RecordedTestCaseUpdate
> = core.serialization.object({
    testCaseId: core.serialization.lazy(async () => (await import(\\"../../..\\")).v2.TestCaseId),
    traceResponsesSize: core.serialization.number(),
});

export declare namespace RecordedTestCaseUpdate {
    interface Raw {
        testCaseId: serializers.v2.TestCaseId.Raw;
        traceResponsesSize: number;
    }
}
",
                        "name": "RecordedTestCaseUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RecordingResponseNotification: core.serialization.ObjectSchema<
    serializers.RecordingResponseNotification.Raw,
    TraceApi.RecordingResponseNotification
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    testCaseId: core.serialization.string().optional(),
    lineNumber: core.serialization.number(),
    lightweightStackInfo: core.serialization.lazyObject(
        async () => (await import(\\"../../..\\")).LightweightStackframeInformation
    ),
    tracedFile: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TracedFile).optional(),
});

export declare namespace RecordingResponseNotification {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        testCaseId?: string | null;
        lineNumber: number;
        lightweightStackInfo: serializers.LightweightStackframeInformation.Raw;
        tracedFile?: serializers.TracedFile.Raw | null;
    }
}
",
                        "name": "RecordingResponseNotification.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RunningResponse: core.serialization.ObjectSchema<
    serializers.RunningResponse.Raw,
    TraceApi.RunningResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    state: core.serialization.lazy(async () => (await import(\\"../../..\\")).RunningSubmissionState),
});

export declare namespace RunningResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        state: serializers.RunningSubmissionState.Raw;
    }
}
",
                        "name": "RunningResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RunningSubmissionState: core.serialization.Schema<
    serializers.RunningSubmissionState.Raw,
    TraceApi.RunningSubmissionState
> = core.serialization.enum_([
    \\"QUEUEING_SUBMISSION\\",
    \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    \\"WRITING_SUBMISSION_TO_FILE\\",
    \\"COMPILING_SUBMISSION\\",
    \\"RUNNING_SUBMISSION\\",
]);

export declare namespace RunningSubmissionState {
    type Raw =
        | \\"QUEUEING_SUBMISSION\\"
        | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
        | \\"WRITING_SUBMISSION_TO_FILE\\"
        | \\"COMPILING_SUBMISSION\\"
        | \\"RUNNING_SUBMISSION\\";
}
",
                        "name": "RunningSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const RuntimeError: core.serialization.ObjectSchema<serializers.RuntimeError.Raw, TraceApi.RuntimeError> =
    core.serialization.object({
        message: core.serialization.string(),
    });

export declare namespace RuntimeError {
    interface Raw {
        message: string;
    }
}
",
                        "name": "RuntimeError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Scope: core.serialization.ObjectSchema<serializers.Scope.Raw, TraceApi.Scope> = core.serialization.object({
    variables: core.serialization.record(
        core.serialization.string(),
        core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue).optional()
    ),
});

export declare namespace Scope {
    interface Raw {
        variables: Record<string, serializers.DebugVariableValue.Raw | null | undefined>;
    }
}
",
                        "name": "Scope.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const ShareId: core.serialization.Schema<serializers.ShareId.Raw, TraceApi.ShareId> = core.serialization
    .string()
    .transform({
        transform: TraceApi.ShareId,
        untransform: (value) => value,
    });

export declare namespace ShareId {
    type Raw = string;
}
",
                        "name": "ShareId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StackFrame: core.serialization.ObjectSchema<serializers.StackFrame.Raw, TraceApi.StackFrame> =
    core.serialization.object({
        methodName: core.serialization.string(),
        lineNumber: core.serialization.number(),
        scopes: core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Scope)),
    });

export declare namespace StackFrame {
    interface Raw {
        methodName: string;
        lineNumber: number;
        scopes: serializers.Scope.Raw[];
    }
}
",
                        "name": "StackFrame.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StackInformation: core.serialization.ObjectSchema<
    serializers.StackInformation.Raw,
    TraceApi.StackInformation
> = core.serialization.object({
    numStackFrames: core.serialization.number(),
    topStackFrame: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).StackFrame).optional(),
});

export declare namespace StackInformation {
    interface Raw {
        numStackFrames: number;
        topStackFrame?: serializers.StackFrame.Raw | null;
    }
}
",
                        "name": "StackInformation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StderrResponse: core.serialization.ObjectSchema<serializers.StderrResponse.Raw, TraceApi.StderrResponse> =
    core.serialization.object({
        submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
        stderr: core.serialization.string(),
    });

export declare namespace StderrResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        stderr: string;
    }
}
",
                        "name": "StderrResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StdoutResponse: core.serialization.ObjectSchema<serializers.StdoutResponse.Raw, TraceApi.StdoutResponse> =
    core.serialization.object({
        submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
        stdout: core.serialization.string(),
    });

export declare namespace StdoutResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        stdout: string;
    }
}
",
                        "name": "StdoutResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StopRequest: core.serialization.ObjectSchema<serializers.StopRequest.Raw, TraceApi.StopRequest> =
    core.serialization.object({
        submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    });

export declare namespace StopRequest {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "StopRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const StoppedResponse: core.serialization.ObjectSchema<
    serializers.StoppedResponse.Raw,
    TraceApi.StoppedResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
});

export declare namespace StoppedResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "StoppedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionFileInfo: core.serialization.ObjectSchema<
    serializers.SubmissionFileInfo.Raw,
    TraceApi.SubmissionFileInfo
> = core.serialization.object({
    directory: core.serialization.string(),
    filename: core.serialization.string(),
    contents: core.serialization.string(),
});

export declare namespace SubmissionFileInfo {
    interface Raw {
        directory: string;
        filename: string;
        contents: string;
    }
}
",
                        "name": "SubmissionFileInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionId: core.serialization.Schema<serializers.SubmissionId.Raw, TraceApi.SubmissionId> =
    core.serialization.string().transform({
        transform: TraceApi.SubmissionId,
        untransform: (value) => value,
    });

export declare namespace SubmissionId {
    type Raw = string;
}
",
                        "name": "SubmissionId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionIdNotFound: core.serialization.ObjectSchema<
    serializers.SubmissionIdNotFound.Raw,
    TraceApi.SubmissionIdNotFound
> = core.serialization.object({
    missingSubmissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
});

export declare namespace SubmissionIdNotFound {
    interface Raw {
        missingSubmissionId: serializers.SubmissionId.Raw;
    }
}
",
                        "name": "SubmissionIdNotFound.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionRequest: core.serialization.Schema<
    serializers.SubmissionRequest.Raw,
    TraceApi.SubmissionRequest
> = core.serialization
    .union(\\"type\\", {
        initializeProblemRequest: core.serialization.lazyObject(
            async () => (await import(\\"../../..\\")).InitializeProblemRequest
        ),
        initializeWorkspaceRequest: core.serialization.object({}),
        submitV2: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SubmitRequestV2),
        workspaceSubmit: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceSubmitRequest),
        stop: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).StopRequest),
    })
    .transform<TraceApi.SubmissionRequest>({
        transform: (value) => {
            switch (value.type) {
                case \\"initializeProblemRequest\\":
                    return TraceApi.SubmissionRequest.initializeProblemRequest(value);
                case \\"initializeWorkspaceRequest\\":
                    return TraceApi.SubmissionRequest.initializeWorkspaceRequest();
                case \\"submitV2\\":
                    return TraceApi.SubmissionRequest.submitV2(value);
                case \\"workspaceSubmit\\":
                    return TraceApi.SubmissionRequest.workspaceSubmit(value);
                case \\"stop\\":
                    return TraceApi.SubmissionRequest.stop(value);
                default:
                    return TraceApi.SubmissionRequest._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace SubmissionRequest {
    type Raw =
        | SubmissionRequest.InitializeProblemRequest
        | SubmissionRequest.InitializeWorkspaceRequest
        | SubmissionRequest.SubmitV2
        | SubmissionRequest.WorkspaceSubmit
        | SubmissionRequest.Stop;

    interface InitializeProblemRequest extends serializers.InitializeProblemRequest.Raw {
        type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends serializers.SubmitRequestV2.Raw {
        type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends serializers.WorkspaceSubmitRequest.Raw {
        type: \\"workspaceSubmit\\";
    }

    interface Stop extends serializers.StopRequest.Raw {
        type: \\"stop\\";
    }
}
",
                        "name": "SubmissionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionResponse: core.serialization.Schema<
    serializers.SubmissionResponse.Raw,
    TraceApi.SubmissionResponse
> = core.serialization
    .union(\\"type\\", {
        serverInitialized: core.serialization.object({}),
        problemInitialized: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
        }),
        workspaceInitialized: core.serialization.object({}),
        serverErrored: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExceptionInfo),
        codeExecutionUpdate: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).CodeExecutionUpdate),
        }),
        terminated: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TerminatedResponse),
    })
    .transform<TraceApi.SubmissionResponse>({
        transform: (value) => {
            switch (value.type) {
                case \\"serverInitialized\\":
                    return TraceApi.SubmissionResponse.serverInitialized();
                case \\"problemInitialized\\":
                    return TraceApi.SubmissionResponse.problemInitialized(value.value);
                case \\"workspaceInitialized\\":
                    return TraceApi.SubmissionResponse.workspaceInitialized();
                case \\"serverErrored\\":
                    return TraceApi.SubmissionResponse.serverErrored(value);
                case \\"codeExecutionUpdate\\":
                    return TraceApi.SubmissionResponse.codeExecutionUpdate(value.value);
                case \\"terminated\\":
                    return TraceApi.SubmissionResponse.terminated(value);
                default:
                    return TraceApi.SubmissionResponse._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace SubmissionResponse {
    type Raw =
        | SubmissionResponse.ServerInitialized
        | SubmissionResponse.ProblemInitialized
        | SubmissionResponse.WorkspaceInitialized
        | SubmissionResponse.ServerErrored
        | SubmissionResponse.CodeExecutionUpdate
        | SubmissionResponse.Terminated;

    interface ServerInitialized {
        type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        type: \\"problemInitialized\\";
        value: serializers.ProblemId.Raw;
    }

    interface WorkspaceInitialized {
        type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends serializers.ExceptionInfo.Raw {
        type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        type: \\"codeExecutionUpdate\\";
        value: serializers.CodeExecutionUpdate.Raw;
    }

    interface Terminated extends serializers.TerminatedResponse.Raw {
        type: \\"terminated\\";
    }
}
",
                        "name": "SubmissionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionStatusForTestCase: core.serialization.Schema<
    serializers.SubmissionStatusForTestCase.Raw,
    TraceApi.SubmissionStatusForTestCase
> = core.serialization
    .union(\\"type\\", {
        graded: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseResultWithStdout),
        gradedV2: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).TestCaseGrade),
        }),
        traced: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TracedTestCase),
    })
    .transform<TraceApi.SubmissionStatusForTestCase>({
        transform: (value) => {
            switch (value.type) {
                case \\"graded\\":
                    return TraceApi.SubmissionStatusForTestCase.graded(value);
                case \\"gradedV2\\":
                    return TraceApi.SubmissionStatusForTestCase.gradedV2(value.value);
                case \\"traced\\":
                    return TraceApi.SubmissionStatusForTestCase.traced(value);
                default:
                    return TraceApi.SubmissionStatusForTestCase._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace SubmissionStatusForTestCase {
    type Raw =
        | SubmissionStatusForTestCase.Graded
        | SubmissionStatusForTestCase.GradedV2
        | SubmissionStatusForTestCase.Traced;

    interface Graded extends serializers.TestCaseResultWithStdout.Raw {
        type: \\"graded\\";
    }

    interface GradedV2 {
        type: \\"gradedV2\\";
        value: serializers.TestCaseGrade.Raw;
    }

    interface Traced extends serializers.TracedTestCase.Raw {
        type: \\"traced\\";
    }
}
",
                        "name": "SubmissionStatusForTestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionStatusV2: core.serialization.Schema<
    serializers.SubmissionStatusV2.Raw,
    TraceApi.SubmissionStatusV2
> = core.serialization
    .union(\\"type\\", {
        test: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestSubmissionStatusV2),
        workspace: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceSubmissionStatusV2),
    })
    .transform<TraceApi.SubmissionStatusV2>({
        transform: (value) => {
            switch (value.type) {
                case \\"test\\":
                    return TraceApi.SubmissionStatusV2.test(value);
                case \\"workspace\\":
                    return TraceApi.SubmissionStatusV2.workspace(value);
                default:
                    return TraceApi.SubmissionStatusV2._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace SubmissionStatusV2 {
    type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

    interface Test extends serializers.TestSubmissionStatusV2.Raw {
        type: \\"test\\";
    }

    interface Workspace extends serializers.WorkspaceSubmissionStatusV2.Raw {
        type: \\"workspace\\";
    }
}
",
                        "name": "SubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionTypeEnum: core.serialization.Schema<
    serializers.SubmissionTypeEnum.Raw,
    TraceApi.SubmissionTypeEnum
> = core.serialization.enum_([\\"TEST\\"]);

export declare namespace SubmissionTypeEnum {
    type Raw = \\"TEST\\";
}
",
                        "name": "SubmissionTypeEnum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmissionTypeState: core.serialization.Schema<
    serializers.SubmissionTypeState.Raw,
    TraceApi.SubmissionTypeState
> = core.serialization
    .union(\\"type\\", {
        test: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestSubmissionState),
        workspace: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceSubmissionState),
    })
    .transform<TraceApi.SubmissionTypeState>({
        transform: (value) => {
            switch (value.type) {
                case \\"test\\":
                    return TraceApi.SubmissionTypeState.test(value);
                case \\"workspace\\":
                    return TraceApi.SubmissionTypeState.workspace(value);
                default:
                    return TraceApi.SubmissionTypeState._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace SubmissionTypeState {
    type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

    interface Test extends serializers.TestSubmissionState.Raw {
        type: \\"test\\";
    }

    interface Workspace extends serializers.WorkspaceSubmissionState.Raw {
        type: \\"workspace\\";
    }
}
",
                        "name": "SubmissionTypeState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const SubmitRequestV2: core.serialization.ObjectSchema<
    serializers.SubmitRequestV2.Raw,
    TraceApi.SubmitRequestV2
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    language: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    submissionFiles: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SubmissionFileInfo)
    ),
    problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
    problemVersion: core.serialization.number().optional(),
    userId: core.serialization.string().optional(),
});

export declare namespace SubmitRequestV2 {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        language: serializers.Language.Raw;
        submissionFiles: serializers.SubmissionFileInfo.Raw[];
        problemId: serializers.ProblemId.Raw;
        problemVersion?: number | null;
        userId?: string | null;
    }
}
",
                        "name": "SubmitRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TerminatedResponse: core.serialization.ObjectSchema<
    serializers.TerminatedResponse.Raw,
    TraceApi.TerminatedResponse
> = core.serialization.object({});

export declare namespace TerminatedResponse {
    interface Raw {}
}
",
                        "name": "TerminatedResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseGrade: core.serialization.Schema<serializers.TestCaseGrade.Raw, TraceApi.TestCaseGrade> =
    core.serialization
        .union(\\"type\\", {
            hidden: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseHiddenGrade),
            nonHidden: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseNonHiddenGrade),
        })
        .transform<TraceApi.TestCaseGrade>({
            transform: (value) => {
                switch (value.type) {
                    case \\"hidden\\":
                        return TraceApi.TestCaseGrade.hidden(value);
                    case \\"nonHidden\\":
                        return TraceApi.TestCaseGrade.nonHidden(value);
                    default:
                        return TraceApi.TestCaseGrade._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace TestCaseGrade {
    type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

    interface Hidden extends serializers.TestCaseHiddenGrade.Raw {
        type: \\"hidden\\";
    }

    interface NonHidden extends serializers.TestCaseNonHiddenGrade.Raw {
        type: \\"nonHidden\\";
    }
}
",
                        "name": "TestCaseGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseHiddenGrade: core.serialization.ObjectSchema<
    serializers.TestCaseHiddenGrade.Raw,
    TraceApi.TestCaseHiddenGrade
> = core.serialization.object({
    passed: core.serialization.boolean(),
});

export declare namespace TestCaseHiddenGrade {
    interface Raw {
        passed: boolean;
    }
}
",
                        "name": "TestCaseHiddenGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseNonHiddenGrade: core.serialization.ObjectSchema<
    serializers.TestCaseNonHiddenGrade.Raw,
    TraceApi.TestCaseNonHiddenGrade
> = core.serialization.object({
    passed: core.serialization.boolean(),
    actualResult: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue).optional(),
    exception: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExceptionV2).optional(),
    stdout: core.serialization.string(),
});

export declare namespace TestCaseNonHiddenGrade {
    interface Raw {
        passed: boolean;
        actualResult?: serializers.VariableValue.Raw | null;
        exception?: serializers.ExceptionV2.Raw | null;
        stdout: string;
    }
}
",
                        "name": "TestCaseNonHiddenGrade.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseResult: core.serialization.ObjectSchema<serializers.TestCaseResult.Raw, TraceApi.TestCaseResult> =
    core.serialization.object({
        expectedResult: core.serialization.lazy(async () => (await import(\\"../../..\\")).VariableValue),
        actualResult: core.serialization.lazy(async () => (await import(\\"../../..\\")).ActualResult),
        passed: core.serialization.boolean(),
    });

export declare namespace TestCaseResult {
    interface Raw {
        expectedResult: serializers.VariableValue.Raw;
        actualResult: serializers.ActualResult.Raw;
        passed: boolean;
    }
}
",
                        "name": "TestCaseResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestCaseResultWithStdout: core.serialization.ObjectSchema<
    serializers.TestCaseResultWithStdout.Raw,
    TraceApi.TestCaseResultWithStdout
> = core.serialization.object({
    result: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseResult),
    stdout: core.serialization.string(),
});

export declare namespace TestCaseResultWithStdout {
    interface Raw {
        result: serializers.TestCaseResult.Raw;
        stdout: string;
    }
}
",
                        "name": "TestCaseResultWithStdout.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestSubmissionState: core.serialization.ObjectSchema<
    serializers.TestSubmissionState.Raw,
    TraceApi.TestSubmissionState
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
    defaultTestCases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCase)
    ),
    customTestCases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCase)
    ),
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).TestSubmissionStatus),
});

export declare namespace TestSubmissionState {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        defaultTestCases: serializers.TestCase.Raw[];
        customTestCases: serializers.TestCase.Raw[];
        status: serializers.TestSubmissionStatus.Raw;
    }
}
",
                        "name": "TestSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestSubmissionStatus: core.serialization.Schema<
    serializers.TestSubmissionStatus.Raw,
    TraceApi.TestSubmissionStatus
> = core.serialization
    .union(\\"type\\", {
        stopped: core.serialization.object({}),
        errored: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ErrorInfo),
        }),
        running: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).RunningSubmissionState),
        }),
        testCaseIdToState: core.serialization.object({
            value: core.serialization.record(
                core.serialization.string(),
                core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionStatusForTestCase).optional()
            ),
        }),
    })
    .transform<TraceApi.TestSubmissionStatus>({
        transform: (value) => {
            switch (value.type) {
                case \\"stopped\\":
                    return TraceApi.TestSubmissionStatus.stopped();
                case \\"errored\\":
                    return TraceApi.TestSubmissionStatus.errored(value.value);
                case \\"running\\":
                    return TraceApi.TestSubmissionStatus.running(value.value);
                case \\"testCaseIdToState\\":
                    return TraceApi.TestSubmissionStatus.testCaseIdToState(value.value);
                default:
                    return TraceApi.TestSubmissionStatus._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestSubmissionStatus {
    type Raw =
        | TestSubmissionStatus.Stopped
        | TestSubmissionStatus.Errored
        | TestSubmissionStatus.Running
        | TestSubmissionStatus.TestCaseIdToState;

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        value: serializers.ErrorInfo.Raw;
    }

    interface Running {
        type: \\"running\\";
        value: serializers.RunningSubmissionState.Raw;
    }

    interface TestCaseIdToState {
        type: \\"testCaseIdToState\\";
        value: Record<string, serializers.SubmissionStatusForTestCase.Raw | null | undefined>;
    }
}
",
                        "name": "TestSubmissionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestSubmissionStatusV2: core.serialization.ObjectSchema<
    serializers.TestSubmissionStatusV2.Raw,
    TraceApi.TestSubmissionStatusV2
> = core.serialization.object({
    updates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestSubmissionUpdate)
    ),
    problemId: core.serialization.lazy(async () => (await import(\\"../../..\\")).ProblemId),
    problemVersion: core.serialization.number(),
    problemInfo: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).v2.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
    interface Raw {
        updates: serializers.TestSubmissionUpdate.Raw[];
        problemId: serializers.ProblemId.Raw;
        problemVersion: number;
        problemInfo: serializers.v2.ProblemInfoV2.Raw;
    }
}
",
                        "name": "TestSubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestSubmissionUpdate: core.serialization.ObjectSchema<
    serializers.TestSubmissionUpdate.Raw,
    TraceApi.TestSubmissionUpdate
> = core.serialization.object({
    updateTime: core.serialization.date(),
    updateInfo: core.serialization.lazy(async () => (await import(\\"../../..\\")).TestSubmissionUpdateInfo),
});

export declare namespace TestSubmissionUpdate {
    interface Raw {
        updateTime: string;
        updateInfo: serializers.TestSubmissionUpdateInfo.Raw;
    }
}
",
                        "name": "TestSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TestSubmissionUpdateInfo: core.serialization.Schema<
    serializers.TestSubmissionUpdateInfo.Raw,
    TraceApi.TestSubmissionUpdateInfo
> = core.serialization
    .union(\\"type\\", {
        running: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).RunningSubmissionState),
        }),
        stopped: core.serialization.object({}),
        errored: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ErrorInfo),
        }),
        gradedTestCase: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).GradedTestCaseUpdate),
        recordedTestCase: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).RecordedTestCaseUpdate),
        finished: core.serialization.object({}),
    })
    .transform<TraceApi.TestSubmissionUpdateInfo>({
        transform: (value) => {
            switch (value.type) {
                case \\"running\\":
                    return TraceApi.TestSubmissionUpdateInfo.running(value.value);
                case \\"stopped\\":
                    return TraceApi.TestSubmissionUpdateInfo.stopped();
                case \\"errored\\":
                    return TraceApi.TestSubmissionUpdateInfo.errored(value.value);
                case \\"gradedTestCase\\":
                    return TraceApi.TestSubmissionUpdateInfo.gradedTestCase(value);
                case \\"recordedTestCase\\":
                    return TraceApi.TestSubmissionUpdateInfo.recordedTestCase(value);
                case \\"finished\\":
                    return TraceApi.TestSubmissionUpdateInfo.finished();
                default:
                    return TraceApi.TestSubmissionUpdateInfo._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestSubmissionUpdateInfo {
    type Raw =
        | TestSubmissionUpdateInfo.Running
        | TestSubmissionUpdateInfo.Stopped
        | TestSubmissionUpdateInfo.Errored
        | TestSubmissionUpdateInfo.GradedTestCase
        | TestSubmissionUpdateInfo.RecordedTestCase
        | TestSubmissionUpdateInfo.Finished;

    interface Running {
        type: \\"running\\";
        value: serializers.RunningSubmissionState.Raw;
    }

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        value: serializers.ErrorInfo.Raw;
    }

    interface GradedTestCase extends serializers.GradedTestCaseUpdate.Raw {
        type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends serializers.RecordedTestCaseUpdate.Raw {
        type: \\"recordedTestCase\\";
    }

    interface Finished {
        type: \\"finished\\";
    }
}
",
                        "name": "TestSubmissionUpdateInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TraceResponse: core.serialization.ObjectSchema<serializers.TraceResponse.Raw, TraceApi.TraceResponse> =
    core.serialization.object({
        submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
        lineNumber: core.serialization.number(),
        returnValue: core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue).optional(),
        expressionLocation: core.serialization
            .lazyObject(async () => (await import(\\"../../..\\")).ExpressionLocation)
            .optional(),
        stack: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).StackInformation),
        stdout: core.serialization.string().optional(),
    });

export declare namespace TraceResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        lineNumber: number;
        returnValue?: serializers.DebugVariableValue.Raw | null;
        expressionLocation?: serializers.ExpressionLocation.Raw | null;
        stack: serializers.StackInformation.Raw;
        stdout?: string | null;
    }
}
",
                        "name": "TraceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TraceResponseV2: core.serialization.ObjectSchema<
    serializers.TraceResponseV2.Raw,
    TraceApi.TraceResponseV2
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    lineNumber: core.serialization.number(),
    file: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TracedFile),
    returnValue: core.serialization.lazy(async () => (await import(\\"../../..\\")).DebugVariableValue).optional(),
    expressionLocation: core.serialization
        .lazyObject(async () => (await import(\\"../../..\\")).ExpressionLocation)
        .optional(),
    stack: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).StackInformation),
    stdout: core.serialization.string().optional(),
});

export declare namespace TraceResponseV2 {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        lineNumber: number;
        file: serializers.TracedFile.Raw;
        returnValue?: serializers.DebugVariableValue.Raw | null;
        expressionLocation?: serializers.ExpressionLocation.Raw | null;
        stack: serializers.StackInformation.Raw;
        stdout?: string | null;
    }
}
",
                        "name": "TraceResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TraceResponsesPage: core.serialization.ObjectSchema<
    serializers.TraceResponsesPage.Raw,
    TraceApi.TraceResponsesPage
> = core.serialization.object({
    offset: core.serialization.number().optional(),
    traceResponses: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TraceResponse)
    ),
});

export declare namespace TraceResponsesPage {
    interface Raw {
        offset?: number | null;
        traceResponses: serializers.TraceResponse.Raw[];
    }
}
",
                        "name": "TraceResponsesPage.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TraceResponsesPageV2: core.serialization.ObjectSchema<
    serializers.TraceResponsesPageV2.Raw,
    TraceApi.TraceResponsesPageV2
> = core.serialization.object({
    offset: core.serialization.number().optional(),
    traceResponses: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TraceResponseV2)
    ),
});

export declare namespace TraceResponsesPageV2 {
    interface Raw {
        offset?: number | null;
        traceResponses: serializers.TraceResponseV2.Raw[];
    }
}
",
                        "name": "TraceResponsesPageV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TracedFile: core.serialization.ObjectSchema<serializers.TracedFile.Raw, TraceApi.TracedFile> =
    core.serialization.object({
        filename: core.serialization.string(),
        directory: core.serialization.string(),
    });

export declare namespace TracedFile {
    interface Raw {
        filename: string;
        directory: string;
    }
}
",
                        "name": "TracedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const TracedTestCase: core.serialization.ObjectSchema<serializers.TracedTestCase.Raw, TraceApi.TracedTestCase> =
    core.serialization.object({
        result: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TestCaseResultWithStdout),
        traceResponsesSize: core.serialization.number(),
    });

export declare namespace TracedTestCase {
    interface Raw {
        result: serializers.TestCaseResultWithStdout.Raw;
        traceResponsesSize: number;
    }
}
",
                        "name": "TracedTestCase.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const UnexpectedLanguageError: core.serialization.ObjectSchema<
    serializers.UnexpectedLanguageError.Raw,
    TraceApi.UnexpectedLanguageError
> = core.serialization.object({
    expectedLanguage: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    actualLanguage: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
});

export declare namespace UnexpectedLanguageError {
    interface Raw {
        expectedLanguage: serializers.Language.Raw;
        actualLanguage: serializers.Language.Raw;
    }
}
",
                        "name": "UnexpectedLanguageError.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceFiles: core.serialization.ObjectSchema<serializers.WorkspaceFiles.Raw, TraceApi.WorkspaceFiles> =
    core.serialization.object({
        mainFile: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FileInfo),
        readOnlyFiles: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FileInfo)
        ),
    });

export declare namespace WorkspaceFiles {
    interface Raw {
        mainFile: serializers.FileInfo.Raw;
        readOnlyFiles: serializers.FileInfo.Raw[];
    }
}
",
                        "name": "WorkspaceFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceRanResponse: core.serialization.ObjectSchema<
    serializers.WorkspaceRanResponse.Raw,
    TraceApi.WorkspaceRanResponse
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    runDetails: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceRunDetails),
});

export declare namespace WorkspaceRanResponse {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        runDetails: serializers.WorkspaceRunDetails.Raw;
    }
}
",
                        "name": "WorkspaceRanResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceRunDetails: core.serialization.ObjectSchema<
    serializers.WorkspaceRunDetails.Raw,
    TraceApi.WorkspaceRunDetails
> = core.serialization.object({
    exceptionV2: core.serialization.lazy(async () => (await import(\\"../../..\\")).ExceptionV2).optional(),
    exception: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).ExceptionInfo).optional(),
    stdout: core.serialization.string(),
});

export declare namespace WorkspaceRunDetails {
    interface Raw {
        exceptionV2?: serializers.ExceptionV2.Raw | null;
        exception?: serializers.ExceptionInfo.Raw | null;
        stdout: string;
    }
}
",
                        "name": "WorkspaceRunDetails.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceStarterFilesResponse: core.serialization.ObjectSchema<
    serializers.WorkspaceStarterFilesResponse.Raw,
    TraceApi.WorkspaceStarterFilesResponse
> = core.serialization.object({
    files: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceFiles).optional()
    ),
});

export declare namespace WorkspaceStarterFilesResponse {
    interface Raw {
        files: Record<serializers.Language.Raw, serializers.WorkspaceFiles.Raw | null | undefined>;
    }
}
",
                        "name": "WorkspaceStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceStarterFilesResponseV2: core.serialization.ObjectSchema<
    serializers.WorkspaceStarterFilesResponseV2.Raw,
    TraceApi.WorkspaceStarterFilesResponseV2
> = core.serialization.object({
    filesByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).v2.Files).optional()
    ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
    interface Raw {
        filesByLanguage: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
    }
}
",
                        "name": "WorkspaceStarterFilesResponseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmissionState: core.serialization.ObjectSchema<
    serializers.WorkspaceSubmissionState.Raw,
    TraceApi.WorkspaceSubmissionState
> = core.serialization.object({
    status: core.serialization.lazy(async () => (await import(\\"../../..\\")).WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
    interface Raw {
        status: serializers.WorkspaceSubmissionStatus.Raw;
    }
}
",
                        "name": "WorkspaceSubmissionState.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmissionStatus: core.serialization.Schema<
    serializers.WorkspaceSubmissionStatus.Raw,
    TraceApi.WorkspaceSubmissionStatus
> = core.serialization
    .union(\\"type\\", {
        stopped: core.serialization.object({}),
        errored: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ErrorInfo),
        }),
        running: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).RunningSubmissionState),
        }),
        ran: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceRunDetails),
        traced: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceRunDetails),
    })
    .transform<TraceApi.WorkspaceSubmissionStatus>({
        transform: (value) => {
            switch (value.type) {
                case \\"stopped\\":
                    return TraceApi.WorkspaceSubmissionStatus.stopped();
                case \\"errored\\":
                    return TraceApi.WorkspaceSubmissionStatus.errored(value.value);
                case \\"running\\":
                    return TraceApi.WorkspaceSubmissionStatus.running(value.value);
                case \\"ran\\":
                    return TraceApi.WorkspaceSubmissionStatus.ran(value);
                case \\"traced\\":
                    return TraceApi.WorkspaceSubmissionStatus.traced(value);
                default:
                    return TraceApi.WorkspaceSubmissionStatus._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace WorkspaceSubmissionStatus {
    type Raw =
        | WorkspaceSubmissionStatus.Stopped
        | WorkspaceSubmissionStatus.Errored
        | WorkspaceSubmissionStatus.Running
        | WorkspaceSubmissionStatus.Ran
        | WorkspaceSubmissionStatus.Traced;

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        value: serializers.ErrorInfo.Raw;
    }

    interface Running {
        type: \\"running\\";
        value: serializers.RunningSubmissionState.Raw;
    }

    interface Ran extends serializers.WorkspaceRunDetails.Raw {
        type: \\"ran\\";
    }

    interface Traced extends serializers.WorkspaceRunDetails.Raw {
        type: \\"traced\\";
    }
}
",
                        "name": "WorkspaceSubmissionStatus.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmissionStatusV2: core.serialization.ObjectSchema<
    serializers.WorkspaceSubmissionStatusV2.Raw,
    TraceApi.WorkspaceSubmissionStatusV2
> = core.serialization.object({
    updates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceSubmissionUpdate)
    ),
});

export declare namespace WorkspaceSubmissionStatusV2 {
    interface Raw {
        updates: serializers.WorkspaceSubmissionUpdate.Raw[];
    }
}
",
                        "name": "WorkspaceSubmissionStatusV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmissionUpdate: core.serialization.ObjectSchema<
    serializers.WorkspaceSubmissionUpdate.Raw,
    TraceApi.WorkspaceSubmissionUpdate
> = core.serialization.object({
    updateTime: core.serialization.date(),
    updateInfo: core.serialization.lazy(async () => (await import(\\"../../..\\")).WorkspaceSubmissionUpdateInfo),
});

export declare namespace WorkspaceSubmissionUpdate {
    interface Raw {
        updateTime: string;
        updateInfo: serializers.WorkspaceSubmissionUpdateInfo.Raw;
    }
}
",
                        "name": "WorkspaceSubmissionUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmissionUpdateInfo: core.serialization.Schema<
    serializers.WorkspaceSubmissionUpdateInfo.Raw,
    TraceApi.WorkspaceSubmissionUpdateInfo
> = core.serialization
    .union(\\"type\\", {
        running: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).RunningSubmissionState),
        }),
        ran: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceRunDetails),
        stopped: core.serialization.object({}),
        traced: core.serialization.object({}),
        tracedV2: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).WorkspaceTracedUpdate),
        errored: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../..\\")).ErrorInfo),
        }),
        finished: core.serialization.object({}),
    })
    .transform<TraceApi.WorkspaceSubmissionUpdateInfo>({
        transform: (value) => {
            switch (value.type) {
                case \\"running\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.running(value.value);
                case \\"ran\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.ran(value);
                case \\"stopped\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.stopped();
                case \\"traced\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.traced();
                case \\"tracedV2\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.tracedV2(value);
                case \\"errored\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.errored(value.value);
                case \\"finished\\":
                    return TraceApi.WorkspaceSubmissionUpdateInfo.finished();
                default:
                    return TraceApi.WorkspaceSubmissionUpdateInfo._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace WorkspaceSubmissionUpdateInfo {
    type Raw =
        | WorkspaceSubmissionUpdateInfo.Running
        | WorkspaceSubmissionUpdateInfo.Ran
        | WorkspaceSubmissionUpdateInfo.Stopped
        | WorkspaceSubmissionUpdateInfo.Traced
        | WorkspaceSubmissionUpdateInfo.TracedV2
        | WorkspaceSubmissionUpdateInfo.Errored
        | WorkspaceSubmissionUpdateInfo.Finished;

    interface Running {
        type: \\"running\\";
        value: serializers.RunningSubmissionState.Raw;
    }

    interface Ran extends serializers.WorkspaceRunDetails.Raw {
        type: \\"ran\\";
    }

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Traced {
        type: \\"traced\\";
    }

    interface TracedV2 extends serializers.WorkspaceTracedUpdate.Raw {
        type: \\"tracedV2\\";
    }

    interface Errored {
        type: \\"errored\\";
        value: serializers.ErrorInfo.Raw;
    }

    interface Finished {
        type: \\"finished\\";
    }
}
",
                        "name": "WorkspaceSubmissionUpdateInfo.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceSubmitRequest: core.serialization.ObjectSchema<
    serializers.WorkspaceSubmitRequest.Raw,
    TraceApi.WorkspaceSubmitRequest
> = core.serialization.object({
    submissionId: core.serialization.lazy(async () => (await import(\\"../../..\\")).SubmissionId),
    language: core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    submissionFiles: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SubmissionFileInfo)
    ),
    userId: core.serialization.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
    interface Raw {
        submissionId: serializers.SubmissionId.Raw;
        language: serializers.Language.Raw;
        submissionFiles: serializers.SubmissionFileInfo.Raw[];
        userId?: string | null;
    }
}
",
                        "name": "WorkspaceSubmitRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const WorkspaceTracedUpdate: core.serialization.ObjectSchema<
    serializers.WorkspaceTracedUpdate.Raw,
    TraceApi.WorkspaceTracedUpdate
> = core.serialization.object({
    traceResponsesSize: core.serialization.number(),
});

export declare namespace WorkspaceTracedUpdate {
    interface Raw {
        traceResponsesSize: number;
    }
}
",
                        "name": "WorkspaceTracedUpdate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "submission",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.sysprop.getNumWarmInstances.Response.Raw,
    Record<TraceApi.Language, number | undefined>
> = core.serialization.record(
    core.serialization.lazy(async () => (await import(\\"../../..\\")).Language),
    core.serialization.number().optional()
);

export declare namespace Response {
    type Raw = Record<serializers.Language.Raw, number | null | undefined>;
}
",
                        "name": "getNumWarmInstances.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "sysprop",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./resources\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.v2.problem.getLightweightProblems.Response.Raw,
    TraceApi.v2.LightweightProblemInfoV2[]
> = core.serialization.list(
    core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.LightweightProblemInfoV2)
);

export declare namespace Response {
    type Raw = serializers.v2.LightweightProblemInfoV2.Raw[];
}
",
                                "name": "getLightweightProblems.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.v2.problem.getProblems.Response.Raw,
    TraceApi.v2.ProblemInfoV2[]
> = core.serialization.list(
    core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.ProblemInfoV2)
);

export declare namespace Response {
    type Raw = serializers.v2.ProblemInfoV2.Raw[];
}
",
                                "name": "getProblems.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "client",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const AssertCorrectnessCheck: core.serialization.Schema<
    serializers.v2.AssertCorrectnessCheck.Raw,
    TraceApi.v2.AssertCorrectnessCheck
> = core.serialization
    .union(\\"type\\", {
        deepEquality: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.DeepEqualityCorrectnessCheck
        ),
        custom: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.VoidFunctionDefinitionThatTakesActualResult
        ),
    })
    .transform<TraceApi.v2.AssertCorrectnessCheck>({
        transform: (value) => {
            switch (value.type) {
                case \\"deepEquality\\":
                    return TraceApi.v2.AssertCorrectnessCheck.deepEquality(value);
                case \\"custom\\":
                    return TraceApi.v2.AssertCorrectnessCheck.custom(value);
                default:
                    return TraceApi.v2.AssertCorrectnessCheck._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace AssertCorrectnessCheck {
    type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

    interface DeepEquality extends serializers.v2.DeepEqualityCorrectnessCheck.Raw {
        type: \\"deepEquality\\";
    }

    interface Custom extends serializers.v2.VoidFunctionDefinitionThatTakesActualResult.Raw {
        type: \\"custom\\";
    }
}
",
                                "name": "AssertCorrectnessCheck.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const BasicCustomFiles: core.serialization.ObjectSchema<
    serializers.v2.BasicCustomFiles.Raw,
    TraceApi.v2.BasicCustomFiles
> = core.serialization.object({
    methodName: core.serialization.string(),
    signature: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.NonVoidFunctionSignature),
    additionalFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Files).optional()
    ),
    basicTestCaseTemplate: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.BasicTestCaseTemplate
    ),
});

export declare namespace BasicCustomFiles {
    interface Raw {
        methodName: string;
        signature: serializers.v2.NonVoidFunctionSignature.Raw;
        additionalFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
        basicTestCaseTemplate: serializers.v2.BasicTestCaseTemplate.Raw;
    }
}
",
                                "name": "BasicCustomFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const BasicTestCaseTemplate: core.serialization.ObjectSchema<
    serializers.v2.BasicTestCaseTemplate.Raw,
    TraceApi.v2.BasicTestCaseTemplate
> = core.serialization.object({
    templateId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplateId),
    name: core.serialization.string(),
    description: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementationDescription
    ),
    expectedValueParameterId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
    interface Raw {
        templateId: serializers.v2.TestCaseTemplateId.Raw;
        name: string;
        description: serializers.v2.TestCaseImplementationDescription.Raw;
        expectedValueParameterId: serializers.v2.ParameterId.Raw;
    }
}
",
                                "name": "BasicTestCaseTemplate.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const CreateProblemRequestV2: core.serialization.ObjectSchema<
    serializers.v2.CreateProblemRequestV2.Raw,
    TraceApi.v2.CreateProblemRequestV2
> = core.serialization.object({
    problemName: core.serialization.string(),
    problemDescription: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).ProblemDescription),
    customFiles: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.CustomFiles),
    customTestCaseTemplates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplate)
    ),
    testcases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseV2)
    ),
    supportedLanguages: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language)
    ),
    isPublic: core.serialization.boolean(),
});

export declare namespace CreateProblemRequestV2 {
    interface Raw {
        problemName: string;
        problemDescription: serializers.ProblemDescription.Raw;
        customFiles: serializers.v2.CustomFiles.Raw;
        customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
        testcases: serializers.v2.TestCaseV2.Raw[];
        supportedLanguages: serializers.Language.Raw[];
        isPublic: boolean;
    }
}
",
                                "name": "CreateProblemRequestV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const CustomFiles: core.serialization.Schema<serializers.v2.CustomFiles.Raw, TraceApi.v2.CustomFiles> =
    core.serialization
        .union(\\"type\\", {
            basic: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.BasicCustomFiles),
            custom: core.serialization.object({
                value: core.serialization.record(
                    core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
                    core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Files).optional()
                ),
            }),
        })
        .transform<TraceApi.v2.CustomFiles>({
            transform: (value) => {
                switch (value.type) {
                    case \\"basic\\":
                        return TraceApi.v2.CustomFiles.basic(value);
                    case \\"custom\\":
                        return TraceApi.v2.CustomFiles.custom(value.value);
                    default:
                        return TraceApi.v2.CustomFiles._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace CustomFiles {
    type Raw = CustomFiles.Basic | CustomFiles.Custom;

    interface Basic extends serializers.v2.BasicCustomFiles.Raw {
        type: \\"basic\\";
    }

    interface Custom {
        type: \\"custom\\";
        value: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
    }
}
",
                                "name": "CustomFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const DeepEqualityCorrectnessCheck: core.serialization.ObjectSchema<
    serializers.v2.DeepEqualityCorrectnessCheck.Raw,
    TraceApi.v2.DeepEqualityCorrectnessCheck
> = core.serialization.object({
    expectedValueParameterId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
    interface Raw {
        expectedValueParameterId: serializers.v2.ParameterId.Raw;
    }
}
",
                                "name": "DeepEqualityCorrectnessCheck.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const DefaultProvidedFile: core.serialization.ObjectSchema<
    serializers.v2.DefaultProvidedFile.Raw,
    TraceApi.v2.DefaultProvidedFile
> = core.serialization.object({
    file: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.FileInfoV2),
    relatedTypes: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableType)
    ),
});

export declare namespace DefaultProvidedFile {
    interface Raw {
        file: serializers.v2.FileInfoV2.Raw;
        relatedTypes: serializers.VariableType.Raw[];
    }
}
",
                                "name": "DefaultProvidedFile.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const FileInfoV2: core.serialization.ObjectSchema<serializers.v2.FileInfoV2.Raw, TraceApi.v2.FileInfoV2> =
    core.serialization.object({
        filename: core.serialization.string(),
        directory: core.serialization.string(),
        contents: core.serialization.string(),
        editable: core.serialization.boolean(),
    });

export declare namespace FileInfoV2 {
    interface Raw {
        filename: string;
        directory: string;
        contents: string;
        editable: boolean;
    }
}
",
                                "name": "FileInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const Files: core.serialization.ObjectSchema<serializers.v2.Files.Raw, TraceApi.v2.Files> =
    core.serialization.object({
        files: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.FileInfoV2)
        ),
    });

export declare namespace Files {
    interface Raw {
        files: serializers.v2.FileInfoV2.Raw[];
    }
}
",
                                "name": "Files.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const FunctionImplementation: core.serialization.ObjectSchema<
    serializers.v2.FunctionImplementation.Raw,
    TraceApi.v2.FunctionImplementation
> = core.serialization.object({
    impl: core.serialization.string(),
    imports: core.serialization.string().optional(),
});

export declare namespace FunctionImplementation {
    interface Raw {
        impl: string;
        imports?: string | null;
    }
}
",
                                "name": "FunctionImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const FunctionImplementationForMultipleLanguages: core.serialization.ObjectSchema<
    serializers.v2.FunctionImplementationForMultipleLanguages.Raw,
    TraceApi.v2.FunctionImplementationForMultipleLanguages
> = core.serialization.object({
    codeByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.FunctionImplementation).optional()
    ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
    interface Raw {
        codeByLanguage: Record<serializers.Language.Raw, serializers.v2.FunctionImplementation.Raw | null | undefined>;
    }
}
",
                                "name": "FunctionImplementationForMultipleLanguages.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const FunctionSignature: core.serialization.Schema<
    serializers.v2.FunctionSignature.Raw,
    TraceApi.v2.FunctionSignature
> = core.serialization
    .union(\\"type\\", {
        void: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.VoidFunctionSignature),
        nonVoid: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.NonVoidFunctionSignature
        ),
        voidThatTakesActualResult: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.VoidFunctionSignatureThatTakesActualResult
        ),
    })
    .transform<TraceApi.v2.FunctionSignature>({
        transform: (value) => {
            switch (value.type) {
                case \\"void\\":
                    return TraceApi.v2.FunctionSignature.void(value);
                case \\"nonVoid\\":
                    return TraceApi.v2.FunctionSignature.nonVoid(value);
                case \\"voidThatTakesActualResult\\":
                    return TraceApi.v2.FunctionSignature.voidThatTakesActualResult(value);
                default:
                    return TraceApi.v2.FunctionSignature._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace FunctionSignature {
    type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

    interface Void extends serializers.v2.VoidFunctionSignature.Raw {
        type: \\"void\\";
    }

    interface NonVoid extends serializers.v2.NonVoidFunctionSignature.Raw {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends serializers.v2.VoidFunctionSignatureThatTakesActualResult.Raw {
        type: \\"voidThatTakesActualResult\\";
    }
}
",
                                "name": "FunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GeneratedFiles: core.serialization.ObjectSchema<
    serializers.v2.GeneratedFiles.Raw,
    TraceApi.v2.GeneratedFiles
> = core.serialization.object({
    generatedTestCaseFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Files).optional()
    ),
    generatedTemplateFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Files).optional()
    ),
    other: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Files).optional()
    ),
});

export declare namespace GeneratedFiles {
    interface Raw {
        generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
        generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
        other: Record<serializers.Language.Raw, serializers.v2.Files.Raw | null | undefined>;
    }
}
",
                                "name": "GeneratedFiles.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetBasicSolutionFileRequest: core.serialization.ObjectSchema<
    serializers.v2.GetBasicSolutionFileRequest.Raw,
    TraceApi.v2.GetBasicSolutionFileRequest
> = core.serialization.object({
    methodName: core.serialization.string(),
    signature: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
    interface Raw {
        methodName: string;
        signature: serializers.v2.NonVoidFunctionSignature.Raw;
    }
}
",
                                "name": "GetBasicSolutionFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetBasicSolutionFileResponse: core.serialization.ObjectSchema<
    serializers.v2.GetBasicSolutionFileResponse.Raw,
    TraceApi.v2.GetBasicSolutionFileResponse
> = core.serialization.object({
    solutionFileByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.FileInfoV2).optional()
    ),
});

export declare namespace GetBasicSolutionFileResponse {
    interface Raw {
        solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.FileInfoV2.Raw | null | undefined>;
    }
}
",
                                "name": "GetBasicSolutionFileResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetFunctionSignatureRequest: core.serialization.ObjectSchema<
    serializers.v2.GetFunctionSignatureRequest.Raw,
    TraceApi.v2.GetFunctionSignatureRequest
> = core.serialization.object({
    functionSignature: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
    interface Raw {
        functionSignature: serializers.v2.FunctionSignature.Raw;
    }
}
",
                                "name": "GetFunctionSignatureRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetFunctionSignatureResponse: core.serialization.ObjectSchema<
    serializers.v2.GetFunctionSignatureResponse.Raw,
    TraceApi.v2.GetFunctionSignatureResponse
> = core.serialization.object({
    functionByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language),
        core.serialization.string().optional()
    ),
});

export declare namespace GetFunctionSignatureResponse {
    interface Raw {
        functionByLanguage: Record<serializers.Language.Raw, string | null | undefined>;
    }
}
",
                                "name": "GetFunctionSignatureResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetGeneratedTestCaseFileRequest: core.serialization.ObjectSchema<
    serializers.v2.GetGeneratedTestCaseFileRequest.Raw,
    TraceApi.v2.GetGeneratedTestCaseFileRequest
> = core.serialization.object({
    template: core.serialization
        .lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplate)
        .optional(),
    testCase: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
    interface Raw {
        template?: serializers.v2.TestCaseTemplate.Raw | null;
        testCase: serializers.v2.TestCaseV2.Raw;
    }
}
",
                                "name": "GetGeneratedTestCaseFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.serialization.ObjectSchema<
    serializers.v2.GetGeneratedTestCaseTemplateFileRequest.Raw,
    TraceApi.v2.GetGeneratedTestCaseTemplateFileRequest
> = core.serialization.object({
    template: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
    interface Raw {
        template: serializers.v2.TestCaseTemplate.Raw;
    }
}
",
                                "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const LightweightProblemInfoV2: core.serialization.ObjectSchema<
    serializers.v2.LightweightProblemInfoV2.Raw,
    TraceApi.v2.LightweightProblemInfoV2
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).ProblemId),
    problemName: core.serialization.string(),
    problemVersion: core.serialization.number(),
    variableTypes: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableType)
    ),
});

export declare namespace LightweightProblemInfoV2 {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemName: string;
        problemVersion: number;
        variableTypes: serializers.VariableType.Raw[];
    }
}
",
                                "name": "LightweightProblemInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const NonVoidFunctionDefinition: core.serialization.ObjectSchema<
    serializers.v2.NonVoidFunctionDefinition.Raw,
    TraceApi.v2.NonVoidFunctionDefinition
> = core.serialization.object({
    signature: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.NonVoidFunctionSignature),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace NonVoidFunctionDefinition {
    interface Raw {
        signature: serializers.v2.NonVoidFunctionSignature.Raw;
        code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                "name": "NonVoidFunctionDefinition.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const NonVoidFunctionSignature: core.serialization.ObjectSchema<
    serializers.v2.NonVoidFunctionSignature.Raw,
    TraceApi.v2.NonVoidFunctionSignature
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Parameter)
    ),
    returnType: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableType),
});

export declare namespace NonVoidFunctionSignature {
    interface Raw {
        parameters: serializers.v2.Parameter.Raw[];
        returnType: serializers.VariableType.Raw;
    }
}
",
                                "name": "NonVoidFunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const Parameter: core.serialization.ObjectSchema<serializers.v2.Parameter.Raw, TraceApi.v2.Parameter> =
    core.serialization.object({
        parameterId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.ParameterId),
        name: core.serialization.string(),
        variableType: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableType),
    });

export declare namespace Parameter {
    interface Raw {
        parameterId: serializers.v2.ParameterId.Raw;
        name: string;
        variableType: serializers.VariableType.Raw;
    }
}
",
                                "name": "Parameter.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const ParameterId: core.serialization.Schema<serializers.v2.ParameterId.Raw, TraceApi.v2.ParameterId> =
    core.serialization.string().transform({
        transform: TraceApi.v2.ParameterId,
        untransform: (value) => value,
    });

export declare namespace ParameterId {
    type Raw = string;
}
",
                                "name": "ParameterId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const ProblemInfoV2: core.serialization.ObjectSchema<
    serializers.v2.ProblemInfoV2.Raw,
    TraceApi.v2.ProblemInfoV2
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).ProblemId),
    problemDescription: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).ProblemDescription),
    problemName: core.serialization.string(),
    problemVersion: core.serialization.number(),
    supportedLanguages: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).Language)
    ),
    customFiles: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.CustomFiles),
    generatedFiles: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.GeneratedFiles),
    customTestCaseTemplates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplate)
    ),
    testcases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseV2)
    ),
    isPublic: core.serialization.boolean(),
});

export declare namespace ProblemInfoV2 {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemDescription: serializers.ProblemDescription.Raw;
        problemName: string;
        problemVersion: number;
        supportedLanguages: serializers.Language.Raw[];
        customFiles: serializers.v2.CustomFiles.Raw;
        generatedFiles: serializers.v2.GeneratedFiles.Raw;
        customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
        testcases: serializers.v2.TestCaseV2.Raw[];
        isPublic: boolean;
    }
}
",
                                "name": "ProblemInfoV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseExpects: core.serialization.ObjectSchema<
    serializers.v2.TestCaseExpects.Raw,
    TraceApi.v2.TestCaseExpects
> = core.serialization.object({
    expectedStdout: core.serialization.string().optional(),
});

export declare namespace TestCaseExpects {
    interface Raw {
        expectedStdout?: string | null;
    }
}
",
                                "name": "TestCaseExpects.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseFunction: core.serialization.Schema<
    serializers.v2.TestCaseFunction.Raw,
    TraceApi.v2.TestCaseFunction
> = core.serialization
    .union(\\"type\\", {
        withActualResult: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.TestCaseWithActualResultImplementation
        ),
        custom: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.VoidFunctionDefinition),
    })
    .transform<TraceApi.v2.TestCaseFunction>({
        transform: (value) => {
            switch (value.type) {
                case \\"withActualResult\\":
                    return TraceApi.v2.TestCaseFunction.withActualResult(value);
                case \\"custom\\":
                    return TraceApi.v2.TestCaseFunction.custom(value);
                default:
                    return TraceApi.v2.TestCaseFunction._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseFunction {
    type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

    interface WithActualResult extends serializers.v2.TestCaseWithActualResultImplementation.Raw {
        type: \\"withActualResult\\";
    }

    interface Custom extends serializers.v2.VoidFunctionDefinition.Raw {
        type: \\"custom\\";
    }
}
",
                                "name": "TestCaseFunction.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseId: core.serialization.Schema<serializers.v2.TestCaseId.Raw, TraceApi.v2.TestCaseId> =
    core.serialization.string().transform({
        transform: TraceApi.v2.TestCaseId,
        untransform: (value) => value,
    });

export declare namespace TestCaseId {
    type Raw = string;
}
",
                                "name": "TestCaseId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseImplementation: core.serialization.ObjectSchema<
    serializers.v2.TestCaseImplementation.Raw,
    TraceApi.v2.TestCaseImplementation
> = core.serialization.object({
    description: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementationDescription
    ),
    function: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
    interface Raw {
        description: serializers.v2.TestCaseImplementationDescription.Raw;
        function: serializers.v2.TestCaseFunction.Raw;
    }
}
",
                                "name": "TestCaseImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseImplementationDescription: core.serialization.ObjectSchema<
    serializers.v2.TestCaseImplementationDescription.Raw,
    TraceApi.v2.TestCaseImplementationDescription
> = core.serialization.object({
    boards: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementationDescriptionBoard)
    ),
});

export declare namespace TestCaseImplementationDescription {
    interface Raw {
        boards: serializers.v2.TestCaseImplementationDescriptionBoard.Raw[];
    }
}
",
                                "name": "TestCaseImplementationDescription.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseImplementationDescriptionBoard: core.serialization.Schema<
    serializers.v2.TestCaseImplementationDescriptionBoard.Raw,
    TraceApi.v2.TestCaseImplementationDescriptionBoard
> = core.serialization
    .union(\\"type\\", {
        html: core.serialization.object({
            value: core.serialization.string(),
        }),
        paramId: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.ParameterId),
        }),
    })
    .transform<TraceApi.v2.TestCaseImplementationDescriptionBoard>({
        transform: (value) => {
            switch (value.type) {
                case \\"html\\":
                    return TraceApi.v2.TestCaseImplementationDescriptionBoard.html(value.value);
                case \\"paramId\\":
                    return TraceApi.v2.TestCaseImplementationDescriptionBoard.paramId(value.value);
                default:
                    return TraceApi.v2.TestCaseImplementationDescriptionBoard._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseImplementationDescriptionBoard {
    type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

    interface Html {
        type: \\"html\\";
        value: string;
    }

    interface ParamId {
        type: \\"paramId\\";
        value: serializers.v2.ParameterId.Raw;
    }
}
",
                                "name": "TestCaseImplementationDescriptionBoard.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseImplementationReference: core.serialization.Schema<
    serializers.v2.TestCaseImplementationReference.Raw,
    TraceApi.v2.TestCaseImplementationReference
> = core.serialization
    .union(\\"type\\", {
        templateId: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplateId),
        }),
        implementation: core.serialization.lazyObject(
            async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementation
        ),
    })
    .transform<TraceApi.v2.TestCaseImplementationReference>({
        transform: (value) => {
            switch (value.type) {
                case \\"templateId\\":
                    return TraceApi.v2.TestCaseImplementationReference.templateId(value.value);
                case \\"implementation\\":
                    return TraceApi.v2.TestCaseImplementationReference.implementation(value);
                default:
                    return TraceApi.v2.TestCaseImplementationReference._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseImplementationReference {
    type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

    interface TemplateId {
        type: \\"templateId\\";
        value: serializers.v2.TestCaseTemplateId.Raw;
    }

    interface Implementation extends serializers.v2.TestCaseImplementation.Raw {
        type: \\"implementation\\";
    }
}
",
                                "name": "TestCaseImplementationReference.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseMetadata: core.serialization.ObjectSchema<
    serializers.v2.TestCaseMetadata.Raw,
    TraceApi.v2.TestCaseMetadata
> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseId),
    name: core.serialization.string(),
    hidden: core.serialization.boolean(),
});

export declare namespace TestCaseMetadata {
    interface Raw {
        id: serializers.v2.TestCaseId.Raw;
        name: string;
        hidden: boolean;
    }
}
",
                                "name": "TestCaseMetadata.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseTemplate: core.serialization.ObjectSchema<
    serializers.v2.TestCaseTemplate.Raw,
    TraceApi.v2.TestCaseTemplate
> = core.serialization.object({
    templateId: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.TestCaseTemplateId),
    name: core.serialization.string(),
    implementation: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementation
    ),
});

export declare namespace TestCaseTemplate {
    interface Raw {
        templateId: serializers.v2.TestCaseTemplateId.Raw;
        name: string;
        implementation: serializers.v2.TestCaseImplementation.Raw;
    }
}
",
                                "name": "TestCaseTemplate.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseTemplateId: core.serialization.Schema<
    serializers.v2.TestCaseTemplateId.Raw,
    TraceApi.v2.TestCaseTemplateId
> = core.serialization.string().transform({
    transform: TraceApi.v2.TestCaseTemplateId,
    untransform: (value) => value,
});

export declare namespace TestCaseTemplateId {
    type Raw = string;
}
",
                                "name": "TestCaseTemplateId.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseV2: core.serialization.ObjectSchema<serializers.v2.TestCaseV2.Raw, TraceApi.v2.TestCaseV2> =
    core.serialization.object({
        metadata: core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseMetadata),
        implementation: core.serialization.lazy(
            async () => (await import(\\"../../../../..\\")).v2.TestCaseImplementationReference
        ),
        arguments: core.serialization.record(
            core.serialization.lazy(async () => (await import(\\"../../../../..\\")).v2.ParameterId),
            core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableValue).optional()
        ),
        expects: core.serialization
            .lazyObject(async () => (await import(\\"../../../../..\\")).v2.TestCaseExpects)
            .optional(),
    });

export declare namespace TestCaseV2 {
    interface Raw {
        metadata: serializers.v2.TestCaseMetadata.Raw;
        implementation: serializers.v2.TestCaseImplementationReference.Raw;
        arguments: Record<serializers.v2.ParameterId.Raw, serializers.VariableValue.Raw | null | undefined>;
        expects?: serializers.v2.TestCaseExpects.Raw | null;
    }
}
",
                                "name": "TestCaseV2.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const TestCaseWithActualResultImplementation: core.serialization.ObjectSchema<
    serializers.v2.TestCaseWithActualResultImplementation.Raw,
    TraceApi.v2.TestCaseWithActualResultImplementation
> = core.serialization.object({
    getActualResult: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.NonVoidFunctionDefinition
    ),
    assertCorrectnessCheck: core.serialization.lazy(
        async () => (await import(\\"../../../../..\\")).v2.AssertCorrectnessCheck
    ),
});

export declare namespace TestCaseWithActualResultImplementation {
    interface Raw {
        getActualResult: serializers.v2.NonVoidFunctionDefinition.Raw;
        assertCorrectnessCheck: serializers.v2.AssertCorrectnessCheck.Raw;
    }
}
",
                                "name": "TestCaseWithActualResultImplementation.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const VoidFunctionDefinition: core.serialization.ObjectSchema<
    serializers.v2.VoidFunctionDefinition.Raw,
    TraceApi.v2.VoidFunctionDefinition
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Parameter)
    ),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace VoidFunctionDefinition {
    interface Raw {
        parameters: serializers.v2.Parameter.Raw[];
        code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                "name": "VoidFunctionDefinition.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.serialization.ObjectSchema<
    serializers.v2.VoidFunctionDefinitionThatTakesActualResult.Raw,
    TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
> = core.serialization.object({
    additionalParameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Parameter)
    ),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../..\\")).v2.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
    interface Raw {
        additionalParameters: serializers.v2.Parameter.Raw[];
        code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const VoidFunctionSignature: core.serialization.ObjectSchema<
    serializers.v2.VoidFunctionSignature.Raw,
    TraceApi.v2.VoidFunctionSignature
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Parameter)
    ),
});

export declare namespace VoidFunctionSignature {
    interface Raw {
        parameters: serializers.v2.Parameter.Raw[];
    }
}
",
                                "name": "VoidFunctionSignature.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../core\\";

export const VoidFunctionSignatureThatTakesActualResult: core.serialization.ObjectSchema<
    serializers.v2.VoidFunctionSignatureThatTakesActualResult.Raw,
    TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../..\\")).v2.Parameter)
    ),
    actualResultType: core.serialization.lazy(async () => (await import(\\"../../../../..\\")).VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
    interface Raw {
        parameters: serializers.v2.Parameter.Raw[];
        actualResultType: serializers.VariableType.Raw;
    }
}
",
                                "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "types",
                            "type": "directory",
                          },
                        ],
                        "name": "problem",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * from \\"./resources\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": Array [
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.v2.v3.problem.getLightweightProblems.Response.Raw,
    TraceApi.v2.v3.LightweightProblemInfoV2[]
> = core.serialization.list(
    core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.LightweightProblemInfoV2)
);

export declare namespace Response {
    type Raw = serializers.v2.v3.LightweightProblemInfoV2.Raw[];
}
",
                                        "name": "getLightweightProblems.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const Response: core.serialization.Schema<
    serializers.v2.v3.problem.getProblems.Response.Raw,
    TraceApi.v2.v3.ProblemInfoV2[]
> = core.serialization.list(
    core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.ProblemInfoV2)
);

export declare namespace Response {
    type Raw = serializers.v2.v3.ProblemInfoV2.Raw[];
}
",
                                        "name": "getProblems.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                                        "name": "index.ts",
                                        "type": "file",
                                      },
                                    ],
                                    "name": "client",
                                    "type": "directory",
                                  },
                                  Object {
                                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": Array [
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const AssertCorrectnessCheck: core.serialization.Schema<
    serializers.v2.v3.AssertCorrectnessCheck.Raw,
    TraceApi.v2.v3.AssertCorrectnessCheck
> = core.serialization
    .union(\\"type\\", {
        deepEquality: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.DeepEqualityCorrectnessCheck
        ),
        custom: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.VoidFunctionDefinitionThatTakesActualResult
        ),
    })
    .transform<TraceApi.v2.v3.AssertCorrectnessCheck>({
        transform: (value) => {
            switch (value.type) {
                case \\"deepEquality\\":
                    return TraceApi.v2.v3.AssertCorrectnessCheck.deepEquality(value);
                case \\"custom\\":
                    return TraceApi.v2.v3.AssertCorrectnessCheck.custom(value);
                default:
                    return TraceApi.v2.v3.AssertCorrectnessCheck._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace AssertCorrectnessCheck {
    type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

    interface DeepEquality extends serializers.v2.v3.DeepEqualityCorrectnessCheck.Raw {
        type: \\"deepEquality\\";
    }

    interface Custom extends serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult.Raw {
        type: \\"custom\\";
    }
}
",
                                        "name": "AssertCorrectnessCheck.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const BasicCustomFiles: core.serialization.ObjectSchema<
    serializers.v2.v3.BasicCustomFiles.Raw,
    TraceApi.v2.v3.BasicCustomFiles
> = core.serialization.object({
    methodName: core.serialization.string(),
    signature: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.NonVoidFunctionSignature
    ),
    additionalFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Files).optional()
    ),
    basicTestCaseTemplate: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.BasicTestCaseTemplate
    ),
});

export declare namespace BasicCustomFiles {
    interface Raw {
        methodName: string;
        signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
        additionalFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw | null | undefined>;
        basicTestCaseTemplate: serializers.v2.v3.BasicTestCaseTemplate.Raw;
    }
}
",
                                        "name": "BasicCustomFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const BasicTestCaseTemplate: core.serialization.ObjectSchema<
    serializers.v2.v3.BasicTestCaseTemplate.Raw,
    TraceApi.v2.v3.BasicTestCaseTemplate
> = core.serialization.object({
    templateId: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplateId),
    name: core.serialization.string(),
    description: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementationDescription
    ),
    expectedValueParameterId: core.serialization.lazy(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.ParameterId
    ),
});

export declare namespace BasicTestCaseTemplate {
    interface Raw {
        templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
        name: string;
        description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
        expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
    }
}
",
                                        "name": "BasicTestCaseTemplate.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const CreateProblemRequestV2: core.serialization.ObjectSchema<
    serializers.v2.v3.CreateProblemRequestV2.Raw,
    TraceApi.v2.v3.CreateProblemRequestV2
> = core.serialization.object({
    problemName: core.serialization.string(),
    problemDescription: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).ProblemDescription
    ),
    customFiles: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.CustomFiles),
    customTestCaseTemplates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplate)
    ),
    testcases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseV2)
    ),
    supportedLanguages: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language)
    ),
    isPublic: core.serialization.boolean(),
});

export declare namespace CreateProblemRequestV2 {
    interface Raw {
        problemName: string;
        problemDescription: serializers.ProblemDescription.Raw;
        customFiles: serializers.v2.v3.CustomFiles.Raw;
        customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
        testcases: serializers.v2.v3.TestCaseV2.Raw[];
        supportedLanguages: serializers.Language.Raw[];
        isPublic: boolean;
    }
}
",
                                        "name": "CreateProblemRequestV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const CustomFiles: core.serialization.Schema<serializers.v2.v3.CustomFiles.Raw, TraceApi.v2.v3.CustomFiles> =
    core.serialization
        .union(\\"type\\", {
            basic: core.serialization.lazyObject(
                async () => (await import(\\"../../../../../../..\\")).v2.v3.BasicCustomFiles
            ),
            custom: core.serialization.object({
                value: core.serialization.record(
                    core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
                    core.serialization
                        .lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Files)
                        .optional()
                ),
            }),
        })
        .transform<TraceApi.v2.v3.CustomFiles>({
            transform: (value) => {
                switch (value.type) {
                    case \\"basic\\":
                        return TraceApi.v2.v3.CustomFiles.basic(value);
                    case \\"custom\\":
                        return TraceApi.v2.v3.CustomFiles.custom(value.value);
                    default:
                        return TraceApi.v2.v3.CustomFiles._unknown(value);
                }
            },
            untransform: ({ _visit, ...value }) => value as any,
        });

export declare namespace CustomFiles {
    type Raw = CustomFiles.Basic | CustomFiles.Custom;

    interface Basic extends serializers.v2.v3.BasicCustomFiles.Raw {
        type: \\"basic\\";
    }

    interface Custom {
        type: \\"custom\\";
        value: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw | null | undefined>;
    }
}
",
                                        "name": "CustomFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const DeepEqualityCorrectnessCheck: core.serialization.ObjectSchema<
    serializers.v2.v3.DeepEqualityCorrectnessCheck.Raw,
    TraceApi.v2.v3.DeepEqualityCorrectnessCheck
> = core.serialization.object({
    expectedValueParameterId: core.serialization.lazy(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.ParameterId
    ),
});

export declare namespace DeepEqualityCorrectnessCheck {
    interface Raw {
        expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
    }
}
",
                                        "name": "DeepEqualityCorrectnessCheck.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const DefaultProvidedFile: core.serialization.ObjectSchema<
    serializers.v2.v3.DefaultProvidedFile.Raw,
    TraceApi.v2.v3.DefaultProvidedFile
> = core.serialization.object({
    file: core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.FileInfoV2),
    relatedTypes: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableType)
    ),
});

export declare namespace DefaultProvidedFile {
    interface Raw {
        file: serializers.v2.v3.FileInfoV2.Raw;
        relatedTypes: serializers.VariableType.Raw[];
    }
}
",
                                        "name": "DefaultProvidedFile.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const FileInfoV2: core.serialization.ObjectSchema<serializers.v2.v3.FileInfoV2.Raw, TraceApi.v2.v3.FileInfoV2> =
    core.serialization.object({
        filename: core.serialization.string(),
        directory: core.serialization.string(),
        contents: core.serialization.string(),
        editable: core.serialization.boolean(),
    });

export declare namespace FileInfoV2 {
    interface Raw {
        filename: string;
        directory: string;
        contents: string;
        editable: boolean;
    }
}
",
                                        "name": "FileInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const Files: core.serialization.ObjectSchema<serializers.v2.v3.Files.Raw, TraceApi.v2.v3.Files> =
    core.serialization.object({
        files: core.serialization.list(
            core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.FileInfoV2)
        ),
    });

export declare namespace Files {
    interface Raw {
        files: serializers.v2.v3.FileInfoV2.Raw[];
    }
}
",
                                        "name": "Files.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const FunctionImplementation: core.serialization.ObjectSchema<
    serializers.v2.v3.FunctionImplementation.Raw,
    TraceApi.v2.v3.FunctionImplementation
> = core.serialization.object({
    impl: core.serialization.string(),
    imports: core.serialization.string().optional(),
});

export declare namespace FunctionImplementation {
    interface Raw {
        impl: string;
        imports?: string | null;
    }
}
",
                                        "name": "FunctionImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const FunctionImplementationForMultipleLanguages: core.serialization.ObjectSchema<
    serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw,
    TraceApi.v2.v3.FunctionImplementationForMultipleLanguages
> = core.serialization.object({
    codeByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization
            .lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.FunctionImplementation)
            .optional()
    ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
    interface Raw {
        codeByLanguage: Record<
            serializers.Language.Raw,
            serializers.v2.v3.FunctionImplementation.Raw | null | undefined
        >;
    }
}
",
                                        "name": "FunctionImplementationForMultipleLanguages.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const FunctionSignature: core.serialization.Schema<
    serializers.v2.v3.FunctionSignature.Raw,
    TraceApi.v2.v3.FunctionSignature
> = core.serialization
    .union(\\"type\\", {
        void: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.VoidFunctionSignature
        ),
        nonVoid: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.NonVoidFunctionSignature
        ),
        voidThatTakesActualResult: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.VoidFunctionSignatureThatTakesActualResult
        ),
    })
    .transform<TraceApi.v2.v3.FunctionSignature>({
        transform: (value) => {
            switch (value.type) {
                case \\"void\\":
                    return TraceApi.v2.v3.FunctionSignature.void(value);
                case \\"nonVoid\\":
                    return TraceApi.v2.v3.FunctionSignature.nonVoid(value);
                case \\"voidThatTakesActualResult\\":
                    return TraceApi.v2.v3.FunctionSignature.voidThatTakesActualResult(value);
                default:
                    return TraceApi.v2.v3.FunctionSignature._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace FunctionSignature {
    type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

    interface Void extends serializers.v2.v3.VoidFunctionSignature.Raw {
        type: \\"void\\";
    }

    interface NonVoid extends serializers.v2.v3.NonVoidFunctionSignature.Raw {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult.Raw {
        type: \\"voidThatTakesActualResult\\";
    }
}
",
                                        "name": "FunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GeneratedFiles: core.serialization.ObjectSchema<
    serializers.v2.v3.GeneratedFiles.Raw,
    TraceApi.v2.v3.GeneratedFiles
> = core.serialization.object({
    generatedTestCaseFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Files).optional()
    ),
    generatedTemplateFiles: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Files).optional()
    ),
    other: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Files).optional()
    ),
});

export declare namespace GeneratedFiles {
    interface Raw {
        generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw | null | undefined>;
        generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw | null | undefined>;
        other: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw | null | undefined>;
    }
}
",
                                        "name": "GeneratedFiles.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetBasicSolutionFileRequest: core.serialization.ObjectSchema<
    serializers.v2.v3.GetBasicSolutionFileRequest.Raw,
    TraceApi.v2.v3.GetBasicSolutionFileRequest
> = core.serialization.object({
    methodName: core.serialization.string(),
    signature: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.NonVoidFunctionSignature
    ),
});

export declare namespace GetBasicSolutionFileRequest {
    interface Raw {
        methodName: string;
        signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
    }
}
",
                                        "name": "GetBasicSolutionFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetBasicSolutionFileResponse: core.serialization.ObjectSchema<
    serializers.v2.v3.GetBasicSolutionFileResponse.Raw,
    TraceApi.v2.v3.GetBasicSolutionFileResponse
> = core.serialization.object({
    solutionFileByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.FileInfoV2).optional()
    ),
});

export declare namespace GetBasicSolutionFileResponse {
    interface Raw {
        solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.v3.FileInfoV2.Raw | null | undefined>;
    }
}
",
                                        "name": "GetBasicSolutionFileResponse.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetFunctionSignatureRequest: core.serialization.ObjectSchema<
    serializers.v2.v3.GetFunctionSignatureRequest.Raw,
    TraceApi.v2.v3.GetFunctionSignatureRequest
> = core.serialization.object({
    functionSignature: core.serialization.lazy(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.FunctionSignature
    ),
});

export declare namespace GetFunctionSignatureRequest {
    interface Raw {
        functionSignature: serializers.v2.v3.FunctionSignature.Raw;
    }
}
",
                                        "name": "GetFunctionSignatureRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetFunctionSignatureResponse: core.serialization.ObjectSchema<
    serializers.v2.v3.GetFunctionSignatureResponse.Raw,
    TraceApi.v2.v3.GetFunctionSignatureResponse
> = core.serialization.object({
    functionByLanguage: core.serialization.record(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language),
        core.serialization.string().optional()
    ),
});

export declare namespace GetFunctionSignatureResponse {
    interface Raw {
        functionByLanguage: Record<serializers.Language.Raw, string | null | undefined>;
    }
}
",
                                        "name": "GetFunctionSignatureResponse.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetGeneratedTestCaseFileRequest: core.serialization.ObjectSchema<
    serializers.v2.v3.GetGeneratedTestCaseFileRequest.Raw,
    TraceApi.v2.v3.GetGeneratedTestCaseFileRequest
> = core.serialization.object({
    template: core.serialization
        .lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplate)
        .optional(),
    testCase: core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
    interface Raw {
        template?: serializers.v2.v3.TestCaseTemplate.Raw | null;
        testCase: serializers.v2.v3.TestCaseV2.Raw;
    }
}
",
                                        "name": "GetGeneratedTestCaseFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.serialization.ObjectSchema<
    serializers.v2.v3.GetGeneratedTestCaseTemplateFileRequest.Raw,
    TraceApi.v2.v3.GetGeneratedTestCaseTemplateFileRequest
> = core.serialization.object({
    template: core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
    interface Raw {
        template: serializers.v2.v3.TestCaseTemplate.Raw;
    }
}
",
                                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const LightweightProblemInfoV2: core.serialization.ObjectSchema<
    serializers.v2.v3.LightweightProblemInfoV2.Raw,
    TraceApi.v2.v3.LightweightProblemInfoV2
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).ProblemId),
    problemName: core.serialization.string(),
    problemVersion: core.serialization.number(),
    variableTypes: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableType)
    ),
});

export declare namespace LightweightProblemInfoV2 {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemName: string;
        problemVersion: number;
        variableTypes: serializers.VariableType.Raw[];
    }
}
",
                                        "name": "LightweightProblemInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const NonVoidFunctionDefinition: core.serialization.ObjectSchema<
    serializers.v2.v3.NonVoidFunctionDefinition.Raw,
    TraceApi.v2.v3.NonVoidFunctionDefinition
> = core.serialization.object({
    signature: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.NonVoidFunctionSignature
    ),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace NonVoidFunctionDefinition {
    interface Raw {
        signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
        code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                        "name": "NonVoidFunctionDefinition.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const NonVoidFunctionSignature: core.serialization.ObjectSchema<
    serializers.v2.v3.NonVoidFunctionSignature.Raw,
    TraceApi.v2.v3.NonVoidFunctionSignature
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Parameter)
    ),
    returnType: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableType),
});

export declare namespace NonVoidFunctionSignature {
    interface Raw {
        parameters: serializers.v2.v3.Parameter.Raw[];
        returnType: serializers.VariableType.Raw;
    }
}
",
                                        "name": "NonVoidFunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const Parameter: core.serialization.ObjectSchema<serializers.v2.v3.Parameter.Raw, TraceApi.v2.v3.Parameter> =
    core.serialization.object({
        parameterId: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.ParameterId),
        name: core.serialization.string(),
        variableType: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableType),
    });

export declare namespace Parameter {
    interface Raw {
        parameterId: serializers.v2.v3.ParameterId.Raw;
        name: string;
        variableType: serializers.VariableType.Raw;
    }
}
",
                                        "name": "Parameter.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const ParameterId: core.serialization.Schema<serializers.v2.v3.ParameterId.Raw, TraceApi.v2.v3.ParameterId> =
    core.serialization.string().transform({
        transform: TraceApi.v2.v3.ParameterId,
        untransform: (value) => value,
    });

export declare namespace ParameterId {
    type Raw = string;
}
",
                                        "name": "ParameterId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const ProblemInfoV2: core.serialization.ObjectSchema<
    serializers.v2.v3.ProblemInfoV2.Raw,
    TraceApi.v2.v3.ProblemInfoV2
> = core.serialization.object({
    problemId: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).ProblemId),
    problemDescription: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).ProblemDescription
    ),
    problemName: core.serialization.string(),
    problemVersion: core.serialization.number(),
    supportedLanguages: core.serialization.list(
        core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).Language)
    ),
    customFiles: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.CustomFiles),
    generatedFiles: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.GeneratedFiles
    ),
    customTestCaseTemplates: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplate)
    ),
    testcases: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseV2)
    ),
    isPublic: core.serialization.boolean(),
});

export declare namespace ProblemInfoV2 {
    interface Raw {
        problemId: serializers.ProblemId.Raw;
        problemDescription: serializers.ProblemDescription.Raw;
        problemName: string;
        problemVersion: number;
        supportedLanguages: serializers.Language.Raw[];
        customFiles: serializers.v2.v3.CustomFiles.Raw;
        generatedFiles: serializers.v2.v3.GeneratedFiles.Raw;
        customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
        testcases: serializers.v2.v3.TestCaseV2.Raw[];
        isPublic: boolean;
    }
}
",
                                        "name": "ProblemInfoV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseExpects: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseExpects.Raw,
    TraceApi.v2.v3.TestCaseExpects
> = core.serialization.object({
    expectedStdout: core.serialization.string().optional(),
});

export declare namespace TestCaseExpects {
    interface Raw {
        expectedStdout?: string | null;
    }
}
",
                                        "name": "TestCaseExpects.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseFunction: core.serialization.Schema<
    serializers.v2.v3.TestCaseFunction.Raw,
    TraceApi.v2.v3.TestCaseFunction
> = core.serialization
    .union(\\"type\\", {
        withActualResult: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseWithActualResultImplementation
        ),
        custom: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.VoidFunctionDefinition
        ),
    })
    .transform<TraceApi.v2.v3.TestCaseFunction>({
        transform: (value) => {
            switch (value.type) {
                case \\"withActualResult\\":
                    return TraceApi.v2.v3.TestCaseFunction.withActualResult(value);
                case \\"custom\\":
                    return TraceApi.v2.v3.TestCaseFunction.custom(value);
                default:
                    return TraceApi.v2.v3.TestCaseFunction._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseFunction {
    type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

    interface WithActualResult extends serializers.v2.v3.TestCaseWithActualResultImplementation.Raw {
        type: \\"withActualResult\\";
    }

    interface Custom extends serializers.v2.v3.VoidFunctionDefinition.Raw {
        type: \\"custom\\";
    }
}
",
                                        "name": "TestCaseFunction.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseId: core.serialization.Schema<serializers.v2.v3.TestCaseId.Raw, TraceApi.v2.v3.TestCaseId> =
    core.serialization.string().transform({
        transform: TraceApi.v2.v3.TestCaseId,
        untransform: (value) => value,
    });

export declare namespace TestCaseId {
    type Raw = string;
}
",
                                        "name": "TestCaseId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseImplementation: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseImplementation.Raw,
    TraceApi.v2.v3.TestCaseImplementation
> = core.serialization.object({
    description: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementationDescription
    ),
    function: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
    interface Raw {
        description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
        function: serializers.v2.v3.TestCaseFunction.Raw;
    }
}
",
                                        "name": "TestCaseImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseImplementationDescription: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseImplementationDescription.Raw,
    TraceApi.v2.v3.TestCaseImplementationDescription
> = core.serialization.object({
    boards: core.serialization.list(
        core.serialization.lazy(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementationDescriptionBoard
        )
    ),
});

export declare namespace TestCaseImplementationDescription {
    interface Raw {
        boards: serializers.v2.v3.TestCaseImplementationDescriptionBoard.Raw[];
    }
}
",
                                        "name": "TestCaseImplementationDescription.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseImplementationDescriptionBoard: core.serialization.Schema<
    serializers.v2.v3.TestCaseImplementationDescriptionBoard.Raw,
    TraceApi.v2.v3.TestCaseImplementationDescriptionBoard
> = core.serialization
    .union(\\"type\\", {
        html: core.serialization.object({
            value: core.serialization.string(),
        }),
        paramId: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.ParameterId),
        }),
    })
    .transform<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard>({
        transform: (value) => {
            switch (value.type) {
                case \\"html\\":
                    return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.html(value.value);
                case \\"paramId\\":
                    return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.paramId(value.value);
                default:
                    return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseImplementationDescriptionBoard {
    type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

    interface Html {
        type: \\"html\\";
        value: string;
    }

    interface ParamId {
        type: \\"paramId\\";
        value: serializers.v2.v3.ParameterId.Raw;
    }
}
",
                                        "name": "TestCaseImplementationDescriptionBoard.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseImplementationReference: core.serialization.Schema<
    serializers.v2.v3.TestCaseImplementationReference.Raw,
    TraceApi.v2.v3.TestCaseImplementationReference
> = core.serialization
    .union(\\"type\\", {
        templateId: core.serialization.object({
            value: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplateId),
        }),
        implementation: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementation
        ),
    })
    .transform<TraceApi.v2.v3.TestCaseImplementationReference>({
        transform: (value) => {
            switch (value.type) {
                case \\"templateId\\":
                    return TraceApi.v2.v3.TestCaseImplementationReference.templateId(value.value);
                case \\"implementation\\":
                    return TraceApi.v2.v3.TestCaseImplementationReference.implementation(value);
                default:
                    return TraceApi.v2.v3.TestCaseImplementationReference._unknown(value);
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TestCaseImplementationReference {
    type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

    interface TemplateId {
        type: \\"templateId\\";
        value: serializers.v2.v3.TestCaseTemplateId.Raw;
    }

    interface Implementation extends serializers.v2.v3.TestCaseImplementation.Raw {
        type: \\"implementation\\";
    }
}
",
                                        "name": "TestCaseImplementationReference.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseMetadata: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseMetadata.Raw,
    TraceApi.v2.v3.TestCaseMetadata
> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseId),
    name: core.serialization.string(),
    hidden: core.serialization.boolean(),
});

export declare namespace TestCaseMetadata {
    interface Raw {
        id: serializers.v2.v3.TestCaseId.Raw;
        name: string;
        hidden: boolean;
    }
}
",
                                        "name": "TestCaseMetadata.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseTemplate: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseTemplate.Raw,
    TraceApi.v2.v3.TestCaseTemplate
> = core.serialization.object({
    templateId: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseTemplateId),
    name: core.serialization.string(),
    implementation: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementation
    ),
});

export declare namespace TestCaseTemplate {
    interface Raw {
        templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
        name: string;
        implementation: serializers.v2.v3.TestCaseImplementation.Raw;
    }
}
",
                                        "name": "TestCaseTemplate.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseTemplateId: core.serialization.Schema<
    serializers.v2.v3.TestCaseTemplateId.Raw,
    TraceApi.v2.v3.TestCaseTemplateId
> = core.serialization.string().transform({
    transform: TraceApi.v2.v3.TestCaseTemplateId,
    untransform: (value) => value,
});

export declare namespace TestCaseTemplateId {
    type Raw = string;
}
",
                                        "name": "TestCaseTemplateId.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseV2: core.serialization.ObjectSchema<serializers.v2.v3.TestCaseV2.Raw, TraceApi.v2.v3.TestCaseV2> =
    core.serialization.object({
        metadata: core.serialization.lazyObject(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseMetadata
        ),
        implementation: core.serialization.lazy(
            async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseImplementationReference
        ),
        arguments: core.serialization.record(
            core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).v2.v3.ParameterId),
            core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableValue).optional()
        ),
        expects: core.serialization
            .lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.TestCaseExpects)
            .optional(),
    });

export declare namespace TestCaseV2 {
    interface Raw {
        metadata: serializers.v2.v3.TestCaseMetadata.Raw;
        implementation: serializers.v2.v3.TestCaseImplementationReference.Raw;
        arguments: Record<serializers.v2.v3.ParameterId.Raw, serializers.VariableValue.Raw | null | undefined>;
        expects?: serializers.v2.v3.TestCaseExpects.Raw | null;
    }
}
",
                                        "name": "TestCaseV2.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const TestCaseWithActualResultImplementation: core.serialization.ObjectSchema<
    serializers.v2.v3.TestCaseWithActualResultImplementation.Raw,
    TraceApi.v2.v3.TestCaseWithActualResultImplementation
> = core.serialization.object({
    getActualResult: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.NonVoidFunctionDefinition
    ),
    assertCorrectnessCheck: core.serialization.lazy(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.AssertCorrectnessCheck
    ),
});

export declare namespace TestCaseWithActualResultImplementation {
    interface Raw {
        getActualResult: serializers.v2.v3.NonVoidFunctionDefinition.Raw;
        assertCorrectnessCheck: serializers.v2.v3.AssertCorrectnessCheck.Raw;
    }
}
",
                                        "name": "TestCaseWithActualResultImplementation.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const VoidFunctionDefinition: core.serialization.ObjectSchema<
    serializers.v2.v3.VoidFunctionDefinition.Raw,
    TraceApi.v2.v3.VoidFunctionDefinition
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Parameter)
    ),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace VoidFunctionDefinition {
    interface Raw {
        parameters: serializers.v2.v3.Parameter.Raw[];
        code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                        "name": "VoidFunctionDefinition.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.serialization.ObjectSchema<
    serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult.Raw,
    TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
> = core.serialization.object({
    additionalParameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Parameter)
    ),
    code: core.serialization.lazyObject(
        async () => (await import(\\"../../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
    ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
    interface Raw {
        additionalParameters: serializers.v2.v3.Parameter.Raw[];
        code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const VoidFunctionSignature: core.serialization.ObjectSchema<
    serializers.v2.v3.VoidFunctionSignature.Raw,
    TraceApi.v2.v3.VoidFunctionSignature
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Parameter)
    ),
});

export declare namespace VoidFunctionSignature {
    interface Raw {
        parameters: serializers.v2.v3.Parameter.Raw[];
    }
}
",
                                        "name": "VoidFunctionSignature.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../../core\\";

export const VoidFunctionSignatureThatTakesActualResult: core.serialization.ObjectSchema<
    serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult.Raw,
    TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
> = core.serialization.object({
    parameters: core.serialization.list(
        core.serialization.lazyObject(async () => (await import(\\"../../../../../../..\\")).v2.v3.Parameter)
    ),
    actualResultType: core.serialization.lazy(async () => (await import(\\"../../../../../../..\\")).VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
    interface Raw {
        parameters: serializers.v2.v3.Parameter.Raw[];
        actualResultType: serializers.VariableType.Raw;
    }
}
",
                                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                        "type": "file",
                                      },
                                      Object {
                                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                        "name": "index.ts",
                                        "type": "file",
                                      },
                                    ],
                                    "name": "types",
                                    "type": "directory",
                                  },
                                ],
                                "name": "problem",
                                "type": "directory",
                              },
                            ],
                            "name": "resources",
                            "type": "directory",
                          },
                        ],
                        "name": "v3",
                        "type": "directory",
                      },
                    ],
                    "name": "resources",
                    "type": "directory",
                  },
                ],
                "name": "v2",
                "type": "directory",
              },
            ],
            "name": "resources",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"extendedDiagnostics\\": true,
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"CommonJS\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"dist\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-trace/api-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as FernIr from "../../../../../../api/index";
import * as core from "../../../../../../core";
import { LiteralType } from "./LiteralType";
import { TypeId } from "../../../../commons/types/TypeId";
import { PrimitiveTypeV1 } from "../../../../types/types/PrimitiveTypeV1";

export const TypeReference: core.serialization.Schema<
    serializers.dynamic.TypeReference.Raw,
    FernIr.dynamic.TypeReference
> = core.serialization
    .union("type", {
        list: core.serialization.object({
            value: core.serialization.lazy(() => serializers.dynamic.TypeReference),
        }),
        literal: core.serialization.object({
            value: LiteralType,
        }),
        map: core.serialization.lazyObject(() => serializers.dynamic.MapType),
        named: core.serialization.object({
            value: TypeId,
        }),
        nullable: core.serialization.object({
            value: core.serialization.lazy(() => serializers.dynamic.TypeReference),
        }),
        optional: core.serialization.object({
            value: core.serialization.lazy(() => serializers.dynamic.TypeReference),
        }),
        primitive: core.serialization.object({
            value: PrimitiveTypeV1,
        }),
        set: core.serialization.object({
            value: core.serialization.lazy(() => serializers.dynamic.TypeReference),
        }),
        unknown: core.serialization.object({}),
    })
    .transform<FernIr.dynamic.TypeReference>({
        transform: (value) => {
            switch (value.type) {
                case "list":
                    return FernIr.dynamic.TypeReference.list(value.value);
                case "literal":
                    return FernIr.dynamic.TypeReference.literal(value.value);
                case "map":
                    return FernIr.dynamic.TypeReference.map(value);
                case "named":
                    return FernIr.dynamic.TypeReference.named(value.value);
                case "nullable":
                    return FernIr.dynamic.TypeReference.nullable(value.value);
                case "optional":
                    return FernIr.dynamic.TypeReference.optional(value.value);
                case "primitive":
                    return FernIr.dynamic.TypeReference.primitive(value.value);
                case "set":
                    return FernIr.dynamic.TypeReference.set(value.value);
                case "unknown":
                    return FernIr.dynamic.TypeReference.unknown();
                default:
                    return value as FernIr.dynamic.TypeReference;
            }
        },
        untransform: ({ _visit, ...value }) => value as any,
    });

export declare namespace TypeReference {
    export type Raw =
        | TypeReference.List
        | TypeReference.Literal
        | TypeReference.Map
        | TypeReference.Named
        | TypeReference.Nullable
        | TypeReference.Optional
        | TypeReference.Primitive
        | TypeReference.Set
        | TypeReference.Unknown;

    export interface List {
        type: "list";
        value: serializers.dynamic.TypeReference.Raw;
    }

    export interface Literal {
        type: "literal";
        value: LiteralType.Raw;
    }

    export interface Map extends serializers.dynamic.MapType.Raw {
        type: "map";
    }

    export interface Named {
        type: "named";
        value: TypeId.Raw;
    }

    export interface Nullable {
        type: "nullable";
        value: serializers.dynamic.TypeReference.Raw;
    }

    export interface Optional {
        type: "optional";
        value: serializers.dynamic.TypeReference.Raw;
    }

    export interface Primitive {
        type: "primitive";
        value: PrimitiveTypeV1.Raw;
    }

    export interface Set {
        type: "set";
        value: serializers.dynamic.TypeReference.Raw;
    }

    export interface Unknown {
        type: "unknown";
    }
}

/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { BamlStream } from "@boundaryml/baml"

export interface BlockEvent {
  block_label: string
  event_type: "enter" | "exit"
}

export interface VarEvent<T> {
  variable_name: string
  value: T
  timestamp: string
  function_name: string
}

// Internal stream event from Rust FFI
interface InternalStreamEvent {
  streamId: string
  eventType: "start" | "update" | "end"
  value?: any
}

// Simple async iterable stream for emit events
class EmitStream<PartialT, FinalT> implements BamlStream<PartialT, FinalT> {
  private eventQueue: (PartialT | null)[] = []
  private isComplete = false

  pushValue(value: PartialT): void {
    this.eventQueue.push(value)
  }

  complete(): void {
    this.isComplete = true
    this.eventQueue.push(null)
  }

  async *[Symbol.asyncIterator](): AsyncIterableIterator<PartialT> {
    while (true) {
      const event = this.eventQueue.shift()

      if (event === undefined) {
        if (this.isComplete) {
          break
        }
        // Wait a bit for more events
        await new Promise(resolve => setTimeout(resolve, 10))
        continue
      }

      if (event === null) {
        break
      }

      yield event
    }
  }

  async getFinalResponse(): Promise<FinalT> {
    // For emit streams, just get the last value
    let lastValue: PartialT | null = null
    for await (const value of this) {
      lastValue = value
    }
    return lastValue as unknown as FinalT
  }

  toStreamable(): ReadableStream<Uint8Array> {
    throw new Error("toStreamable not implemented for EmitStream")
  }
}

type BlockHandler = (event: BlockEvent) => void
type VarHandler<T> = (event: VarEvent<T>) => void
type StreamHandler<PartialT, FinalT> = (event: VarEvent<BamlStream<PartialT, FinalT>>) => void
type InternalStreamHandler = (event: InternalStreamEvent) => void

export interface InternalEventBindings {
  functionName: string
  block: BlockHandler[]
  vars: Record<string, VarHandler<any>[]>
  streams: Record<string, InternalStreamHandler[]>
  functions: Record<string, InternalEventBindings>
}

export interface EventCollectorInternal {
  __handlers(): InternalEventBindings
}


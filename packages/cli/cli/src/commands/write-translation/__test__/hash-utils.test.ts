import { join, RelativeFilePath } from "@fern-api/fs-utils";
import { existsSync } from "fs";
import { mkdir, readFile, rmdir, writeFile } from "fs/promises";
import path from "path";
import tmp from "tmp-promise";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import {
    calculateContentHash,
    cleanupHashMappings,
    FileHashMap,
    hasFileChanged,
    loadHashMappings,
    saveHashMappings,
    updateHashForFile
} from "../hash-utils";

describe("hash-utils", () => {
    let tempDir: tmp.DirectoryResult;
    let testDir: string;

    beforeEach(async () => {
        tempDir = await tmp.dir();
        testDir = tempDir.path;
    });

    afterEach(async () => {
        try {
            await tempDir.cleanup();
        } catch {
            // Ignore cleanup errors
        }
    });

    describe("calculateContentHash", () => {
        it("should generate consistent SHA-256 hashes for the same content", () => {
            const content = "Hello, world!";
            const hash1 = calculateContentHash(content);
            const hash2 = calculateContentHash(content);

            expect(hash1).toBe(hash2);
            expect(hash1).toMatch(/^[a-f0-9]{64}$/); // SHA-256 is 64 hex chars
        });

        it("should generate different hashes for different content", () => {
            const content1 = "Hello, world!";
            const content2 = "Hello, universe!";

            const hash1 = calculateContentHash(content1);
            const hash2 = calculateContentHash(content2);

            expect(hash1).not.toBe(hash2);
        });
    });

    describe("loadHashMappings and saveHashMappings", () => {
        it("should return empty object when .hashes file doesn't exist", async () => {
            const result = await loadHashMappings(testDir);
            expect(result).toEqual({});
        });

        it("should save and load hash mappings correctly", async () => {
            const mappings: FileHashMap = {
                "file1.md": "hash1",
                "dir/file2.md": "hash2"
            };

            await saveHashMappings(testDir, mappings);

            const hashesFilePath = path.join(testDir, ".hashes");
            expect(existsSync(hashesFilePath)).toBe(true);

            const loaded = await loadHashMappings(testDir);
            expect(loaded).toEqual(mappings);
        });

        it("should save hash mappings in sorted order with comment", async () => {
            const mappings: FileHashMap = {
                "z-file.md": "hash-z",
                "a-file.md": "hash-a",
                "m-file.md": "hash-m"
            };

            await saveHashMappings(testDir, mappings);

            const hashesFilePath = path.join(testDir, ".hashes");
            const content = await readFile(hashesFilePath, "utf-8");
            const parsed = JSON.parse(content);

            // Check that comment is present
            expect(parsed._comment).toContain("auto-generated by Fern");

            // Check that hash keys are in sorted order (excluding comment)
            const { _comment, ...hashKeys } = parsed;
            const keys = Object.keys(hashKeys);
            expect(keys).toEqual(["a-file.md", "m-file.md", "z-file.md"]);
        });

        it("should load hash mappings correctly, ignoring comment field", async () => {
            // Manually create a .hashes file with comment field
            const hashesFilePath = path.join(testDir, ".hashes");
            const fileContent = {
                _comment: "Test comment",
                "file1.md": "hash1",
                "file2.md": "hash2"
            };
            await writeFile(hashesFilePath, JSON.stringify(fileContent), "utf-8");

            const loaded = await loadHashMappings(testDir);

            // Should load mappings but exclude the comment
            expect(loaded).toEqual({
                "file1.md": "hash1",
                "file2.md": "hash2"
            });
        });

        it("should handle corrupted .hashes file gracefully", async () => {
            const hashesFilePath = path.join(testDir, ".hashes");
            await writeFile(hashesFilePath, "invalid json", "utf-8");

            const result = await loadHashMappings(testDir);
            expect(result).toEqual({});
        });
    });

    describe("hasFileChanged", () => {
        it("should return true for new files", async () => {
            const filePath = path.join(testDir, "test.md");
            await writeFile(filePath, "test content", "utf-8");

            const result = await hasFileChanged(filePath, "test.md" as RelativeFilePath, {});
            expect(result).toBe(true);
        });

        it("should return false when content hasn't changed", async () => {
            const content = "test content";
            const filePath = path.join(testDir, "test.md");
            await writeFile(filePath, content, "utf-8");

            const hash = calculateContentHash(content);
            const previousHashes: FileHashMap = {
                "test.md": hash
            };

            const result = await hasFileChanged(filePath, "test.md" as RelativeFilePath, previousHashes);
            expect(result).toBe(false);
        });

        it("should return true when content has changed", async () => {
            const oldContent = "old content";
            const newContent = "new content";
            const filePath = path.join(testDir, "test.md");

            // Create file with new content
            await writeFile(filePath, newContent, "utf-8");

            // But hash mapping has old content hash
            const oldHash = calculateContentHash(oldContent);
            const previousHashes: FileHashMap = {
                "test.md": oldHash
            };

            const result = await hasFileChanged(filePath, "test.md" as RelativeFilePath, previousHashes);
            expect(result).toBe(true);
        });

        it("should return true when file cannot be read", async () => {
            const nonExistentPath = path.join(testDir, "nonexistent.md");
            const previousHashes: FileHashMap = {
                "nonexistent.md": "some-hash"
            };

            const result = await hasFileChanged(nonExistentPath, "nonexistent.md" as RelativeFilePath, previousHashes);
            expect(result).toBe(true);
        });
    });

    describe("updateHashForFile", () => {
        it("should update hash mapping with correct hash", () => {
            const content = "test content";
            const mappings: FileHashMap = {};

            updateHashForFile(mappings, "test.md" as RelativeFilePath, content);

            const expectedHash = calculateContentHash(content);
            expect(mappings["test.md"]).toBe(expectedHash);
        });

        it("should overwrite existing hash mapping", () => {
            const content = "new content";
            const mappings: FileHashMap = {
                "test.md": "old-hash"
            };

            updateHashForFile(mappings, "test.md" as RelativeFilePath, content);

            const expectedHash = calculateContentHash(content);
            expect(mappings["test.md"]).toBe(expectedHash);
        });
    });

    describe("cleanupHashMappings", () => {
        it("should remove mappings for files that no longer exist", () => {
            const mappings: FileHashMap = {
                "existing.md": "hash1",
                "deleted.md": "hash2",
                "also-existing.md": "hash3"
            };

            const existingFiles = new Set(["existing.md" as RelativeFilePath, "also-existing.md" as RelativeFilePath]);

            const cleaned = cleanupHashMappings(mappings, existingFiles);

            expect(cleaned).toEqual({
                "existing.md": "hash1",
                "also-existing.md": "hash3"
            });
        });

        it("should return empty object when no files exist", () => {
            const mappings: FileHashMap = {
                "deleted1.md": "hash1",
                "deleted2.md": "hash2"
            };

            const existingFiles = new Set<RelativeFilePath>();

            const cleaned = cleanupHashMappings(mappings, existingFiles);

            expect(cleaned).toEqual({});
        });
    });
});

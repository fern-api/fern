import { RelativeFilePath } from "@fern-api/fs-utils";
import { createHash } from "crypto";
import { existsSync } from "fs";
import { readFile, writeFile } from "fs/promises";
import path from "path";

export interface FileHashMap {
    [relativePath: string]: string;
}

/**
 * Calculate SHA-256 hash of file content
 */
export function calculateContentHash(content: string): string {
    return createHash("sha256").update(content, "utf-8").digest("hex");
}

/**
 * Load hash mappings from .hashes file
 */
export async function loadHashMappings(translationsDirectory: string): Promise<FileHashMap> {
    const hashesFilePath = path.join(translationsDirectory, ".hashes");

    if (!existsSync(hashesFilePath)) {
        return {};
    }

    try {
        const hashesContent = await readFile(hashesFilePath, "utf-8");
        const parsed = JSON.parse(hashesContent);

        // Remove the comment field if it exists (for backward/forward compatibility)
        const { _comment, ...hashMappings } = parsed;

        return hashMappings as FileHashMap;
    } catch (error) {
        // If the file is corrupted or invalid, start fresh
        return {};
    }
}

/**
 * Save hash mappings to .hashes file
 */
export async function saveHashMappings(translationsDirectory: string, hashMappings: FileHashMap): Promise<void> {
    const hashesFilePath = path.join(translationsDirectory, ".hashes");
    const sortedMappings: FileHashMap = {};

    // Sort keys for consistent file format
    Object.keys(hashMappings)
        .sort()
        .forEach((key) => {
            const value = hashMappings[key];
            if (value !== undefined) {
                sortedMappings[key] = value;
            }
        });

    // Create the file content with explanatory comment
    const fileContent = {
        _comment:
            "This file is auto-generated by Fern to track source file changes for translation purposes. Do not edit manually - it will be overwritten on the next translation update.",
        ...sortedMappings
    };

    await writeFile(hashesFilePath, JSON.stringify(fileContent, null, 2), "utf-8");
}

/**
 * Check if file content has changed by comparing hashes
 */
export async function hasFileChanged(
    filePath: string,
    relativePath: RelativeFilePath,
    previousHashes: FileHashMap
): Promise<boolean> {
    try {
        const content = await readFile(filePath, "utf-8");
        const currentHash = calculateContentHash(content);
        const previousHash = previousHashes[relativePath];

        return currentHash !== previousHash;
    } catch (error) {
        // If we can't read the file, consider it changed
        return true;
    }
}

/**
 * Update hash mapping for a specific file
 */
export function updateHashForFile(hashMappings: FileHashMap, relativePath: RelativeFilePath, content: string): void {
    const hash = calculateContentHash(content);
    hashMappings[relativePath] = hash;
}

/**
 * Remove hash mapping for files that no longer exist
 */
export function cleanupHashMappings(hashMappings: FileHashMap, existingFiles: Set<RelativeFilePath>): FileHashMap {
    const cleanedMappings: FileHashMap = {};

    for (const [relativePath, hash] of Object.entries(hashMappings)) {
        if (existingFiles.has(relativePath as RelativeFilePath)) {
            cleanedMappings[relativePath] = hash;
        }
    }

    return cleanedMappings;
}

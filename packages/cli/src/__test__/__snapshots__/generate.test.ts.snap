// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator trace client 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
        "name": ".npmignore",
        "type": "file",
      },
      Object {
        "contents": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type SendTestSubmissionUpdateErrorBody = never;

export declare namespace SendTestSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendTestSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendTestSubmissionUpdateErrorBody, visitor: SendTestSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendTestSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendTestSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendTestSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionUpdate;
}
",
                        "name": "SendTestSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendTestSubmissionUpdateResponse = SendTestSubmissionUpdateResponse.SuccessResponse | SendTestSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendTestSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendTestSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendTestSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SendWorkspaceSubmissionUpdateErrorBody = never;

export declare namespace SendWorkspaceSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendWorkspaceSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendWorkspaceSubmissionUpdateErrorBody, visitor: SendWorkspaceSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendWorkspaceSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendWorkspaceSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendWorkspaceSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionUpdate;
}
",
                        "name": "SendWorkspaceSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendWorkspaceSubmissionUpdateResponse = SendWorkspaceSubmissionUpdateResponse.SuccessResponse | SendWorkspaceSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendWorkspaceSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendWorkspaceSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendWorkspaceSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseErrorBody = never;

export declare namespace StoreTracedTestCaseErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseErrorBody, visitor: StoreTracedTestCaseErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseResponse = StoreTracedTestCaseResponse.SuccessResponse | StoreTracedTestCaseResponse.ErrorResponse;

export declare namespace StoreTracedTestCaseResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseV2ErrorBody = never;

export declare namespace StoreTracedTestCaseV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseV2ErrorBody, visitor: StoreTracedTestCaseV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedTestCaseV2Request {
    submissionId: model.submission.SubmissionId;
    testCaseId: model.v2.problem.TestCaseId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedTestCaseV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseV2Response = StoreTracedTestCaseV2Response.SuccessResponse | StoreTracedTestCaseV2Response.ErrorResponse;

export declare namespace StoreTracedTestCaseV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseV2ErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceErrorBody = never;

export declare namespace StoreTracedWorkspaceErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceErrorBody, visitor: StoreTracedWorkspaceErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceResponse = StoreTracedWorkspaceResponse.SuccessResponse | StoreTracedWorkspaceResponse.ErrorResponse;

export declare namespace StoreTracedWorkspaceResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceV2ErrorBody = never;

export declare namespace StoreTracedWorkspaceV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceV2ErrorBody, visitor: StoreTracedWorkspaceV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedWorkspaceV2Request {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedWorkspaceV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceV2Response = StoreTracedWorkspaceV2Response.SuccessResponse | StoreTracedWorkspaceV2Response.ErrorResponse;

export declare namespace StoreTracedWorkspaceV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceV2ErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateTestSubmissionStatusErrorBody = never;

export declare namespace UpdateTestSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateTestSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateTestSubmissionStatusErrorBody, visitor: UpdateTestSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateTestSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateTestSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateTestSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionStatus;
}
",
                        "name": "UpdateTestSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateTestSubmissionStatusResponse = UpdateTestSubmissionStatusResponse.SuccessResponse | UpdateTestSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateTestSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateTestSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateTestSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateWorkspaceSubmissionStatusErrorBody = never;

export declare namespace UpdateWorkspaceSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateWorkspaceSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateWorkspaceSubmissionStatusErrorBody, visitor: UpdateWorkspaceSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateWorkspaceSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateWorkspaceSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateWorkspaceSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionStatus;
}
",
                        "name": "UpdateWorkspaceSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateWorkspaceSubmissionStatusResponse = UpdateWorkspaceSubmissionStatusResponse.SuccessResponse | UpdateWorkspaceSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateWorkspaceSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateWorkspaceSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateWorkspaceSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedTestCaseRequest {
    submissionId: model.submission.SubmissionId;
    testCaseId: string;
    body: model.admin.StoreTracedTestCaseRequest;
}
",
                        "name": "_StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedWorkspaceRequest {
    submissionId: model.submission.SubmissionId;
    body: model.admin.StoreTracedWorkspaceRequest;
}
",
                        "name": "_StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UpdateTestSubmissionStatusRequest\\";
export * from \\"./UpdateTestSubmissionStatusErrorBody\\";
export * from \\"./UpdateTestSubmissionStatusResponse\\";
export * from \\"./SendTestSubmissionUpdateRequest\\";
export * from \\"./SendTestSubmissionUpdateErrorBody\\";
export * from \\"./SendTestSubmissionUpdateResponse\\";
export * from \\"./UpdateWorkspaceSubmissionStatusRequest\\";
export * from \\"./UpdateWorkspaceSubmissionStatusErrorBody\\";
export * from \\"./UpdateWorkspaceSubmissionStatusResponse\\";
export * from \\"./SendWorkspaceSubmissionUpdateRequest\\";
export * from \\"./SendWorkspaceSubmissionUpdateErrorBody\\";
export * from \\"./SendWorkspaceSubmissionUpdateResponse\\";
export * from \\"./_StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedTestCaseErrorBody\\";
export * from \\"./StoreTracedTestCaseResponse\\";
export * from \\"./StoreTracedTestCaseV2Request\\";
export * from \\"./StoreTracedTestCaseV2ErrorBody\\";
export * from \\"./StoreTracedTestCaseV2Response\\";
export * from \\"./_StoreTracedWorkspaceRequest\\";
export * from \\"./StoreTracedWorkspaceErrorBody\\";
export * from \\"./StoreTracedWorkspaceResponse\\";
export * from \\"./StoreTracedWorkspaceV2Request\\";
export * from \\"./StoreTracedWorkspaceV2ErrorBody\\";
export * from \\"./StoreTracedWorkspaceV2Response\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "AdminService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./AdminService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedTestCaseRequest {
    result: model.submission.TestCaseResultWithStdout;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: model.submission.WorkspaceRunDetails;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: model.commons.NodeId;
    fullTree: model.commons.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    right: model.commons.NodeId | null | undefined;
    left: model.commons.NodeId | null | undefined;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeValue {
    root: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugKeyValuePairs {
    key: model.commons.DebugVariableValue;
    value: model.commons.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugMapValue {
    keyValuePairs: model.commons.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type DebugVariableValue =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

export declare namespace DebugVariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.DebugMapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends commons.BinaryTreeNodeAndTreeValue {
        _type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends commons.SinglyLinkedListNodeAndListValue {
        _type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends commons.DoublyLinkedListNodeAndListValue {
        _type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        _type: \\"undefinedValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    interface GenericValue extends commons.GenericValue {
        _type: \\"genericValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.DebugMapValue) => Result;
        listValue: (value: commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: commons.GenericValue) => Result;
        _unknown: () => Result;
    }
}

export const DebugVariableValue = {
    integerValue: (value: number): DebugVariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): DebugVariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): DebugVariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.DebugMapValue): DebugVariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
        ...value,
        _type: \\"binaryTreeNodeValue\\"
    }),

    singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
        ...value,
        _type: \\"singlyLinkedListNodeValue\\"
    }),

    doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
        ...value,
        _type: \\"doublyLinkedListNodeValue\\"
    }),

    undefinedValue: (): DebugVariableValue.UndefinedValue => ({
        _type: \\"undefinedValue\\"
    }),

    nullValue: (): DebugVariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    genericValue: (value: commons.GenericValue): DebugVariableValue.GenericValue => ({
        ...value,
        _type: \\"genericValue\\"
    }),

    _visit: <Result>(value: DebugVariableValue, visitor: DebugVariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeNodeValue\\": return visitor.binaryTreeNodeValue(value);
            case \\"singlyLinkedListNodeValue\\": return visitor.singlyLinkedListNodeValue(value);
            case \\"doublyLinkedListNodeValue\\": return visitor.doublyLinkedListNodeValue(value);
            case \\"undefinedValue\\": return visitor.undefinedValue();
            case \\"nullValue\\": return visitor.nullValue();
            case \\"genericValue\\": return visitor.genericValue(value);
            default: return visitor._unknown();
        }
    },

    _types: (): DebugVariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeNodeValue\\", \\"singlyLinkedListNodeValue\\", \\"doublyLinkedListNodeValue\\", \\"undefinedValue\\", \\"nullValue\\", \\"genericValue\\"],
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
    prev: model.commons.NodeId | null | undefined;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericValue {
    stringifiedType: string | null | undefined;
    stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface KeyValuePair {
    key: model.commons.VariableValue;
    value: model.commons.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type Language =
    | \\"JAVA\\"
    | \\"JAVASCRIPT\\"
    | \\"PYTHON\\";

export const Language = {
    Java: \\"JAVA\\",
    Javascript: \\"JAVASCRIPT\\",
    Python: \\"PYTHON\\",

    _visit: <Result>(value: Language, visitor: Language._Visitor<Result>): Result => {
        switch (value) {
            case Language.Java: return visitor.java();
            case Language.Javascript: return visitor.javascript();
            case Language.Python: return visitor.python();
            default: return visitor._unknown();
        }
    },

    _values: (): Language[] => [Language.Java, Language.Javascript, Language.Python],
} as const;

export declare namespace Language {
    type Java = \\"JAVA\\";
    type Javascript = \\"JAVASCRIPT\\";
    type Python = \\"PYTHON\\";

    export interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ListType {
    valueType: model.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength: boolean | null | undefined;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapType {
    keyType: model.commons.VariableType;
    valueType: model.commons.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapValue {
    keyValuePairs: model.commons.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type NodeId = string;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ProblemId = string;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCase {
    id: string;
    params: model.commons.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseWithExpectedResult {
    testCase: model.commons.TestCase;
    expectedResult: model.commons.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UserId = string;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableType =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

export declare namespace VariableType {
    interface IntegerType {
        _type: \\"integerType\\";
    }

    interface DoubleType {
        _type: \\"doubleType\\";
    }

    interface BooleanType {
        _type: \\"booleanType\\";
    }

    interface StringType {
        _type: \\"stringType\\";
    }

    interface CharType {
        _type: \\"charType\\";
    }

    interface ListType extends commons.ListType {
        _type: \\"listType\\";
    }

    interface MapType extends commons.MapType {
        _type: \\"mapType\\";
    }

    interface BinaryTreeType {
        _type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        _type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        _type: \\"doublyLinkedListType\\";
    }

    export interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: commons.ListType) => Result;
        mapType: (value: commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: () => Result;
    }
}

export const VariableType = {
    integerType: (): VariableType.IntegerType => ({
        _type: \\"integerType\\"
    }),

    doubleType: (): VariableType.DoubleType => ({
        _type: \\"doubleType\\"
    }),

    booleanType: (): VariableType.BooleanType => ({
        _type: \\"booleanType\\"
    }),

    stringType: (): VariableType.StringType => ({
        _type: \\"stringType\\"
    }),

    charType: (): VariableType.CharType => ({
        _type: \\"charType\\"
    }),

    listType: (value: commons.ListType): VariableType.ListType => ({
        ...value,
        _type: \\"listType\\"
    }),

    mapType: (value: commons.MapType): VariableType.MapType => ({
        ...value,
        _type: \\"mapType\\"
    }),

    binaryTreeType: (): VariableType.BinaryTreeType => ({
        _type: \\"binaryTreeType\\"
    }),

    singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
        _type: \\"singlyLinkedListType\\"
    }),

    doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
        _type: \\"doublyLinkedListType\\"
    }),

    _visit: <Result>(value: VariableType, visitor: VariableType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerType\\": return visitor.integerType();
            case \\"doubleType\\": return visitor.doubleType();
            case \\"booleanType\\": return visitor.booleanType();
            case \\"stringType\\": return visitor.stringType();
            case \\"charType\\": return visitor.charType();
            case \\"listType\\": return visitor.listType(value);
            case \\"mapType\\": return visitor.mapType(value);
            case \\"binaryTreeType\\": return visitor.binaryTreeType();
            case \\"singlyLinkedListType\\": return visitor.singlyLinkedListType();
            case \\"doublyLinkedListType\\": return visitor.doublyLinkedListType();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableType[\\"_type\\"][] => [\\"integerType\\", \\"doubleType\\", \\"booleanType\\", \\"stringType\\", \\"charType\\", \\"listType\\", \\"mapType\\", \\"binaryTreeType\\", \\"singlyLinkedListType\\", \\"doublyLinkedListType\\"],
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableValue =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

export declare namespace VariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.MapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.VariableValue[];
    }

    interface BinaryTreeValue extends commons.BinaryTreeValue {
        _type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends commons.SinglyLinkedListValue {
        _type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends commons.DoublyLinkedListValue {
        _type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.MapValue) => Result;
        listValue: (value: commons.VariableValue[]) => Result;
        binaryTreeValue: (value: commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: () => Result;
    }
}

export const VariableValue = {
    integerValue: (value: number): VariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): VariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): VariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): VariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): VariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.MapValue): VariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.VariableValue[]): VariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeValue: (value: commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
        ...value,
        _type: \\"binaryTreeValue\\"
    }),

    singlyLinkedListValue: (value: commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
        ...value,
        _type: \\"singlyLinkedListValue\\"
    }),

    doublyLinkedListValue: (value: commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
        ...value,
        _type: \\"doublyLinkedListValue\\"
    }),

    nullValue: (): VariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    _visit: <Result>(value: VariableValue, visitor: VariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeValue\\": return visitor.binaryTreeValue(value);
            case \\"singlyLinkedListValue\\": return visitor.singlyLinkedListValue(value);
            case \\"doublyLinkedListValue\\": return visitor.doublyLinkedListValue(value);
            case \\"nullValue\\": return visitor.nullValue();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeValue\\", \\"singlyLinkedListValue\\", \\"doublyLinkedListValue\\", \\"nullValue\\"],
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetHomepageProblemsErrorBody = never;

export declare namespace GetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: GetHomepageProblemsErrorBody, visitor: GetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetHomepageProblemsResponse = GetHomepageProblemsResponse.SuccessResponse | GetHomepageProblemsResponse.ErrorResponse;

export declare namespace GetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.commons.ProblemId[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.GetHomepageProblemsErrorBody;
    }
}
",
                        "name": "GetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetHomepageProblemsErrorBody = never;

export declare namespace SetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: SetHomepageProblemsErrorBody, visitor: SetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetHomepageProblemsResponse = SetHomepageProblemsResponse.SuccessResponse | SetHomepageProblemsResponse.ErrorResponse;

export declare namespace SetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.SetHomepageProblemsErrorBody;
    }
}
",
                        "name": "SetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetHomepageProblemsErrorBody\\";
export * from \\"./GetHomepageProblemsResponse\\";
export * from \\"./SetHomepageProblemsErrorBody\\";
export * from \\"./SetHomepageProblemsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "HomepageProblemService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./HomepageProblemService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export interface LangServerRequest {
    request: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LangServerResponse {
    response: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "lang-server",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetAttemptedMigrationsErrorBody = never;

export declare namespace GetAttemptedMigrationsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetAttemptedMigrationsErrorBody = {
    _visit: <Result>(_value: GetAttemptedMigrationsErrorBody, visitor: GetAttemptedMigrationsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetAttemptedMigrationsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetAttemptedMigrationsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetAttemptedMigrationsResponse = GetAttemptedMigrationsResponse.SuccessResponse | GetAttemptedMigrationsResponse.ErrorResponse;

export declare namespace GetAttemptedMigrationsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.migration.Migration[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.migration.GetAttemptedMigrationsErrorBody;
    }
}
",
                        "name": "GetAttemptedMigrationsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetAttemptedMigrationsErrorBody\\";
export * from \\"./GetAttemptedMigrationsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "MigrationInfoService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationInfoService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Migration {
    name: string;
    status: model.migration.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type MigrationStatus =
    | \\"RUNNING\\"
    | \\"FAILED\\"
    | \\"FINISHED\\";

export const MigrationStatus = {
    Running: \\"RUNNING\\",
    Failed: \\"FAILED\\",
    Finished: \\"FINISHED\\",

    _visit: <Result>(value: MigrationStatus, visitor: MigrationStatus._Visitor<Result>): Result => {
        switch (value) {
            case MigrationStatus.Running: return visitor.running();
            case MigrationStatus.Failed: return visitor.failed();
            case MigrationStatus.Finished: return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _values: (): MigrationStatus[] => [MigrationStatus.Running, MigrationStatus.Failed, MigrationStatus.Finished],
} as const;

export declare namespace MigrationStatus {
    type Running = \\"RUNNING\\";
    type Failed = \\"FAILED\\";
    type Finished = \\"FINISHED\\";

    export interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistIdNotFoundError {
    playlistId: model.playlist.PlaylistId;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UnauthorizedError = Record<string, never>;
",
                    "name": "UnauthorizedError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_errors",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreatePlaylistErrorBody = never;

export declare namespace CreatePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreatePlaylistErrorBody = {
    _visit: <Result>(_value: CreatePlaylistErrorBody, visitor: CreatePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreatePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreatePlaylistResponse = CreatePlaylistResponse.SuccessResponse | CreatePlaylistResponse.ErrorResponse;

export declare namespace CreatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.CreatePlaylistErrorBody;
    }
}
",
                        "name": "CreatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeletePlaylistErrorBody = never;

export declare namespace DeletePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeletePlaylistErrorBody = {
    _visit: <Result>(_value: DeletePlaylistErrorBody, visitor: DeletePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeletePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeletePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeletePlaylistRequest {
    playlist_id: model.playlist.PlaylistId;
}
",
                        "name": "DeletePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeletePlaylistResponse = DeletePlaylistResponse.SuccessResponse | DeletePlaylistResponse.ErrorResponse;

export declare namespace DeletePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.DeletePlaylistErrorBody;
    }
}
",
                        "name": "DeletePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPlaylistErrorBody =
    | GetPlaylistErrorBody.PlaylistIdNotFoundError
    | GetPlaylistErrorBody.UnauthorizedError;

export declare namespace GetPlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    interface UnauthorizedError {
        _error: \\"UnauthorizedError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        UnauthorizedError: () => Result;
        _unknown: () => Result;
    }
}

export const GetPlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): GetPlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    unauthorizedError: (): GetPlaylistErrorBody.UnauthorizedError => ({
        _error: \\"UnauthorizedError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPlaylistErrorBody, visitor: GetPlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            case \\"UnauthorizedError\\": return visitor.UnauthorizedError();
            default: return visitor._unknown();
        }
    },

    _types: (): GetPlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\", \\"UnauthorizedError\\"],
} as const;
",
                        "name": "GetPlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetPlaylistRequest {
    playlistId: model.playlist.PlaylistId;
}
",
                        "name": "GetPlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistResponse = GetPlaylistResponse.SuccessResponse | GetPlaylistResponse.ErrorResponse;

export declare namespace GetPlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistErrorBody;
    }
}
",
                        "name": "GetPlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetPlaylistsErrorBody = never;

export declare namespace GetPlaylistsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetPlaylistsErrorBody = {
    _visit: <Result>(_value: GetPlaylistsErrorBody, visitor: GetPlaylistsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetPlaylistsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetPlaylistsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetPlaylistsRequest {
    limit: number | null | undefined;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistsResponse = GetPlaylistsResponse.SuccessResponse | GetPlaylistsResponse.ErrorResponse;

export declare namespace GetPlaylistsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistsErrorBody;
    }
}
",
                        "name": "GetPlaylistsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type UpdatePlaylistErrorBody =
    | UpdatePlaylistErrorBody.PlaylistIdNotFoundError;

export declare namespace UpdatePlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const UpdatePlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): UpdatePlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: UpdatePlaylistErrorBody, visitor: UpdatePlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): UpdatePlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\"],
} as const;
",
                        "name": "UpdatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdatePlaylistResponse = UpdatePlaylistResponse.SuccessResponse | UpdatePlaylistResponse.ErrorResponse;

export declare namespace UpdatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.UpdatePlaylistErrorBody;
    }
}
",
                        "name": "UpdatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _UpdatePlaylistRequest {
    playlistId: model.playlist.PlaylistId;
    body: model.playlist.UpdatePlaylistRequest | null | undefined;
}
",
                        "name": "_UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreatePlaylistErrorBody\\";
export * from \\"./CreatePlaylistResponse\\";
export * from \\"./GetPlaylistsRequest\\";
export * from \\"./GetPlaylistsErrorBody\\";
export * from \\"./GetPlaylistsResponse\\";
export * from \\"./GetPlaylistRequest\\";
export * from \\"./GetPlaylistErrorBody\\";
export * from \\"./GetPlaylistResponse\\";
export * from \\"./_UpdatePlaylistRequest\\";
export * from \\"./UpdatePlaylistErrorBody\\";
export * from \\"./UpdatePlaylistResponse\\";
export * from \\"./DeletePlaylistRequest\\";
export * from \\"./DeletePlaylistErrorBody\\";
export * from \\"./DeletePlaylistResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "PlaylistCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Playlist {
    playlist_id: model.playlist.PlaylistId;
    name: string;
    problems: model.commons.ProblemId[];
    \\"owner-id\\": model.commons.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type PlaylistId = string;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateProblemErrorBody = never;

export declare namespace CreateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateProblemErrorBody = {
    _visit: <Result>(_value: CreateProblemErrorBody, visitor: CreateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeleteProblemErrorBody = never;

export declare namespace DeleteProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeleteProblemErrorBody = {
    _visit: <Result>(_value: DeleteProblemErrorBody, visitor: DeleteProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeleteProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeleteProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeleteProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                        "name": "DeleteProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeleteProblemResponse = DeleteProblemResponse.SuccessResponse | DeleteProblemResponse.ErrorResponse;

export declare namespace DeleteProblemResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.DeleteProblemErrorBody;
    }
}
",
                        "name": "DeleteProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetDefaultStarterFilesErrorBody = never;

export declare namespace GetDefaultStarterFilesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetDefaultStarterFilesErrorBody = {
    _visit: <Result>(_value: GetDefaultStarterFilesErrorBody, visitor: GetDefaultStarterFilesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetDefaultStarterFilesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetDefaultStarterFilesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateProblemErrorBody = never;

export declare namespace UpdateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateProblemErrorBody = {
    _visit: <Result>(_value: UpdateProblemErrorBody, visitor: UpdateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateProblemRequest {
    problemId: model.commons.ProblemId;
    body: model.problem.CreateProblemRequest;
}
",
                        "name": "UpdateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _CreateProblemResponse = _CreateProblemResponse.SuccessResponse | _CreateProblemResponse.ErrorResponse;

export declare namespace _CreateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.CreateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.CreateProblemErrorBody;
    }
}
",
                        "name": "_CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _GetDefaultStarterFilesResponse = _GetDefaultStarterFilesResponse.SuccessResponse | _GetDefaultStarterFilesResponse.ErrorResponse;

export declare namespace _GetDefaultStarterFilesResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.GetDefaultStarterFilesResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.GetDefaultStarterFilesErrorBody;
    }
}
",
                        "name": "_GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _UpdateProblemResponse = _UpdateProblemResponse.SuccessResponse | _UpdateProblemResponse.ErrorResponse;

export declare namespace _UpdateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.UpdateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.UpdateProblemErrorBody;
    }
}
",
                        "name": "_UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateProblemErrorBody\\";
export * from \\"./_CreateProblemResponse\\";
export * from \\"./UpdateProblemRequest\\";
export * from \\"./UpdateProblemErrorBody\\";
export * from \\"./_UpdateProblemResponse\\";
export * from \\"./DeleteProblemRequest\\";
export * from \\"./DeleteProblemErrorBody\\";
export * from \\"./DeleteProblemResponse\\";
export * from \\"./GetDefaultStarterFilesErrorBody\\";
export * from \\"./_GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ProblemCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { problem } from \\"../..\\";

export type CreateProblemError =
    | CreateProblemError.Generic;

export declare namespace CreateProblemError {
    interface Generic extends problem.GenericCreateProblemError {
        _type: \\"generic\\";
    }

    export interface _Visitor<Result> {
        generic: (value: problem.GenericCreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemError = {
    generic: (value: problem.GenericCreateProblemError): CreateProblemError.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    _visit: <Result>(value: CreateProblemError, visitor: CreateProblemError._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemError[\\"_type\\"][] => [\\"generic\\"],
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { problem, commons } from \\"../..\\";

export type CreateProblemResponse =
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error;

export declare namespace CreateProblemResponse {
    interface Success {
        _type: \\"success\\";
        success: commons.ProblemId;
    }

    interface Error {
        _type: \\"error\\";
        error: problem.CreateProblemError;
    }

    export interface _Visitor<Result> {
        success: (value: commons.ProblemId) => Result;
        error: (value: problem.CreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemResponse = {
    success: (value: commons.ProblemId): CreateProblemResponse.Success => ({
        success: value,
        _type: \\"success\\"
    }),

    error: (value: problem.CreateProblemError): CreateProblemResponse.Error => ({
        error: value,
        _type: \\"error\\"
    }),

    _visit: <Result>(value: CreateProblemResponse, visitor: CreateProblemResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"success\\": return visitor.success(value.success);
            case \\"error\\": return visitor.error(value.error);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemResponse[\\"_type\\"][] => [\\"success\\", \\"error\\"],
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemDescription {
    boards: model.problem.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type ProblemDescriptionBoard =
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

export declare namespace ProblemDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface Variable {
        _type: \\"variable\\";
        variable: commons.VariableValue;
    }

    interface TestCaseId {
        _type: \\"testCaseId\\";
        testCaseId: string;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const ProblemDescriptionBoard = {
    html: (value: string): ProblemDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    variable: (value: commons.VariableValue): ProblemDescriptionBoard.Variable => ({
        variable: value,
        _type: \\"variable\\"
    }),

    testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
        testCaseId: value,
        _type: \\"testCaseId\\"
    }),

    _visit: <Result>(value: ProblemDescriptionBoard, visitor: ProblemDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"variable\\": return visitor.variable(value.variable);
            case \\"testCaseId\\": return visitor.testCaseId(value.testCaseId);
            default: return visitor._unknown();
        }
    },

    _types: (): ProblemDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"variable\\", \\"testCaseId\\"],
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemFiles {
    solutionFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemInfo {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface VariableTypeAndName {
    variableType: model.commons.VariableType;
    name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateExecutionSessionErrorBody = never;

export declare namespace CreateExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateExecutionSessionErrorBody = {
    _visit: <Result>(_value: CreateExecutionSessionErrorBody, visitor: CreateExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateExecutionSessionRequest {
    language: model.commons.Language;
}
",
                        "name": "CreateExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreateExecutionSessionResponse = CreateExecutionSessionResponse.SuccessResponse | CreateExecutionSessionResponse.ErrorResponse;

export declare namespace CreateExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.CreateExecutionSessionErrorBody;
    }
}
",
                        "name": "CreateExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionErrorBody = never;

export declare namespace GetExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionErrorBody, visitor: GetExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "GetExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionResponse = GetExecutionSessionResponse.SuccessResponse | GetExecutionSessionResponse.ErrorResponse;

export declare namespace GetExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionErrorBody;
    }
}
",
                        "name": "GetExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionsStateErrorBody = never;

export declare namespace GetExecutionSessionsStateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionsStateErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionsStateErrorBody, visitor: GetExecutionSessionsStateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionsStateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionsStateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionsStateResponse = GetExecutionSessionsStateResponse.SuccessResponse | GetExecutionSessionsStateResponse.ErrorResponse;

export declare namespace GetExecutionSessionsStateResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.GetExecutionSessionStateResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionsStateErrorBody;
    }
}
",
                        "name": "GetExecutionSessionsStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StopExecutionSessionErrorBody = never;

export declare namespace StopExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StopExecutionSessionErrorBody = {
    _visit: <Result>(_value: StopExecutionSessionErrorBody, visitor: StopExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StopExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StopExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface StopExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "StopExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StopExecutionSessionResponse = StopExecutionSessionResponse.SuccessResponse | StopExecutionSessionResponse.ErrorResponse;

export declare namespace StopExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.StopExecutionSessionErrorBody;
    }
}
",
                        "name": "StopExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateExecutionSessionRequest\\";
export * from \\"./CreateExecutionSessionErrorBody\\";
export * from \\"./CreateExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionRequest\\";
export * from \\"./GetExecutionSessionErrorBody\\";
export * from \\"./GetExecutionSessionResponse\\";
export * from \\"./StopExecutionSessionRequest\\";
export * from \\"./StopExecutionSessionErrorBody\\";
export * from \\"./StopExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionsStateErrorBody\\";
export * from \\"./GetExecutionSessionsStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ExecutionSesssionManagementService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type ActualResult =
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

export declare namespace ActualResult {
    interface Value {
        _type: \\"value\\";
        value: commons.VariableValue;
    }

    interface Exception extends submission.ExceptionInfo {
        _type: \\"exception\\";
    }

    interface ExceptionV2 {
        _type: \\"exceptionV2\\";
        exceptionV2: submission.ExceptionV2;
    }

    export interface _Visitor<Result> {
        value: (value: commons.VariableValue) => Result;
        exception: (value: submission.ExceptionInfo) => Result;
        exceptionV2: (value: submission.ExceptionV2) => Result;
        _unknown: () => Result;
    }
}

export const ActualResult = {
    value: (value: commons.VariableValue): ActualResult.Value => ({
        value: value,
        _type: \\"value\\"
    }),

    exception: (value: submission.ExceptionInfo): ActualResult.Exception => ({
        ...value,
        _type: \\"exception\\"
    }),

    exceptionV2: (value: submission.ExceptionV2): ActualResult.ExceptionV2 => ({
        exceptionV2: value,
        _type: \\"exceptionV2\\"
    }),

    _visit: <Result>(value: ActualResult, visitor: ActualResult._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"value\\": return visitor.value(value.value);
            case \\"exception\\": return visitor.exception(value);
            case \\"exceptionV2\\": return visitor.exceptionV2(value.exceptionV2);
            default: return visitor._unknown();
        }
    },

    _types: (): ActualResult[\\"_type\\"][] => [\\"value\\", \\"exception\\", \\"exceptionV2\\"],
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BuildingExecutorResponse {
    submissionId: model.submission.SubmissionId;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type CodeExecutionUpdate =
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends submission.BuildingExecutorResponse {
        _type: \\"buildingExecutor\\";
    }

    interface Running extends submission.RunningResponse {
        _type: \\"running\\";
    }

    interface Errored extends submission.ErroredResponse {
        _type: \\"errored\\";
    }

    interface Stopped extends submission.StoppedResponse {
        _type: \\"stopped\\";
    }

    interface Graded extends submission.GradedResponse {
        _type: \\"graded\\";
    }

    interface GradedV2 extends submission.GradedResponseV2 {
        _type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends submission.WorkspaceRanResponse {
        _type: \\"workspaceRan\\";
    }

    interface Recording extends submission.RecordingResponseNotification {
        _type: \\"recording\\";
    }

    interface Recorded extends submission.RecordedResponseNotification {
        _type: \\"recorded\\";
    }

    interface InvalidRequest extends submission.InvalidRequestResponse {
        _type: \\"invalidRequest\\";
    }

    interface Finished extends submission.FinishedResponse {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        buildingExecutor: (value: submission.BuildingExecutorResponse) => Result;
        running: (value: submission.RunningResponse) => Result;
        errored: (value: submission.ErroredResponse) => Result;
        stopped: (value: submission.StoppedResponse) => Result;
        graded: (value: submission.GradedResponse) => Result;
        gradedV2: (value: submission.GradedResponseV2) => Result;
        workspaceRan: (value: submission.WorkspaceRanResponse) => Result;
        recording: (value: submission.RecordingResponseNotification) => Result;
        recorded: (value: submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: submission.InvalidRequestResponse) => Result;
        finished: (value: submission.FinishedResponse) => Result;
        _unknown: () => Result;
    }
}

export const CodeExecutionUpdate = {
    buildingExecutor: (value: submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
        ...value,
        _type: \\"buildingExecutor\\"
    }),

    running: (value: submission.RunningResponse): CodeExecutionUpdate.Running => ({
        ...value,
        _type: \\"running\\"
    }),

    errored: (value: submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
        ...value,
        _type: \\"errored\\"
    }),

    stopped: (value: submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
        ...value,
        _type: \\"stopped\\"
    }),

    graded: (value: submission.GradedResponse): CodeExecutionUpdate.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
        ...value,
        _type: \\"gradedV2\\"
    }),

    workspaceRan: (value: submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
        ...value,
        _type: \\"workspaceRan\\"
    }),

    recording: (value: submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
        ...value,
        _type: \\"recording\\"
    }),

    recorded: (value: submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
        ...value,
        _type: \\"recorded\\"
    }),

    invalidRequest: (value: submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
        ...value,
        _type: \\"invalidRequest\\"
    }),

    finished: (value: submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
        ...value,
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: CodeExecutionUpdate, visitor: CodeExecutionUpdate._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"buildingExecutor\\": return visitor.buildingExecutor(value);
            case \\"running\\": return visitor.running(value);
            case \\"errored\\": return visitor.errored(value);
            case \\"stopped\\": return visitor.stopped(value);
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value);
            case \\"workspaceRan\\": return visitor.workspaceRan(value);
            case \\"recording\\": return visitor.recording(value);
            case \\"recorded\\": return visitor.recorded(value);
            case \\"invalidRequest\\": return visitor.invalidRequest(value);
            case \\"finished\\": return visitor.finished(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CodeExecutionUpdate[\\"_type\\"][] => [\\"buildingExecutor\\", \\"running\\", \\"errored\\", \\"stopped\\", \\"graded\\", \\"gradedV2\\", \\"workspaceRan\\", \\"recording\\", \\"recorded\\", \\"invalidRequest\\", \\"finished\\"],
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface CompileError {
    message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CustomTestCasesUnsupported {
    problemId: model.commons.ProblemId;
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ErrorInfo =
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError;

export declare namespace ErrorInfo {
    interface CompileError extends submission.CompileError {
        _type: \\"compileError\\";
    }

    interface RuntimeError extends submission.RuntimeError {
        _type: \\"runtimeError\\";
    }

    interface InternalError extends submission.InternalError {
        _type: \\"internalError\\";
    }

    export interface _Visitor<Result> {
        compileError: (value: submission.CompileError) => Result;
        runtimeError: (value: submission.RuntimeError) => Result;
        internalError: (value: submission.InternalError) => Result;
        _unknown: () => Result;
    }
}

export const ErrorInfo = {
    compileError: (value: submission.CompileError): ErrorInfo.CompileError => ({
        ...value,
        _type: \\"compileError\\"
    }),

    runtimeError: (value: submission.RuntimeError): ErrorInfo.RuntimeError => ({
        ...value,
        _type: \\"runtimeError\\"
    }),

    internalError: (value: submission.InternalError): ErrorInfo.InternalError => ({
        ...value,
        _type: \\"internalError\\"
    }),

    _visit: <Result>(value: ErrorInfo, visitor: ErrorInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"compileError\\": return visitor.compileError(value);
            case \\"runtimeError\\": return visitor.runtimeError(value);
            case \\"internalError\\": return visitor.internalError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): ErrorInfo[\\"_type\\"][] => [\\"compileError\\", \\"runtimeError\\", \\"internalError\\"],
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ErroredResponse {
    submissionId: model.submission.SubmissionId;
    errorInfo: model.submission.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ExceptionV2 =
    | ExceptionV2.Generic
    | ExceptionV2.Timeout;

export declare namespace ExceptionV2 {
    interface Generic extends submission.ExceptionInfo {
        _type: \\"generic\\";
    }

    interface Timeout {
        _type: \\"timeout\\";
    }

    export interface _Visitor<Result> {
        generic: (value: submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: () => Result;
    }
}

export const ExceptionV2 = {
    generic: (value: submission.ExceptionInfo): ExceptionV2.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    timeout: (): ExceptionV2.Timeout => ({
        _type: \\"timeout\\"
    }),

    _visit: <Result>(value: ExceptionV2, visitor: ExceptionV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            case \\"timeout\\": return visitor.timeout();
            default: return visitor._unknown();
        }
    },

    _types: (): ExceptionV2[\\"_type\\"][] => [\\"generic\\", \\"timeout\\"],
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionState {
    lastTimeContacted: string | null | undefined;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ExecutionSessionStatus =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
    CreatingContainer: \\"CREATING_CONTAINER\\",
    ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
    PendingContainer: \\"PENDING_CONTAINER\\",
    RunningContainer: \\"RUNNING_CONTAINER\\",
    LiveContainer: \\"LIVE_CONTAINER\\",
    FailedToLaunch: \\"FAILED_TO_LAUNCH\\",

    _visit: <Result>(value: ExecutionSessionStatus, visitor: ExecutionSessionStatus._Visitor<Result>): Result => {
        switch (value) {
            case ExecutionSessionStatus.CreatingContainer: return visitor.creatingContainer();
            case ExecutionSessionStatus.ProvisioningContainer: return visitor.provisioningContainer();
            case ExecutionSessionStatus.PendingContainer: return visitor.pendingContainer();
            case ExecutionSessionStatus.RunningContainer: return visitor.runningContainer();
            case ExecutionSessionStatus.LiveContainer: return visitor.liveContainer();
            case ExecutionSessionStatus.FailedToLaunch: return visitor.failedToLaunch();
            default: return visitor._unknown();
        }
    },

    _values: (): ExecutionSessionStatus[] => [ExecutionSessionStatus.CreatingContainer, ExecutionSessionStatus.ProvisioningContainer, ExecutionSessionStatus.PendingContainer, ExecutionSessionStatus.RunningContainer, ExecutionSessionStatus.LiveContainer, ExecutionSessionStatus.FailedToLaunch],
} as const;

export declare namespace ExecutionSessionStatus {
    type CreatingContainer = \\"CREATING_CONTAINER\\";
    type ProvisioningContainer = \\"PROVISIONING_CONTAINER\\";
    type PendingContainer = \\"PENDING_CONTAINER\\";
    type RunningContainer = \\"RUNNING_CONTAINER\\";
    type LiveContainer = \\"LIVE_CONTAINER\\";
    type FailedToLaunch = \\"FAILED_TO_LAUNCH\\";

    export interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface FinishedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, model.submission.ExecutionSessionState>;
    numWarmingInstances: number | null | undefined;
    warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted: string | null | undefined;
    submission: string;
    language: model.commons.Language;
    submissionTypeState: model.submission.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GetTraceResponsesPageRequest {
    offset: number | null | undefined;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponse {
    submissionId: model.submission.SubmissionId;
    testCases: Record<string, model.submission.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponseV2 {
    submissionId: model.submission.SubmissionId;
    testCases: Record<model.v2.problem.TestCaseId, model.submission.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    grade: model.submission.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InitializeProblemRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InternalError {
    exceptionInfo: model.submission.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type InvalidRequestCause =
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends submission.SubmissionIdNotFound {
        _type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends submission.CustomTestCasesUnsupported {
        _type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends submission.UnexpectedLanguageError {
        _type: \\"unexpectedLanguage\\";
    }

    export interface _Visitor<Result> {
        submissionIdNotFound: (value: submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: submission.UnexpectedLanguageError) => Result;
        _unknown: () => Result;
    }
}

export const InvalidRequestCause = {
    submissionIdNotFound: (value: submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
        ...value,
        _type: \\"submissionIdNotFound\\"
    }),

    customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
        ...value,
        _type: \\"customTestCasesUnsupported\\"
    }),

    unexpectedLanguage: (value: submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
        ...value,
        _type: \\"unexpectedLanguage\\"
    }),

    _visit: <Result>(value: InvalidRequestCause, visitor: InvalidRequestCause._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"submissionIdNotFound\\": return visitor.submissionIdNotFound(value);
            case \\"customTestCasesUnsupported\\": return visitor.customTestCasesUnsupported(value);
            case \\"unexpectedLanguage\\": return visitor.unexpectedLanguage(value);
            default: return visitor._unknown();
        }
    },

    _types: (): InvalidRequestCause[\\"_type\\"][] => [\\"submissionIdNotFound\\", \\"customTestCasesUnsupported\\", \\"unexpectedLanguage\\"],
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InvalidRequestResponse {
    request: model.submission.SubmissionRequest;
    cause: model.submission.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedResponseNotification {
    submissionId: model.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId: string | null | undefined;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordingResponseNotification {
    submissionId: model.submission.SubmissionId;
    testCaseId: string | null | undefined;
    lineNumber: number;
    lightweightStackInfo: model.submission.LightweightStackframeInformation;
    tracedFile: model.submission.TracedFile | null | undefined;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RunningResponse {
    submissionId: model.submission.SubmissionId;
    state: model.submission.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type RunningSubmissionState =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
    QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
    KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
    CompilingSubmission: \\"COMPILING_SUBMISSION\\",
    RunningSubmission: \\"RUNNING_SUBMISSION\\",

    _visit: <Result>(value: RunningSubmissionState, visitor: RunningSubmissionState._Visitor<Result>): Result => {
        switch (value) {
            case RunningSubmissionState.QueueingSubmission: return visitor.queueingSubmission();
            case RunningSubmissionState.KillingHistoricalSubmissions: return visitor.killingHistoricalSubmissions();
            case RunningSubmissionState.WritingSubmissionToFile: return visitor.writingSubmissionToFile();
            case RunningSubmissionState.CompilingSubmission: return visitor.compilingSubmission();
            case RunningSubmissionState.RunningSubmission: return visitor.runningSubmission();
            default: return visitor._unknown();
        }
    },

    _values: (): RunningSubmissionState[] => [RunningSubmissionState.QueueingSubmission, RunningSubmissionState.KillingHistoricalSubmissions, RunningSubmissionState.WritingSubmissionToFile, RunningSubmissionState.CompilingSubmission, RunningSubmissionState.RunningSubmission],
} as const;

export declare namespace RunningSubmissionState {
    type QueueingSubmission = \\"QUEUEING_SUBMISSION\\";
    type KillingHistoricalSubmissions = \\"KILLING_HISTORICAL_SUBMISSIONS\\";
    type WritingSubmissionToFile = \\"WRITING_SUBMISSION_TO_FILE\\";
    type CompilingSubmission = \\"COMPILING_SUBMISSION\\";
    type RunningSubmission = \\"RUNNING_SUBMISSION\\";

    export interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface RuntimeError {
    message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Scope {
    variables: Record<string, model.commons.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ShareId = string;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: model.submission.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame: model.submission.StackFrame | null | undefined;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StderrResponse {
    submissionId: model.submission.SubmissionId;
    stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StdoutResponse {
    submissionId: model.submission.SubmissionId;
    stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StopRequest {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoppedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type SubmissionId = string;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: model.submission.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionRequest =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends submission.InitializeProblemRequest {
        _type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        _type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends submission.SubmitRequestV2 {
        _type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends submission.WorkspaceSubmitRequest {
        _type: \\"workspaceSubmit\\";
    }

    interface Stop extends submission.StopRequest {
        _type: \\"stop\\";
    }

    export interface _Visitor<Result> {
        initializeProblemRequest: (value: submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: submission.WorkspaceSubmitRequest) => Result;
        stop: (value: submission.StopRequest) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionRequest = {
    initializeProblemRequest: (value: submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
        ...value,
        _type: \\"initializeProblemRequest\\"
    }),

    initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
        _type: \\"initializeWorkspaceRequest\\"
    }),

    submitV2: (value: submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
        ...value,
        _type: \\"submitV2\\"
    }),

    workspaceSubmit: (value: submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
        ...value,
        _type: \\"workspaceSubmit\\"
    }),

    stop: (value: submission.StopRequest): SubmissionRequest.Stop => ({
        ...value,
        _type: \\"stop\\"
    }),

    _visit: <Result>(value: SubmissionRequest, visitor: SubmissionRequest._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"initializeProblemRequest\\": return visitor.initializeProblemRequest(value);
            case \\"initializeWorkspaceRequest\\": return visitor.initializeWorkspaceRequest();
            case \\"submitV2\\": return visitor.submitV2(value);
            case \\"workspaceSubmit\\": return visitor.workspaceSubmit(value);
            case \\"stop\\": return visitor.stop(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionRequest[\\"_type\\"][] => [\\"initializeProblemRequest\\", \\"initializeWorkspaceRequest\\", \\"submitV2\\", \\"workspaceSubmit\\", \\"stop\\"],
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type SubmissionResponse =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

export declare namespace SubmissionResponse {
    interface ServerInitialized {
        _type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        _type: \\"problemInitialized\\";
        problemInitialized: commons.ProblemId;
    }

    interface WorkspaceInitialized {
        _type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends submission.ExceptionInfo {
        _type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        _type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: submission.CodeExecutionUpdate;
    }

    interface Terminated extends submission.TerminatedResponse {
        _type: \\"terminated\\";
    }

    export interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: submission.CodeExecutionUpdate) => Result;
        terminated: (value: submission.TerminatedResponse) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionResponse = {
    serverInitialized: (): SubmissionResponse.ServerInitialized => ({
        _type: \\"serverInitialized\\"
    }),

    problemInitialized: (value: commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
        problemInitialized: value,
        _type: \\"problemInitialized\\"
    }),

    workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
        _type: \\"workspaceInitialized\\"
    }),

    serverErrored: (value: submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
        ...value,
        _type: \\"serverErrored\\"
    }),

    codeExecutionUpdate: (value: submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
        codeExecutionUpdate: value,
        _type: \\"codeExecutionUpdate\\"
    }),

    terminated: (value: submission.TerminatedResponse): SubmissionResponse.Terminated => ({
        ...value,
        _type: \\"terminated\\"
    }),

    _visit: <Result>(value: SubmissionResponse, visitor: SubmissionResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"serverInitialized\\": return visitor.serverInitialized();
            case \\"problemInitialized\\": return visitor.problemInitialized(value.problemInitialized);
            case \\"workspaceInitialized\\": return visitor.workspaceInitialized();
            case \\"serverErrored\\": return visitor.serverErrored(value);
            case \\"codeExecutionUpdate\\": return visitor.codeExecutionUpdate(value.codeExecutionUpdate);
            case \\"terminated\\": return visitor.terminated(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionResponse[\\"_type\\"][] => [\\"serverInitialized\\", \\"problemInitialized\\", \\"workspaceInitialized\\", \\"serverErrored\\", \\"codeExecutionUpdate\\", \\"terminated\\"],
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusForTestCase =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends submission.TestCaseResultWithStdout {
        _type: \\"graded\\";
    }

    interface GradedV2 {
        _type: \\"gradedV2\\";
        gradedV2: submission.TestCaseGrade;
    }

    interface Traced extends submission.TracedTestCase {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        graded: (value: submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: submission.TestCaseGrade) => Result;
        traced: (value: submission.TracedTestCase) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusForTestCase = {
    graded: (value: submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
        gradedV2: value,
        _type: \\"gradedV2\\"
    }),

    traced: (value: submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: SubmissionStatusForTestCase, visitor: SubmissionStatusForTestCase._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value.gradedV2);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusForTestCase[\\"_type\\"][] => [\\"graded\\", \\"gradedV2\\", \\"traced\\"],
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusV2 =
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace;

export declare namespace SubmissionStatusV2 {
    interface Test extends submission.TestSubmissionStatusV2 {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionStatusV2 {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionStatusV2) => Result;
        workspace: (value: submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusV2 = {
    test: (value: submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionStatusV2, visitor: SubmissionStatusV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusV2[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum =
    | \\"TEST\\";

export const SubmissionTypeEnum = {
    Test: \\"TEST\\",

    _visit: <Result>(value: SubmissionTypeEnum, visitor: SubmissionTypeEnum._Visitor<Result>): Result => {
        switch (value) {
            case SubmissionTypeEnum.Test: return visitor.test();
            default: return visitor._unknown();
        }
    },

    _values: (): SubmissionTypeEnum[] => [SubmissionTypeEnum.Test],
} as const;

export declare namespace SubmissionTypeEnum {
    type Test = \\"TEST\\";

    export interface _Visitor<Result> {
        test: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionTypeState =
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace;

export declare namespace SubmissionTypeState {
    interface Test extends submission.TestSubmissionState {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionState {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionState) => Result;
        workspace: (value: submission.WorkspaceSubmissionState) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionTypeState = {
    test: (value: submission.TestSubmissionState): SubmissionTypeState.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionTypeState, visitor: SubmissionTypeState._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionTypeState[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmitRequestV2 {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
    userId: string | null | undefined;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TerminatedResponse {
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestCaseGrade =
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden;

export declare namespace TestCaseGrade {
    interface Hidden extends submission.TestCaseHiddenGrade {
        _type: \\"hidden\\";
    }

    interface NonHidden extends submission.TestCaseNonHiddenGrade {
        _type: \\"nonHidden\\";
    }

    export interface _Visitor<Result> {
        hidden: (value: submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: submission.TestCaseNonHiddenGrade) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseGrade = {
    hidden: (value: submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
        ...value,
        _type: \\"hidden\\"
    }),

    nonHidden: (value: submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
        ...value,
        _type: \\"nonHidden\\"
    }),

    _visit: <Result>(value: TestCaseGrade, visitor: TestCaseGrade._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"hidden\\": return visitor.hidden(value);
            case \\"nonHidden\\": return visitor.nonHidden(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseGrade[\\"_type\\"][] => [\\"hidden\\", \\"nonHidden\\"],
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult: model.commons.VariableValue | null | undefined;
    exception: model.submission.ExceptionV2 | null | undefined;
    stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResult {
    expectedResult: model.commons.VariableValue;
    actualResult: model.submission.ActualResult;
    passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResultWithStdout {
    result: model.submission.TestCaseResult;
    stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionState {
    problemId: model.commons.ProblemId;
    defaultTestCases: model.commons.TestCase[];
    customTestCases: model.commons.TestCase[];
    status: model.submission.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionStatus =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

export declare namespace TestSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface TestCaseIdToState {
        _type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, submission.SubmissionStatusForTestCase>;
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>) => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionStatus = {
    stopped: (): TestSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
        testCaseIdToState: value,
        _type: \\"testCaseIdToState\\"
    }),

    _visit: <Result>(value: TestSubmissionStatus, visitor: TestSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"testCaseIdToState\\": return visitor.testCaseIdToState(value.testCaseIdToState);
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"testCaseIdToState\\"],
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionStatusV2 {
    updates: model.submission.TestSubmissionUpdate[];
    problemId: model.commons.ProblemId;
    problemVersion: number;
    problemInfo: model.v2.problem.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionUpdateInfo =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

export declare namespace TestSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface GradedTestCase extends submission.GradedTestCaseUpdate {
        _type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends submission.RecordedTestCaseUpdate {
        _type: \\"recordedTestCase\\";
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        gradedTestCase: (value: submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    stopped: (): TestSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    gradedTestCase: (value: submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
        ...value,
        _type: \\"gradedTestCase\\"
    }),

    recordedTestCase: (value: submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
        ...value,
        _type: \\"recordedTestCase\\"
    }),

    finished: (): TestSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: TestSubmissionUpdateInfo, visitor: TestSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"gradedTestCase\\": return visitor.gradedTestCase(value);
            case \\"recordedTestCase\\": return visitor.recordedTestCase(value);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"stopped\\", \\"errored\\", \\"gradedTestCase\\", \\"recordedTestCase\\", \\"finished\\"],
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponse {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponseV2 {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    file: model.submission.TracedFile;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TracedTestCase {
    result: model.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: model.commons.Language;
    actualLanguage: model.commons.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceFiles {
    mainFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRanResponse {
    submissionId: model.submission.SubmissionId;
    runDetails: model.submission.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRunDetails {
    exceptionV2: model.submission.ExceptionV2 | null | undefined;
    exception: model.submission.ExceptionInfo | null | undefined;
    stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<model.commons.Language, model.submission.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionState {
    status: model.submission.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionStatus =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Traced extends submission.WorkspaceRunDetails {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        traced: (value: submission.WorkspaceRunDetails) => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionStatus = {
    stopped: (): WorkspaceSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    traced: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionStatus, visitor: WorkspaceSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"ran\\", \\"traced\\"],
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: model.submission.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionUpdateInfo =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Traced {
        _type: \\"traced\\";
    }

    interface TracedV2 extends submission.WorkspaceTracedUpdate {
        _type: \\"tracedV2\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: submission.WorkspaceTracedUpdate) => Result;
        errored: (value: submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
        _type: \\"traced\\"
    }),

    tracedV2: (value: submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
        ...value,
        _type: \\"tracedV2\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionUpdateInfo, visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"stopped\\": return visitor.stopped();
            case \\"traced\\": return visitor.traced();
            case \\"tracedV2\\": return visitor.tracedV2(value);
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"ran\\", \\"stopped\\", \\"traced\\", \\"tracedV2\\", \\"errored\\", \\"finished\\"],
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    userId: string | null | undefined;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetNumWarmInstancesErrorBody = never;

export declare namespace GetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: GetNumWarmInstancesErrorBody, visitor: GetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetNumWarmInstancesResponse = GetNumWarmInstancesResponse.SuccessResponse | GetNumWarmInstancesResponse.ErrorResponse;

export declare namespace GetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
        body: Record<model.commons.Language, number>;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.GetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "GetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetNumWarmInstancesErrorBody = never;

export declare namespace SetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: SetNumWarmInstancesErrorBody, visitor: SetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SetNumWarmInstancesRequest {
    language: model.commons.Language;
    numWarmInstances: number;
}
",
                        "name": "SetNumWarmInstancesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetNumWarmInstancesResponse = SetNumWarmInstancesResponse.SuccessResponse | SetNumWarmInstancesResponse.ErrorResponse;

export declare namespace SetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.SetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "SetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SetNumWarmInstancesRequest\\";
export * from \\"./SetNumWarmInstancesErrorBody\\";
export * from \\"./SetNumWarmInstancesResponse\\";
export * from \\"./GetNumWarmInstancesErrorBody\\";
export * from \\"./GetNumWarmInstancesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "SysPropCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./SysPropCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLatestProblemErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                            "name": "GetLatestProblemRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLatestProblemErrorBody;
    }
}
",
                            "name": "GetLatestProblemResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLightweightProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLightweightProblemsErrorBody;
    }
}
",
                            "name": "GetLightweightProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemVersionErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                            "name": "GetProblemVersionRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemVersionErrorBody;
    }
}
",
                            "name": "GetProblemVersionResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemsErrorBody;
    }
}
",
                            "name": "GetProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "ProblemInfoServicV2",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_service-types",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.problem.Files>;
    basicTestCaseTemplate: model.v2.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.problem.CustomFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2, commons } from \\"../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Files {
    files: model.v2.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.problem.Files>;
    other: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.problem.NonVoidFunctionSignature;
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Parameter {
    parameterId: model.v2.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.problem.CustomFiles;
    generatedFiles: model.v2.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementation {
    description: model.v2.problem.TestCaseImplementationDescription;
    function: model.v2.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseMetadata {
    id: model.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.problem.TestCaseMetadata;
    implementation: model.v2.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.problem.TestCaseExpects | null | undefined;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_types",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLatestProblemErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                                "name": "GetLatestProblemRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLatestProblemErrorBody;
    }
}
",
                                "name": "GetLatestProblemResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLightweightProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLightweightProblemsErrorBody;
    }
}
",
                                "name": "GetLightweightProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemVersionErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                                "name": "GetProblemVersionRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemVersionErrorBody;
    }
}
",
                                "name": "GetProblemVersionResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemsErrorBody;
    }
}
",
                                "name": "GetProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "ProblemInfoServicV2",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_service-types",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.v3.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    basicTestCaseTemplate: model.v2.v3.problem.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2, commons } from \\"../../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.v3.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.v3.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.v3.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.v3.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.v3.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Files {
    files: model.v2.v3.problem.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.v3.problem.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.v3.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.v3.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.v3.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    other: Record<model.commons.Language, model.v2.v3.problem.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.v3.problem.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.v3.problem.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.v3.problem.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Parameter {
    parameterId: model.v2.v3.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type ParameterId = string;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.v3.problem.CustomFiles;
    generatedFiles: model.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.v3.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseId = string;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementation {
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    function: model.v2.v3.problem.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.v3.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.v3.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.v3.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseMetadata {
    id: model.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.v3.problem.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseTemplateId = string;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.v3.problem.TestCaseMetadata;
    implementation: model.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.v3.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.v3.problem.TestCaseExpects | null | undefined;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.v3.problem.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.v3.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_types",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "model",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"name\\": \\"@fern-api/my-api-client\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"@fern-typescript/service-utils\\": \\"0.0.184\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
        "name": "package.json",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface AdminService {
    updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): Promise<model.admin.UpdateTestSubmissionStatusResponse>;
    sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): Promise<model.admin.SendTestSubmissionUpdateResponse>;
    updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse>;
    sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): Promise<model.admin.SendWorkspaceSubmissionUpdateResponse>;
    storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): Promise<model.admin.StoreTracedTestCaseResponse>;
    storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): Promise<model.admin.StoreTracedTestCaseV2Response>;
    storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): Promise<model.admin.StoreTracedWorkspaceResponse>;
    storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): Promise<model.admin.StoreTracedWorkspaceV2Response>;
}

export declare namespace AdminService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class AdminService implements AdminService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: AdminService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/admin\\");
    }

    public async updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): Promise<model.admin.UpdateTestSubmissionStatusResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-submission-status/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.UpdateTestSubmissionStatusErrorBody
            };
        }
    }

    public async sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): Promise<model.admin.SendTestSubmissionUpdateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-submission-status-v2/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.SendTestSubmissionUpdateErrorBody
            };
        }
    }

    public async updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-submission-status/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.UpdateWorkspaceSubmissionStatusErrorBody
            };
        }
    }

    public async sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): Promise<model.admin.SendWorkspaceSubmissionUpdateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-submission-status-v2/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.SendWorkspaceSubmissionUpdateErrorBody
            };
        }
    }

    public async storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): Promise<model.admin.StoreTracedTestCaseResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedTestCaseErrorBody
            };
        }
    }

    public async storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): Promise<model.admin.StoreTracedTestCaseV2Response> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedTestCaseV2ErrorBody
            };
        }
    }

    public async storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): Promise<model.admin.StoreTracedWorkspaceResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-trace/submission/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedWorkspaceErrorBody
            };
        }
    }

    public async storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): Promise<model.admin.StoreTracedWorkspaceV2Response> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-trace-v2/submission/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedWorkspaceV2ErrorBody
            };
        }
    }
}
",
                "name": "AdminService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./AdminService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface HomepageProblemService {
    getHomepageProblems(): Promise<model.homepage.GetHomepageProblemsResponse>;
    setHomepageProblems(request: model.commons.ProblemId[]): Promise<model.homepage.SetHomepageProblemsResponse>;
}

export declare namespace HomepageProblemService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class HomepageProblemService implements HomepageProblemService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: HomepageProblemService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/homepage-problems\\");
    }

    public async getHomepageProblems(): Promise<model.homepage.GetHomepageProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.commons.ProblemId[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.homepage.GetHomepageProblemsErrorBody
            };
        }
    }

    public async setHomepageProblems(request: model.commons.ProblemId[]): Promise<model.homepage.SetHomepageProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.homepage.SetHomepageProblemsErrorBody
            };
        }
    }
}
",
                "name": "HomepageProblemService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./HomepageProblemService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as sysprop from \\"./sysprop\\";
export * as v2 from \\"./v2\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface MigrationInfoService {
    getAttemptedMigrations(): Promise<model.migration.GetAttemptedMigrationsResponse>;
}

export declare namespace MigrationInfoService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class MigrationInfoService implements MigrationInfoService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: MigrationInfoService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/migration-info\\");
    }

    public async getAttemptedMigrations(): Promise<model.migration.GetAttemptedMigrationsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/all\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.migration.Migration[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.migration.GetAttemptedMigrationsErrorBody
            };
        }
    }
}
",
                "name": "MigrationInfoService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationInfoService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface PlaylistCrudService {
    createPlaylist(request: model.playlist.PlaylistCreateRequest): Promise<model.playlist.CreatePlaylistResponse>;
    getPlaylists(request: model.playlist.GetPlaylistsRequest): Promise<model.playlist.GetPlaylistsResponse>;
    getPlaylist(request: model.playlist.GetPlaylistRequest): Promise<model.playlist.GetPlaylistResponse>;
    updatePlaylist(request: model.playlist._UpdatePlaylistRequest): Promise<model.playlist.UpdatePlaylistResponse>;
    deletePlaylist(request: model.playlist.DeletePlaylistRequest): Promise<model.playlist.DeletePlaylistResponse>;
}

export declare namespace PlaylistCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class PlaylistCrudService implements PlaylistCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: PlaylistCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/v2/playlist\\");
    }

    public async createPlaylist(request: model.playlist.PlaylistCreateRequest): Promise<model.playlist.CreatePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/create\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.CreatePlaylistErrorBody
            };
        }
    }

    public async getPlaylists(request: model.playlist.GetPlaylistsRequest): Promise<model.playlist.GetPlaylistsResponse> {
        const queryParameters = new URLSearchParams();
        if (request.limit != null) {
            queryParameters.append(\\"limit\\", request.limit.toString());
        }

        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/all\\"),
            method: \\"GET\\",
            headers: {},
            queryParameters
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.GetPlaylistsErrorBody
            };
        }
    }

    public async getPlaylist(request: model.playlist.GetPlaylistRequest): Promise<model.playlist.GetPlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlistId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.GetPlaylistErrorBody
            };
        }
    }

    public async updatePlaylist(request: model.playlist._UpdatePlaylistRequest): Promise<model.playlist.UpdatePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlistId}\`),
            method: \\"PUT\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist | null | undefined
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.UpdatePlaylistErrorBody
            };
        }
    }

    public async deletePlaylist(request: model.playlist.DeletePlaylistRequest): Promise<model.playlist.DeletePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlist_id}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.DeletePlaylistErrorBody
            };
        }
    }
}
",
                "name": "PlaylistCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ProblemCrudService {
    createProblem(request: model.problem.CreateProblemRequest): Promise<model.problem._CreateProblemResponse>;
    updateProblem(request: model.problem.UpdateProblemRequest): Promise<model.problem._UpdateProblemResponse>;
    deleteProblem(request: model.problem.DeleteProblemRequest): Promise<model.problem.DeleteProblemResponse>;
    getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): Promise<model.problem._GetDefaultStarterFilesResponse>;
}

export declare namespace ProblemCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemCrudService implements ProblemCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problem-crud\\");
    }

    public async createProblem(request: model.problem.CreateProblemRequest): Promise<model.problem._CreateProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/create\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.CreateProblemResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.CreateProblemErrorBody
            };
        }
    }

    public async updateProblem(request: model.problem.UpdateProblemRequest): Promise<model.problem._UpdateProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/update/\${request.problemId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.UpdateProblemResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.UpdateProblemErrorBody
            };
        }
    }

    public async deleteProblem(request: model.problem.DeleteProblemRequest): Promise<model.problem.DeleteProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/delete/\${request.problemId}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.DeleteProblemErrorBody
            };
        }
    }

    public async getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): Promise<model.problem._GetDefaultStarterFilesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/default-starter-files\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.GetDefaultStarterFilesResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.GetDefaultStarterFilesErrorBody
            };
        }
    }
}
",
                "name": "ProblemCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ExecutionSesssionManagementService {
    createExecutionSession(request: model.submission.CreateExecutionSessionRequest): Promise<model.submission.CreateExecutionSessionResponse>;
    getExecutionSession(request: model.submission.GetExecutionSessionRequest): Promise<model.submission.GetExecutionSessionResponse>;
    stopExecutionSession(request: model.submission.StopExecutionSessionRequest): Promise<model.submission.StopExecutionSessionResponse>;
    getExecutionSessionsState(): Promise<model.submission.GetExecutionSessionsStateResponse>;
}

export declare namespace ExecutionSesssionManagementService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class ExecutionSesssionManagementService implements ExecutionSesssionManagementService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ExecutionSesssionManagementService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/sessions\\");
    }

    public async createExecutionSession(request: model.submission.CreateExecutionSessionRequest): Promise<model.submission.CreateExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/create-session/\${request.language}\`),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.ExecutionSessionResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.CreateExecutionSessionErrorBody
            };
        }
    }

    public async getExecutionSession(request: model.submission.GetExecutionSessionRequest): Promise<model.submission.GetExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.sessionId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.ExecutionSessionResponse | null | undefined
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.GetExecutionSessionErrorBody
            };
        }
    }

    public async stopExecutionSession(request: model.submission.StopExecutionSessionRequest): Promise<model.submission.StopExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/stop/\${request.sessionId}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.StopExecutionSessionErrorBody
            };
        }
    }

    public async getExecutionSessionsState(): Promise<model.submission.GetExecutionSessionsStateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/execution-sessions-state\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.GetExecutionSessionStateResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.GetExecutionSessionsStateErrorBody
            };
        }
    }
}
",
                "name": "ExecutionSesssionManagementService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface SysPropCrudService {
    setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): Promise<model.sysprop.SetNumWarmInstancesResponse>;
    getNumWarmInstances(): Promise<model.sysprop.GetNumWarmInstancesResponse>;
}

export declare namespace SysPropCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class SysPropCrudService implements SysPropCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: SysPropCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/sysprop\\");
    }

    public async setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): Promise<model.sysprop.SetNumWarmInstancesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`),
            method: \\"PUT\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.sysprop.SetNumWarmInstancesErrorBody
            };
        }
    }

    public async getNumWarmInstances(): Promise<model.sysprop.GetNumWarmInstancesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/num-warm-instances\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as Record<model.commons.Language, number>
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.sysprop.GetNumWarmInstancesErrorBody
            };
        }
    }
}
",
                "name": "SysPropCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SysPropCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../../model\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): Promise<model.v2.problem.GetLightweightProblemsResponse>;
    getProblems(): Promise<model.v2.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): Promise<model.v2.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): Promise<model.v2.problem.GetProblemVersionResponse>;
}

export declare namespace ProblemInfoServicV2 {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemInfoServicV2 implements ProblemInfoServicV2 {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemInfoServicV2.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problems-v2\\");
    }

    public async getLightweightProblems(): Promise<model.v2.problem.GetLightweightProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/lightweight-problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.LightweightProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetLightweightProblemsErrorBody
            };
        }
    }

    public async getProblems(): Promise<model.v2.problem.GetProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetProblemsErrorBody
            };
        }
    }

    public async getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): Promise<model.v2.problem.GetLatestProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetLatestProblemErrorBody
            };
        }
    }

    public async getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): Promise<model.v2.problem.GetProblemVersionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetProblemVersionErrorBody
            };
        }
    }
}
",
                    "name": "ProblemInfoServicV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../../../model\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): Promise<model.v2.v3.problem.GetLightweightProblemsResponse>;
    getProblems(): Promise<model.v2.v3.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): Promise<model.v2.v3.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): Promise<model.v2.v3.problem.GetProblemVersionResponse>;
}

export declare namespace ProblemInfoServicV2 {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemInfoServicV2 implements ProblemInfoServicV2 {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemInfoServicV2.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problems-v2\\");
    }

    public async getLightweightProblems(): Promise<model.v2.v3.problem.GetLightweightProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/lightweight-problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.LightweightProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetLightweightProblemsErrorBody
            };
        }
    }

    public async getProblems(): Promise<model.v2.v3.problem.GetProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetProblemsErrorBody
            };
        }
    }

    public async getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): Promise<model.v2.v3.problem.GetLatestProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetLatestProblemErrorBody
            };
        }
    }

    public async getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): Promise<model.v2.v3.problem.GetProblemVersionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetProblemVersionErrorBody
            };
        }
    }
}
",
                        "name": "ProblemInfoServicV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "services",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
        "name": "tsconfig.json",
        "type": "file",
      },
    ],
    "name": "client",
    "type": "directory",
  },
]
`;

exports[`runGenerator trace client_and_server 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
        "name": ".npmignore",
        "type": "file",
      },
      Object {
        "contents": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type SendTestSubmissionUpdateErrorBody = never;

export declare namespace SendTestSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendTestSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendTestSubmissionUpdateErrorBody, visitor: SendTestSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendTestSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendTestSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendTestSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionUpdate;
}
",
                        "name": "SendTestSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendTestSubmissionUpdateResponse = SendTestSubmissionUpdateResponse.SuccessResponse | SendTestSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendTestSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendTestSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendTestSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SendWorkspaceSubmissionUpdateErrorBody = never;

export declare namespace SendWorkspaceSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendWorkspaceSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendWorkspaceSubmissionUpdateErrorBody, visitor: SendWorkspaceSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendWorkspaceSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendWorkspaceSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendWorkspaceSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionUpdate;
}
",
                        "name": "SendWorkspaceSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendWorkspaceSubmissionUpdateResponse = SendWorkspaceSubmissionUpdateResponse.SuccessResponse | SendWorkspaceSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendWorkspaceSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendWorkspaceSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendWorkspaceSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseErrorBody = never;

export declare namespace StoreTracedTestCaseErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseErrorBody, visitor: StoreTracedTestCaseErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseResponse = StoreTracedTestCaseResponse.SuccessResponse | StoreTracedTestCaseResponse.ErrorResponse;

export declare namespace StoreTracedTestCaseResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseV2ErrorBody = never;

export declare namespace StoreTracedTestCaseV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseV2ErrorBody, visitor: StoreTracedTestCaseV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedTestCaseV2Request {
    submissionId: model.submission.SubmissionId;
    testCaseId: model.v2.problem.TestCaseId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedTestCaseV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseV2Response = StoreTracedTestCaseV2Response.SuccessResponse | StoreTracedTestCaseV2Response.ErrorResponse;

export declare namespace StoreTracedTestCaseV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseV2ErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceErrorBody = never;

export declare namespace StoreTracedWorkspaceErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceErrorBody, visitor: StoreTracedWorkspaceErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceResponse = StoreTracedWorkspaceResponse.SuccessResponse | StoreTracedWorkspaceResponse.ErrorResponse;

export declare namespace StoreTracedWorkspaceResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceV2ErrorBody = never;

export declare namespace StoreTracedWorkspaceV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceV2ErrorBody, visitor: StoreTracedWorkspaceV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedWorkspaceV2Request {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedWorkspaceV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceV2Response = StoreTracedWorkspaceV2Response.SuccessResponse | StoreTracedWorkspaceV2Response.ErrorResponse;

export declare namespace StoreTracedWorkspaceV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceV2ErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateTestSubmissionStatusErrorBody = never;

export declare namespace UpdateTestSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateTestSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateTestSubmissionStatusErrorBody, visitor: UpdateTestSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateTestSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateTestSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateTestSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionStatus;
}
",
                        "name": "UpdateTestSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateTestSubmissionStatusResponse = UpdateTestSubmissionStatusResponse.SuccessResponse | UpdateTestSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateTestSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateTestSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateTestSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateWorkspaceSubmissionStatusErrorBody = never;

export declare namespace UpdateWorkspaceSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateWorkspaceSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateWorkspaceSubmissionStatusErrorBody, visitor: UpdateWorkspaceSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateWorkspaceSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateWorkspaceSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateWorkspaceSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionStatus;
}
",
                        "name": "UpdateWorkspaceSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateWorkspaceSubmissionStatusResponse = UpdateWorkspaceSubmissionStatusResponse.SuccessResponse | UpdateWorkspaceSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateWorkspaceSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateWorkspaceSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateWorkspaceSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedTestCaseRequest {
    submissionId: model.submission.SubmissionId;
    testCaseId: string;
    body: model.admin.StoreTracedTestCaseRequest;
}
",
                        "name": "_StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedWorkspaceRequest {
    submissionId: model.submission.SubmissionId;
    body: model.admin.StoreTracedWorkspaceRequest;
}
",
                        "name": "_StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UpdateTestSubmissionStatusRequest\\";
export * from \\"./UpdateTestSubmissionStatusErrorBody\\";
export * from \\"./UpdateTestSubmissionStatusResponse\\";
export * from \\"./SendTestSubmissionUpdateRequest\\";
export * from \\"./SendTestSubmissionUpdateErrorBody\\";
export * from \\"./SendTestSubmissionUpdateResponse\\";
export * from \\"./UpdateWorkspaceSubmissionStatusRequest\\";
export * from \\"./UpdateWorkspaceSubmissionStatusErrorBody\\";
export * from \\"./UpdateWorkspaceSubmissionStatusResponse\\";
export * from \\"./SendWorkspaceSubmissionUpdateRequest\\";
export * from \\"./SendWorkspaceSubmissionUpdateErrorBody\\";
export * from \\"./SendWorkspaceSubmissionUpdateResponse\\";
export * from \\"./_StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedTestCaseErrorBody\\";
export * from \\"./StoreTracedTestCaseResponse\\";
export * from \\"./StoreTracedTestCaseV2Request\\";
export * from \\"./StoreTracedTestCaseV2ErrorBody\\";
export * from \\"./StoreTracedTestCaseV2Response\\";
export * from \\"./_StoreTracedWorkspaceRequest\\";
export * from \\"./StoreTracedWorkspaceErrorBody\\";
export * from \\"./StoreTracedWorkspaceResponse\\";
export * from \\"./StoreTracedWorkspaceV2Request\\";
export * from \\"./StoreTracedWorkspaceV2ErrorBody\\";
export * from \\"./StoreTracedWorkspaceV2Response\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "AdminService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./AdminService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedTestCaseRequest {
    result: model.submission.TestCaseResultWithStdout;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: model.submission.WorkspaceRunDetails;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: model.commons.NodeId;
    fullTree: model.commons.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    right: model.commons.NodeId | null | undefined;
    left: model.commons.NodeId | null | undefined;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeValue {
    root: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugKeyValuePairs {
    key: model.commons.DebugVariableValue;
    value: model.commons.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugMapValue {
    keyValuePairs: model.commons.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type DebugVariableValue =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

export declare namespace DebugVariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.DebugMapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends commons.BinaryTreeNodeAndTreeValue {
        _type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends commons.SinglyLinkedListNodeAndListValue {
        _type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends commons.DoublyLinkedListNodeAndListValue {
        _type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        _type: \\"undefinedValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    interface GenericValue extends commons.GenericValue {
        _type: \\"genericValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.DebugMapValue) => Result;
        listValue: (value: commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: commons.GenericValue) => Result;
        _unknown: () => Result;
    }
}

export const DebugVariableValue = {
    integerValue: (value: number): DebugVariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): DebugVariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): DebugVariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.DebugMapValue): DebugVariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
        ...value,
        _type: \\"binaryTreeNodeValue\\"
    }),

    singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
        ...value,
        _type: \\"singlyLinkedListNodeValue\\"
    }),

    doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
        ...value,
        _type: \\"doublyLinkedListNodeValue\\"
    }),

    undefinedValue: (): DebugVariableValue.UndefinedValue => ({
        _type: \\"undefinedValue\\"
    }),

    nullValue: (): DebugVariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    genericValue: (value: commons.GenericValue): DebugVariableValue.GenericValue => ({
        ...value,
        _type: \\"genericValue\\"
    }),

    _visit: <Result>(value: DebugVariableValue, visitor: DebugVariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeNodeValue\\": return visitor.binaryTreeNodeValue(value);
            case \\"singlyLinkedListNodeValue\\": return visitor.singlyLinkedListNodeValue(value);
            case \\"doublyLinkedListNodeValue\\": return visitor.doublyLinkedListNodeValue(value);
            case \\"undefinedValue\\": return visitor.undefinedValue();
            case \\"nullValue\\": return visitor.nullValue();
            case \\"genericValue\\": return visitor.genericValue(value);
            default: return visitor._unknown();
        }
    },

    _types: (): DebugVariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeNodeValue\\", \\"singlyLinkedListNodeValue\\", \\"doublyLinkedListNodeValue\\", \\"undefinedValue\\", \\"nullValue\\", \\"genericValue\\"],
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
    prev: model.commons.NodeId | null | undefined;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericValue {
    stringifiedType: string | null | undefined;
    stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface KeyValuePair {
    key: model.commons.VariableValue;
    value: model.commons.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type Language =
    | \\"JAVA\\"
    | \\"JAVASCRIPT\\"
    | \\"PYTHON\\";

export const Language = {
    Java: \\"JAVA\\",
    Javascript: \\"JAVASCRIPT\\",
    Python: \\"PYTHON\\",

    _visit: <Result>(value: Language, visitor: Language._Visitor<Result>): Result => {
        switch (value) {
            case Language.Java: return visitor.java();
            case Language.Javascript: return visitor.javascript();
            case Language.Python: return visitor.python();
            default: return visitor._unknown();
        }
    },

    _values: (): Language[] => [Language.Java, Language.Javascript, Language.Python],
} as const;

export declare namespace Language {
    type Java = \\"JAVA\\";
    type Javascript = \\"JAVASCRIPT\\";
    type Python = \\"PYTHON\\";

    export interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ListType {
    valueType: model.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength: boolean | null | undefined;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapType {
    keyType: model.commons.VariableType;
    valueType: model.commons.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapValue {
    keyValuePairs: model.commons.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type NodeId = string;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ProblemId = string;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCase {
    id: string;
    params: model.commons.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseWithExpectedResult {
    testCase: model.commons.TestCase;
    expectedResult: model.commons.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UserId = string;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableType =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

export declare namespace VariableType {
    interface IntegerType {
        _type: \\"integerType\\";
    }

    interface DoubleType {
        _type: \\"doubleType\\";
    }

    interface BooleanType {
        _type: \\"booleanType\\";
    }

    interface StringType {
        _type: \\"stringType\\";
    }

    interface CharType {
        _type: \\"charType\\";
    }

    interface ListType extends commons.ListType {
        _type: \\"listType\\";
    }

    interface MapType extends commons.MapType {
        _type: \\"mapType\\";
    }

    interface BinaryTreeType {
        _type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        _type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        _type: \\"doublyLinkedListType\\";
    }

    export interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: commons.ListType) => Result;
        mapType: (value: commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: () => Result;
    }
}

export const VariableType = {
    integerType: (): VariableType.IntegerType => ({
        _type: \\"integerType\\"
    }),

    doubleType: (): VariableType.DoubleType => ({
        _type: \\"doubleType\\"
    }),

    booleanType: (): VariableType.BooleanType => ({
        _type: \\"booleanType\\"
    }),

    stringType: (): VariableType.StringType => ({
        _type: \\"stringType\\"
    }),

    charType: (): VariableType.CharType => ({
        _type: \\"charType\\"
    }),

    listType: (value: commons.ListType): VariableType.ListType => ({
        ...value,
        _type: \\"listType\\"
    }),

    mapType: (value: commons.MapType): VariableType.MapType => ({
        ...value,
        _type: \\"mapType\\"
    }),

    binaryTreeType: (): VariableType.BinaryTreeType => ({
        _type: \\"binaryTreeType\\"
    }),

    singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
        _type: \\"singlyLinkedListType\\"
    }),

    doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
        _type: \\"doublyLinkedListType\\"
    }),

    _visit: <Result>(value: VariableType, visitor: VariableType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerType\\": return visitor.integerType();
            case \\"doubleType\\": return visitor.doubleType();
            case \\"booleanType\\": return visitor.booleanType();
            case \\"stringType\\": return visitor.stringType();
            case \\"charType\\": return visitor.charType();
            case \\"listType\\": return visitor.listType(value);
            case \\"mapType\\": return visitor.mapType(value);
            case \\"binaryTreeType\\": return visitor.binaryTreeType();
            case \\"singlyLinkedListType\\": return visitor.singlyLinkedListType();
            case \\"doublyLinkedListType\\": return visitor.doublyLinkedListType();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableType[\\"_type\\"][] => [\\"integerType\\", \\"doubleType\\", \\"booleanType\\", \\"stringType\\", \\"charType\\", \\"listType\\", \\"mapType\\", \\"binaryTreeType\\", \\"singlyLinkedListType\\", \\"doublyLinkedListType\\"],
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableValue =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

export declare namespace VariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.MapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.VariableValue[];
    }

    interface BinaryTreeValue extends commons.BinaryTreeValue {
        _type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends commons.SinglyLinkedListValue {
        _type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends commons.DoublyLinkedListValue {
        _type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.MapValue) => Result;
        listValue: (value: commons.VariableValue[]) => Result;
        binaryTreeValue: (value: commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: () => Result;
    }
}

export const VariableValue = {
    integerValue: (value: number): VariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): VariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): VariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): VariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): VariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.MapValue): VariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.VariableValue[]): VariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeValue: (value: commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
        ...value,
        _type: \\"binaryTreeValue\\"
    }),

    singlyLinkedListValue: (value: commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
        ...value,
        _type: \\"singlyLinkedListValue\\"
    }),

    doublyLinkedListValue: (value: commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
        ...value,
        _type: \\"doublyLinkedListValue\\"
    }),

    nullValue: (): VariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    _visit: <Result>(value: VariableValue, visitor: VariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeValue\\": return visitor.binaryTreeValue(value);
            case \\"singlyLinkedListValue\\": return visitor.singlyLinkedListValue(value);
            case \\"doublyLinkedListValue\\": return visitor.doublyLinkedListValue(value);
            case \\"nullValue\\": return visitor.nullValue();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeValue\\", \\"singlyLinkedListValue\\", \\"doublyLinkedListValue\\", \\"nullValue\\"],
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetHomepageProblemsErrorBody = never;

export declare namespace GetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: GetHomepageProblemsErrorBody, visitor: GetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetHomepageProblemsResponse = GetHomepageProblemsResponse.SuccessResponse | GetHomepageProblemsResponse.ErrorResponse;

export declare namespace GetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.commons.ProblemId[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.GetHomepageProblemsErrorBody;
    }
}
",
                        "name": "GetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetHomepageProblemsErrorBody = never;

export declare namespace SetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: SetHomepageProblemsErrorBody, visitor: SetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetHomepageProblemsResponse = SetHomepageProblemsResponse.SuccessResponse | SetHomepageProblemsResponse.ErrorResponse;

export declare namespace SetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.SetHomepageProblemsErrorBody;
    }
}
",
                        "name": "SetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetHomepageProblemsErrorBody\\";
export * from \\"./GetHomepageProblemsResponse\\";
export * from \\"./SetHomepageProblemsErrorBody\\";
export * from \\"./SetHomepageProblemsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "HomepageProblemService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./HomepageProblemService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export interface LangServerRequest {
    request: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LangServerResponse {
    response: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "lang-server",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetAttemptedMigrationsErrorBody = never;

export declare namespace GetAttemptedMigrationsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetAttemptedMigrationsErrorBody = {
    _visit: <Result>(_value: GetAttemptedMigrationsErrorBody, visitor: GetAttemptedMigrationsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetAttemptedMigrationsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetAttemptedMigrationsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetAttemptedMigrationsResponse = GetAttemptedMigrationsResponse.SuccessResponse | GetAttemptedMigrationsResponse.ErrorResponse;

export declare namespace GetAttemptedMigrationsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.migration.Migration[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.migration.GetAttemptedMigrationsErrorBody;
    }
}
",
                        "name": "GetAttemptedMigrationsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetAttemptedMigrationsErrorBody\\";
export * from \\"./GetAttemptedMigrationsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "MigrationInfoService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationInfoService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Migration {
    name: string;
    status: model.migration.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type MigrationStatus =
    | \\"RUNNING\\"
    | \\"FAILED\\"
    | \\"FINISHED\\";

export const MigrationStatus = {
    Running: \\"RUNNING\\",
    Failed: \\"FAILED\\",
    Finished: \\"FINISHED\\",

    _visit: <Result>(value: MigrationStatus, visitor: MigrationStatus._Visitor<Result>): Result => {
        switch (value) {
            case MigrationStatus.Running: return visitor.running();
            case MigrationStatus.Failed: return visitor.failed();
            case MigrationStatus.Finished: return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _values: (): MigrationStatus[] => [MigrationStatus.Running, MigrationStatus.Failed, MigrationStatus.Finished],
} as const;

export declare namespace MigrationStatus {
    type Running = \\"RUNNING\\";
    type Failed = \\"FAILED\\";
    type Finished = \\"FINISHED\\";

    export interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistIdNotFoundError {
    playlistId: model.playlist.PlaylistId;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UnauthorizedError = Record<string, never>;
",
                    "name": "UnauthorizedError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_errors",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreatePlaylistErrorBody = never;

export declare namespace CreatePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreatePlaylistErrorBody = {
    _visit: <Result>(_value: CreatePlaylistErrorBody, visitor: CreatePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreatePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreatePlaylistResponse = CreatePlaylistResponse.SuccessResponse | CreatePlaylistResponse.ErrorResponse;

export declare namespace CreatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.CreatePlaylistErrorBody;
    }
}
",
                        "name": "CreatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeletePlaylistErrorBody = never;

export declare namespace DeletePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeletePlaylistErrorBody = {
    _visit: <Result>(_value: DeletePlaylistErrorBody, visitor: DeletePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeletePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeletePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeletePlaylistRequest {
    playlist_id: model.playlist.PlaylistId;
}
",
                        "name": "DeletePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeletePlaylistResponse = DeletePlaylistResponse.SuccessResponse | DeletePlaylistResponse.ErrorResponse;

export declare namespace DeletePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.DeletePlaylistErrorBody;
    }
}
",
                        "name": "DeletePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPlaylistErrorBody =
    | GetPlaylistErrorBody.PlaylistIdNotFoundError
    | GetPlaylistErrorBody.UnauthorizedError;

export declare namespace GetPlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    interface UnauthorizedError {
        _error: \\"UnauthorizedError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        UnauthorizedError: () => Result;
        _unknown: () => Result;
    }
}

export const GetPlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): GetPlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    unauthorizedError: (): GetPlaylistErrorBody.UnauthorizedError => ({
        _error: \\"UnauthorizedError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPlaylistErrorBody, visitor: GetPlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            case \\"UnauthorizedError\\": return visitor.UnauthorizedError();
            default: return visitor._unknown();
        }
    },

    _types: (): GetPlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\", \\"UnauthorizedError\\"],
} as const;
",
                        "name": "GetPlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetPlaylistRequest {
    playlistId: model.playlist.PlaylistId;
}
",
                        "name": "GetPlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistResponse = GetPlaylistResponse.SuccessResponse | GetPlaylistResponse.ErrorResponse;

export declare namespace GetPlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistErrorBody;
    }
}
",
                        "name": "GetPlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetPlaylistsErrorBody = never;

export declare namespace GetPlaylistsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetPlaylistsErrorBody = {
    _visit: <Result>(_value: GetPlaylistsErrorBody, visitor: GetPlaylistsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetPlaylistsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetPlaylistsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetPlaylistsRequest {
    limit: number | null | undefined;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistsResponse = GetPlaylistsResponse.SuccessResponse | GetPlaylistsResponse.ErrorResponse;

export declare namespace GetPlaylistsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistsErrorBody;
    }
}
",
                        "name": "GetPlaylistsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type UpdatePlaylistErrorBody =
    | UpdatePlaylistErrorBody.PlaylistIdNotFoundError;

export declare namespace UpdatePlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const UpdatePlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): UpdatePlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: UpdatePlaylistErrorBody, visitor: UpdatePlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): UpdatePlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\"],
} as const;
",
                        "name": "UpdatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdatePlaylistResponse = UpdatePlaylistResponse.SuccessResponse | UpdatePlaylistResponse.ErrorResponse;

export declare namespace UpdatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.UpdatePlaylistErrorBody;
    }
}
",
                        "name": "UpdatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _UpdatePlaylistRequest {
    playlistId: model.playlist.PlaylistId;
    body: model.playlist.UpdatePlaylistRequest | null | undefined;
}
",
                        "name": "_UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreatePlaylistErrorBody\\";
export * from \\"./CreatePlaylistResponse\\";
export * from \\"./GetPlaylistsRequest\\";
export * from \\"./GetPlaylistsErrorBody\\";
export * from \\"./GetPlaylistsResponse\\";
export * from \\"./GetPlaylistRequest\\";
export * from \\"./GetPlaylistErrorBody\\";
export * from \\"./GetPlaylistResponse\\";
export * from \\"./_UpdatePlaylistRequest\\";
export * from \\"./UpdatePlaylistErrorBody\\";
export * from \\"./UpdatePlaylistResponse\\";
export * from \\"./DeletePlaylistRequest\\";
export * from \\"./DeletePlaylistErrorBody\\";
export * from \\"./DeletePlaylistResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "PlaylistCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Playlist {
    playlist_id: model.playlist.PlaylistId;
    name: string;
    problems: model.commons.ProblemId[];
    \\"owner-id\\": model.commons.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type PlaylistId = string;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateProblemErrorBody = never;

export declare namespace CreateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateProblemErrorBody = {
    _visit: <Result>(_value: CreateProblemErrorBody, visitor: CreateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeleteProblemErrorBody = never;

export declare namespace DeleteProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeleteProblemErrorBody = {
    _visit: <Result>(_value: DeleteProblemErrorBody, visitor: DeleteProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeleteProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeleteProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeleteProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                        "name": "DeleteProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeleteProblemResponse = DeleteProblemResponse.SuccessResponse | DeleteProblemResponse.ErrorResponse;

export declare namespace DeleteProblemResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.DeleteProblemErrorBody;
    }
}
",
                        "name": "DeleteProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetDefaultStarterFilesErrorBody = never;

export declare namespace GetDefaultStarterFilesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetDefaultStarterFilesErrorBody = {
    _visit: <Result>(_value: GetDefaultStarterFilesErrorBody, visitor: GetDefaultStarterFilesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetDefaultStarterFilesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetDefaultStarterFilesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateProblemErrorBody = never;

export declare namespace UpdateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateProblemErrorBody = {
    _visit: <Result>(_value: UpdateProblemErrorBody, visitor: UpdateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateProblemRequest {
    problemId: model.commons.ProblemId;
    body: model.problem.CreateProblemRequest;
}
",
                        "name": "UpdateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _CreateProblemResponse = _CreateProblemResponse.SuccessResponse | _CreateProblemResponse.ErrorResponse;

export declare namespace _CreateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.CreateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.CreateProblemErrorBody;
    }
}
",
                        "name": "_CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _GetDefaultStarterFilesResponse = _GetDefaultStarterFilesResponse.SuccessResponse | _GetDefaultStarterFilesResponse.ErrorResponse;

export declare namespace _GetDefaultStarterFilesResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.GetDefaultStarterFilesResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.GetDefaultStarterFilesErrorBody;
    }
}
",
                        "name": "_GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _UpdateProblemResponse = _UpdateProblemResponse.SuccessResponse | _UpdateProblemResponse.ErrorResponse;

export declare namespace _UpdateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.UpdateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.UpdateProblemErrorBody;
    }
}
",
                        "name": "_UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateProblemErrorBody\\";
export * from \\"./_CreateProblemResponse\\";
export * from \\"./UpdateProblemRequest\\";
export * from \\"./UpdateProblemErrorBody\\";
export * from \\"./_UpdateProblemResponse\\";
export * from \\"./DeleteProblemRequest\\";
export * from \\"./DeleteProblemErrorBody\\";
export * from \\"./DeleteProblemResponse\\";
export * from \\"./GetDefaultStarterFilesErrorBody\\";
export * from \\"./_GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ProblemCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { problem } from \\"../..\\";

export type CreateProblemError =
    | CreateProblemError.Generic;

export declare namespace CreateProblemError {
    interface Generic extends problem.GenericCreateProblemError {
        _type: \\"generic\\";
    }

    export interface _Visitor<Result> {
        generic: (value: problem.GenericCreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemError = {
    generic: (value: problem.GenericCreateProblemError): CreateProblemError.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    _visit: <Result>(value: CreateProblemError, visitor: CreateProblemError._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemError[\\"_type\\"][] => [\\"generic\\"],
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { problem, commons } from \\"../..\\";

export type CreateProblemResponse =
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error;

export declare namespace CreateProblemResponse {
    interface Success {
        _type: \\"success\\";
        success: commons.ProblemId;
    }

    interface Error {
        _type: \\"error\\";
        error: problem.CreateProblemError;
    }

    export interface _Visitor<Result> {
        success: (value: commons.ProblemId) => Result;
        error: (value: problem.CreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemResponse = {
    success: (value: commons.ProblemId): CreateProblemResponse.Success => ({
        success: value,
        _type: \\"success\\"
    }),

    error: (value: problem.CreateProblemError): CreateProblemResponse.Error => ({
        error: value,
        _type: \\"error\\"
    }),

    _visit: <Result>(value: CreateProblemResponse, visitor: CreateProblemResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"success\\": return visitor.success(value.success);
            case \\"error\\": return visitor.error(value.error);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemResponse[\\"_type\\"][] => [\\"success\\", \\"error\\"],
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemDescription {
    boards: model.problem.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type ProblemDescriptionBoard =
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

export declare namespace ProblemDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface Variable {
        _type: \\"variable\\";
        variable: commons.VariableValue;
    }

    interface TestCaseId {
        _type: \\"testCaseId\\";
        testCaseId: string;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const ProblemDescriptionBoard = {
    html: (value: string): ProblemDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    variable: (value: commons.VariableValue): ProblemDescriptionBoard.Variable => ({
        variable: value,
        _type: \\"variable\\"
    }),

    testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
        testCaseId: value,
        _type: \\"testCaseId\\"
    }),

    _visit: <Result>(value: ProblemDescriptionBoard, visitor: ProblemDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"variable\\": return visitor.variable(value.variable);
            case \\"testCaseId\\": return visitor.testCaseId(value.testCaseId);
            default: return visitor._unknown();
        }
    },

    _types: (): ProblemDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"variable\\", \\"testCaseId\\"],
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemFiles {
    solutionFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemInfo {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface VariableTypeAndName {
    variableType: model.commons.VariableType;
    name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateExecutionSessionErrorBody = never;

export declare namespace CreateExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateExecutionSessionErrorBody = {
    _visit: <Result>(_value: CreateExecutionSessionErrorBody, visitor: CreateExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateExecutionSessionRequest {
    language: model.commons.Language;
}
",
                        "name": "CreateExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreateExecutionSessionResponse = CreateExecutionSessionResponse.SuccessResponse | CreateExecutionSessionResponse.ErrorResponse;

export declare namespace CreateExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.CreateExecutionSessionErrorBody;
    }
}
",
                        "name": "CreateExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionErrorBody = never;

export declare namespace GetExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionErrorBody, visitor: GetExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "GetExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionResponse = GetExecutionSessionResponse.SuccessResponse | GetExecutionSessionResponse.ErrorResponse;

export declare namespace GetExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionErrorBody;
    }
}
",
                        "name": "GetExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionsStateErrorBody = never;

export declare namespace GetExecutionSessionsStateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionsStateErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionsStateErrorBody, visitor: GetExecutionSessionsStateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionsStateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionsStateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionsStateResponse = GetExecutionSessionsStateResponse.SuccessResponse | GetExecutionSessionsStateResponse.ErrorResponse;

export declare namespace GetExecutionSessionsStateResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.GetExecutionSessionStateResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionsStateErrorBody;
    }
}
",
                        "name": "GetExecutionSessionsStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StopExecutionSessionErrorBody = never;

export declare namespace StopExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StopExecutionSessionErrorBody = {
    _visit: <Result>(_value: StopExecutionSessionErrorBody, visitor: StopExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StopExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StopExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface StopExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "StopExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StopExecutionSessionResponse = StopExecutionSessionResponse.SuccessResponse | StopExecutionSessionResponse.ErrorResponse;

export declare namespace StopExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.StopExecutionSessionErrorBody;
    }
}
",
                        "name": "StopExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateExecutionSessionRequest\\";
export * from \\"./CreateExecutionSessionErrorBody\\";
export * from \\"./CreateExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionRequest\\";
export * from \\"./GetExecutionSessionErrorBody\\";
export * from \\"./GetExecutionSessionResponse\\";
export * from \\"./StopExecutionSessionRequest\\";
export * from \\"./StopExecutionSessionErrorBody\\";
export * from \\"./StopExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionsStateErrorBody\\";
export * from \\"./GetExecutionSessionsStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ExecutionSesssionManagementService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type ActualResult =
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

export declare namespace ActualResult {
    interface Value {
        _type: \\"value\\";
        value: commons.VariableValue;
    }

    interface Exception extends submission.ExceptionInfo {
        _type: \\"exception\\";
    }

    interface ExceptionV2 {
        _type: \\"exceptionV2\\";
        exceptionV2: submission.ExceptionV2;
    }

    export interface _Visitor<Result> {
        value: (value: commons.VariableValue) => Result;
        exception: (value: submission.ExceptionInfo) => Result;
        exceptionV2: (value: submission.ExceptionV2) => Result;
        _unknown: () => Result;
    }
}

export const ActualResult = {
    value: (value: commons.VariableValue): ActualResult.Value => ({
        value: value,
        _type: \\"value\\"
    }),

    exception: (value: submission.ExceptionInfo): ActualResult.Exception => ({
        ...value,
        _type: \\"exception\\"
    }),

    exceptionV2: (value: submission.ExceptionV2): ActualResult.ExceptionV2 => ({
        exceptionV2: value,
        _type: \\"exceptionV2\\"
    }),

    _visit: <Result>(value: ActualResult, visitor: ActualResult._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"value\\": return visitor.value(value.value);
            case \\"exception\\": return visitor.exception(value);
            case \\"exceptionV2\\": return visitor.exceptionV2(value.exceptionV2);
            default: return visitor._unknown();
        }
    },

    _types: (): ActualResult[\\"_type\\"][] => [\\"value\\", \\"exception\\", \\"exceptionV2\\"],
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BuildingExecutorResponse {
    submissionId: model.submission.SubmissionId;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type CodeExecutionUpdate =
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends submission.BuildingExecutorResponse {
        _type: \\"buildingExecutor\\";
    }

    interface Running extends submission.RunningResponse {
        _type: \\"running\\";
    }

    interface Errored extends submission.ErroredResponse {
        _type: \\"errored\\";
    }

    interface Stopped extends submission.StoppedResponse {
        _type: \\"stopped\\";
    }

    interface Graded extends submission.GradedResponse {
        _type: \\"graded\\";
    }

    interface GradedV2 extends submission.GradedResponseV2 {
        _type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends submission.WorkspaceRanResponse {
        _type: \\"workspaceRan\\";
    }

    interface Recording extends submission.RecordingResponseNotification {
        _type: \\"recording\\";
    }

    interface Recorded extends submission.RecordedResponseNotification {
        _type: \\"recorded\\";
    }

    interface InvalidRequest extends submission.InvalidRequestResponse {
        _type: \\"invalidRequest\\";
    }

    interface Finished extends submission.FinishedResponse {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        buildingExecutor: (value: submission.BuildingExecutorResponse) => Result;
        running: (value: submission.RunningResponse) => Result;
        errored: (value: submission.ErroredResponse) => Result;
        stopped: (value: submission.StoppedResponse) => Result;
        graded: (value: submission.GradedResponse) => Result;
        gradedV2: (value: submission.GradedResponseV2) => Result;
        workspaceRan: (value: submission.WorkspaceRanResponse) => Result;
        recording: (value: submission.RecordingResponseNotification) => Result;
        recorded: (value: submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: submission.InvalidRequestResponse) => Result;
        finished: (value: submission.FinishedResponse) => Result;
        _unknown: () => Result;
    }
}

export const CodeExecutionUpdate = {
    buildingExecutor: (value: submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
        ...value,
        _type: \\"buildingExecutor\\"
    }),

    running: (value: submission.RunningResponse): CodeExecutionUpdate.Running => ({
        ...value,
        _type: \\"running\\"
    }),

    errored: (value: submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
        ...value,
        _type: \\"errored\\"
    }),

    stopped: (value: submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
        ...value,
        _type: \\"stopped\\"
    }),

    graded: (value: submission.GradedResponse): CodeExecutionUpdate.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
        ...value,
        _type: \\"gradedV2\\"
    }),

    workspaceRan: (value: submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
        ...value,
        _type: \\"workspaceRan\\"
    }),

    recording: (value: submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
        ...value,
        _type: \\"recording\\"
    }),

    recorded: (value: submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
        ...value,
        _type: \\"recorded\\"
    }),

    invalidRequest: (value: submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
        ...value,
        _type: \\"invalidRequest\\"
    }),

    finished: (value: submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
        ...value,
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: CodeExecutionUpdate, visitor: CodeExecutionUpdate._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"buildingExecutor\\": return visitor.buildingExecutor(value);
            case \\"running\\": return visitor.running(value);
            case \\"errored\\": return visitor.errored(value);
            case \\"stopped\\": return visitor.stopped(value);
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value);
            case \\"workspaceRan\\": return visitor.workspaceRan(value);
            case \\"recording\\": return visitor.recording(value);
            case \\"recorded\\": return visitor.recorded(value);
            case \\"invalidRequest\\": return visitor.invalidRequest(value);
            case \\"finished\\": return visitor.finished(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CodeExecutionUpdate[\\"_type\\"][] => [\\"buildingExecutor\\", \\"running\\", \\"errored\\", \\"stopped\\", \\"graded\\", \\"gradedV2\\", \\"workspaceRan\\", \\"recording\\", \\"recorded\\", \\"invalidRequest\\", \\"finished\\"],
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface CompileError {
    message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CustomTestCasesUnsupported {
    problemId: model.commons.ProblemId;
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ErrorInfo =
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError;

export declare namespace ErrorInfo {
    interface CompileError extends submission.CompileError {
        _type: \\"compileError\\";
    }

    interface RuntimeError extends submission.RuntimeError {
        _type: \\"runtimeError\\";
    }

    interface InternalError extends submission.InternalError {
        _type: \\"internalError\\";
    }

    export interface _Visitor<Result> {
        compileError: (value: submission.CompileError) => Result;
        runtimeError: (value: submission.RuntimeError) => Result;
        internalError: (value: submission.InternalError) => Result;
        _unknown: () => Result;
    }
}

export const ErrorInfo = {
    compileError: (value: submission.CompileError): ErrorInfo.CompileError => ({
        ...value,
        _type: \\"compileError\\"
    }),

    runtimeError: (value: submission.RuntimeError): ErrorInfo.RuntimeError => ({
        ...value,
        _type: \\"runtimeError\\"
    }),

    internalError: (value: submission.InternalError): ErrorInfo.InternalError => ({
        ...value,
        _type: \\"internalError\\"
    }),

    _visit: <Result>(value: ErrorInfo, visitor: ErrorInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"compileError\\": return visitor.compileError(value);
            case \\"runtimeError\\": return visitor.runtimeError(value);
            case \\"internalError\\": return visitor.internalError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): ErrorInfo[\\"_type\\"][] => [\\"compileError\\", \\"runtimeError\\", \\"internalError\\"],
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ErroredResponse {
    submissionId: model.submission.SubmissionId;
    errorInfo: model.submission.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ExceptionV2 =
    | ExceptionV2.Generic
    | ExceptionV2.Timeout;

export declare namespace ExceptionV2 {
    interface Generic extends submission.ExceptionInfo {
        _type: \\"generic\\";
    }

    interface Timeout {
        _type: \\"timeout\\";
    }

    export interface _Visitor<Result> {
        generic: (value: submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: () => Result;
    }
}

export const ExceptionV2 = {
    generic: (value: submission.ExceptionInfo): ExceptionV2.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    timeout: (): ExceptionV2.Timeout => ({
        _type: \\"timeout\\"
    }),

    _visit: <Result>(value: ExceptionV2, visitor: ExceptionV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            case \\"timeout\\": return visitor.timeout();
            default: return visitor._unknown();
        }
    },

    _types: (): ExceptionV2[\\"_type\\"][] => [\\"generic\\", \\"timeout\\"],
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionState {
    lastTimeContacted: string | null | undefined;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ExecutionSessionStatus =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
    CreatingContainer: \\"CREATING_CONTAINER\\",
    ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
    PendingContainer: \\"PENDING_CONTAINER\\",
    RunningContainer: \\"RUNNING_CONTAINER\\",
    LiveContainer: \\"LIVE_CONTAINER\\",
    FailedToLaunch: \\"FAILED_TO_LAUNCH\\",

    _visit: <Result>(value: ExecutionSessionStatus, visitor: ExecutionSessionStatus._Visitor<Result>): Result => {
        switch (value) {
            case ExecutionSessionStatus.CreatingContainer: return visitor.creatingContainer();
            case ExecutionSessionStatus.ProvisioningContainer: return visitor.provisioningContainer();
            case ExecutionSessionStatus.PendingContainer: return visitor.pendingContainer();
            case ExecutionSessionStatus.RunningContainer: return visitor.runningContainer();
            case ExecutionSessionStatus.LiveContainer: return visitor.liveContainer();
            case ExecutionSessionStatus.FailedToLaunch: return visitor.failedToLaunch();
            default: return visitor._unknown();
        }
    },

    _values: (): ExecutionSessionStatus[] => [ExecutionSessionStatus.CreatingContainer, ExecutionSessionStatus.ProvisioningContainer, ExecutionSessionStatus.PendingContainer, ExecutionSessionStatus.RunningContainer, ExecutionSessionStatus.LiveContainer, ExecutionSessionStatus.FailedToLaunch],
} as const;

export declare namespace ExecutionSessionStatus {
    type CreatingContainer = \\"CREATING_CONTAINER\\";
    type ProvisioningContainer = \\"PROVISIONING_CONTAINER\\";
    type PendingContainer = \\"PENDING_CONTAINER\\";
    type RunningContainer = \\"RUNNING_CONTAINER\\";
    type LiveContainer = \\"LIVE_CONTAINER\\";
    type FailedToLaunch = \\"FAILED_TO_LAUNCH\\";

    export interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface FinishedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, model.submission.ExecutionSessionState>;
    numWarmingInstances: number | null | undefined;
    warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted: string | null | undefined;
    submission: string;
    language: model.commons.Language;
    submissionTypeState: model.submission.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GetTraceResponsesPageRequest {
    offset: number | null | undefined;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponse {
    submissionId: model.submission.SubmissionId;
    testCases: Record<string, model.submission.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponseV2 {
    submissionId: model.submission.SubmissionId;
    testCases: Record<model.v2.problem.TestCaseId, model.submission.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    grade: model.submission.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InitializeProblemRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InternalError {
    exceptionInfo: model.submission.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type InvalidRequestCause =
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends submission.SubmissionIdNotFound {
        _type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends submission.CustomTestCasesUnsupported {
        _type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends submission.UnexpectedLanguageError {
        _type: \\"unexpectedLanguage\\";
    }

    export interface _Visitor<Result> {
        submissionIdNotFound: (value: submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: submission.UnexpectedLanguageError) => Result;
        _unknown: () => Result;
    }
}

export const InvalidRequestCause = {
    submissionIdNotFound: (value: submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
        ...value,
        _type: \\"submissionIdNotFound\\"
    }),

    customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
        ...value,
        _type: \\"customTestCasesUnsupported\\"
    }),

    unexpectedLanguage: (value: submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
        ...value,
        _type: \\"unexpectedLanguage\\"
    }),

    _visit: <Result>(value: InvalidRequestCause, visitor: InvalidRequestCause._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"submissionIdNotFound\\": return visitor.submissionIdNotFound(value);
            case \\"customTestCasesUnsupported\\": return visitor.customTestCasesUnsupported(value);
            case \\"unexpectedLanguage\\": return visitor.unexpectedLanguage(value);
            default: return visitor._unknown();
        }
    },

    _types: (): InvalidRequestCause[\\"_type\\"][] => [\\"submissionIdNotFound\\", \\"customTestCasesUnsupported\\", \\"unexpectedLanguage\\"],
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InvalidRequestResponse {
    request: model.submission.SubmissionRequest;
    cause: model.submission.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedResponseNotification {
    submissionId: model.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId: string | null | undefined;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordingResponseNotification {
    submissionId: model.submission.SubmissionId;
    testCaseId: string | null | undefined;
    lineNumber: number;
    lightweightStackInfo: model.submission.LightweightStackframeInformation;
    tracedFile: model.submission.TracedFile | null | undefined;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RunningResponse {
    submissionId: model.submission.SubmissionId;
    state: model.submission.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type RunningSubmissionState =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
    QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
    KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
    CompilingSubmission: \\"COMPILING_SUBMISSION\\",
    RunningSubmission: \\"RUNNING_SUBMISSION\\",

    _visit: <Result>(value: RunningSubmissionState, visitor: RunningSubmissionState._Visitor<Result>): Result => {
        switch (value) {
            case RunningSubmissionState.QueueingSubmission: return visitor.queueingSubmission();
            case RunningSubmissionState.KillingHistoricalSubmissions: return visitor.killingHistoricalSubmissions();
            case RunningSubmissionState.WritingSubmissionToFile: return visitor.writingSubmissionToFile();
            case RunningSubmissionState.CompilingSubmission: return visitor.compilingSubmission();
            case RunningSubmissionState.RunningSubmission: return visitor.runningSubmission();
            default: return visitor._unknown();
        }
    },

    _values: (): RunningSubmissionState[] => [RunningSubmissionState.QueueingSubmission, RunningSubmissionState.KillingHistoricalSubmissions, RunningSubmissionState.WritingSubmissionToFile, RunningSubmissionState.CompilingSubmission, RunningSubmissionState.RunningSubmission],
} as const;

export declare namespace RunningSubmissionState {
    type QueueingSubmission = \\"QUEUEING_SUBMISSION\\";
    type KillingHistoricalSubmissions = \\"KILLING_HISTORICAL_SUBMISSIONS\\";
    type WritingSubmissionToFile = \\"WRITING_SUBMISSION_TO_FILE\\";
    type CompilingSubmission = \\"COMPILING_SUBMISSION\\";
    type RunningSubmission = \\"RUNNING_SUBMISSION\\";

    export interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface RuntimeError {
    message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Scope {
    variables: Record<string, model.commons.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ShareId = string;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: model.submission.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame: model.submission.StackFrame | null | undefined;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StderrResponse {
    submissionId: model.submission.SubmissionId;
    stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StdoutResponse {
    submissionId: model.submission.SubmissionId;
    stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StopRequest {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoppedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type SubmissionId = string;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: model.submission.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionRequest =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends submission.InitializeProblemRequest {
        _type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        _type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends submission.SubmitRequestV2 {
        _type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends submission.WorkspaceSubmitRequest {
        _type: \\"workspaceSubmit\\";
    }

    interface Stop extends submission.StopRequest {
        _type: \\"stop\\";
    }

    export interface _Visitor<Result> {
        initializeProblemRequest: (value: submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: submission.WorkspaceSubmitRequest) => Result;
        stop: (value: submission.StopRequest) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionRequest = {
    initializeProblemRequest: (value: submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
        ...value,
        _type: \\"initializeProblemRequest\\"
    }),

    initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
        _type: \\"initializeWorkspaceRequest\\"
    }),

    submitV2: (value: submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
        ...value,
        _type: \\"submitV2\\"
    }),

    workspaceSubmit: (value: submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
        ...value,
        _type: \\"workspaceSubmit\\"
    }),

    stop: (value: submission.StopRequest): SubmissionRequest.Stop => ({
        ...value,
        _type: \\"stop\\"
    }),

    _visit: <Result>(value: SubmissionRequest, visitor: SubmissionRequest._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"initializeProblemRequest\\": return visitor.initializeProblemRequest(value);
            case \\"initializeWorkspaceRequest\\": return visitor.initializeWorkspaceRequest();
            case \\"submitV2\\": return visitor.submitV2(value);
            case \\"workspaceSubmit\\": return visitor.workspaceSubmit(value);
            case \\"stop\\": return visitor.stop(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionRequest[\\"_type\\"][] => [\\"initializeProblemRequest\\", \\"initializeWorkspaceRequest\\", \\"submitV2\\", \\"workspaceSubmit\\", \\"stop\\"],
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type SubmissionResponse =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

export declare namespace SubmissionResponse {
    interface ServerInitialized {
        _type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        _type: \\"problemInitialized\\";
        problemInitialized: commons.ProblemId;
    }

    interface WorkspaceInitialized {
        _type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends submission.ExceptionInfo {
        _type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        _type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: submission.CodeExecutionUpdate;
    }

    interface Terminated extends submission.TerminatedResponse {
        _type: \\"terminated\\";
    }

    export interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: submission.CodeExecutionUpdate) => Result;
        terminated: (value: submission.TerminatedResponse) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionResponse = {
    serverInitialized: (): SubmissionResponse.ServerInitialized => ({
        _type: \\"serverInitialized\\"
    }),

    problemInitialized: (value: commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
        problemInitialized: value,
        _type: \\"problemInitialized\\"
    }),

    workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
        _type: \\"workspaceInitialized\\"
    }),

    serverErrored: (value: submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
        ...value,
        _type: \\"serverErrored\\"
    }),

    codeExecutionUpdate: (value: submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
        codeExecutionUpdate: value,
        _type: \\"codeExecutionUpdate\\"
    }),

    terminated: (value: submission.TerminatedResponse): SubmissionResponse.Terminated => ({
        ...value,
        _type: \\"terminated\\"
    }),

    _visit: <Result>(value: SubmissionResponse, visitor: SubmissionResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"serverInitialized\\": return visitor.serverInitialized();
            case \\"problemInitialized\\": return visitor.problemInitialized(value.problemInitialized);
            case \\"workspaceInitialized\\": return visitor.workspaceInitialized();
            case \\"serverErrored\\": return visitor.serverErrored(value);
            case \\"codeExecutionUpdate\\": return visitor.codeExecutionUpdate(value.codeExecutionUpdate);
            case \\"terminated\\": return visitor.terminated(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionResponse[\\"_type\\"][] => [\\"serverInitialized\\", \\"problemInitialized\\", \\"workspaceInitialized\\", \\"serverErrored\\", \\"codeExecutionUpdate\\", \\"terminated\\"],
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusForTestCase =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends submission.TestCaseResultWithStdout {
        _type: \\"graded\\";
    }

    interface GradedV2 {
        _type: \\"gradedV2\\";
        gradedV2: submission.TestCaseGrade;
    }

    interface Traced extends submission.TracedTestCase {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        graded: (value: submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: submission.TestCaseGrade) => Result;
        traced: (value: submission.TracedTestCase) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusForTestCase = {
    graded: (value: submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
        gradedV2: value,
        _type: \\"gradedV2\\"
    }),

    traced: (value: submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: SubmissionStatusForTestCase, visitor: SubmissionStatusForTestCase._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value.gradedV2);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusForTestCase[\\"_type\\"][] => [\\"graded\\", \\"gradedV2\\", \\"traced\\"],
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusV2 =
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace;

export declare namespace SubmissionStatusV2 {
    interface Test extends submission.TestSubmissionStatusV2 {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionStatusV2 {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionStatusV2) => Result;
        workspace: (value: submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusV2 = {
    test: (value: submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionStatusV2, visitor: SubmissionStatusV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusV2[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum =
    | \\"TEST\\";

export const SubmissionTypeEnum = {
    Test: \\"TEST\\",

    _visit: <Result>(value: SubmissionTypeEnum, visitor: SubmissionTypeEnum._Visitor<Result>): Result => {
        switch (value) {
            case SubmissionTypeEnum.Test: return visitor.test();
            default: return visitor._unknown();
        }
    },

    _values: (): SubmissionTypeEnum[] => [SubmissionTypeEnum.Test],
} as const;

export declare namespace SubmissionTypeEnum {
    type Test = \\"TEST\\";

    export interface _Visitor<Result> {
        test: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionTypeState =
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace;

export declare namespace SubmissionTypeState {
    interface Test extends submission.TestSubmissionState {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionState {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionState) => Result;
        workspace: (value: submission.WorkspaceSubmissionState) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionTypeState = {
    test: (value: submission.TestSubmissionState): SubmissionTypeState.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionTypeState, visitor: SubmissionTypeState._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionTypeState[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmitRequestV2 {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
    userId: string | null | undefined;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TerminatedResponse {
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestCaseGrade =
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden;

export declare namespace TestCaseGrade {
    interface Hidden extends submission.TestCaseHiddenGrade {
        _type: \\"hidden\\";
    }

    interface NonHidden extends submission.TestCaseNonHiddenGrade {
        _type: \\"nonHidden\\";
    }

    export interface _Visitor<Result> {
        hidden: (value: submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: submission.TestCaseNonHiddenGrade) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseGrade = {
    hidden: (value: submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
        ...value,
        _type: \\"hidden\\"
    }),

    nonHidden: (value: submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
        ...value,
        _type: \\"nonHidden\\"
    }),

    _visit: <Result>(value: TestCaseGrade, visitor: TestCaseGrade._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"hidden\\": return visitor.hidden(value);
            case \\"nonHidden\\": return visitor.nonHidden(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseGrade[\\"_type\\"][] => [\\"hidden\\", \\"nonHidden\\"],
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult: model.commons.VariableValue | null | undefined;
    exception: model.submission.ExceptionV2 | null | undefined;
    stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResult {
    expectedResult: model.commons.VariableValue;
    actualResult: model.submission.ActualResult;
    passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResultWithStdout {
    result: model.submission.TestCaseResult;
    stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionState {
    problemId: model.commons.ProblemId;
    defaultTestCases: model.commons.TestCase[];
    customTestCases: model.commons.TestCase[];
    status: model.submission.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionStatus =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

export declare namespace TestSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface TestCaseIdToState {
        _type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, submission.SubmissionStatusForTestCase>;
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>) => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionStatus = {
    stopped: (): TestSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
        testCaseIdToState: value,
        _type: \\"testCaseIdToState\\"
    }),

    _visit: <Result>(value: TestSubmissionStatus, visitor: TestSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"testCaseIdToState\\": return visitor.testCaseIdToState(value.testCaseIdToState);
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"testCaseIdToState\\"],
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionStatusV2 {
    updates: model.submission.TestSubmissionUpdate[];
    problemId: model.commons.ProblemId;
    problemVersion: number;
    problemInfo: model.v2.problem.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionUpdateInfo =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

export declare namespace TestSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface GradedTestCase extends submission.GradedTestCaseUpdate {
        _type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends submission.RecordedTestCaseUpdate {
        _type: \\"recordedTestCase\\";
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        gradedTestCase: (value: submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    stopped: (): TestSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    gradedTestCase: (value: submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
        ...value,
        _type: \\"gradedTestCase\\"
    }),

    recordedTestCase: (value: submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
        ...value,
        _type: \\"recordedTestCase\\"
    }),

    finished: (): TestSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: TestSubmissionUpdateInfo, visitor: TestSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"gradedTestCase\\": return visitor.gradedTestCase(value);
            case \\"recordedTestCase\\": return visitor.recordedTestCase(value);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"stopped\\", \\"errored\\", \\"gradedTestCase\\", \\"recordedTestCase\\", \\"finished\\"],
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponse {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponseV2 {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    file: model.submission.TracedFile;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TracedTestCase {
    result: model.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: model.commons.Language;
    actualLanguage: model.commons.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceFiles {
    mainFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRanResponse {
    submissionId: model.submission.SubmissionId;
    runDetails: model.submission.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRunDetails {
    exceptionV2: model.submission.ExceptionV2 | null | undefined;
    exception: model.submission.ExceptionInfo | null | undefined;
    stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<model.commons.Language, model.submission.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionState {
    status: model.submission.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionStatus =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Traced extends submission.WorkspaceRunDetails {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        traced: (value: submission.WorkspaceRunDetails) => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionStatus = {
    stopped: (): WorkspaceSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    traced: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionStatus, visitor: WorkspaceSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"ran\\", \\"traced\\"],
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: model.submission.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionUpdateInfo =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Traced {
        _type: \\"traced\\";
    }

    interface TracedV2 extends submission.WorkspaceTracedUpdate {
        _type: \\"tracedV2\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: submission.WorkspaceTracedUpdate) => Result;
        errored: (value: submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
        _type: \\"traced\\"
    }),

    tracedV2: (value: submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
        ...value,
        _type: \\"tracedV2\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionUpdateInfo, visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"stopped\\": return visitor.stopped();
            case \\"traced\\": return visitor.traced();
            case \\"tracedV2\\": return visitor.tracedV2(value);
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"ran\\", \\"stopped\\", \\"traced\\", \\"tracedV2\\", \\"errored\\", \\"finished\\"],
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    userId: string | null | undefined;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetNumWarmInstancesErrorBody = never;

export declare namespace GetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: GetNumWarmInstancesErrorBody, visitor: GetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetNumWarmInstancesResponse = GetNumWarmInstancesResponse.SuccessResponse | GetNumWarmInstancesResponse.ErrorResponse;

export declare namespace GetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
        body: Record<model.commons.Language, number>;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.GetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "GetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetNumWarmInstancesErrorBody = never;

export declare namespace SetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: SetNumWarmInstancesErrorBody, visitor: SetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SetNumWarmInstancesRequest {
    language: model.commons.Language;
    numWarmInstances: number;
}
",
                        "name": "SetNumWarmInstancesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetNumWarmInstancesResponse = SetNumWarmInstancesResponse.SuccessResponse | SetNumWarmInstancesResponse.ErrorResponse;

export declare namespace SetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.SetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "SetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SetNumWarmInstancesRequest\\";
export * from \\"./SetNumWarmInstancesErrorBody\\";
export * from \\"./SetNumWarmInstancesResponse\\";
export * from \\"./GetNumWarmInstancesErrorBody\\";
export * from \\"./GetNumWarmInstancesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "SysPropCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./SysPropCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLatestProblemErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                            "name": "GetLatestProblemRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLatestProblemErrorBody;
    }
}
",
                            "name": "GetLatestProblemResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLightweightProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLightweightProblemsErrorBody;
    }
}
",
                            "name": "GetLightweightProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemVersionErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                            "name": "GetProblemVersionRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemVersionErrorBody;
    }
}
",
                            "name": "GetProblemVersionResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemsErrorBody;
    }
}
",
                            "name": "GetProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "ProblemInfoServicV2",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_service-types",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.problem.Files>;
    basicTestCaseTemplate: model.v2.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.problem.CustomFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2, commons } from \\"../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Files {
    files: model.v2.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.problem.Files>;
    other: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.problem.NonVoidFunctionSignature;
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Parameter {
    parameterId: model.v2.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.problem.CustomFiles;
    generatedFiles: model.v2.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementation {
    description: model.v2.problem.TestCaseImplementationDescription;
    function: model.v2.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseMetadata {
    id: model.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.problem.TestCaseMetadata;
    implementation: model.v2.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.problem.TestCaseExpects | null | undefined;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_types",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLatestProblemErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                                "name": "GetLatestProblemRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLatestProblemErrorBody;
    }
}
",
                                "name": "GetLatestProblemResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLightweightProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLightweightProblemsErrorBody;
    }
}
",
                                "name": "GetLightweightProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemVersionErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                                "name": "GetProblemVersionRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemVersionErrorBody;
    }
}
",
                                "name": "GetProblemVersionResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemsErrorBody;
    }
}
",
                                "name": "GetProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "ProblemInfoServicV2",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_service-types",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.v3.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    basicTestCaseTemplate: model.v2.v3.problem.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2, commons } from \\"../../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.v3.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.v3.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.v3.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.v3.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.v3.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Files {
    files: model.v2.v3.problem.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.v3.problem.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.v3.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.v3.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.v3.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    other: Record<model.commons.Language, model.v2.v3.problem.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.v3.problem.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.v3.problem.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.v3.problem.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Parameter {
    parameterId: model.v2.v3.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type ParameterId = string;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.v3.problem.CustomFiles;
    generatedFiles: model.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.v3.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseId = string;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementation {
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    function: model.v2.v3.problem.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.v3.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.v3.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.v3.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseMetadata {
    id: model.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.v3.problem.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseTemplateId = string;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.v3.problem.TestCaseMetadata;
    implementation: model.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.v3.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.v3.problem.TestCaseExpects | null | undefined;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.v3.problem.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.v3.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_types",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "model",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"name\\": \\"@fern-api/my-api-client\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"@fern-typescript/service-utils\\": \\"0.0.184\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
        "name": "package.json",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface AdminService {
    updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): Promise<model.admin.UpdateTestSubmissionStatusResponse>;
    sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): Promise<model.admin.SendTestSubmissionUpdateResponse>;
    updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse>;
    sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): Promise<model.admin.SendWorkspaceSubmissionUpdateResponse>;
    storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): Promise<model.admin.StoreTracedTestCaseResponse>;
    storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): Promise<model.admin.StoreTracedTestCaseV2Response>;
    storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): Promise<model.admin.StoreTracedWorkspaceResponse>;
    storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): Promise<model.admin.StoreTracedWorkspaceV2Response>;
}

export declare namespace AdminService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class AdminService implements AdminService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: AdminService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/admin\\");
    }

    public async updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): Promise<model.admin.UpdateTestSubmissionStatusResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-submission-status/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.UpdateTestSubmissionStatusErrorBody
            };
        }
    }

    public async sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): Promise<model.admin.SendTestSubmissionUpdateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-submission-status-v2/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.SendTestSubmissionUpdateErrorBody
            };
        }
    }

    public async updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-submission-status/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.UpdateWorkspaceSubmissionStatusErrorBody
            };
        }
    }

    public async sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): Promise<model.admin.SendWorkspaceSubmissionUpdateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-submission-status-v2/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.SendWorkspaceSubmissionUpdateErrorBody
            };
        }
    }

    public async storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): Promise<model.admin.StoreTracedTestCaseResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedTestCaseErrorBody
            };
        }
    }

    public async storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): Promise<model.admin.StoreTracedTestCaseV2Response> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedTestCaseV2ErrorBody
            };
        }
    }

    public async storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): Promise<model.admin.StoreTracedWorkspaceResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-trace/submission/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedWorkspaceErrorBody
            };
        }
    }

    public async storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): Promise<model.admin.StoreTracedWorkspaceV2Response> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/store-workspace-trace-v2/submission/\${request.submissionId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.admin.StoreTracedWorkspaceV2ErrorBody
            };
        }
    }
}
",
                "name": "AdminService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./AdminService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface HomepageProblemService {
    getHomepageProblems(): Promise<model.homepage.GetHomepageProblemsResponse>;
    setHomepageProblems(request: model.commons.ProblemId[]): Promise<model.homepage.SetHomepageProblemsResponse>;
}

export declare namespace HomepageProblemService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class HomepageProblemService implements HomepageProblemService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: HomepageProblemService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/homepage-problems\\");
    }

    public async getHomepageProblems(): Promise<model.homepage.GetHomepageProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.commons.ProblemId[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.homepage.GetHomepageProblemsErrorBody
            };
        }
    }

    public async setHomepageProblems(request: model.commons.ProblemId[]): Promise<model.homepage.SetHomepageProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.homepage.SetHomepageProblemsErrorBody
            };
        }
    }
}
",
                "name": "HomepageProblemService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./HomepageProblemService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as sysprop from \\"./sysprop\\";
export * as v2 from \\"./v2\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface MigrationInfoService {
    getAttemptedMigrations(): Promise<model.migration.GetAttemptedMigrationsResponse>;
}

export declare namespace MigrationInfoService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class MigrationInfoService implements MigrationInfoService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: MigrationInfoService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/migration-info\\");
    }

    public async getAttemptedMigrations(): Promise<model.migration.GetAttemptedMigrationsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/all\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.migration.Migration[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.migration.GetAttemptedMigrationsErrorBody
            };
        }
    }
}
",
                "name": "MigrationInfoService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationInfoService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface PlaylistCrudService {
    createPlaylist(request: model.playlist.PlaylistCreateRequest): Promise<model.playlist.CreatePlaylistResponse>;
    getPlaylists(request: model.playlist.GetPlaylistsRequest): Promise<model.playlist.GetPlaylistsResponse>;
    getPlaylist(request: model.playlist.GetPlaylistRequest): Promise<model.playlist.GetPlaylistResponse>;
    updatePlaylist(request: model.playlist._UpdatePlaylistRequest): Promise<model.playlist.UpdatePlaylistResponse>;
    deletePlaylist(request: model.playlist.DeletePlaylistRequest): Promise<model.playlist.DeletePlaylistResponse>;
}

export declare namespace PlaylistCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class PlaylistCrudService implements PlaylistCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: PlaylistCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/v2/playlist\\");
    }

    public async createPlaylist(request: model.playlist.PlaylistCreateRequest): Promise<model.playlist.CreatePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/create\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.CreatePlaylistErrorBody
            };
        }
    }

    public async getPlaylists(request: model.playlist.GetPlaylistsRequest): Promise<model.playlist.GetPlaylistsResponse> {
        const queryParameters = new URLSearchParams();
        if (request.limit != null) {
            queryParameters.append(\\"limit\\", request.limit.toString());
        }

        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/all\\"),
            method: \\"GET\\",
            headers: {},
            queryParameters
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.GetPlaylistsErrorBody
            };
        }
    }

    public async getPlaylist(request: model.playlist.GetPlaylistRequest): Promise<model.playlist.GetPlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlistId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.GetPlaylistErrorBody
            };
        }
    }

    public async updatePlaylist(request: model.playlist._UpdatePlaylistRequest): Promise<model.playlist.UpdatePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlistId}\`),
            method: \\"PUT\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.playlist.Playlist | null | undefined
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.UpdatePlaylistErrorBody
            };
        }
    }

    public async deletePlaylist(request: model.playlist.DeletePlaylistRequest): Promise<model.playlist.DeletePlaylistResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.playlist_id}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.playlist.DeletePlaylistErrorBody
            };
        }
    }
}
",
                "name": "PlaylistCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ProblemCrudService {
    createProblem(request: model.problem.CreateProblemRequest): Promise<model.problem._CreateProblemResponse>;
    updateProblem(request: model.problem.UpdateProblemRequest): Promise<model.problem._UpdateProblemResponse>;
    deleteProblem(request: model.problem.DeleteProblemRequest): Promise<model.problem.DeleteProblemResponse>;
    getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): Promise<model.problem._GetDefaultStarterFilesResponse>;
}

export declare namespace ProblemCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemCrudService implements ProblemCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problem-crud\\");
    }

    public async createProblem(request: model.problem.CreateProblemRequest): Promise<model.problem._CreateProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/create\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.CreateProblemResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.CreateProblemErrorBody
            };
        }
    }

    public async updateProblem(request: model.problem.UpdateProblemRequest): Promise<model.problem._UpdateProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/update/\${request.problemId}\`),
            method: \\"POST\\",
            headers: {},
            body: request.body
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.UpdateProblemResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.UpdateProblemErrorBody
            };
        }
    }

    public async deleteProblem(request: model.problem.DeleteProblemRequest): Promise<model.problem.DeleteProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/delete/\${request.problemId}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.DeleteProblemErrorBody
            };
        }
    }

    public async getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): Promise<model.problem._GetDefaultStarterFilesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/default-starter-files\\"),
            method: \\"POST\\",
            headers: {},
            body: request
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.problem.GetDefaultStarterFilesResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.problem.GetDefaultStarterFilesErrorBody
            };
        }
    }
}
",
                "name": "ProblemCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface ExecutionSesssionManagementService {
    createExecutionSession(request: model.submission.CreateExecutionSessionRequest): Promise<model.submission.CreateExecutionSessionResponse>;
    getExecutionSession(request: model.submission.GetExecutionSessionRequest): Promise<model.submission.GetExecutionSessionResponse>;
    stopExecutionSession(request: model.submission.StopExecutionSessionRequest): Promise<model.submission.StopExecutionSessionResponse>;
    getExecutionSessionsState(): Promise<model.submission.GetExecutionSessionsStateResponse>;
}

export declare namespace ExecutionSesssionManagementService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class ExecutionSesssionManagementService implements ExecutionSesssionManagementService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ExecutionSesssionManagementService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/sessions\\");
    }

    public async createExecutionSession(request: model.submission.CreateExecutionSessionRequest): Promise<model.submission.CreateExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/create-session/\${request.language}\`),
            method: \\"POST\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.ExecutionSessionResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.CreateExecutionSessionErrorBody
            };
        }
    }

    public async getExecutionSession(request: model.submission.GetExecutionSessionRequest): Promise<model.submission.GetExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/\${request.sessionId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.ExecutionSessionResponse | null | undefined
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.GetExecutionSessionErrorBody
            };
        }
    }

    public async stopExecutionSession(request: model.submission.StopExecutionSessionRequest): Promise<model.submission.StopExecutionSessionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/stop/\${request.sessionId}\`),
            method: \\"DELETE\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.StopExecutionSessionErrorBody
            };
        }
    }

    public async getExecutionSessionsState(): Promise<model.submission.GetExecutionSessionsStateResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/execution-sessions-state\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.submission.GetExecutionSessionStateResponse
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.submission.GetExecutionSessionsStateErrorBody
            };
        }
    }
}
",
                "name": "ExecutionSesssionManagementService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../model\\";

export interface SysPropCrudService {
    setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): Promise<model.sysprop.SetNumWarmInstancesResponse>;
    getNumWarmInstances(): Promise<model.sysprop.GetNumWarmInstancesResponse>;
}

export declare namespace SysPropCrudService {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class SysPropCrudService implements SysPropCrudService {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: SysPropCrudService.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/sysprop\\");
    }

    public async setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): Promise<model.sysprop.SetNumWarmInstancesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`),
            method: \\"PUT\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.sysprop.SetNumWarmInstancesErrorBody
            };
        }
    }

    public async getNumWarmInstances(): Promise<model.sysprop.GetNumWarmInstancesResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/num-warm-instances\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as Record<model.commons.Language, number>
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.sysprop.GetNumWarmInstancesErrorBody
            };
        }
    }
}
",
                "name": "SysPropCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SysPropCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../../model\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): Promise<model.v2.problem.GetLightweightProblemsResponse>;
    getProblems(): Promise<model.v2.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): Promise<model.v2.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): Promise<model.v2.problem.GetProblemVersionResponse>;
}

export declare namespace ProblemInfoServicV2 {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemInfoServicV2 implements ProblemInfoServicV2 {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemInfoServicV2.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problems-v2\\");
    }

    public async getLightweightProblems(): Promise<model.v2.problem.GetLightweightProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/lightweight-problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.LightweightProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetLightweightProblemsErrorBody
            };
        }
    }

    public async getProblems(): Promise<model.v2.problem.GetProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetProblemsErrorBody
            };
        }
    }

    public async getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): Promise<model.v2.problem.GetLatestProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetLatestProblemErrorBody
            };
        }
    }

    public async getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): Promise<model.v2.problem.GetProblemVersionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.problem.GetProblemVersionErrorBody
            };
        }
    }
}
",
                    "name": "ProblemInfoServicV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { isResponseOk, defaultFetcher, Fetcher } from \\"@fern-typescript/service-utils\\";
import urlJoin from \\"url-join\\";
import * as model from \\"../../../../model\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): Promise<model.v2.v3.problem.GetLightweightProblemsResponse>;
    getProblems(): Promise<model.v2.v3.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): Promise<model.v2.v3.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): Promise<model.v2.v3.problem.GetProblemVersionResponse>;
}

export declare namespace ProblemInfoServicV2 {
    interface Init {
        origin: string;
        fetcher?: Fetcher;
    }
}

export class ProblemInfoServicV2 implements ProblemInfoServicV2 {
    private baseUrl: string;
    private fetcher: Fetcher;

    constructor(args: ProblemInfoServicV2.Init) {
        this.fetcher = args.fetcher ?? defaultFetcher;
        this.baseUrl = urlJoin(args.origin, \\"/problems-v2\\");
    }

    public async getLightweightProblems(): Promise<model.v2.v3.problem.GetLightweightProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/lightweight-problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.LightweightProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetLightweightProblemsErrorBody
            };
        }
    }

    public async getProblems(): Promise<model.v2.v3.problem.GetProblemsResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \\"/problem-info\\"),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2[]
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetProblemsErrorBody
            };
        }
    }

    public async getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): Promise<model.v2.v3.problem.GetLatestProblemResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetLatestProblemErrorBody
            };
        }
    }

    public async getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): Promise<model.v2.v3.problem.GetProblemVersionResponse> {
        const encodedResponse = await this.fetcher({
            url: urlJoin(this.baseUrl, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
            method: \\"GET\\",
            headers: {}
        });

        if (isResponseOk(encodedResponse)) {
            return {
                ok: true,
                body: encodedResponse.body as model.v2.v3.problem.ProblemInfoV2
            };
        }
        else {
            return {
                ok: false,
                error: encodedResponse.body as model.v2.v3.problem.GetProblemVersionErrorBody
            };
        }
    }
}
",
                        "name": "ProblemInfoServicV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "services",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
        "name": "tsconfig.json",
        "type": "file",
      },
    ],
    "name": "client",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
        "name": ".npmignore",
        "type": "file",
      },
      Object {
        "contents": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type SendTestSubmissionUpdateErrorBody = never;

export declare namespace SendTestSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendTestSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendTestSubmissionUpdateErrorBody, visitor: SendTestSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendTestSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendTestSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendTestSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionUpdate;
}
",
                        "name": "SendTestSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendTestSubmissionUpdateResponse = SendTestSubmissionUpdateResponse.SuccessResponse | SendTestSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendTestSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendTestSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendTestSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SendWorkspaceSubmissionUpdateErrorBody = never;

export declare namespace SendWorkspaceSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendWorkspaceSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendWorkspaceSubmissionUpdateErrorBody, visitor: SendWorkspaceSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendWorkspaceSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendWorkspaceSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendWorkspaceSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionUpdate;
}
",
                        "name": "SendWorkspaceSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendWorkspaceSubmissionUpdateResponse = SendWorkspaceSubmissionUpdateResponse.SuccessResponse | SendWorkspaceSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendWorkspaceSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendWorkspaceSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendWorkspaceSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseErrorBody = never;

export declare namespace StoreTracedTestCaseErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseErrorBody, visitor: StoreTracedTestCaseErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseResponse = StoreTracedTestCaseResponse.SuccessResponse | StoreTracedTestCaseResponse.ErrorResponse;

export declare namespace StoreTracedTestCaseResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseV2ErrorBody = never;

export declare namespace StoreTracedTestCaseV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseV2ErrorBody, visitor: StoreTracedTestCaseV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedTestCaseV2Request {
    submissionId: model.submission.SubmissionId;
    testCaseId: model.v2.problem.TestCaseId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedTestCaseV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseV2Response = StoreTracedTestCaseV2Response.SuccessResponse | StoreTracedTestCaseV2Response.ErrorResponse;

export declare namespace StoreTracedTestCaseV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseV2ErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceErrorBody = never;

export declare namespace StoreTracedWorkspaceErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceErrorBody, visitor: StoreTracedWorkspaceErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceResponse = StoreTracedWorkspaceResponse.SuccessResponse | StoreTracedWorkspaceResponse.ErrorResponse;

export declare namespace StoreTracedWorkspaceResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceV2ErrorBody = never;

export declare namespace StoreTracedWorkspaceV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceV2ErrorBody, visitor: StoreTracedWorkspaceV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedWorkspaceV2Request {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedWorkspaceV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceV2Response = StoreTracedWorkspaceV2Response.SuccessResponse | StoreTracedWorkspaceV2Response.ErrorResponse;

export declare namespace StoreTracedWorkspaceV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceV2ErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateTestSubmissionStatusErrorBody = never;

export declare namespace UpdateTestSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateTestSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateTestSubmissionStatusErrorBody, visitor: UpdateTestSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateTestSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateTestSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateTestSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionStatus;
}
",
                        "name": "UpdateTestSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateTestSubmissionStatusResponse = UpdateTestSubmissionStatusResponse.SuccessResponse | UpdateTestSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateTestSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateTestSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateTestSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateWorkspaceSubmissionStatusErrorBody = never;

export declare namespace UpdateWorkspaceSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateWorkspaceSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateWorkspaceSubmissionStatusErrorBody, visitor: UpdateWorkspaceSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateWorkspaceSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateWorkspaceSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateWorkspaceSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionStatus;
}
",
                        "name": "UpdateWorkspaceSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateWorkspaceSubmissionStatusResponse = UpdateWorkspaceSubmissionStatusResponse.SuccessResponse | UpdateWorkspaceSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateWorkspaceSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateWorkspaceSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateWorkspaceSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedTestCaseRequest {
    submissionId: model.submission.SubmissionId;
    testCaseId: string;
    body: model.admin.StoreTracedTestCaseRequest;
}
",
                        "name": "_StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedWorkspaceRequest {
    submissionId: model.submission.SubmissionId;
    body: model.admin.StoreTracedWorkspaceRequest;
}
",
                        "name": "_StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UpdateTestSubmissionStatusRequest\\";
export * from \\"./UpdateTestSubmissionStatusErrorBody\\";
export * from \\"./UpdateTestSubmissionStatusResponse\\";
export * from \\"./SendTestSubmissionUpdateRequest\\";
export * from \\"./SendTestSubmissionUpdateErrorBody\\";
export * from \\"./SendTestSubmissionUpdateResponse\\";
export * from \\"./UpdateWorkspaceSubmissionStatusRequest\\";
export * from \\"./UpdateWorkspaceSubmissionStatusErrorBody\\";
export * from \\"./UpdateWorkspaceSubmissionStatusResponse\\";
export * from \\"./SendWorkspaceSubmissionUpdateRequest\\";
export * from \\"./SendWorkspaceSubmissionUpdateErrorBody\\";
export * from \\"./SendWorkspaceSubmissionUpdateResponse\\";
export * from \\"./_StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedTestCaseErrorBody\\";
export * from \\"./StoreTracedTestCaseResponse\\";
export * from \\"./StoreTracedTestCaseV2Request\\";
export * from \\"./StoreTracedTestCaseV2ErrorBody\\";
export * from \\"./StoreTracedTestCaseV2Response\\";
export * from \\"./_StoreTracedWorkspaceRequest\\";
export * from \\"./StoreTracedWorkspaceErrorBody\\";
export * from \\"./StoreTracedWorkspaceResponse\\";
export * from \\"./StoreTracedWorkspaceV2Request\\";
export * from \\"./StoreTracedWorkspaceV2ErrorBody\\";
export * from \\"./StoreTracedWorkspaceV2Response\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "AdminService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./AdminService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedTestCaseRequest {
    result: model.submission.TestCaseResultWithStdout;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: model.submission.WorkspaceRunDetails;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: model.commons.NodeId;
    fullTree: model.commons.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    right: model.commons.NodeId | null | undefined;
    left: model.commons.NodeId | null | undefined;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeValue {
    root: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugKeyValuePairs {
    key: model.commons.DebugVariableValue;
    value: model.commons.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugMapValue {
    keyValuePairs: model.commons.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type DebugVariableValue =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

export declare namespace DebugVariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.DebugMapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends commons.BinaryTreeNodeAndTreeValue {
        _type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends commons.SinglyLinkedListNodeAndListValue {
        _type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends commons.DoublyLinkedListNodeAndListValue {
        _type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        _type: \\"undefinedValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    interface GenericValue extends commons.GenericValue {
        _type: \\"genericValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.DebugMapValue) => Result;
        listValue: (value: commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: commons.GenericValue) => Result;
        _unknown: () => Result;
    }
}

export const DebugVariableValue = {
    integerValue: (value: number): DebugVariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): DebugVariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): DebugVariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.DebugMapValue): DebugVariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
        ...value,
        _type: \\"binaryTreeNodeValue\\"
    }),

    singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
        ...value,
        _type: \\"singlyLinkedListNodeValue\\"
    }),

    doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
        ...value,
        _type: \\"doublyLinkedListNodeValue\\"
    }),

    undefinedValue: (): DebugVariableValue.UndefinedValue => ({
        _type: \\"undefinedValue\\"
    }),

    nullValue: (): DebugVariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    genericValue: (value: commons.GenericValue): DebugVariableValue.GenericValue => ({
        ...value,
        _type: \\"genericValue\\"
    }),

    _visit: <Result>(value: DebugVariableValue, visitor: DebugVariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeNodeValue\\": return visitor.binaryTreeNodeValue(value);
            case \\"singlyLinkedListNodeValue\\": return visitor.singlyLinkedListNodeValue(value);
            case \\"doublyLinkedListNodeValue\\": return visitor.doublyLinkedListNodeValue(value);
            case \\"undefinedValue\\": return visitor.undefinedValue();
            case \\"nullValue\\": return visitor.nullValue();
            case \\"genericValue\\": return visitor.genericValue(value);
            default: return visitor._unknown();
        }
    },

    _types: (): DebugVariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeNodeValue\\", \\"singlyLinkedListNodeValue\\", \\"doublyLinkedListNodeValue\\", \\"undefinedValue\\", \\"nullValue\\", \\"genericValue\\"],
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
    prev: model.commons.NodeId | null | undefined;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericValue {
    stringifiedType: string | null | undefined;
    stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface KeyValuePair {
    key: model.commons.VariableValue;
    value: model.commons.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type Language =
    | \\"JAVA\\"
    | \\"JAVASCRIPT\\"
    | \\"PYTHON\\";

export const Language = {
    Java: \\"JAVA\\",
    Javascript: \\"JAVASCRIPT\\",
    Python: \\"PYTHON\\",

    _visit: <Result>(value: Language, visitor: Language._Visitor<Result>): Result => {
        switch (value) {
            case Language.Java: return visitor.java();
            case Language.Javascript: return visitor.javascript();
            case Language.Python: return visitor.python();
            default: return visitor._unknown();
        }
    },

    _values: (): Language[] => [Language.Java, Language.Javascript, Language.Python],
} as const;

export declare namespace Language {
    type Java = \\"JAVA\\";
    type Javascript = \\"JAVASCRIPT\\";
    type Python = \\"PYTHON\\";

    export interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ListType {
    valueType: model.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength: boolean | null | undefined;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapType {
    keyType: model.commons.VariableType;
    valueType: model.commons.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapValue {
    keyValuePairs: model.commons.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type NodeId = string;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ProblemId = string;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCase {
    id: string;
    params: model.commons.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseWithExpectedResult {
    testCase: model.commons.TestCase;
    expectedResult: model.commons.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UserId = string;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableType =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

export declare namespace VariableType {
    interface IntegerType {
        _type: \\"integerType\\";
    }

    interface DoubleType {
        _type: \\"doubleType\\";
    }

    interface BooleanType {
        _type: \\"booleanType\\";
    }

    interface StringType {
        _type: \\"stringType\\";
    }

    interface CharType {
        _type: \\"charType\\";
    }

    interface ListType extends commons.ListType {
        _type: \\"listType\\";
    }

    interface MapType extends commons.MapType {
        _type: \\"mapType\\";
    }

    interface BinaryTreeType {
        _type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        _type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        _type: \\"doublyLinkedListType\\";
    }

    export interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: commons.ListType) => Result;
        mapType: (value: commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: () => Result;
    }
}

export const VariableType = {
    integerType: (): VariableType.IntegerType => ({
        _type: \\"integerType\\"
    }),

    doubleType: (): VariableType.DoubleType => ({
        _type: \\"doubleType\\"
    }),

    booleanType: (): VariableType.BooleanType => ({
        _type: \\"booleanType\\"
    }),

    stringType: (): VariableType.StringType => ({
        _type: \\"stringType\\"
    }),

    charType: (): VariableType.CharType => ({
        _type: \\"charType\\"
    }),

    listType: (value: commons.ListType): VariableType.ListType => ({
        ...value,
        _type: \\"listType\\"
    }),

    mapType: (value: commons.MapType): VariableType.MapType => ({
        ...value,
        _type: \\"mapType\\"
    }),

    binaryTreeType: (): VariableType.BinaryTreeType => ({
        _type: \\"binaryTreeType\\"
    }),

    singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
        _type: \\"singlyLinkedListType\\"
    }),

    doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
        _type: \\"doublyLinkedListType\\"
    }),

    _visit: <Result>(value: VariableType, visitor: VariableType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerType\\": return visitor.integerType();
            case \\"doubleType\\": return visitor.doubleType();
            case \\"booleanType\\": return visitor.booleanType();
            case \\"stringType\\": return visitor.stringType();
            case \\"charType\\": return visitor.charType();
            case \\"listType\\": return visitor.listType(value);
            case \\"mapType\\": return visitor.mapType(value);
            case \\"binaryTreeType\\": return visitor.binaryTreeType();
            case \\"singlyLinkedListType\\": return visitor.singlyLinkedListType();
            case \\"doublyLinkedListType\\": return visitor.doublyLinkedListType();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableType[\\"_type\\"][] => [\\"integerType\\", \\"doubleType\\", \\"booleanType\\", \\"stringType\\", \\"charType\\", \\"listType\\", \\"mapType\\", \\"binaryTreeType\\", \\"singlyLinkedListType\\", \\"doublyLinkedListType\\"],
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableValue =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

export declare namespace VariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.MapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.VariableValue[];
    }

    interface BinaryTreeValue extends commons.BinaryTreeValue {
        _type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends commons.SinglyLinkedListValue {
        _type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends commons.DoublyLinkedListValue {
        _type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.MapValue) => Result;
        listValue: (value: commons.VariableValue[]) => Result;
        binaryTreeValue: (value: commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: () => Result;
    }
}

export const VariableValue = {
    integerValue: (value: number): VariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): VariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): VariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): VariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): VariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.MapValue): VariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.VariableValue[]): VariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeValue: (value: commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
        ...value,
        _type: \\"binaryTreeValue\\"
    }),

    singlyLinkedListValue: (value: commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
        ...value,
        _type: \\"singlyLinkedListValue\\"
    }),

    doublyLinkedListValue: (value: commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
        ...value,
        _type: \\"doublyLinkedListValue\\"
    }),

    nullValue: (): VariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    _visit: <Result>(value: VariableValue, visitor: VariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeValue\\": return visitor.binaryTreeValue(value);
            case \\"singlyLinkedListValue\\": return visitor.singlyLinkedListValue(value);
            case \\"doublyLinkedListValue\\": return visitor.doublyLinkedListValue(value);
            case \\"nullValue\\": return visitor.nullValue();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeValue\\", \\"singlyLinkedListValue\\", \\"doublyLinkedListValue\\", \\"nullValue\\"],
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetHomepageProblemsErrorBody = never;

export declare namespace GetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: GetHomepageProblemsErrorBody, visitor: GetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetHomepageProblemsResponse = GetHomepageProblemsResponse.SuccessResponse | GetHomepageProblemsResponse.ErrorResponse;

export declare namespace GetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.commons.ProblemId[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.GetHomepageProblemsErrorBody;
    }
}
",
                        "name": "GetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetHomepageProblemsErrorBody = never;

export declare namespace SetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: SetHomepageProblemsErrorBody, visitor: SetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetHomepageProblemsResponse = SetHomepageProblemsResponse.SuccessResponse | SetHomepageProblemsResponse.ErrorResponse;

export declare namespace SetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.SetHomepageProblemsErrorBody;
    }
}
",
                        "name": "SetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetHomepageProblemsErrorBody\\";
export * from \\"./GetHomepageProblemsResponse\\";
export * from \\"./SetHomepageProblemsErrorBody\\";
export * from \\"./SetHomepageProblemsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "HomepageProblemService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./HomepageProblemService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export interface LangServerRequest {
    request: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LangServerResponse {
    response: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "lang-server",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetAttemptedMigrationsErrorBody = never;

export declare namespace GetAttemptedMigrationsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetAttemptedMigrationsErrorBody = {
    _visit: <Result>(_value: GetAttemptedMigrationsErrorBody, visitor: GetAttemptedMigrationsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetAttemptedMigrationsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetAttemptedMigrationsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetAttemptedMigrationsResponse = GetAttemptedMigrationsResponse.SuccessResponse | GetAttemptedMigrationsResponse.ErrorResponse;

export declare namespace GetAttemptedMigrationsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.migration.Migration[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.migration.GetAttemptedMigrationsErrorBody;
    }
}
",
                        "name": "GetAttemptedMigrationsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetAttemptedMigrationsErrorBody\\";
export * from \\"./GetAttemptedMigrationsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "MigrationInfoService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationInfoService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Migration {
    name: string;
    status: model.migration.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type MigrationStatus =
    | \\"RUNNING\\"
    | \\"FAILED\\"
    | \\"FINISHED\\";

export const MigrationStatus = {
    Running: \\"RUNNING\\",
    Failed: \\"FAILED\\",
    Finished: \\"FINISHED\\",

    _visit: <Result>(value: MigrationStatus, visitor: MigrationStatus._Visitor<Result>): Result => {
        switch (value) {
            case MigrationStatus.Running: return visitor.running();
            case MigrationStatus.Failed: return visitor.failed();
            case MigrationStatus.Finished: return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _values: (): MigrationStatus[] => [MigrationStatus.Running, MigrationStatus.Failed, MigrationStatus.Finished],
} as const;

export declare namespace MigrationStatus {
    type Running = \\"RUNNING\\";
    type Failed = \\"FAILED\\";
    type Finished = \\"FINISHED\\";

    export interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistIdNotFoundError {
    playlistId: model.playlist.PlaylistId;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UnauthorizedError = Record<string, never>;
",
                    "name": "UnauthorizedError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_errors",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreatePlaylistErrorBody = never;

export declare namespace CreatePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreatePlaylistErrorBody = {
    _visit: <Result>(_value: CreatePlaylistErrorBody, visitor: CreatePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreatePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreatePlaylistResponse = CreatePlaylistResponse.SuccessResponse | CreatePlaylistResponse.ErrorResponse;

export declare namespace CreatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.CreatePlaylistErrorBody;
    }
}
",
                        "name": "CreatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeletePlaylistErrorBody = never;

export declare namespace DeletePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeletePlaylistErrorBody = {
    _visit: <Result>(_value: DeletePlaylistErrorBody, visitor: DeletePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeletePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeletePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeletePlaylistRequest {
    playlist_id: model.playlist.PlaylistId;
}
",
                        "name": "DeletePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeletePlaylistResponse = DeletePlaylistResponse.SuccessResponse | DeletePlaylistResponse.ErrorResponse;

export declare namespace DeletePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.DeletePlaylistErrorBody;
    }
}
",
                        "name": "DeletePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPlaylistErrorBody =
    | GetPlaylistErrorBody.PlaylistIdNotFoundError
    | GetPlaylistErrorBody.UnauthorizedError;

export declare namespace GetPlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    interface UnauthorizedError {
        _error: \\"UnauthorizedError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        UnauthorizedError: () => Result;
        _unknown: () => Result;
    }
}

export const GetPlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): GetPlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    unauthorizedError: (): GetPlaylistErrorBody.UnauthorizedError => ({
        _error: \\"UnauthorizedError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPlaylistErrorBody, visitor: GetPlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            case \\"UnauthorizedError\\": return visitor.UnauthorizedError();
            default: return visitor._unknown();
        }
    },

    _types: (): GetPlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\", \\"UnauthorizedError\\"],
} as const;
",
                        "name": "GetPlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetPlaylistRequest {
    playlistId: model.playlist.PlaylistId;
}
",
                        "name": "GetPlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistResponse = GetPlaylistResponse.SuccessResponse | GetPlaylistResponse.ErrorResponse;

export declare namespace GetPlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistErrorBody;
    }
}
",
                        "name": "GetPlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetPlaylistsErrorBody = never;

export declare namespace GetPlaylistsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetPlaylistsErrorBody = {
    _visit: <Result>(_value: GetPlaylistsErrorBody, visitor: GetPlaylistsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetPlaylistsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetPlaylistsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetPlaylistsRequest {
    limit: number | null | undefined;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistsResponse = GetPlaylistsResponse.SuccessResponse | GetPlaylistsResponse.ErrorResponse;

export declare namespace GetPlaylistsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistsErrorBody;
    }
}
",
                        "name": "GetPlaylistsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type UpdatePlaylistErrorBody =
    | UpdatePlaylistErrorBody.PlaylistIdNotFoundError;

export declare namespace UpdatePlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const UpdatePlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): UpdatePlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: UpdatePlaylistErrorBody, visitor: UpdatePlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): UpdatePlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\"],
} as const;
",
                        "name": "UpdatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdatePlaylistResponse = UpdatePlaylistResponse.SuccessResponse | UpdatePlaylistResponse.ErrorResponse;

export declare namespace UpdatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.UpdatePlaylistErrorBody;
    }
}
",
                        "name": "UpdatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _UpdatePlaylistRequest {
    playlistId: model.playlist.PlaylistId;
    body: model.playlist.UpdatePlaylistRequest | null | undefined;
}
",
                        "name": "_UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreatePlaylistErrorBody\\";
export * from \\"./CreatePlaylistResponse\\";
export * from \\"./GetPlaylistsRequest\\";
export * from \\"./GetPlaylistsErrorBody\\";
export * from \\"./GetPlaylistsResponse\\";
export * from \\"./GetPlaylistRequest\\";
export * from \\"./GetPlaylistErrorBody\\";
export * from \\"./GetPlaylistResponse\\";
export * from \\"./_UpdatePlaylistRequest\\";
export * from \\"./UpdatePlaylistErrorBody\\";
export * from \\"./UpdatePlaylistResponse\\";
export * from \\"./DeletePlaylistRequest\\";
export * from \\"./DeletePlaylistErrorBody\\";
export * from \\"./DeletePlaylistResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "PlaylistCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Playlist {
    playlist_id: model.playlist.PlaylistId;
    name: string;
    problems: model.commons.ProblemId[];
    \\"owner-id\\": model.commons.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type PlaylistId = string;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateProblemErrorBody = never;

export declare namespace CreateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateProblemErrorBody = {
    _visit: <Result>(_value: CreateProblemErrorBody, visitor: CreateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeleteProblemErrorBody = never;

export declare namespace DeleteProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeleteProblemErrorBody = {
    _visit: <Result>(_value: DeleteProblemErrorBody, visitor: DeleteProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeleteProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeleteProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeleteProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                        "name": "DeleteProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeleteProblemResponse = DeleteProblemResponse.SuccessResponse | DeleteProblemResponse.ErrorResponse;

export declare namespace DeleteProblemResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.DeleteProblemErrorBody;
    }
}
",
                        "name": "DeleteProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetDefaultStarterFilesErrorBody = never;

export declare namespace GetDefaultStarterFilesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetDefaultStarterFilesErrorBody = {
    _visit: <Result>(_value: GetDefaultStarterFilesErrorBody, visitor: GetDefaultStarterFilesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetDefaultStarterFilesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetDefaultStarterFilesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateProblemErrorBody = never;

export declare namespace UpdateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateProblemErrorBody = {
    _visit: <Result>(_value: UpdateProblemErrorBody, visitor: UpdateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateProblemRequest {
    problemId: model.commons.ProblemId;
    body: model.problem.CreateProblemRequest;
}
",
                        "name": "UpdateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _CreateProblemResponse = _CreateProblemResponse.SuccessResponse | _CreateProblemResponse.ErrorResponse;

export declare namespace _CreateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.CreateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.CreateProblemErrorBody;
    }
}
",
                        "name": "_CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _GetDefaultStarterFilesResponse = _GetDefaultStarterFilesResponse.SuccessResponse | _GetDefaultStarterFilesResponse.ErrorResponse;

export declare namespace _GetDefaultStarterFilesResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.GetDefaultStarterFilesResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.GetDefaultStarterFilesErrorBody;
    }
}
",
                        "name": "_GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _UpdateProblemResponse = _UpdateProblemResponse.SuccessResponse | _UpdateProblemResponse.ErrorResponse;

export declare namespace _UpdateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.UpdateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.UpdateProblemErrorBody;
    }
}
",
                        "name": "_UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateProblemErrorBody\\";
export * from \\"./_CreateProblemResponse\\";
export * from \\"./UpdateProblemRequest\\";
export * from \\"./UpdateProblemErrorBody\\";
export * from \\"./_UpdateProblemResponse\\";
export * from \\"./DeleteProblemRequest\\";
export * from \\"./DeleteProblemErrorBody\\";
export * from \\"./DeleteProblemResponse\\";
export * from \\"./GetDefaultStarterFilesErrorBody\\";
export * from \\"./_GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ProblemCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { problem } from \\"../..\\";

export type CreateProblemError =
    | CreateProblemError.Generic;

export declare namespace CreateProblemError {
    interface Generic extends problem.GenericCreateProblemError {
        _type: \\"generic\\";
    }

    export interface _Visitor<Result> {
        generic: (value: problem.GenericCreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemError = {
    generic: (value: problem.GenericCreateProblemError): CreateProblemError.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    _visit: <Result>(value: CreateProblemError, visitor: CreateProblemError._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemError[\\"_type\\"][] => [\\"generic\\"],
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { problem, commons } from \\"../..\\";

export type CreateProblemResponse =
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error;

export declare namespace CreateProblemResponse {
    interface Success {
        _type: \\"success\\";
        success: commons.ProblemId;
    }

    interface Error {
        _type: \\"error\\";
        error: problem.CreateProblemError;
    }

    export interface _Visitor<Result> {
        success: (value: commons.ProblemId) => Result;
        error: (value: problem.CreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemResponse = {
    success: (value: commons.ProblemId): CreateProblemResponse.Success => ({
        success: value,
        _type: \\"success\\"
    }),

    error: (value: problem.CreateProblemError): CreateProblemResponse.Error => ({
        error: value,
        _type: \\"error\\"
    }),

    _visit: <Result>(value: CreateProblemResponse, visitor: CreateProblemResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"success\\": return visitor.success(value.success);
            case \\"error\\": return visitor.error(value.error);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemResponse[\\"_type\\"][] => [\\"success\\", \\"error\\"],
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemDescription {
    boards: model.problem.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type ProblemDescriptionBoard =
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

export declare namespace ProblemDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface Variable {
        _type: \\"variable\\";
        variable: commons.VariableValue;
    }

    interface TestCaseId {
        _type: \\"testCaseId\\";
        testCaseId: string;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const ProblemDescriptionBoard = {
    html: (value: string): ProblemDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    variable: (value: commons.VariableValue): ProblemDescriptionBoard.Variable => ({
        variable: value,
        _type: \\"variable\\"
    }),

    testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
        testCaseId: value,
        _type: \\"testCaseId\\"
    }),

    _visit: <Result>(value: ProblemDescriptionBoard, visitor: ProblemDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"variable\\": return visitor.variable(value.variable);
            case \\"testCaseId\\": return visitor.testCaseId(value.testCaseId);
            default: return visitor._unknown();
        }
    },

    _types: (): ProblemDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"variable\\", \\"testCaseId\\"],
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemFiles {
    solutionFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemInfo {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface VariableTypeAndName {
    variableType: model.commons.VariableType;
    name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateExecutionSessionErrorBody = never;

export declare namespace CreateExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateExecutionSessionErrorBody = {
    _visit: <Result>(_value: CreateExecutionSessionErrorBody, visitor: CreateExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateExecutionSessionRequest {
    language: model.commons.Language;
}
",
                        "name": "CreateExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreateExecutionSessionResponse = CreateExecutionSessionResponse.SuccessResponse | CreateExecutionSessionResponse.ErrorResponse;

export declare namespace CreateExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.CreateExecutionSessionErrorBody;
    }
}
",
                        "name": "CreateExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionErrorBody = never;

export declare namespace GetExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionErrorBody, visitor: GetExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "GetExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionResponse = GetExecutionSessionResponse.SuccessResponse | GetExecutionSessionResponse.ErrorResponse;

export declare namespace GetExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionErrorBody;
    }
}
",
                        "name": "GetExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionsStateErrorBody = never;

export declare namespace GetExecutionSessionsStateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionsStateErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionsStateErrorBody, visitor: GetExecutionSessionsStateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionsStateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionsStateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionsStateResponse = GetExecutionSessionsStateResponse.SuccessResponse | GetExecutionSessionsStateResponse.ErrorResponse;

export declare namespace GetExecutionSessionsStateResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.GetExecutionSessionStateResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionsStateErrorBody;
    }
}
",
                        "name": "GetExecutionSessionsStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StopExecutionSessionErrorBody = never;

export declare namespace StopExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StopExecutionSessionErrorBody = {
    _visit: <Result>(_value: StopExecutionSessionErrorBody, visitor: StopExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StopExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StopExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface StopExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "StopExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StopExecutionSessionResponse = StopExecutionSessionResponse.SuccessResponse | StopExecutionSessionResponse.ErrorResponse;

export declare namespace StopExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.StopExecutionSessionErrorBody;
    }
}
",
                        "name": "StopExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateExecutionSessionRequest\\";
export * from \\"./CreateExecutionSessionErrorBody\\";
export * from \\"./CreateExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionRequest\\";
export * from \\"./GetExecutionSessionErrorBody\\";
export * from \\"./GetExecutionSessionResponse\\";
export * from \\"./StopExecutionSessionRequest\\";
export * from \\"./StopExecutionSessionErrorBody\\";
export * from \\"./StopExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionsStateErrorBody\\";
export * from \\"./GetExecutionSessionsStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ExecutionSesssionManagementService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type ActualResult =
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

export declare namespace ActualResult {
    interface Value {
        _type: \\"value\\";
        value: commons.VariableValue;
    }

    interface Exception extends submission.ExceptionInfo {
        _type: \\"exception\\";
    }

    interface ExceptionV2 {
        _type: \\"exceptionV2\\";
        exceptionV2: submission.ExceptionV2;
    }

    export interface _Visitor<Result> {
        value: (value: commons.VariableValue) => Result;
        exception: (value: submission.ExceptionInfo) => Result;
        exceptionV2: (value: submission.ExceptionV2) => Result;
        _unknown: () => Result;
    }
}

export const ActualResult = {
    value: (value: commons.VariableValue): ActualResult.Value => ({
        value: value,
        _type: \\"value\\"
    }),

    exception: (value: submission.ExceptionInfo): ActualResult.Exception => ({
        ...value,
        _type: \\"exception\\"
    }),

    exceptionV2: (value: submission.ExceptionV2): ActualResult.ExceptionV2 => ({
        exceptionV2: value,
        _type: \\"exceptionV2\\"
    }),

    _visit: <Result>(value: ActualResult, visitor: ActualResult._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"value\\": return visitor.value(value.value);
            case \\"exception\\": return visitor.exception(value);
            case \\"exceptionV2\\": return visitor.exceptionV2(value.exceptionV2);
            default: return visitor._unknown();
        }
    },

    _types: (): ActualResult[\\"_type\\"][] => [\\"value\\", \\"exception\\", \\"exceptionV2\\"],
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BuildingExecutorResponse {
    submissionId: model.submission.SubmissionId;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type CodeExecutionUpdate =
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends submission.BuildingExecutorResponse {
        _type: \\"buildingExecutor\\";
    }

    interface Running extends submission.RunningResponse {
        _type: \\"running\\";
    }

    interface Errored extends submission.ErroredResponse {
        _type: \\"errored\\";
    }

    interface Stopped extends submission.StoppedResponse {
        _type: \\"stopped\\";
    }

    interface Graded extends submission.GradedResponse {
        _type: \\"graded\\";
    }

    interface GradedV2 extends submission.GradedResponseV2 {
        _type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends submission.WorkspaceRanResponse {
        _type: \\"workspaceRan\\";
    }

    interface Recording extends submission.RecordingResponseNotification {
        _type: \\"recording\\";
    }

    interface Recorded extends submission.RecordedResponseNotification {
        _type: \\"recorded\\";
    }

    interface InvalidRequest extends submission.InvalidRequestResponse {
        _type: \\"invalidRequest\\";
    }

    interface Finished extends submission.FinishedResponse {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        buildingExecutor: (value: submission.BuildingExecutorResponse) => Result;
        running: (value: submission.RunningResponse) => Result;
        errored: (value: submission.ErroredResponse) => Result;
        stopped: (value: submission.StoppedResponse) => Result;
        graded: (value: submission.GradedResponse) => Result;
        gradedV2: (value: submission.GradedResponseV2) => Result;
        workspaceRan: (value: submission.WorkspaceRanResponse) => Result;
        recording: (value: submission.RecordingResponseNotification) => Result;
        recorded: (value: submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: submission.InvalidRequestResponse) => Result;
        finished: (value: submission.FinishedResponse) => Result;
        _unknown: () => Result;
    }
}

export const CodeExecutionUpdate = {
    buildingExecutor: (value: submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
        ...value,
        _type: \\"buildingExecutor\\"
    }),

    running: (value: submission.RunningResponse): CodeExecutionUpdate.Running => ({
        ...value,
        _type: \\"running\\"
    }),

    errored: (value: submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
        ...value,
        _type: \\"errored\\"
    }),

    stopped: (value: submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
        ...value,
        _type: \\"stopped\\"
    }),

    graded: (value: submission.GradedResponse): CodeExecutionUpdate.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
        ...value,
        _type: \\"gradedV2\\"
    }),

    workspaceRan: (value: submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
        ...value,
        _type: \\"workspaceRan\\"
    }),

    recording: (value: submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
        ...value,
        _type: \\"recording\\"
    }),

    recorded: (value: submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
        ...value,
        _type: \\"recorded\\"
    }),

    invalidRequest: (value: submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
        ...value,
        _type: \\"invalidRequest\\"
    }),

    finished: (value: submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
        ...value,
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: CodeExecutionUpdate, visitor: CodeExecutionUpdate._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"buildingExecutor\\": return visitor.buildingExecutor(value);
            case \\"running\\": return visitor.running(value);
            case \\"errored\\": return visitor.errored(value);
            case \\"stopped\\": return visitor.stopped(value);
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value);
            case \\"workspaceRan\\": return visitor.workspaceRan(value);
            case \\"recording\\": return visitor.recording(value);
            case \\"recorded\\": return visitor.recorded(value);
            case \\"invalidRequest\\": return visitor.invalidRequest(value);
            case \\"finished\\": return visitor.finished(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CodeExecutionUpdate[\\"_type\\"][] => [\\"buildingExecutor\\", \\"running\\", \\"errored\\", \\"stopped\\", \\"graded\\", \\"gradedV2\\", \\"workspaceRan\\", \\"recording\\", \\"recorded\\", \\"invalidRequest\\", \\"finished\\"],
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface CompileError {
    message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CustomTestCasesUnsupported {
    problemId: model.commons.ProblemId;
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ErrorInfo =
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError;

export declare namespace ErrorInfo {
    interface CompileError extends submission.CompileError {
        _type: \\"compileError\\";
    }

    interface RuntimeError extends submission.RuntimeError {
        _type: \\"runtimeError\\";
    }

    interface InternalError extends submission.InternalError {
        _type: \\"internalError\\";
    }

    export interface _Visitor<Result> {
        compileError: (value: submission.CompileError) => Result;
        runtimeError: (value: submission.RuntimeError) => Result;
        internalError: (value: submission.InternalError) => Result;
        _unknown: () => Result;
    }
}

export const ErrorInfo = {
    compileError: (value: submission.CompileError): ErrorInfo.CompileError => ({
        ...value,
        _type: \\"compileError\\"
    }),

    runtimeError: (value: submission.RuntimeError): ErrorInfo.RuntimeError => ({
        ...value,
        _type: \\"runtimeError\\"
    }),

    internalError: (value: submission.InternalError): ErrorInfo.InternalError => ({
        ...value,
        _type: \\"internalError\\"
    }),

    _visit: <Result>(value: ErrorInfo, visitor: ErrorInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"compileError\\": return visitor.compileError(value);
            case \\"runtimeError\\": return visitor.runtimeError(value);
            case \\"internalError\\": return visitor.internalError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): ErrorInfo[\\"_type\\"][] => [\\"compileError\\", \\"runtimeError\\", \\"internalError\\"],
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ErroredResponse {
    submissionId: model.submission.SubmissionId;
    errorInfo: model.submission.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ExceptionV2 =
    | ExceptionV2.Generic
    | ExceptionV2.Timeout;

export declare namespace ExceptionV2 {
    interface Generic extends submission.ExceptionInfo {
        _type: \\"generic\\";
    }

    interface Timeout {
        _type: \\"timeout\\";
    }

    export interface _Visitor<Result> {
        generic: (value: submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: () => Result;
    }
}

export const ExceptionV2 = {
    generic: (value: submission.ExceptionInfo): ExceptionV2.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    timeout: (): ExceptionV2.Timeout => ({
        _type: \\"timeout\\"
    }),

    _visit: <Result>(value: ExceptionV2, visitor: ExceptionV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            case \\"timeout\\": return visitor.timeout();
            default: return visitor._unknown();
        }
    },

    _types: (): ExceptionV2[\\"_type\\"][] => [\\"generic\\", \\"timeout\\"],
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionState {
    lastTimeContacted: string | null | undefined;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ExecutionSessionStatus =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
    CreatingContainer: \\"CREATING_CONTAINER\\",
    ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
    PendingContainer: \\"PENDING_CONTAINER\\",
    RunningContainer: \\"RUNNING_CONTAINER\\",
    LiveContainer: \\"LIVE_CONTAINER\\",
    FailedToLaunch: \\"FAILED_TO_LAUNCH\\",

    _visit: <Result>(value: ExecutionSessionStatus, visitor: ExecutionSessionStatus._Visitor<Result>): Result => {
        switch (value) {
            case ExecutionSessionStatus.CreatingContainer: return visitor.creatingContainer();
            case ExecutionSessionStatus.ProvisioningContainer: return visitor.provisioningContainer();
            case ExecutionSessionStatus.PendingContainer: return visitor.pendingContainer();
            case ExecutionSessionStatus.RunningContainer: return visitor.runningContainer();
            case ExecutionSessionStatus.LiveContainer: return visitor.liveContainer();
            case ExecutionSessionStatus.FailedToLaunch: return visitor.failedToLaunch();
            default: return visitor._unknown();
        }
    },

    _values: (): ExecutionSessionStatus[] => [ExecutionSessionStatus.CreatingContainer, ExecutionSessionStatus.ProvisioningContainer, ExecutionSessionStatus.PendingContainer, ExecutionSessionStatus.RunningContainer, ExecutionSessionStatus.LiveContainer, ExecutionSessionStatus.FailedToLaunch],
} as const;

export declare namespace ExecutionSessionStatus {
    type CreatingContainer = \\"CREATING_CONTAINER\\";
    type ProvisioningContainer = \\"PROVISIONING_CONTAINER\\";
    type PendingContainer = \\"PENDING_CONTAINER\\";
    type RunningContainer = \\"RUNNING_CONTAINER\\";
    type LiveContainer = \\"LIVE_CONTAINER\\";
    type FailedToLaunch = \\"FAILED_TO_LAUNCH\\";

    export interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface FinishedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, model.submission.ExecutionSessionState>;
    numWarmingInstances: number | null | undefined;
    warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted: string | null | undefined;
    submission: string;
    language: model.commons.Language;
    submissionTypeState: model.submission.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GetTraceResponsesPageRequest {
    offset: number | null | undefined;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponse {
    submissionId: model.submission.SubmissionId;
    testCases: Record<string, model.submission.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponseV2 {
    submissionId: model.submission.SubmissionId;
    testCases: Record<model.v2.problem.TestCaseId, model.submission.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    grade: model.submission.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InitializeProblemRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InternalError {
    exceptionInfo: model.submission.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type InvalidRequestCause =
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends submission.SubmissionIdNotFound {
        _type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends submission.CustomTestCasesUnsupported {
        _type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends submission.UnexpectedLanguageError {
        _type: \\"unexpectedLanguage\\";
    }

    export interface _Visitor<Result> {
        submissionIdNotFound: (value: submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: submission.UnexpectedLanguageError) => Result;
        _unknown: () => Result;
    }
}

export const InvalidRequestCause = {
    submissionIdNotFound: (value: submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
        ...value,
        _type: \\"submissionIdNotFound\\"
    }),

    customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
        ...value,
        _type: \\"customTestCasesUnsupported\\"
    }),

    unexpectedLanguage: (value: submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
        ...value,
        _type: \\"unexpectedLanguage\\"
    }),

    _visit: <Result>(value: InvalidRequestCause, visitor: InvalidRequestCause._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"submissionIdNotFound\\": return visitor.submissionIdNotFound(value);
            case \\"customTestCasesUnsupported\\": return visitor.customTestCasesUnsupported(value);
            case \\"unexpectedLanguage\\": return visitor.unexpectedLanguage(value);
            default: return visitor._unknown();
        }
    },

    _types: (): InvalidRequestCause[\\"_type\\"][] => [\\"submissionIdNotFound\\", \\"customTestCasesUnsupported\\", \\"unexpectedLanguage\\"],
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InvalidRequestResponse {
    request: model.submission.SubmissionRequest;
    cause: model.submission.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedResponseNotification {
    submissionId: model.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId: string | null | undefined;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordingResponseNotification {
    submissionId: model.submission.SubmissionId;
    testCaseId: string | null | undefined;
    lineNumber: number;
    lightweightStackInfo: model.submission.LightweightStackframeInformation;
    tracedFile: model.submission.TracedFile | null | undefined;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RunningResponse {
    submissionId: model.submission.SubmissionId;
    state: model.submission.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type RunningSubmissionState =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
    QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
    KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
    CompilingSubmission: \\"COMPILING_SUBMISSION\\",
    RunningSubmission: \\"RUNNING_SUBMISSION\\",

    _visit: <Result>(value: RunningSubmissionState, visitor: RunningSubmissionState._Visitor<Result>): Result => {
        switch (value) {
            case RunningSubmissionState.QueueingSubmission: return visitor.queueingSubmission();
            case RunningSubmissionState.KillingHistoricalSubmissions: return visitor.killingHistoricalSubmissions();
            case RunningSubmissionState.WritingSubmissionToFile: return visitor.writingSubmissionToFile();
            case RunningSubmissionState.CompilingSubmission: return visitor.compilingSubmission();
            case RunningSubmissionState.RunningSubmission: return visitor.runningSubmission();
            default: return visitor._unknown();
        }
    },

    _values: (): RunningSubmissionState[] => [RunningSubmissionState.QueueingSubmission, RunningSubmissionState.KillingHistoricalSubmissions, RunningSubmissionState.WritingSubmissionToFile, RunningSubmissionState.CompilingSubmission, RunningSubmissionState.RunningSubmission],
} as const;

export declare namespace RunningSubmissionState {
    type QueueingSubmission = \\"QUEUEING_SUBMISSION\\";
    type KillingHistoricalSubmissions = \\"KILLING_HISTORICAL_SUBMISSIONS\\";
    type WritingSubmissionToFile = \\"WRITING_SUBMISSION_TO_FILE\\";
    type CompilingSubmission = \\"COMPILING_SUBMISSION\\";
    type RunningSubmission = \\"RUNNING_SUBMISSION\\";

    export interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface RuntimeError {
    message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Scope {
    variables: Record<string, model.commons.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ShareId = string;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: model.submission.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame: model.submission.StackFrame | null | undefined;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StderrResponse {
    submissionId: model.submission.SubmissionId;
    stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StdoutResponse {
    submissionId: model.submission.SubmissionId;
    stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StopRequest {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoppedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type SubmissionId = string;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: model.submission.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionRequest =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends submission.InitializeProblemRequest {
        _type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        _type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends submission.SubmitRequestV2 {
        _type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends submission.WorkspaceSubmitRequest {
        _type: \\"workspaceSubmit\\";
    }

    interface Stop extends submission.StopRequest {
        _type: \\"stop\\";
    }

    export interface _Visitor<Result> {
        initializeProblemRequest: (value: submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: submission.WorkspaceSubmitRequest) => Result;
        stop: (value: submission.StopRequest) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionRequest = {
    initializeProblemRequest: (value: submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
        ...value,
        _type: \\"initializeProblemRequest\\"
    }),

    initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
        _type: \\"initializeWorkspaceRequest\\"
    }),

    submitV2: (value: submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
        ...value,
        _type: \\"submitV2\\"
    }),

    workspaceSubmit: (value: submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
        ...value,
        _type: \\"workspaceSubmit\\"
    }),

    stop: (value: submission.StopRequest): SubmissionRequest.Stop => ({
        ...value,
        _type: \\"stop\\"
    }),

    _visit: <Result>(value: SubmissionRequest, visitor: SubmissionRequest._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"initializeProblemRequest\\": return visitor.initializeProblemRequest(value);
            case \\"initializeWorkspaceRequest\\": return visitor.initializeWorkspaceRequest();
            case \\"submitV2\\": return visitor.submitV2(value);
            case \\"workspaceSubmit\\": return visitor.workspaceSubmit(value);
            case \\"stop\\": return visitor.stop(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionRequest[\\"_type\\"][] => [\\"initializeProblemRequest\\", \\"initializeWorkspaceRequest\\", \\"submitV2\\", \\"workspaceSubmit\\", \\"stop\\"],
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type SubmissionResponse =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

export declare namespace SubmissionResponse {
    interface ServerInitialized {
        _type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        _type: \\"problemInitialized\\";
        problemInitialized: commons.ProblemId;
    }

    interface WorkspaceInitialized {
        _type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends submission.ExceptionInfo {
        _type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        _type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: submission.CodeExecutionUpdate;
    }

    interface Terminated extends submission.TerminatedResponse {
        _type: \\"terminated\\";
    }

    export interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: submission.CodeExecutionUpdate) => Result;
        terminated: (value: submission.TerminatedResponse) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionResponse = {
    serverInitialized: (): SubmissionResponse.ServerInitialized => ({
        _type: \\"serverInitialized\\"
    }),

    problemInitialized: (value: commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
        problemInitialized: value,
        _type: \\"problemInitialized\\"
    }),

    workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
        _type: \\"workspaceInitialized\\"
    }),

    serverErrored: (value: submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
        ...value,
        _type: \\"serverErrored\\"
    }),

    codeExecutionUpdate: (value: submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
        codeExecutionUpdate: value,
        _type: \\"codeExecutionUpdate\\"
    }),

    terminated: (value: submission.TerminatedResponse): SubmissionResponse.Terminated => ({
        ...value,
        _type: \\"terminated\\"
    }),

    _visit: <Result>(value: SubmissionResponse, visitor: SubmissionResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"serverInitialized\\": return visitor.serverInitialized();
            case \\"problemInitialized\\": return visitor.problemInitialized(value.problemInitialized);
            case \\"workspaceInitialized\\": return visitor.workspaceInitialized();
            case \\"serverErrored\\": return visitor.serverErrored(value);
            case \\"codeExecutionUpdate\\": return visitor.codeExecutionUpdate(value.codeExecutionUpdate);
            case \\"terminated\\": return visitor.terminated(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionResponse[\\"_type\\"][] => [\\"serverInitialized\\", \\"problemInitialized\\", \\"workspaceInitialized\\", \\"serverErrored\\", \\"codeExecutionUpdate\\", \\"terminated\\"],
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusForTestCase =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends submission.TestCaseResultWithStdout {
        _type: \\"graded\\";
    }

    interface GradedV2 {
        _type: \\"gradedV2\\";
        gradedV2: submission.TestCaseGrade;
    }

    interface Traced extends submission.TracedTestCase {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        graded: (value: submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: submission.TestCaseGrade) => Result;
        traced: (value: submission.TracedTestCase) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusForTestCase = {
    graded: (value: submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
        gradedV2: value,
        _type: \\"gradedV2\\"
    }),

    traced: (value: submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: SubmissionStatusForTestCase, visitor: SubmissionStatusForTestCase._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value.gradedV2);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusForTestCase[\\"_type\\"][] => [\\"graded\\", \\"gradedV2\\", \\"traced\\"],
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusV2 =
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace;

export declare namespace SubmissionStatusV2 {
    interface Test extends submission.TestSubmissionStatusV2 {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionStatusV2 {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionStatusV2) => Result;
        workspace: (value: submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusV2 = {
    test: (value: submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionStatusV2, visitor: SubmissionStatusV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusV2[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum =
    | \\"TEST\\";

export const SubmissionTypeEnum = {
    Test: \\"TEST\\",

    _visit: <Result>(value: SubmissionTypeEnum, visitor: SubmissionTypeEnum._Visitor<Result>): Result => {
        switch (value) {
            case SubmissionTypeEnum.Test: return visitor.test();
            default: return visitor._unknown();
        }
    },

    _values: (): SubmissionTypeEnum[] => [SubmissionTypeEnum.Test],
} as const;

export declare namespace SubmissionTypeEnum {
    type Test = \\"TEST\\";

    export interface _Visitor<Result> {
        test: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionTypeState =
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace;

export declare namespace SubmissionTypeState {
    interface Test extends submission.TestSubmissionState {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionState {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionState) => Result;
        workspace: (value: submission.WorkspaceSubmissionState) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionTypeState = {
    test: (value: submission.TestSubmissionState): SubmissionTypeState.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionTypeState, visitor: SubmissionTypeState._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionTypeState[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmitRequestV2 {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
    userId: string | null | undefined;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TerminatedResponse {
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestCaseGrade =
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden;

export declare namespace TestCaseGrade {
    interface Hidden extends submission.TestCaseHiddenGrade {
        _type: \\"hidden\\";
    }

    interface NonHidden extends submission.TestCaseNonHiddenGrade {
        _type: \\"nonHidden\\";
    }

    export interface _Visitor<Result> {
        hidden: (value: submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: submission.TestCaseNonHiddenGrade) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseGrade = {
    hidden: (value: submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
        ...value,
        _type: \\"hidden\\"
    }),

    nonHidden: (value: submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
        ...value,
        _type: \\"nonHidden\\"
    }),

    _visit: <Result>(value: TestCaseGrade, visitor: TestCaseGrade._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"hidden\\": return visitor.hidden(value);
            case \\"nonHidden\\": return visitor.nonHidden(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseGrade[\\"_type\\"][] => [\\"hidden\\", \\"nonHidden\\"],
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult: model.commons.VariableValue | null | undefined;
    exception: model.submission.ExceptionV2 | null | undefined;
    stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResult {
    expectedResult: model.commons.VariableValue;
    actualResult: model.submission.ActualResult;
    passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResultWithStdout {
    result: model.submission.TestCaseResult;
    stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionState {
    problemId: model.commons.ProblemId;
    defaultTestCases: model.commons.TestCase[];
    customTestCases: model.commons.TestCase[];
    status: model.submission.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionStatus =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

export declare namespace TestSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface TestCaseIdToState {
        _type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, submission.SubmissionStatusForTestCase>;
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>) => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionStatus = {
    stopped: (): TestSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
        testCaseIdToState: value,
        _type: \\"testCaseIdToState\\"
    }),

    _visit: <Result>(value: TestSubmissionStatus, visitor: TestSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"testCaseIdToState\\": return visitor.testCaseIdToState(value.testCaseIdToState);
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"testCaseIdToState\\"],
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionStatusV2 {
    updates: model.submission.TestSubmissionUpdate[];
    problemId: model.commons.ProblemId;
    problemVersion: number;
    problemInfo: model.v2.problem.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionUpdateInfo =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

export declare namespace TestSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface GradedTestCase extends submission.GradedTestCaseUpdate {
        _type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends submission.RecordedTestCaseUpdate {
        _type: \\"recordedTestCase\\";
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        gradedTestCase: (value: submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    stopped: (): TestSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    gradedTestCase: (value: submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
        ...value,
        _type: \\"gradedTestCase\\"
    }),

    recordedTestCase: (value: submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
        ...value,
        _type: \\"recordedTestCase\\"
    }),

    finished: (): TestSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: TestSubmissionUpdateInfo, visitor: TestSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"gradedTestCase\\": return visitor.gradedTestCase(value);
            case \\"recordedTestCase\\": return visitor.recordedTestCase(value);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"stopped\\", \\"errored\\", \\"gradedTestCase\\", \\"recordedTestCase\\", \\"finished\\"],
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponse {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponseV2 {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    file: model.submission.TracedFile;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TracedTestCase {
    result: model.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: model.commons.Language;
    actualLanguage: model.commons.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceFiles {
    mainFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRanResponse {
    submissionId: model.submission.SubmissionId;
    runDetails: model.submission.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRunDetails {
    exceptionV2: model.submission.ExceptionV2 | null | undefined;
    exception: model.submission.ExceptionInfo | null | undefined;
    stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<model.commons.Language, model.submission.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionState {
    status: model.submission.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionStatus =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Traced extends submission.WorkspaceRunDetails {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        traced: (value: submission.WorkspaceRunDetails) => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionStatus = {
    stopped: (): WorkspaceSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    traced: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionStatus, visitor: WorkspaceSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"ran\\", \\"traced\\"],
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: model.submission.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionUpdateInfo =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Traced {
        _type: \\"traced\\";
    }

    interface TracedV2 extends submission.WorkspaceTracedUpdate {
        _type: \\"tracedV2\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: submission.WorkspaceTracedUpdate) => Result;
        errored: (value: submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
        _type: \\"traced\\"
    }),

    tracedV2: (value: submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
        ...value,
        _type: \\"tracedV2\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionUpdateInfo, visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"stopped\\": return visitor.stopped();
            case \\"traced\\": return visitor.traced();
            case \\"tracedV2\\": return visitor.tracedV2(value);
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"ran\\", \\"stopped\\", \\"traced\\", \\"tracedV2\\", \\"errored\\", \\"finished\\"],
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    userId: string | null | undefined;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetNumWarmInstancesErrorBody = never;

export declare namespace GetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: GetNumWarmInstancesErrorBody, visitor: GetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetNumWarmInstancesResponse = GetNumWarmInstancesResponse.SuccessResponse | GetNumWarmInstancesResponse.ErrorResponse;

export declare namespace GetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
        body: Record<model.commons.Language, number>;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.GetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "GetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetNumWarmInstancesErrorBody = never;

export declare namespace SetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: SetNumWarmInstancesErrorBody, visitor: SetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SetNumWarmInstancesRequest {
    language: model.commons.Language;
    numWarmInstances: number;
}
",
                        "name": "SetNumWarmInstancesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetNumWarmInstancesResponse = SetNumWarmInstancesResponse.SuccessResponse | SetNumWarmInstancesResponse.ErrorResponse;

export declare namespace SetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.SetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "SetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SetNumWarmInstancesRequest\\";
export * from \\"./SetNumWarmInstancesErrorBody\\";
export * from \\"./SetNumWarmInstancesResponse\\";
export * from \\"./GetNumWarmInstancesErrorBody\\";
export * from \\"./GetNumWarmInstancesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "SysPropCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./SysPropCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLatestProblemErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                            "name": "GetLatestProblemRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLatestProblemErrorBody;
    }
}
",
                            "name": "GetLatestProblemResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLightweightProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLightweightProblemsErrorBody;
    }
}
",
                            "name": "GetLightweightProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemVersionErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                            "name": "GetProblemVersionRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemVersionErrorBody;
    }
}
",
                            "name": "GetProblemVersionResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemsErrorBody;
    }
}
",
                            "name": "GetProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "ProblemInfoServicV2",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_service-types",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.problem.Files>;
    basicTestCaseTemplate: model.v2.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.problem.CustomFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2, commons } from \\"../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Files {
    files: model.v2.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.problem.Files>;
    other: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.problem.NonVoidFunctionSignature;
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Parameter {
    parameterId: model.v2.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.problem.CustomFiles;
    generatedFiles: model.v2.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementation {
    description: model.v2.problem.TestCaseImplementationDescription;
    function: model.v2.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseMetadata {
    id: model.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.problem.TestCaseMetadata;
    implementation: model.v2.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.problem.TestCaseExpects | null | undefined;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_types",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLatestProblemErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                                "name": "GetLatestProblemRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLatestProblemErrorBody;
    }
}
",
                                "name": "GetLatestProblemResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLightweightProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLightweightProblemsErrorBody;
    }
}
",
                                "name": "GetLightweightProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemVersionErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                                "name": "GetProblemVersionRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemVersionErrorBody;
    }
}
",
                                "name": "GetProblemVersionResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemsErrorBody;
    }
}
",
                                "name": "GetProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "ProblemInfoServicV2",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_service-types",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.v3.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    basicTestCaseTemplate: model.v2.v3.problem.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2, commons } from \\"../../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.v3.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.v3.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.v3.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.v3.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.v3.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Files {
    files: model.v2.v3.problem.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.v3.problem.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.v3.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.v3.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.v3.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    other: Record<model.commons.Language, model.v2.v3.problem.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.v3.problem.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.v3.problem.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.v3.problem.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Parameter {
    parameterId: model.v2.v3.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type ParameterId = string;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.v3.problem.CustomFiles;
    generatedFiles: model.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.v3.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseId = string;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementation {
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    function: model.v2.v3.problem.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.v3.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.v3.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.v3.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseMetadata {
    id: model.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.v3.problem.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseTemplateId = string;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.v3.problem.TestCaseMetadata;
    implementation: model.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.v3.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.v3.problem.TestCaseExpects | null | undefined;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.v3.problem.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.v3.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_types",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "model",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"name\\": \\"@fern-api/my-api-server\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"express\\": \\"4.18.1\\",
        \\"@types/express\\": \\"4.17.13\\"
    },
    \\"peerDependencies\\": {
        \\"express\\": \\"*\\",
        \\"@types/express\\": \\"*\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
        "name": "package.json",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface AdminService {
    updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): model.admin.UpdateTestSubmissionStatusResponse | Promise<model.admin.UpdateTestSubmissionStatusResponse>;
    sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): model.admin.SendTestSubmissionUpdateResponse | Promise<model.admin.SendTestSubmissionUpdateResponse>;
    updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): model.admin.UpdateWorkspaceSubmissionStatusResponse | Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse>;
    sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): model.admin.SendWorkspaceSubmissionUpdateResponse | Promise<model.admin.SendWorkspaceSubmissionUpdateResponse>;
    storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): model.admin.StoreTracedTestCaseResponse | Promise<model.admin.StoreTracedTestCaseResponse>;
    storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): model.admin.StoreTracedTestCaseV2Response | Promise<model.admin.StoreTracedTestCaseV2Response>;
    storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): model.admin.StoreTracedWorkspaceResponse | Promise<model.admin.StoreTracedWorkspaceResponse>;
    storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): model.admin.StoreTracedWorkspaceV2Response | Promise<model.admin.StoreTracedWorkspaceV2Response>;
}

export const AdminService = {
    expressMiddleware: (impl: AdminService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/admin/store-test-submission-status/:submissionId\\", async (request, response) => {
            const result = await impl.updateTestSubmissionStatus({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-submission-status-v2/:submissionId\\", async (request, response) => {
            const result = await impl.sendTestSubmissionUpdate({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-submission-status/:submissionId\\", async (request, response) => {
            const result = await impl.updateWorkspaceSubmissionStatus({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-submission-status-v2/:submissionId\\", async (request, response) => {
            const result = await impl.sendWorkspaceSubmissionUpdate({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-trace/submission/:submissionId/testCase/:testCaseId\\", async (request, response) => {
            const result = await impl.storeTracedTestCase({
                submissionId: request.params.submissionId,
                testCaseId: request.params.testCaseId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-trace-v2/submission/:submissionId/testCase/:testCaseId\\", async (request, response) => {
            const result = await impl.storeTracedTestCaseV2({
                submissionId: request.params.submissionId,
                testCaseId: request.params.testCaseId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-trace/submission/:submissionId\\", async (request, response) => {
            const result = await impl.storeTracedWorkspace({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-trace-v2/submission/:submissionId\\", async (request, response) => {
            const result = await impl.storeTracedWorkspaceV2({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "AdminService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./AdminService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface HomepageProblemService {
    getHomepageProblems(): model.homepage.GetHomepageProblemsResponse | Promise<model.homepage.GetHomepageProblemsResponse>;
    setHomepageProblems(request: model.commons.ProblemId[]): model.homepage.SetHomepageProblemsResponse | Promise<model.homepage.SetHomepageProblemsResponse>;
}

export const HomepageProblemService = {
    expressMiddleware: (impl: HomepageProblemService): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/homepage-problems/\\", async (_request, response) => {
            const result = await impl.getHomepageProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/homepage-problems/\\", async (request, response) => {
            const result = await impl.setHomepageProblems(request.body);
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "HomepageProblemService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./HomepageProblemService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as sysprop from \\"./sysprop\\";
export * as v2 from \\"./v2\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface MigrationInfoService {
    getAttemptedMigrations(): model.migration.GetAttemptedMigrationsResponse | Promise<model.migration.GetAttemptedMigrationsResponse>;
}

export const MigrationInfoService = {
    expressMiddleware: (impl: MigrationInfoService): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/migration-info/all\\", async (_request, response) => {
            const result = await impl.getAttemptedMigrations();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "MigrationInfoService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationInfoService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface PlaylistCrudService {
    createPlaylist(request: model.playlist.PlaylistCreateRequest): model.playlist.CreatePlaylistResponse | Promise<model.playlist.CreatePlaylistResponse>;
    getPlaylists(request: model.playlist.GetPlaylistsRequest): model.playlist.GetPlaylistsResponse | Promise<model.playlist.GetPlaylistsResponse>;
    getPlaylist(request: model.playlist.GetPlaylistRequest): model.playlist.GetPlaylistResponse | Promise<model.playlist.GetPlaylistResponse>;
    updatePlaylist(request: model.playlist._UpdatePlaylistRequest): model.playlist.UpdatePlaylistResponse | Promise<model.playlist.UpdatePlaylistResponse>;
    deletePlaylist(request: model.playlist.DeletePlaylistRequest): model.playlist.DeletePlaylistResponse | Promise<model.playlist.DeletePlaylistResponse>;
}

export const PlaylistCrudService = {
    expressMiddleware: (impl: PlaylistCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/v2/playlist/create\\", async (request, response) => {
            const result = await impl.createPlaylist(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/v2/playlist/all\\", async (request, response) => {
            const result = await impl.getPlaylists({
                limit: request.query.limit != null ? Number(request.query.limit) : undefined
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/v2/playlist/:playlistId\\", async (request, response) => {
            const result = await impl.getPlaylist({
                playlistId: request.params.playlistId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                const statusCode = model.playlist.GetPlaylistErrorBody._visit(result.error, {
                    PlaylistIdNotFoundError: () => 404,
                    UnauthorizedError: () => 401,
                    _unknown: () => 500
                });
                response.status(statusCode).send(result.error);
            }
        });
        app.put(\\"/v2/playlist/:playlistId\\", async (request, response) => {
            const result = await impl.updatePlaylist({
                playlistId: request.params.playlistId,
                body: request.body
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                const statusCode = model.playlist.UpdatePlaylistErrorBody._visit(result.error, {
                    PlaylistIdNotFoundError: () => 404,
                    _unknown: () => 500
                });
                response.status(statusCode).send(result.error);
            }
        });
        app.delete(\\"/v2/playlist/:playlist_id\\", async (request, response) => {
            const result = await impl.deletePlaylist({
                playlist_id: request.params.playlist_id
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "PlaylistCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemCrudService {
    createProblem(request: model.problem.CreateProblemRequest): model.problem._CreateProblemResponse | Promise<model.problem._CreateProblemResponse>;
    updateProblem(request: model.problem.UpdateProblemRequest): model.problem._UpdateProblemResponse | Promise<model.problem._UpdateProblemResponse>;
    deleteProblem(request: model.problem.DeleteProblemRequest): model.problem.DeleteProblemResponse | Promise<model.problem.DeleteProblemResponse>;
    getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): model.problem._GetDefaultStarterFilesResponse | Promise<model.problem._GetDefaultStarterFilesResponse>;
}

export const ProblemCrudService = {
    expressMiddleware: (impl: ProblemCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/problem-crud/create\\", async (request, response) => {
            const result = await impl.createProblem(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/problem-crud/update/:problemId\\", async (request, response) => {
            const result = await impl.updateProblem({
                problemId: request.params.problemId,
                body: request.body
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.delete(\\"/problem-crud/delete/:problemId\\", async (request, response) => {
            const result = await impl.deleteProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/problem-crud/default-starter-files\\", async (request, response) => {
            const result = await impl.getDefaultStarterFiles(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "ProblemCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface ExecutionSesssionManagementService {
    createExecutionSession(request: model.submission.CreateExecutionSessionRequest): model.submission.CreateExecutionSessionResponse | Promise<model.submission.CreateExecutionSessionResponse>;
    getExecutionSession(request: model.submission.GetExecutionSessionRequest): model.submission.GetExecutionSessionResponse | Promise<model.submission.GetExecutionSessionResponse>;
    stopExecutionSession(request: model.submission.StopExecutionSessionRequest): model.submission.StopExecutionSessionResponse | Promise<model.submission.StopExecutionSessionResponse>;
    getExecutionSessionsState(): model.submission.GetExecutionSessionsStateResponse | Promise<model.submission.GetExecutionSessionsStateResponse>;
}

export const ExecutionSesssionManagementService = {
    expressMiddleware: (impl: ExecutionSesssionManagementService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/sessions/create-session/:language\\", async (request, response) => {
            const result = await impl.createExecutionSession({
                language: request.params.language as model.commons.Language
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sessions/:sessionId\\", async (request, response) => {
            const result = await impl.getExecutionSession({
                sessionId: request.params.sessionId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.delete(\\"/sessions/stop/:sessionId\\", async (request, response) => {
            const result = await impl.stopExecutionSession({
                sessionId: request.params.sessionId
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sessions/execution-sessions-state\\", async (_request, response) => {
            const result = await impl.getExecutionSessionsState();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "ExecutionSesssionManagementService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface SysPropCrudService {
    setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): model.sysprop.SetNumWarmInstancesResponse | Promise<model.sysprop.SetNumWarmInstancesResponse>;
    getNumWarmInstances(): model.sysprop.GetNumWarmInstancesResponse | Promise<model.sysprop.GetNumWarmInstancesResponse>;
}

export const SysPropCrudService = {
    expressMiddleware: (impl: SysPropCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.put(\\"/sysprop/num-warm-instances/:language/:numWarmInstances\\", async (request, response) => {
            const result = await impl.setNumWarmInstances({
                language: request.params.language as model.commons.Language,
                numWarmInstances: Number(request.params.numWarmInstances)
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sysprop/num-warm-instances\\", async (_request, response) => {
            const result = await impl.getNumWarmInstances();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "SysPropCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SysPropCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): model.v2.problem.GetLightweightProblemsResponse | Promise<model.v2.problem.GetLightweightProblemsResponse>;
    getProblems(): model.v2.problem.GetProblemsResponse | Promise<model.v2.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): model.v2.problem.GetLatestProblemResponse | Promise<model.v2.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): model.v2.problem.GetProblemVersionResponse | Promise<model.v2.problem.GetProblemVersionResponse>;
}

export const ProblemInfoServicV2 = {
    expressMiddleware: (impl: ProblemInfoServicV2): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/problems-v2/lightweight-problem-info\\", async (_request, response) => {
            const result = await impl.getLightweightProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info\\", async (_request, response) => {
            const result = await impl.getProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId\\", async (request, response) => {
            const result = await impl.getLatestProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId/version/:problemVersion\\", async (request, response) => {
            const result = await impl.getProblemVersion({
                problemId: request.params.problemId,
                problemVersion: Number(request.params.problemVersion)
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                    "name": "ProblemInfoServicV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import * as model from \\"../../../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): model.v2.v3.problem.GetLightweightProblemsResponse | Promise<model.v2.v3.problem.GetLightweightProblemsResponse>;
    getProblems(): model.v2.v3.problem.GetProblemsResponse | Promise<model.v2.v3.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): model.v2.v3.problem.GetLatestProblemResponse | Promise<model.v2.v3.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): model.v2.v3.problem.GetProblemVersionResponse | Promise<model.v2.v3.problem.GetProblemVersionResponse>;
}

export const ProblemInfoServicV2 = {
    expressMiddleware: (impl: ProblemInfoServicV2): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/problems-v2/lightweight-problem-info\\", async (_request, response) => {
            const result = await impl.getLightweightProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info\\", async (_request, response) => {
            const result = await impl.getProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId\\", async (request, response) => {
            const result = await impl.getLatestProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId/version/:problemVersion\\", async (request, response) => {
            const result = await impl.getProblemVersion({
                problemId: request.params.problemId,
                problemVersion: Number(request.params.problemVersion)
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                        "name": "ProblemInfoServicV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "services",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
        "name": "tsconfig.json",
        "type": "file",
      },
    ],
    "name": "server",
    "type": "directory",
  },
]
`;

exports[`runGenerator trace client-v2 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
        "name": ".npmignore",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { BasicAuth, BearerToken } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"..\\";
import urlJoin from \\"url-join\\";

export namespace Client {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {
    }

    #admin: MyApi.admin._Client | undefined;

    public get admin(): MyApi.admin._Client {
        return (this.#admin ??= new MyApi.admin._Client({
            _basePath: urlJoin(this.options._origin, \\"/admin\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #homepage: MyApi.homepage._Client | undefined;

    public get homepage(): MyApi.homepage._Client {
        return (this.#homepage ??= new MyApi.homepage._Client({
            _basePath: urlJoin(this.options._origin, \\"/homepage-problems\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #migration: MyApi.migration._Client | undefined;

    public get migration(): MyApi.migration._Client {
        return (this.#migration ??= new MyApi.migration._Client({
            _basePath: urlJoin(this.options._origin, \\"/migration-info\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #playlist: MyApi.playlist._Client | undefined;

    public get playlist(): MyApi.playlist._Client {
        return (this.#playlist ??= new MyApi.playlist._Client({
            _basePath: urlJoin(this.options._origin, \\"/v2/playlist\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #problem: MyApi.problem._Client | undefined;

    public get problem(): MyApi.problem._Client {
        return (this.#problem ??= new MyApi.problem._Client({
            _basePath: urlJoin(this.options._origin, \\"/problem-crud\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #submission: MyApi.submission._Client | undefined;

    public get submission(): MyApi.submission._Client {
        return (this.#submission ??= new MyApi.submission._Client({
            _basePath: urlJoin(this.options._origin, \\"/sessions\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #sysprop: MyApi.sysprop._Client | undefined;

    public get sysprop(): MyApi.sysprop._Client {
        return (this.#sysprop ??= new MyApi.sysprop._Client({
            _basePath: urlJoin(this.options._origin, \\"/sysprop\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #v2: MyApi.v2._Client | undefined;

    public get v2(): MyApi.v2._Client {
        return (this.#v2 ??= new MyApi.v2._Client(this.options));
    }
}
",
            "name": "Client.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StoreTracedTestCaseRequest {
    result: MyApi.submission.TestCaseResultWithStdout;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: MyApi.submission.WorkspaceRunDetails;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    updateTestSubmissionStatus(request: MyApi.admin.updateTestSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateTestSubmissionStatus.Error>>;
    sendTestSubmissionUpdate(request: MyApi.admin.sendTestSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendTestSubmissionUpdate.Error>>;
    updateWorkspaceSubmissionStatus(request: MyApi.admin.updateWorkspaceSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateWorkspaceSubmissionStatus.Error>>;
    sendWorkspaceSubmissionUpdate(request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendWorkspaceSubmissionUpdate.Error>>;
    storeTracedTestCase(request: MyApi.admin.storeTracedTestCase.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCase.Error>>;
    storeTracedTestCaseV2(request: MyApi.admin.storeTracedTestCaseV2.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCaseV2.Error>>;
    storeTracedWorkspace(request: MyApi.admin.storeTracedWorkspace.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspace.Error>>;
    storeTracedWorkspaceV2(request: MyApi.admin.storeTracedWorkspaceV2.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspaceV2.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async updateTestSubmissionStatus(request: MyApi.admin.updateTestSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateTestSubmissionStatus.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-submission-status/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async sendTestSubmissionUpdate(request: MyApi.admin.sendTestSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendTestSubmissionUpdate.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-submission-status-v2/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async updateWorkspaceSubmissionStatus(request: MyApi.admin.updateWorkspaceSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateWorkspaceSubmissionStatus.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-submission-status/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async sendWorkspaceSubmissionUpdate(request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendWorkspaceSubmissionUpdate.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-submission-status-v2/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedTestCase(request: MyApi.admin.storeTracedTestCase.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCase.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedTestCaseV2(request: MyApi.admin.storeTracedTestCaseV2.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCaseV2.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedWorkspace(request: MyApi.admin.storeTracedWorkspace.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspace.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-trace/submission/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedWorkspaceV2(request: MyApi.admin.storeTracedWorkspaceV2.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspaceV2.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-trace-v2/submission/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace updateTestSubmissionStatus {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TestSubmissionStatus;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.updateTestSubmissionStatus.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace sendTestSubmissionUpdate {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TestSubmissionUpdate;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.sendTestSubmissionUpdate.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace updateWorkspaceSubmissionStatus {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.WorkspaceSubmissionStatus;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.updateWorkspaceSubmissionStatus.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace sendWorkspaceSubmissionUpdate {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.WorkspaceSubmissionUpdate;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.sendWorkspaceSubmissionUpdate.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedTestCase {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        testCaseId: string;
        body: MyApi.admin.StoreTracedTestCaseRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedTestCase.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedTestCaseV2 {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        testCaseId: MyApi.v2.problem.TestCaseId;
        body: MyApi.submission.TraceResponseV2[];
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedTestCaseV2.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedWorkspace {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.admin.StoreTracedWorkspaceRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedWorkspace.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedWorkspaceV2 {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TraceResponseV2[];
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedWorkspaceV2.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: MyApi.commons.NodeId;
    fullTree: MyApi.commons.BinaryTreeValue;
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface BinaryTreeNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    right?: MyApi.commons.NodeId;
    left?: MyApi.commons.NodeId;
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface BinaryTreeValue {
    root?: MyApi.commons.NodeId;
    nodes: Record<MyApi.commons.NodeId, MyApi.commons.BinaryTreeNodeValue>;
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface DebugKeyValuePairs {
    key: MyApi.commons.DebugVariableValue;
    value: MyApi.commons.DebugVariableValue;
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface DebugMapValue {
    keyValuePairs: MyApi.commons.DebugKeyValuePairs[];
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type DebugVariableValue = 
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

export declare namespace DebugVariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends MyApi.commons.DebugMapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: MyApi.commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends MyApi.commons.BinaryTreeNodeAndTreeValue {
        _type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends MyApi.commons.SinglyLinkedListNodeAndListValue {
        _type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends MyApi.commons.DoublyLinkedListNodeAndListValue {
        _type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        _type: \\"undefinedValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    interface GenericValue extends MyApi.commons.GenericValue {
        _type: \\"genericValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: MyApi.commons.DebugMapValue) => Result;
        listValue: (value: MyApi.commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: MyApi.commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: MyApi.commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: MyApi.commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: MyApi.commons.GenericValue) => Result;
        _unknown: () => Result;
    }
}

export const DebugVariableValue = {
        integerValue: (value: number): DebugVariableValue.IntegerValue => ({
            integerValue: value,
            _type: \\"integerValue\\"
        }),

        booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
            booleanValue: value,
            _type: \\"booleanValue\\"
        }),

        doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
            doubleValue: value,
            _type: \\"doubleValue\\"
        }),

        stringValue: (value: string): DebugVariableValue.StringValue => ({
            stringValue: value,
            _type: \\"stringValue\\"
        }),

        charValue: (value: string): DebugVariableValue.CharValue => ({
            charValue: value,
            _type: \\"charValue\\"
        }),

        mapValue: (value: MyApi.commons.DebugMapValue): DebugVariableValue.MapValue => ({
            ...value,
            _type: \\"mapValue\\"
        }),

        listValue: (value: MyApi.commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
            listValue: value,
            _type: \\"listValue\\"
        }),

        binaryTreeNodeValue: (value: MyApi.commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
            ...value,
            _type: \\"binaryTreeNodeValue\\"
        }),

        singlyLinkedListNodeValue: (value: MyApi.commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
            ...value,
            _type: \\"singlyLinkedListNodeValue\\"
        }),

        doublyLinkedListNodeValue: (value: MyApi.commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
            ...value,
            _type: \\"doublyLinkedListNodeValue\\"
        }),

        undefinedValue: (): DebugVariableValue.UndefinedValue => ({
            _type: \\"undefinedValue\\"
        }),

        nullValue: (): DebugVariableValue.NullValue => ({
            _type: \\"nullValue\\"
        }),

        genericValue: (value: MyApi.commons.GenericValue): DebugVariableValue.GenericValue => ({
            ...value,
            _type: \\"genericValue\\"
        }),

        _visit: <Result>(value: DebugVariableValue, visitor: DebugVariableValue._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"integerValue\\": return visitor.integerValue(value.integerValue);
                case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
                case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
                case \\"stringValue\\": return visitor.stringValue(value.stringValue);
                case \\"charValue\\": return visitor.charValue(value.charValue);
                case \\"mapValue\\": return visitor.mapValue(value);
                case \\"listValue\\": return visitor.listValue(value.listValue);
                case \\"binaryTreeNodeValue\\": return visitor.binaryTreeNodeValue(value);
                case \\"singlyLinkedListNodeValue\\": return visitor.singlyLinkedListNodeValue(value);
                case \\"doublyLinkedListNodeValue\\": return visitor.doublyLinkedListNodeValue(value);
                case \\"undefinedValue\\": return visitor.undefinedValue();
                case \\"nullValue\\": return visitor.nullValue();
                case \\"genericValue\\": return visitor.genericValue(value);
                default: return visitor._unknown();
            }
        },

        _types: (): DebugVariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeNodeValue\\", \\"singlyLinkedListNodeValue\\", \\"doublyLinkedListNodeValue\\", \\"undefinedValue\\", \\"nullValue\\", \\"genericValue\\"],
    } as const;
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: MyApi.commons.NodeId;
    fullList: MyApi.commons.DoublyLinkedListValue;
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    next?: MyApi.commons.NodeId;
    prev?: MyApi.commons.NodeId;
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface DoublyLinkedListValue {
    head?: MyApi.commons.NodeId;
    nodes: Record<MyApi.commons.NodeId, MyApi.commons.DoublyLinkedListNodeValue>;
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericValue {
    stringifiedType?: string;
    stringifiedValue: string;
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface KeyValuePair {
    key: MyApi.commons.VariableValue;
    value: MyApi.commons.VariableValue;
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Language = 
    | \\"JAVA\\"
    | \\"JAVASCRIPT\\"
    | \\"PYTHON\\";

export const Language = {
        Java: \\"JAVA\\",
        Javascript: \\"JAVASCRIPT\\",
        Python: \\"PYTHON\\",

        _visit: <Result>(value: Language, visitor: Language._Visitor<Result>): Result => {
            switch (value) {
                case Language.Java: return visitor.java();
                case Language.Javascript: return visitor.javascript();
                case Language.Python: return visitor.python();
                default: return visitor._unknown();
            }
        },

        _values: (): Language[] => [Language.Java, Language.Javascript, Language.Python],
    } as const;

export declare namespace Language {
    type Java = \\"JAVA\\";
    type Javascript = \\"JAVASCRIPT\\";
    type Python = \\"PYTHON\\";

    export interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: () => Result;
    }
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ListType {
    valueType: MyApi.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength?: boolean;
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface MapType {
    keyType: MyApi.commons.VariableType;
    valueType: MyApi.commons.VariableType;
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface MapValue {
    keyValuePairs: MyApi.commons.KeyValuePair[];
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export type NodeId = string;
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ProblemId = string;
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: MyApi.commons.NodeId;
    fullList: MyApi.commons.SinglyLinkedListValue;
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    next?: MyApi.commons.NodeId;
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface SinglyLinkedListValue {
    head?: MyApi.commons.NodeId;
    nodes: Record<MyApi.commons.NodeId, MyApi.commons.SinglyLinkedListNodeValue>;
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestCase {
    id: string;
    params: MyApi.commons.VariableValue[];
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestCaseWithExpectedResult {
    testCase: MyApi.commons.TestCase;
    expectedResult: MyApi.commons.VariableValue;
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "export type UserId = string;
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type VariableType = 
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

export declare namespace VariableType {
    interface IntegerType {
        _type: \\"integerType\\";
    }

    interface DoubleType {
        _type: \\"doubleType\\";
    }

    interface BooleanType {
        _type: \\"booleanType\\";
    }

    interface StringType {
        _type: \\"stringType\\";
    }

    interface CharType {
        _type: \\"charType\\";
    }

    interface ListType extends MyApi.commons.ListType {
        _type: \\"listType\\";
    }

    interface MapType extends MyApi.commons.MapType {
        _type: \\"mapType\\";
    }

    interface BinaryTreeType {
        _type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        _type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        _type: \\"doublyLinkedListType\\";
    }

    export interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: MyApi.commons.ListType) => Result;
        mapType: (value: MyApi.commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: () => Result;
    }
}

export const VariableType = {
        integerType: (): VariableType.IntegerType => ({
            _type: \\"integerType\\"
        }),

        doubleType: (): VariableType.DoubleType => ({
            _type: \\"doubleType\\"
        }),

        booleanType: (): VariableType.BooleanType => ({
            _type: \\"booleanType\\"
        }),

        stringType: (): VariableType.StringType => ({
            _type: \\"stringType\\"
        }),

        charType: (): VariableType.CharType => ({
            _type: \\"charType\\"
        }),

        listType: (value: MyApi.commons.ListType): VariableType.ListType => ({
            ...value,
            _type: \\"listType\\"
        }),

        mapType: (value: MyApi.commons.MapType): VariableType.MapType => ({
            ...value,
            _type: \\"mapType\\"
        }),

        binaryTreeType: (): VariableType.BinaryTreeType => ({
            _type: \\"binaryTreeType\\"
        }),

        singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
            _type: \\"singlyLinkedListType\\"
        }),

        doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
            _type: \\"doublyLinkedListType\\"
        }),

        _visit: <Result>(value: VariableType, visitor: VariableType._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"integerType\\": return visitor.integerType();
                case \\"doubleType\\": return visitor.doubleType();
                case \\"booleanType\\": return visitor.booleanType();
                case \\"stringType\\": return visitor.stringType();
                case \\"charType\\": return visitor.charType();
                case \\"listType\\": return visitor.listType(value);
                case \\"mapType\\": return visitor.mapType(value);
                case \\"binaryTreeType\\": return visitor.binaryTreeType();
                case \\"singlyLinkedListType\\": return visitor.singlyLinkedListType();
                case \\"doublyLinkedListType\\": return visitor.doublyLinkedListType();
                default: return visitor._unknown();
            }
        },

        _types: (): VariableType[\\"_type\\"][] => [\\"integerType\\", \\"doubleType\\", \\"booleanType\\", \\"stringType\\", \\"charType\\", \\"listType\\", \\"mapType\\", \\"binaryTreeType\\", \\"singlyLinkedListType\\", \\"doublyLinkedListType\\"],
    } as const;
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type VariableValue = 
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

export declare namespace VariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends MyApi.commons.MapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: MyApi.commons.VariableValue[];
    }

    interface BinaryTreeValue extends MyApi.commons.BinaryTreeValue {
        _type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends MyApi.commons.SinglyLinkedListValue {
        _type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends MyApi.commons.DoublyLinkedListValue {
        _type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: MyApi.commons.MapValue) => Result;
        listValue: (value: MyApi.commons.VariableValue[]) => Result;
        binaryTreeValue: (value: MyApi.commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: MyApi.commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: MyApi.commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: () => Result;
    }
}

export const VariableValue = {
        integerValue: (value: number): VariableValue.IntegerValue => ({
            integerValue: value,
            _type: \\"integerValue\\"
        }),

        booleanValue: (value: boolean): VariableValue.BooleanValue => ({
            booleanValue: value,
            _type: \\"booleanValue\\"
        }),

        doubleValue: (value: number): VariableValue.DoubleValue => ({
            doubleValue: value,
            _type: \\"doubleValue\\"
        }),

        stringValue: (value: string): VariableValue.StringValue => ({
            stringValue: value,
            _type: \\"stringValue\\"
        }),

        charValue: (value: string): VariableValue.CharValue => ({
            charValue: value,
            _type: \\"charValue\\"
        }),

        mapValue: (value: MyApi.commons.MapValue): VariableValue.MapValue => ({
            ...value,
            _type: \\"mapValue\\"
        }),

        listValue: (value: MyApi.commons.VariableValue[]): VariableValue.ListValue => ({
            listValue: value,
            _type: \\"listValue\\"
        }),

        binaryTreeValue: (value: MyApi.commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
            ...value,
            _type: \\"binaryTreeValue\\"
        }),

        singlyLinkedListValue: (value: MyApi.commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
            ...value,
            _type: \\"singlyLinkedListValue\\"
        }),

        doublyLinkedListValue: (value: MyApi.commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
            ...value,
            _type: \\"doublyLinkedListValue\\"
        }),

        nullValue: (): VariableValue.NullValue => ({
            _type: \\"nullValue\\"
        }),

        _visit: <Result>(value: VariableValue, visitor: VariableValue._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"integerValue\\": return visitor.integerValue(value.integerValue);
                case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
                case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
                case \\"stringValue\\": return visitor.stringValue(value.stringValue);
                case \\"charValue\\": return visitor.charValue(value.charValue);
                case \\"mapValue\\": return visitor.mapValue(value);
                case \\"listValue\\": return visitor.listValue(value.listValue);
                case \\"binaryTreeValue\\": return visitor.binaryTreeValue(value);
                case \\"singlyLinkedListValue\\": return visitor.singlyLinkedListValue(value);
                case \\"doublyLinkedListValue\\": return visitor.doublyLinkedListValue(value);
                case \\"nullValue\\": return visitor.nullValue();
                default: return visitor._unknown();
            }
        },

        _types: (): VariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeValue\\", \\"singlyLinkedListValue\\", \\"doublyLinkedListValue\\", \\"nullValue\\"],
    } as const;
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    getHomepageProblems(): Promise<_Response<MyApi.commons.ProblemId[], MyApi.homepage.getHomepageProblems.Error>>;
    setHomepageProblems(request: MyApi.commons.ProblemId[]): Promise<_Response<void, MyApi.homepage.setHomepageProblems.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async getHomepageProblems(): Promise<_Response<MyApi.commons.ProblemId[], MyApi.homepage.getHomepageProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.commons.ProblemId[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async setHomepageProblems(request: MyApi.commons.ProblemId[]): Promise<_Response<void, MyApi.homepage.setHomepageProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getHomepageProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.homepage.getHomepageProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace setHomepageProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.homepage.setHomepageProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./Client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export interface LangServerRequest {
    request: unknown;
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LangServerResponse {
    response: unknown;
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "lang-server",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface Migration {
    name: string;
    status: MyApi.migration.MigrationStatus;
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "export type MigrationStatus = 
    | \\"RUNNING\\"
    | \\"FAILED\\"
    | \\"FINISHED\\";

export const MigrationStatus = {
        Running: \\"RUNNING\\",
        Failed: \\"FAILED\\",
        Finished: \\"FINISHED\\",

        _visit: <Result>(value: MigrationStatus, visitor: MigrationStatus._Visitor<Result>): Result => {
            switch (value) {
                case MigrationStatus.Running: return visitor.running();
                case MigrationStatus.Failed: return visitor.failed();
                case MigrationStatus.Finished: return visitor.finished();
                default: return visitor._unknown();
            }
        },

        _values: (): MigrationStatus[] => [MigrationStatus.Running, MigrationStatus.Failed, MigrationStatus.Finished],
    } as const;

export declare namespace MigrationStatus {
    type Running = \\"RUNNING\\";
    type Failed = \\"FAILED\\";
    type Finished = \\"FINISHED\\";

    export interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    getAttemptedMigrations(): Promise<_Response<MyApi.migration.Migration[], MyApi.migration.getAttemptedMigrations.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async getAttemptedMigrations(): Promise<_Response<MyApi.migration.Migration[], MyApi.migration.getAttemptedMigrations.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/all\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.migration.Migration[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getAttemptedMigrations {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.migration.getAttemptedMigrations.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface Playlist {
    playlist_id: MyApi.playlist.PlaylistId;
    name: string;
    problems: MyApi.commons.ProblemId[];
    \\"owner-id\\": MyApi.commons.UserId;
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: MyApi.commons.ProblemId[];
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export type PlaylistId = string;
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface PlaylistIdNotFoundError {
    _error: \\"PlaylistIdNotFoundError\\";
    playlistId: MyApi.playlist.PlaylistId;
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface UnauthorizedError {
    _error: \\"UnauthorizedError\\";
}
",
                "name": "UnauthorizedError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: MyApi.commons.ProblemId[];
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    createPlaylist(request: MyApi.playlist.PlaylistCreateRequest): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.createPlaylist.Error>>;
    getPlaylists(request: MyApi.playlist.getPlaylists.Request): Promise<_Response<MyApi.playlist.Playlist[], MyApi.playlist.getPlaylists.Error>>;
    getPlaylist(request: MyApi.playlist.getPlaylist.Request): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.getPlaylist.Error>>;
    updatePlaylist(request: MyApi.playlist.updatePlaylist.Request): Promise<_Response<MyApi.playlist.Playlist | undefined, MyApi.playlist.updatePlaylist.Error>>;
    deletePlaylist(request: MyApi.playlist.deletePlaylist.Request): Promise<_Response<void, MyApi.playlist.deletePlaylist.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async createPlaylist(request: MyApi.playlist.PlaylistCreateRequest): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.createPlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/create\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getPlaylists(request: MyApi.playlist.getPlaylists.Request): Promise<_Response<MyApi.playlist.Playlist[], MyApi.playlist.getPlaylists.Error>> {
        const queryParameters = new URLSearchParams();
        if (request.limit != null) {
            queryParameters.append(\\"limit\\", request.limit.toString());
        }

        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/all\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                queryParameters
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getPlaylist(request: MyApi.playlist.getPlaylist.Request): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.getPlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        switch ((response.body as MyApi.playlist.getPlaylist.ErrorBody)?._error) {
            case \\"PlaylistIdNotFoundError\\":
            case \\"UnauthorizedError\\": return {
                ok: false,
                error: MyApi.playlist.getPlaylist.Error(response.body as MyApi.playlist.getPlaylist.ErrorBody)
            };
            default: return {
                ok: false,
                error: {
                    body: response.body as _UnknownError,
                    _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
                }
            };
        }
    }

    public async updatePlaylist(request: MyApi.playlist.updatePlaylist.Request): Promise<_Response<MyApi.playlist.Playlist | undefined, MyApi.playlist.updatePlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"PUT\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist | undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        switch ((response.body as MyApi.playlist.updatePlaylist.ErrorBody)?._error) {
            case \\"PlaylistIdNotFoundError\\": return {
                ok: false,
                error: MyApi.playlist.updatePlaylist.Error(response.body as MyApi.playlist.updatePlaylist.ErrorBody)
            };
            default: return {
                ok: false,
                error: {
                    body: response.body as _UnknownError,
                    _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
                }
            };
        }
    }

    public async deletePlaylist(request: MyApi.playlist.deletePlaylist.Request): Promise<_Response<void, MyApi.playlist.deletePlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createPlaylist {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.createPlaylist.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getPlaylists {
    export interface Request {
        limit?: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.getPlaylists.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getPlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
    }

    export interface Error {
        body: 
            | MyApi.playlist.getPlaylist.ErrorBody
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.getPlaylist.ErrorVisitor<Result>) => Result;
    }

    export type ErrorBody = 
        | MyApi.playlist.PlaylistIdNotFoundError
        | MyApi.playlist.UnauthorizedError;

    export interface ErrorVisitor<Result> {
        playlistIdNotFoundError: (value: MyApi.playlist.PlaylistIdNotFoundError) => Result;
        unauthorizedError: (value: MyApi.playlist.UnauthorizedError) => Result;
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export const getPlaylist = {
        Error: (value: MyApi.playlist.getPlaylist.ErrorBody): MyApi.playlist.getPlaylist.Error => ({
            body: value,
            _visit: visitor => {
                switch (value._error) {
                    case \\"PlaylistIdNotFoundError\\": return visitor.playlistIdNotFoundError(value as MyApi.playlist.PlaylistIdNotFoundError);
                    case \\"UnauthorizedError\\": return visitor.unauthorizedError(value as MyApi.playlist.UnauthorizedError);
                }
            }
        })
    };

export namespace updatePlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
        body?: MyApi.playlist.UpdatePlaylistRequest;
    }

    export interface Error {
        body: 
            | MyApi.playlist.updatePlaylist.ErrorBody
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.updatePlaylist.ErrorVisitor<Result>) => Result;
    }

    export type ErrorBody = 
        | MyApi.playlist.PlaylistIdNotFoundError;

    export interface ErrorVisitor<Result> {
        playlistIdNotFoundError: (value: MyApi.playlist.PlaylistIdNotFoundError) => Result;
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export const updatePlaylist = {
        Error: (value: MyApi.playlist.updatePlaylist.ErrorBody): MyApi.playlist.updatePlaylist.Error => ({
            body: value,
            _visit: visitor => {
                switch (value._error) {
                    case \\"PlaylistIdNotFoundError\\": return visitor.playlistIdNotFoundError(value as MyApi.playlist.PlaylistIdNotFoundError);
                }
            }
        })
    };

export namespace deletePlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.deletePlaylist.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type CreateProblemError = 
    | CreateProblemError.Generic;

export declare namespace CreateProblemError {
    interface Generic extends MyApi.problem.GenericCreateProblemError {
        _type: \\"generic\\";
    }

    export interface _Visitor<Result> {
        generic: (value: MyApi.problem.GenericCreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemError = {
        generic: (value: MyApi.problem.GenericCreateProblemError): CreateProblemError.Generic => ({
            ...value,
            _type: \\"generic\\"
        }),

        _visit: <Result>(value: CreateProblemError, visitor: CreateProblemError._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"generic\\": return visitor.generic(value);
                default: return visitor._unknown();
            }
        },

        _types: (): CreateProblemError[\\"_type\\"][] => [\\"generic\\"],
    } as const;
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    files: Record<MyApi.commons.Language, MyApi.problem.ProblemFiles>;
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    testcases: MyApi.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type CreateProblemResponse = 
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error;

export declare namespace CreateProblemResponse {
    interface Success {
        _type: \\"success\\";
        success: MyApi.commons.ProblemId;
    }

    interface Error {
        _type: \\"error\\";
        error: MyApi.problem.CreateProblemError;
    }

    export interface _Visitor<Result> {
        success: (value: MyApi.commons.ProblemId) => Result;
        error: (value: MyApi.problem.CreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemResponse = {
        success: (value: MyApi.commons.ProblemId): CreateProblemResponse.Success => ({
            success: value,
            _type: \\"success\\"
        }),

        error: (value: MyApi.problem.CreateProblemError): CreateProblemResponse.Error => ({
            error: value,
            _type: \\"error\\"
        }),

        _visit: <Result>(value: CreateProblemResponse, visitor: CreateProblemResponse._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"success\\": return visitor.success(value.success);
                case \\"error\\": return visitor.error(value.error);
                default: return visitor._unknown();
            }
        },

        _types: (): CreateProblemResponse[\\"_type\\"][] => [\\"success\\", \\"error\\"],
    } as const;
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    methodName: string;
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<MyApi.commons.Language, MyApi.problem.ProblemFiles>;
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ProblemDescription {
    boards: MyApi.problem.ProblemDescriptionBoard[];
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type ProblemDescriptionBoard = 
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

export declare namespace ProblemDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface Variable {
        _type: \\"variable\\";
        variable: MyApi.commons.VariableValue;
    }

    interface TestCaseId {
        _type: \\"testCaseId\\";
        testCaseId: string;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: MyApi.commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const ProblemDescriptionBoard = {
        html: (value: string): ProblemDescriptionBoard.Html => ({
            html: value,
            _type: \\"html\\"
        }),

        variable: (value: MyApi.commons.VariableValue): ProblemDescriptionBoard.Variable => ({
            variable: value,
            _type: \\"variable\\"
        }),

        testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
            testCaseId: value,
            _type: \\"testCaseId\\"
        }),

        _visit: <Result>(value: ProblemDescriptionBoard, visitor: ProblemDescriptionBoard._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"html\\": return visitor.html(value.html);
                case \\"variable\\": return visitor.variable(value.variable);
                case \\"testCaseId\\": return visitor.testCaseId(value.testCaseId);
                default: return visitor._unknown();
            }
        },

        _types: (): ProblemDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"variable\\", \\"testCaseId\\"],
    } as const;
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ProblemFiles {
    solutionFile: MyApi.commons.FileInfo;
    readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ProblemInfo {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<MyApi.commons.Language, MyApi.problem.ProblemFiles>;
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    testcases: MyApi.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface VariableTypeAndName {
    variableType: MyApi.commons.VariableType;
    name: string;
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    createProblem(request: MyApi.problem.CreateProblemRequest): Promise<_Response<MyApi.problem.CreateProblemResponse, MyApi.problem.createProblem.Error>>;
    updateProblem(request: MyApi.problem.updateProblem.Request): Promise<_Response<MyApi.problem.UpdateProblemResponse, MyApi.problem.updateProblem.Error>>;
    deleteProblem(request: MyApi.problem.deleteProblem.Request): Promise<_Response<void, MyApi.problem.deleteProblem.Error>>;
    getDefaultStarterFiles(request: MyApi.problem.GetDefaultStarterFilesRequest): Promise<_Response<MyApi.problem.GetDefaultStarterFilesResponse, MyApi.problem.getDefaultStarterFiles.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async createProblem(request: MyApi.problem.CreateProblemRequest): Promise<_Response<MyApi.problem.CreateProblemResponse, MyApi.problem.createProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/create\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.CreateProblemResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async updateProblem(request: MyApi.problem.updateProblem.Request): Promise<_Response<MyApi.problem.UpdateProblemResponse, MyApi.problem.updateProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/update/\${request.problemId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.UpdateProblemResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async deleteProblem(request: MyApi.problem.deleteProblem.Request): Promise<_Response<void, MyApi.problem.deleteProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/delete/\${request.problemId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getDefaultStarterFiles(request: MyApi.problem.GetDefaultStarterFilesRequest): Promise<_Response<MyApi.problem.GetDefaultStarterFilesResponse, MyApi.problem.getDefaultStarterFiles.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/default-starter-files\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.GetDefaultStarterFilesResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createProblem {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.createProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace updateProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        body: MyApi.problem.CreateProblemRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.updateProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace deleteProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.deleteProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getDefaultStarterFiles {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.getDefaultStarterFiles.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type ActualResult = 
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

export declare namespace ActualResult {
    interface Value {
        _type: \\"value\\";
        value: MyApi.commons.VariableValue;
    }

    interface Exception extends MyApi.submission.ExceptionInfo {
        _type: \\"exception\\";
    }

    interface ExceptionV2 {
        _type: \\"exceptionV2\\";
        exceptionV2: MyApi.submission.ExceptionV2;
    }

    export interface _Visitor<Result> {
        value: (value: MyApi.commons.VariableValue) => Result;
        exception: (value: MyApi.submission.ExceptionInfo) => Result;
        exceptionV2: (value: MyApi.submission.ExceptionV2) => Result;
        _unknown: () => Result;
    }
}

export const ActualResult = {
        value: (value: MyApi.commons.VariableValue): ActualResult.Value => ({
            value,
            _type: \\"value\\"
        }),

        exception: (value: MyApi.submission.ExceptionInfo): ActualResult.Exception => ({
            ...value,
            _type: \\"exception\\"
        }),

        exceptionV2: (value: MyApi.submission.ExceptionV2): ActualResult.ExceptionV2 => ({
            exceptionV2: value,
            _type: \\"exceptionV2\\"
        }),

        _visit: <Result>(value: ActualResult, visitor: ActualResult._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"value\\": return visitor.value(value.value);
                case \\"exception\\": return visitor.exception(value);
                case \\"exceptionV2\\": return visitor.exceptionV2(value.exceptionV2);
                default: return visitor._unknown();
            }
        },

        _types: (): ActualResult[\\"_type\\"][] => [\\"value\\", \\"exception\\", \\"exceptionV2\\"],
    } as const;
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface BuildingExecutorResponse {
    submissionId: MyApi.submission.SubmissionId;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type CodeExecutionUpdate = 
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends MyApi.submission.BuildingExecutorResponse {
        _type: \\"buildingExecutor\\";
    }

    interface Running extends MyApi.submission.RunningResponse {
        _type: \\"running\\";
    }

    interface Errored extends MyApi.submission.ErroredResponse {
        _type: \\"errored\\";
    }

    interface Stopped extends MyApi.submission.StoppedResponse {
        _type: \\"stopped\\";
    }

    interface Graded extends MyApi.submission.GradedResponse {
        _type: \\"graded\\";
    }

    interface GradedV2 extends MyApi.submission.GradedResponseV2 {
        _type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends MyApi.submission.WorkspaceRanResponse {
        _type: \\"workspaceRan\\";
    }

    interface Recording extends MyApi.submission.RecordingResponseNotification {
        _type: \\"recording\\";
    }

    interface Recorded extends MyApi.submission.RecordedResponseNotification {
        _type: \\"recorded\\";
    }

    interface InvalidRequest extends MyApi.submission.InvalidRequestResponse {
        _type: \\"invalidRequest\\";
    }

    interface Finished extends MyApi.submission.FinishedResponse {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        buildingExecutor: (value: MyApi.submission.BuildingExecutorResponse) => Result;
        running: (value: MyApi.submission.RunningResponse) => Result;
        errored: (value: MyApi.submission.ErroredResponse) => Result;
        stopped: (value: MyApi.submission.StoppedResponse) => Result;
        graded: (value: MyApi.submission.GradedResponse) => Result;
        gradedV2: (value: MyApi.submission.GradedResponseV2) => Result;
        workspaceRan: (value: MyApi.submission.WorkspaceRanResponse) => Result;
        recording: (value: MyApi.submission.RecordingResponseNotification) => Result;
        recorded: (value: MyApi.submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: MyApi.submission.InvalidRequestResponse) => Result;
        finished: (value: MyApi.submission.FinishedResponse) => Result;
        _unknown: () => Result;
    }
}

export const CodeExecutionUpdate = {
        buildingExecutor: (value: MyApi.submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
            ...value,
            _type: \\"buildingExecutor\\"
        }),

        running: (value: MyApi.submission.RunningResponse): CodeExecutionUpdate.Running => ({
            ...value,
            _type: \\"running\\"
        }),

        errored: (value: MyApi.submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
            ...value,
            _type: \\"errored\\"
        }),

        stopped: (value: MyApi.submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
            ...value,
            _type: \\"stopped\\"
        }),

        graded: (value: MyApi.submission.GradedResponse): CodeExecutionUpdate.Graded => ({
            ...value,
            _type: \\"graded\\"
        }),

        gradedV2: (value: MyApi.submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
            ...value,
            _type: \\"gradedV2\\"
        }),

        workspaceRan: (value: MyApi.submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
            ...value,
            _type: \\"workspaceRan\\"
        }),

        recording: (value: MyApi.submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
            ...value,
            _type: \\"recording\\"
        }),

        recorded: (value: MyApi.submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
            ...value,
            _type: \\"recorded\\"
        }),

        invalidRequest: (value: MyApi.submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
            ...value,
            _type: \\"invalidRequest\\"
        }),

        finished: (value: MyApi.submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
            ...value,
            _type: \\"finished\\"
        }),

        _visit: <Result>(value: CodeExecutionUpdate, visitor: CodeExecutionUpdate._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"buildingExecutor\\": return visitor.buildingExecutor(value);
                case \\"running\\": return visitor.running(value);
                case \\"errored\\": return visitor.errored(value);
                case \\"stopped\\": return visitor.stopped(value);
                case \\"graded\\": return visitor.graded(value);
                case \\"gradedV2\\": return visitor.gradedV2(value);
                case \\"workspaceRan\\": return visitor.workspaceRan(value);
                case \\"recording\\": return visitor.recording(value);
                case \\"recorded\\": return visitor.recorded(value);
                case \\"invalidRequest\\": return visitor.invalidRequest(value);
                case \\"finished\\": return visitor.finished(value);
                default: return visitor._unknown();
            }
        },

        _types: (): CodeExecutionUpdate[\\"_type\\"][] => [\\"buildingExecutor\\", \\"running\\", \\"errored\\", \\"stopped\\", \\"graded\\", \\"gradedV2\\", \\"workspaceRan\\", \\"recording\\", \\"recorded\\", \\"invalidRequest\\", \\"finished\\"],
    } as const;
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface CompileError {
    message: string;
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface CustomTestCasesUnsupported {
    problemId: MyApi.commons.ProblemId;
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type ErrorInfo = 
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError;

export declare namespace ErrorInfo {
    interface CompileError extends MyApi.submission.CompileError {
        _type: \\"compileError\\";
    }

    interface RuntimeError extends MyApi.submission.RuntimeError {
        _type: \\"runtimeError\\";
    }

    interface InternalError extends MyApi.submission.InternalError {
        _type: \\"internalError\\";
    }

    export interface _Visitor<Result> {
        compileError: (value: MyApi.submission.CompileError) => Result;
        runtimeError: (value: MyApi.submission.RuntimeError) => Result;
        internalError: (value: MyApi.submission.InternalError) => Result;
        _unknown: () => Result;
    }
}

export const ErrorInfo = {
        compileError: (value: MyApi.submission.CompileError): ErrorInfo.CompileError => ({
            ...value,
            _type: \\"compileError\\"
        }),

        runtimeError: (value: MyApi.submission.RuntimeError): ErrorInfo.RuntimeError => ({
            ...value,
            _type: \\"runtimeError\\"
        }),

        internalError: (value: MyApi.submission.InternalError): ErrorInfo.InternalError => ({
            ...value,
            _type: \\"internalError\\"
        }),

        _visit: <Result>(value: ErrorInfo, visitor: ErrorInfo._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"compileError\\": return visitor.compileError(value);
                case \\"runtimeError\\": return visitor.runtimeError(value);
                case \\"internalError\\": return visitor.internalError(value);
                default: return visitor._unknown();
            }
        },

        _types: (): ErrorInfo[\\"_type\\"][] => [\\"compileError\\", \\"runtimeError\\", \\"internalError\\"],
    } as const;
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ErroredResponse {
    submissionId: MyApi.submission.SubmissionId;
    errorInfo: MyApi.submission.ErrorInfo;
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type ExceptionV2 = 
    | ExceptionV2.Generic
    | ExceptionV2.Timeout;

export declare namespace ExceptionV2 {
    interface Generic extends MyApi.submission.ExceptionInfo {
        _type: \\"generic\\";
    }

    interface Timeout {
        _type: \\"timeout\\";
    }

    export interface _Visitor<Result> {
        generic: (value: MyApi.submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: () => Result;
    }
}

export const ExceptionV2 = {
        generic: (value: MyApi.submission.ExceptionInfo): ExceptionV2.Generic => ({
            ...value,
            _type: \\"generic\\"
        }),

        timeout: (): ExceptionV2.Timeout => ({
            _type: \\"timeout\\"
        }),

        _visit: <Result>(value: ExceptionV2, visitor: ExceptionV2._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"generic\\": return visitor.generic(value);
                case \\"timeout\\": return visitor.timeout();
                default: return visitor._unknown();
            }
        },

        _types: (): ExceptionV2[\\"_type\\"][] => [\\"generic\\", \\"timeout\\"],
    } as const;
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl?: string;
    language: MyApi.commons.Language;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ExecutionSessionState {
    lastTimeContacted?: string;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string;
    language: MyApi.commons.Language;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ExecutionSessionStatus = 
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
        CreatingContainer: \\"CREATING_CONTAINER\\",
        ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
        PendingContainer: \\"PENDING_CONTAINER\\",
        RunningContainer: \\"RUNNING_CONTAINER\\",
        LiveContainer: \\"LIVE_CONTAINER\\",
        FailedToLaunch: \\"FAILED_TO_LAUNCH\\",

        _visit: <Result>(value: ExecutionSessionStatus, visitor: ExecutionSessionStatus._Visitor<Result>): Result => {
            switch (value) {
                case ExecutionSessionStatus.CreatingContainer: return visitor.creatingContainer();
                case ExecutionSessionStatus.ProvisioningContainer: return visitor.provisioningContainer();
                case ExecutionSessionStatus.PendingContainer: return visitor.pendingContainer();
                case ExecutionSessionStatus.RunningContainer: return visitor.runningContainer();
                case ExecutionSessionStatus.LiveContainer: return visitor.liveContainer();
                case ExecutionSessionStatus.FailedToLaunch: return visitor.failedToLaunch();
                default: return visitor._unknown();
            }
        },

        _values: (): ExecutionSessionStatus[] => [ExecutionSessionStatus.CreatingContainer, ExecutionSessionStatus.ProvisioningContainer, ExecutionSessionStatus.PendingContainer, ExecutionSessionStatus.RunningContainer, ExecutionSessionStatus.LiveContainer, ExecutionSessionStatus.FailedToLaunch],
    } as const;

export declare namespace ExecutionSessionStatus {
    type CreatingContainer = \\"CREATING_CONTAINER\\";
    type ProvisioningContainer = \\"PROVISIONING_CONTAINER\\";
    type PendingContainer = \\"PENDING_CONTAINER\\";
    type RunningContainer = \\"RUNNING_CONTAINER\\";
    type LiveContainer = \\"LIVE_CONTAINER\\";
    type FailedToLaunch = \\"FAILED_TO_LAUNCH\\";

    export interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: () => Result;
    }
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface FinishedResponse {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, MyApi.submission.ExecutionSessionState>;
    numWarmingInstances?: number;
    warmingSessionIds: string[];
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted?: string;
    submission: string;
    language: MyApi.commons.Language;
    submissionTypeState: MyApi.submission.SubmissionTypeState;
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GetTraceResponsesPageRequest {
    offset?: number;
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GradedResponse {
    submissionId: MyApi.submission.SubmissionId;
    testCases: Record<string, MyApi.submission.TestCaseResultWithStdout>;
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GradedResponseV2 {
    submissionId: MyApi.submission.SubmissionId;
    testCases: Record<MyApi.v2.problem.TestCaseId, MyApi.submission.TestCaseGrade>;
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: MyApi.v2.problem.TestCaseId;
    grade: MyApi.submission.TestCaseGrade;
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface InitializeProblemRequest {
    problemId: MyApi.commons.ProblemId;
    problemVersion?: number;
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface InternalError {
    exceptionInfo: MyApi.submission.ExceptionInfo;
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type InvalidRequestCause = 
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends MyApi.submission.SubmissionIdNotFound {
        _type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends MyApi.submission.CustomTestCasesUnsupported {
        _type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends MyApi.submission.UnexpectedLanguageError {
        _type: \\"unexpectedLanguage\\";
    }

    export interface _Visitor<Result> {
        submissionIdNotFound: (value: MyApi.submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: MyApi.submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: MyApi.submission.UnexpectedLanguageError) => Result;
        _unknown: () => Result;
    }
}

export const InvalidRequestCause = {
        submissionIdNotFound: (value: MyApi.submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
            ...value,
            _type: \\"submissionIdNotFound\\"
        }),

        customTestCasesUnsupported: (value: MyApi.submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
            ...value,
            _type: \\"customTestCasesUnsupported\\"
        }),

        unexpectedLanguage: (value: MyApi.submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
            ...value,
            _type: \\"unexpectedLanguage\\"
        }),

        _visit: <Result>(value: InvalidRequestCause, visitor: InvalidRequestCause._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"submissionIdNotFound\\": return visitor.submissionIdNotFound(value);
                case \\"customTestCasesUnsupported\\": return visitor.customTestCasesUnsupported(value);
                case \\"unexpectedLanguage\\": return visitor.unexpectedLanguage(value);
                default: return visitor._unknown();
            }
        },

        _types: (): InvalidRequestCause[\\"_type\\"][] => [\\"submissionIdNotFound\\", \\"customTestCasesUnsupported\\", \\"unexpectedLanguage\\"],
    } as const;
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface InvalidRequestResponse {
    request: MyApi.submission.SubmissionRequest;
    cause: MyApi.submission.InvalidRequestCause;
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface RecordedResponseNotification {
    submissionId: MyApi.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId?: string;
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: MyApi.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface RecordingResponseNotification {
    submissionId: MyApi.submission.SubmissionId;
    testCaseId?: string;
    lineNumber: number;
    lightweightStackInfo: MyApi.submission.LightweightStackframeInformation;
    tracedFile?: MyApi.submission.TracedFile;
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface RunningResponse {
    submissionId: MyApi.submission.SubmissionId;
    state: MyApi.submission.RunningSubmissionState;
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export type RunningSubmissionState = 
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
        QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
        KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
        WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
        CompilingSubmission: \\"COMPILING_SUBMISSION\\",
        RunningSubmission: \\"RUNNING_SUBMISSION\\",

        _visit: <Result>(value: RunningSubmissionState, visitor: RunningSubmissionState._Visitor<Result>): Result => {
            switch (value) {
                case RunningSubmissionState.QueueingSubmission: return visitor.queueingSubmission();
                case RunningSubmissionState.KillingHistoricalSubmissions: return visitor.killingHistoricalSubmissions();
                case RunningSubmissionState.WritingSubmissionToFile: return visitor.writingSubmissionToFile();
                case RunningSubmissionState.CompilingSubmission: return visitor.compilingSubmission();
                case RunningSubmissionState.RunningSubmission: return visitor.runningSubmission();
                default: return visitor._unknown();
            }
        },

        _values: (): RunningSubmissionState[] => [RunningSubmissionState.QueueingSubmission, RunningSubmissionState.KillingHistoricalSubmissions, RunningSubmissionState.WritingSubmissionToFile, RunningSubmissionState.CompilingSubmission, RunningSubmissionState.RunningSubmission],
    } as const;

export declare namespace RunningSubmissionState {
    type QueueingSubmission = \\"QUEUEING_SUBMISSION\\";
    type KillingHistoricalSubmissions = \\"KILLING_HISTORICAL_SUBMISSIONS\\";
    type WritingSubmissionToFile = \\"WRITING_SUBMISSION_TO_FILE\\";
    type CompilingSubmission = \\"COMPILING_SUBMISSION\\";
    type RunningSubmission = \\"RUNNING_SUBMISSION\\";

    export interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: () => Result;
    }
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface RuntimeError {
    message: string;
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface Scope {
    variables: Record<string, MyApi.commons.DebugVariableValue>;
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ShareId = string;
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: MyApi.submission.Scope[];
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame?: MyApi.submission.StackFrame;
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StderrResponse {
    submissionId: MyApi.submission.SubmissionId;
    stderr: string;
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StdoutResponse {
    submissionId: MyApi.submission.SubmissionId;
    stdout: string;
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StopRequest {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface StoppedResponse {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export type SubmissionId = string;
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: MyApi.submission.SubmissionId;
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type SubmissionRequest = 
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends MyApi.submission.InitializeProblemRequest {
        _type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        _type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends MyApi.submission.SubmitRequestV2 {
        _type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends MyApi.submission.WorkspaceSubmitRequest {
        _type: \\"workspaceSubmit\\";
    }

    interface Stop extends MyApi.submission.StopRequest {
        _type: \\"stop\\";
    }

    export interface _Visitor<Result> {
        initializeProblemRequest: (value: MyApi.submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: MyApi.submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: MyApi.submission.WorkspaceSubmitRequest) => Result;
        stop: (value: MyApi.submission.StopRequest) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionRequest = {
        initializeProblemRequest: (value: MyApi.submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
            ...value,
            _type: \\"initializeProblemRequest\\"
        }),

        initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
            _type: \\"initializeWorkspaceRequest\\"
        }),

        submitV2: (value: MyApi.submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
            ...value,
            _type: \\"submitV2\\"
        }),

        workspaceSubmit: (value: MyApi.submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
            ...value,
            _type: \\"workspaceSubmit\\"
        }),

        stop: (value: MyApi.submission.StopRequest): SubmissionRequest.Stop => ({
            ...value,
            _type: \\"stop\\"
        }),

        _visit: <Result>(value: SubmissionRequest, visitor: SubmissionRequest._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"initializeProblemRequest\\": return visitor.initializeProblemRequest(value);
                case \\"initializeWorkspaceRequest\\": return visitor.initializeWorkspaceRequest();
                case \\"submitV2\\": return visitor.submitV2(value);
                case \\"workspaceSubmit\\": return visitor.workspaceSubmit(value);
                case \\"stop\\": return visitor.stop(value);
                default: return visitor._unknown();
            }
        },

        _types: (): SubmissionRequest[\\"_type\\"][] => [\\"initializeProblemRequest\\", \\"initializeWorkspaceRequest\\", \\"submitV2\\", \\"workspaceSubmit\\", \\"stop\\"],
    } as const;
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type SubmissionResponse = 
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

export declare namespace SubmissionResponse {
    interface ServerInitialized {
        _type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        _type: \\"problemInitialized\\";
        problemInitialized: MyApi.commons.ProblemId;
    }

    interface WorkspaceInitialized {
        _type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends MyApi.submission.ExceptionInfo {
        _type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        _type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: MyApi.submission.CodeExecutionUpdate;
    }

    interface Terminated extends MyApi.submission.TerminatedResponse {
        _type: \\"terminated\\";
    }

    export interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: MyApi.commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: MyApi.submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: MyApi.submission.CodeExecutionUpdate) => Result;
        terminated: (value: MyApi.submission.TerminatedResponse) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionResponse = {
        serverInitialized: (): SubmissionResponse.ServerInitialized => ({
            _type: \\"serverInitialized\\"
        }),

        problemInitialized: (value: MyApi.commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
            problemInitialized: value,
            _type: \\"problemInitialized\\"
        }),

        workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
            _type: \\"workspaceInitialized\\"
        }),

        serverErrored: (value: MyApi.submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
            ...value,
            _type: \\"serverErrored\\"
        }),

        codeExecutionUpdate: (value: MyApi.submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
            codeExecutionUpdate: value,
            _type: \\"codeExecutionUpdate\\"
        }),

        terminated: (value: MyApi.submission.TerminatedResponse): SubmissionResponse.Terminated => ({
            ...value,
            _type: \\"terminated\\"
        }),

        _visit: <Result>(value: SubmissionResponse, visitor: SubmissionResponse._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"serverInitialized\\": return visitor.serverInitialized();
                case \\"problemInitialized\\": return visitor.problemInitialized(value.problemInitialized);
                case \\"workspaceInitialized\\": return visitor.workspaceInitialized();
                case \\"serverErrored\\": return visitor.serverErrored(value);
                case \\"codeExecutionUpdate\\": return visitor.codeExecutionUpdate(value.codeExecutionUpdate);
                case \\"terminated\\": return visitor.terminated(value);
                default: return visitor._unknown();
            }
        },

        _types: (): SubmissionResponse[\\"_type\\"][] => [\\"serverInitialized\\", \\"problemInitialized\\", \\"workspaceInitialized\\", \\"serverErrored\\", \\"codeExecutionUpdate\\", \\"terminated\\"],
    } as const;
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type SubmissionStatusForTestCase = 
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends MyApi.submission.TestCaseResultWithStdout {
        _type: \\"graded\\";
    }

    interface GradedV2 {
        _type: \\"gradedV2\\";
        gradedV2: MyApi.submission.TestCaseGrade;
    }

    interface Traced extends MyApi.submission.TracedTestCase {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        graded: (value: MyApi.submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: MyApi.submission.TestCaseGrade) => Result;
        traced: (value: MyApi.submission.TracedTestCase) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusForTestCase = {
        graded: (value: MyApi.submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
            ...value,
            _type: \\"graded\\"
        }),

        gradedV2: (value: MyApi.submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
            gradedV2: value,
            _type: \\"gradedV2\\"
        }),

        traced: (value: MyApi.submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
            ...value,
            _type: \\"traced\\"
        }),

        _visit: <Result>(value: SubmissionStatusForTestCase, visitor: SubmissionStatusForTestCase._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"graded\\": return visitor.graded(value);
                case \\"gradedV2\\": return visitor.gradedV2(value.gradedV2);
                case \\"traced\\": return visitor.traced(value);
                default: return visitor._unknown();
            }
        },

        _types: (): SubmissionStatusForTestCase[\\"_type\\"][] => [\\"graded\\", \\"gradedV2\\", \\"traced\\"],
    } as const;
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type SubmissionStatusV2 = 
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace;

export declare namespace SubmissionStatusV2 {
    interface Test extends MyApi.submission.TestSubmissionStatusV2 {
        _type: \\"test\\";
    }

    interface Workspace extends MyApi.submission.WorkspaceSubmissionStatusV2 {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: MyApi.submission.TestSubmissionStatusV2) => Result;
        workspace: (value: MyApi.submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusV2 = {
        test: (value: MyApi.submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
            ...value,
            _type: \\"test\\"
        }),

        workspace: (value: MyApi.submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
            ...value,
            _type: \\"workspace\\"
        }),

        _visit: <Result>(value: SubmissionStatusV2, visitor: SubmissionStatusV2._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"test\\": return visitor.test(value);
                case \\"workspace\\": return visitor.workspace(value);
                default: return visitor._unknown();
            }
        },

        _types: (): SubmissionStatusV2[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
    } as const;
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum = 
    | \\"TEST\\";

export const SubmissionTypeEnum = {
        Test: \\"TEST\\",

        _visit: <Result>(value: SubmissionTypeEnum, visitor: SubmissionTypeEnum._Visitor<Result>): Result => {
            switch (value) {
                case SubmissionTypeEnum.Test: return visitor.test();
                default: return visitor._unknown();
            }
        },

        _values: (): SubmissionTypeEnum[] => [SubmissionTypeEnum.Test],
    } as const;

export declare namespace SubmissionTypeEnum {
    type Test = \\"TEST\\";

    export interface _Visitor<Result> {
        test: () => Result;
        _unknown: () => Result;
    }
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type SubmissionTypeState = 
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace;

export declare namespace SubmissionTypeState {
    interface Test extends MyApi.submission.TestSubmissionState {
        _type: \\"test\\";
    }

    interface Workspace extends MyApi.submission.WorkspaceSubmissionState {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: MyApi.submission.TestSubmissionState) => Result;
        workspace: (value: MyApi.submission.WorkspaceSubmissionState) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionTypeState = {
        test: (value: MyApi.submission.TestSubmissionState): SubmissionTypeState.Test => ({
            ...value,
            _type: \\"test\\"
        }),

        workspace: (value: MyApi.submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
            ...value,
            _type: \\"workspace\\"
        }),

        _visit: <Result>(value: SubmissionTypeState, visitor: SubmissionTypeState._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"test\\": return visitor.test(value);
                case \\"workspace\\": return visitor.workspace(value);
                default: return visitor._unknown();
            }
        },

        _types: (): SubmissionTypeState[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
    } as const;
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface SubmitRequestV2 {
    submissionId: MyApi.submission.SubmissionId;
    language: MyApi.commons.Language;
    submissionFiles: MyApi.submission.SubmissionFileInfo[];
    problemId: MyApi.commons.ProblemId;
    problemVersion?: number;
    userId?: string;
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TerminatedResponse {
}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type TestCaseGrade = 
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden;

export declare namespace TestCaseGrade {
    interface Hidden extends MyApi.submission.TestCaseHiddenGrade {
        _type: \\"hidden\\";
    }

    interface NonHidden extends MyApi.submission.TestCaseNonHiddenGrade {
        _type: \\"nonHidden\\";
    }

    export interface _Visitor<Result> {
        hidden: (value: MyApi.submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: MyApi.submission.TestCaseNonHiddenGrade) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseGrade = {
        hidden: (value: MyApi.submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
            ...value,
            _type: \\"hidden\\"
        }),

        nonHidden: (value: MyApi.submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
            ...value,
            _type: \\"nonHidden\\"
        }),

        _visit: <Result>(value: TestCaseGrade, visitor: TestCaseGrade._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"hidden\\": return visitor.hidden(value);
                case \\"nonHidden\\": return visitor.nonHidden(value);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseGrade[\\"_type\\"][] => [\\"hidden\\", \\"nonHidden\\"],
    } as const;
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult?: MyApi.commons.VariableValue;
    exception?: MyApi.submission.ExceptionV2;
    stdout: string;
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestCaseResult {
    expectedResult: MyApi.commons.VariableValue;
    actualResult: MyApi.submission.ActualResult;
    passed: boolean;
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestCaseResultWithStdout {
    result: MyApi.submission.TestCaseResult;
    stdout: string;
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestSubmissionState {
    problemId: MyApi.commons.ProblemId;
    defaultTestCases: MyApi.commons.TestCase[];
    customTestCases: MyApi.commons.TestCase[];
    status: MyApi.submission.TestSubmissionStatus;
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type TestSubmissionStatus = 
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

export declare namespace TestSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: MyApi.submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: MyApi.submission.RunningSubmissionState;
    }

    interface TestCaseIdToState {
        _type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, MyApi.submission.SubmissionStatusForTestCase>;
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, MyApi.submission.SubmissionStatusForTestCase>) => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionStatus = {
        stopped: (): TestSubmissionStatus.Stopped => ({
            _type: \\"stopped\\"
        }),

        errored: (value: MyApi.submission.ErrorInfo): TestSubmissionStatus.Errored => ({
            errored: value,
            _type: \\"errored\\"
        }),

        running: (value: MyApi.submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
            running: value,
            _type: \\"running\\"
        }),

        testCaseIdToState: (value: Record<string, MyApi.submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
            testCaseIdToState: value,
            _type: \\"testCaseIdToState\\"
        }),

        _visit: <Result>(value: TestSubmissionStatus, visitor: TestSubmissionStatus._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"stopped\\": return visitor.stopped();
                case \\"errored\\": return visitor.errored(value.errored);
                case \\"running\\": return visitor.running(value.running);
                case \\"testCaseIdToState\\": return visitor.testCaseIdToState(value.testCaseIdToState);
                default: return visitor._unknown();
            }
        },

        _types: (): TestSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"testCaseIdToState\\"],
    } as const;
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestSubmissionStatusV2 {
    updates: MyApi.submission.TestSubmissionUpdate[];
    problemId: MyApi.commons.ProblemId;
    problemVersion: number;
    problemInfo: MyApi.v2.problem.ProblemInfoV2;
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: MyApi.submission.TestSubmissionUpdateInfo;
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type TestSubmissionUpdateInfo = 
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

export declare namespace TestSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: MyApi.submission.RunningSubmissionState;
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: MyApi.submission.ErrorInfo;
    }

    interface GradedTestCase extends MyApi.submission.GradedTestCaseUpdate {
        _type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends MyApi.submission.RecordedTestCaseUpdate {
        _type: \\"recordedTestCase\\";
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        gradedTestCase: (value: MyApi.submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: MyApi.submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionUpdateInfo = {
        running: (value: MyApi.submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
            running: value,
            _type: \\"running\\"
        }),

        stopped: (): TestSubmissionUpdateInfo.Stopped => ({
            _type: \\"stopped\\"
        }),

        errored: (value: MyApi.submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
            errored: value,
            _type: \\"errored\\"
        }),

        gradedTestCase: (value: MyApi.submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
            ...value,
            _type: \\"gradedTestCase\\"
        }),

        recordedTestCase: (value: MyApi.submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
            ...value,
            _type: \\"recordedTestCase\\"
        }),

        finished: (): TestSubmissionUpdateInfo.Finished => ({
            _type: \\"finished\\"
        }),

        _visit: <Result>(value: TestSubmissionUpdateInfo, visitor: TestSubmissionUpdateInfo._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"running\\": return visitor.running(value.running);
                case \\"stopped\\": return visitor.stopped();
                case \\"errored\\": return visitor.errored(value.errored);
                case \\"gradedTestCase\\": return visitor.gradedTestCase(value);
                case \\"recordedTestCase\\": return visitor.recordedTestCase(value);
                case \\"finished\\": return visitor.finished();
                default: return visitor._unknown();
            }
        },

        _types: (): TestSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"stopped\\", \\"errored\\", \\"gradedTestCase\\", \\"recordedTestCase\\", \\"finished\\"],
    } as const;
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TraceResponse {
    submissionId: MyApi.submission.SubmissionId;
    lineNumber: number;
    returnValue?: MyApi.commons.DebugVariableValue;
    expressionLocation?: MyApi.submission.ExpressionLocation;
    stack: MyApi.submission.StackInformation;
    stdout?: string;
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TraceResponseV2 {
    submissionId: MyApi.submission.SubmissionId;
    lineNumber: number;
    file: MyApi.submission.TracedFile;
    returnValue?: MyApi.commons.DebugVariableValue;
    expressionLocation?: MyApi.submission.ExpressionLocation;
    stack: MyApi.submission.StackInformation;
    stdout?: string;
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: MyApi.submission.TraceResponseV2[];
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface TracedTestCase {
    result: MyApi.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: MyApi.commons.Language;
    actualLanguage: MyApi.commons.Language;
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceFiles {
    mainFile: MyApi.commons.FileInfo;
    readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceRanResponse {
    submissionId: MyApi.submission.SubmissionId;
    runDetails: MyApi.submission.WorkspaceRunDetails;
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceRunDetails {
    exceptionV2?: MyApi.submission.ExceptionV2;
    exception?: MyApi.submission.ExceptionInfo;
    stdout: string;
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<MyApi.commons.Language, MyApi.submission.WorkspaceFiles>;
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceSubmissionState {
    status: MyApi.submission.WorkspaceSubmissionStatus;
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type WorkspaceSubmissionStatus = 
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: MyApi.submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: MyApi.submission.RunningSubmissionState;
    }

    interface Ran extends MyApi.submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Traced extends MyApi.submission.WorkspaceRunDetails {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        traced: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionStatus = {
        stopped: (): WorkspaceSubmissionStatus.Stopped => ({
            _type: \\"stopped\\"
        }),

        errored: (value: MyApi.submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
            errored: value,
            _type: \\"errored\\"
        }),

        running: (value: MyApi.submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
            running: value,
            _type: \\"running\\"
        }),

        ran: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
            ...value,
            _type: \\"ran\\"
        }),

        traced: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
            ...value,
            _type: \\"traced\\"
        }),

        _visit: <Result>(value: WorkspaceSubmissionStatus, visitor: WorkspaceSubmissionStatus._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"stopped\\": return visitor.stopped();
                case \\"errored\\": return visitor.errored(value.errored);
                case \\"running\\": return visitor.running(value.running);
                case \\"ran\\": return visitor.ran(value);
                case \\"traced\\": return visitor.traced(value);
                default: return visitor._unknown();
            }
        },

        _types: (): WorkspaceSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"ran\\", \\"traced\\"],
    } as const;
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: MyApi.submission.WorkspaceSubmissionUpdate[];
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: MyApi.submission.WorkspaceSubmissionUpdateInfo;
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export type WorkspaceSubmissionUpdateInfo = 
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: MyApi.submission.RunningSubmissionState;
    }

    interface Ran extends MyApi.submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Traced {
        _type: \\"traced\\";
    }

    interface TracedV2 extends MyApi.submission.WorkspaceTracedUpdate {
        _type: \\"tracedV2\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: MyApi.submission.ErrorInfo;
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: MyApi.submission.WorkspaceTracedUpdate) => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
        running: (value: MyApi.submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
            running: value,
            _type: \\"running\\"
        }),

        ran: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
            ...value,
            _type: \\"ran\\"
        }),

        stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
            _type: \\"stopped\\"
        }),

        traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
            _type: \\"traced\\"
        }),

        tracedV2: (value: MyApi.submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
            ...value,
            _type: \\"tracedV2\\"
        }),

        errored: (value: MyApi.submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
            errored: value,
            _type: \\"errored\\"
        }),

        finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
            _type: \\"finished\\"
        }),

        _visit: <Result>(value: WorkspaceSubmissionUpdateInfo, visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"running\\": return visitor.running(value.running);
                case \\"ran\\": return visitor.ran(value);
                case \\"stopped\\": return visitor.stopped();
                case \\"traced\\": return visitor.traced();
                case \\"tracedV2\\": return visitor.tracedV2(value);
                case \\"errored\\": return visitor.errored(value.errored);
                case \\"finished\\": return visitor.finished();
                default: return visitor._unknown();
            }
        },

        _types: (): WorkspaceSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"ran\\", \\"stopped\\", \\"traced\\", \\"tracedV2\\", \\"errored\\", \\"finished\\"],
    } as const;
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: MyApi.submission.SubmissionId;
    language: MyApi.commons.Language;
    submissionFiles: MyApi.submission.SubmissionFileInfo[];
    userId?: string;
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    createExecutionSession(request: MyApi.submission.createExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse, MyApi.submission.createExecutionSession.Error>>;
    getExecutionSession(request: MyApi.submission.getExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse | undefined, MyApi.submission.getExecutionSession.Error>>;
    stopExecutionSession(request: MyApi.submission.stopExecutionSession.Request): Promise<_Response<void, MyApi.submission.stopExecutionSession.Error>>;
    getExecutionSessionsState(): Promise<_Response<MyApi.submission.GetExecutionSessionStateResponse, MyApi.submission.getExecutionSessionsState.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async createExecutionSession(request: MyApi.submission.createExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse, MyApi.submission.createExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/create-session/\${request.language}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.ExecutionSessionResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getExecutionSession(request: MyApi.submission.getExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse | undefined, MyApi.submission.getExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.sessionId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.ExecutionSessionResponse | undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async stopExecutionSession(request: MyApi.submission.stopExecutionSession.Request): Promise<_Response<void, MyApi.submission.stopExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/stop/\${request.sessionId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getExecutionSessionsState(): Promise<_Response<MyApi.submission.GetExecutionSessionStateResponse, MyApi.submission.getExecutionSessionsState.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/execution-sessions-state\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.GetExecutionSessionStateResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createExecutionSession {
    export interface Request {
        language: MyApi.commons.Language;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.createExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getExecutionSession {
    export interface Request {
        sessionId: string;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.getExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace stopExecutionSession {
    export interface Request {
        sessionId: string;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.stopExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getExecutionSessionsState {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.getExecutionSessionsState.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    setNumWarmInstances(request: MyApi.sysprop.setNumWarmInstances.Request): Promise<_Response<void, MyApi.sysprop.setNumWarmInstances.Error>>;
    getNumWarmInstances(): Promise<_Response<Record<MyApi.commons.Language, number>, MyApi.sysprop.getNumWarmInstances.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async setNumWarmInstances(request: MyApi.sysprop.setNumWarmInstances.Request): Promise<_Response<void, MyApi.sysprop.setNumWarmInstances.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`),
                method: \\"PUT\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getNumWarmInstances(): Promise<_Response<Record<MyApi.commons.Language, number>, MyApi.sysprop.getNumWarmInstances.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/num-warm-instances\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as Record<MyApi.commons.Language, number>
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace setNumWarmInstances {
    export interface Request {
        language: MyApi.commons.Language;
        numWarmInstances: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.sysprop.setNumWarmInstances.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getNumWarmInstances {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.sysprop.getNumWarmInstances.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { BasicAuth, BearerToken } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../..\\";
import urlJoin from \\"url-join\\";

export namespace _Client {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client {
    constructor(private readonly options: _Client.Options) {
    }

    #problem: MyApi.v2.problem._Client | undefined;

    public get problem(): MyApi.v2.problem._Client {
        return (this.#problem ??= new MyApi.v2.problem._Client({
            _basePath: urlJoin(this.options._origin, \\"/problems-v2\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #v3: MyApi.v2.v3._Client | undefined;

    public get v3(): MyApi.v2.v3._Client {
        return (this.#v3 ??= new MyApi.v2.v3._Client(this.options));
    }
}
",
                "name": "_Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
export * from \\"./_Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type AssertCorrectnessCheck = 
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends MyApi.v2.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: MyApi.v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
        deepEquality: (value: MyApi.v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
            ...value,
            _type: \\"deepEquality\\"
        }),

        custom: (value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
            ...value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"deepEquality\\": return visitor.deepEquality(value);
                case \\"custom\\": return visitor.custom(value);
                default: return visitor._unknown();
            }
        },

        _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
    } as const;
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
    basicTestCaseTemplate: MyApi.v2.problem.BasicTestCaseTemplate;
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface BasicTestCaseTemplate {
    templateId: MyApi.v2.problem.TestCaseTemplateId;
    name: string;
    description: MyApi.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    customFiles: MyApi.v2.problem.CustomFiles;
    customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
    testcases: MyApi.v2.problem.TestCaseV2[];
    supportedLanguages: MyApi.commons.Language[];
    isPublic: boolean;
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type CustomFiles = 
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends MyApi.v2.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: MyApi.v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<MyApi.commons.Language, MyApi.v2.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
        basic: (value: MyApi.v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
            ...value,
            _type: \\"basic\\"
        }),

        custom: (value: Record<MyApi.commons.Language, MyApi.v2.problem.Files>): CustomFiles.Custom => ({
            custom: value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"basic\\": return visitor.basic(value);
                case \\"custom\\": return visitor.custom(value.custom);
                default: return visitor._unknown();
            }
        },

        _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
    } as const;
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface DefaultProvidedFile {
    file: MyApi.v2.problem.FileInfoV2;
    relatedTypes: MyApi.commons.VariableType[];
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface Files {
    files: MyApi.v2.problem.FileInfoV2[];
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<MyApi.commons.Language, MyApi.v2.problem.FunctionImplementation>;
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type FunctionSignature = 
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends MyApi.v2.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends MyApi.v2.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: MyApi.v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: MyApi.v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
        void: (value: MyApi.v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
            ...value,
            _type: \\"void\\"
        }),

        nonVoid: (value: MyApi.v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
            ...value,
            _type: \\"nonVoid\\"
        }),

        voidThatTakesActualResult: (value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
            ...value,
            _type: \\"voidThatTakesActualResult\\"
        }),

        _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"void\\": return visitor.void(value);
                case \\"nonVoid\\": return visitor.nonVoid(value);
                case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
                default: return visitor._unknown();
            }
        },

        _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
    } as const;
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
    generatedTemplateFiles: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
    other: Record<MyApi.commons.Language, MyApi.v2.problem.Files>;
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<MyApi.commons.Language, MyApi.v2.problem.FileInfoV2>;
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: MyApi.v2.problem.FunctionSignature;
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<MyApi.commons.Language, string>;
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: MyApi.v2.problem.TestCaseTemplate;
    testCase: MyApi.v2.problem.TestCaseV2;
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: MyApi.v2.problem.TestCaseTemplate;
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: MyApi.commons.VariableType[];
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface NonVoidFunctionDefinition {
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface NonVoidFunctionSignature {
    parameters: MyApi.v2.problem.Parameter[];
    returnType: MyApi.commons.VariableType;
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface Parameter {
    parameterId: MyApi.v2.problem.ParameterId;
    name: string;
    variableType: MyApi.commons.VariableType;
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ParameterId = string;
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: MyApi.commons.Language[];
    customFiles: MyApi.v2.problem.CustomFiles;
    generatedFiles: MyApi.v2.problem.GeneratedFiles;
    customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
    testcases: MyApi.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type TestCaseFunction = 
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends MyApi.v2.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends MyApi.v2.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: MyApi.v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: MyApi.v2.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
        withActualResult: (value: MyApi.v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
            ...value,
            _type: \\"withActualResult\\"
        }),

        custom: (value: MyApi.v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
            ...value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"withActualResult\\": return visitor.withActualResult(value);
                case \\"custom\\": return visitor.custom(value);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
    } as const;
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseId = string;
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseImplementation {
    description: MyApi.v2.problem.TestCaseImplementationDescription;
    function: MyApi.v2.problem.TestCaseFunction;
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseImplementationDescription {
    boards: MyApi.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type TestCaseImplementationDescriptionBoard = 
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: MyApi.v2.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: MyApi.v2.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
        html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
            html: value,
            _type: \\"html\\"
        }),

        paramId: (value: MyApi.v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
            paramId: value,
            _type: \\"paramId\\"
        }),

        _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"html\\": return visitor.html(value.html);
                case \\"paramId\\": return visitor.paramId(value.paramId);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
    } as const;
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export type TestCaseImplementationReference = 
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: MyApi.v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends MyApi.v2.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: MyApi.v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: MyApi.v2.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
        templateId: (value: MyApi.v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
            templateId: value,
            _type: \\"templateId\\"
        }),

        implementation: (value: MyApi.v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
            ...value,
            _type: \\"implementation\\"
        }),

        _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"templateId\\": return visitor.templateId(value.templateId);
                case \\"implementation\\": return visitor.implementation(value);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
    } as const;
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseMetadata {
    id: MyApi.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseTemplate {
    templateId: MyApi.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: MyApi.v2.problem.TestCaseImplementation;
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseTemplateId = string;
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseV2 {
    metadata: MyApi.v2.problem.TestCaseMetadata;
    implementation: MyApi.v2.problem.TestCaseImplementationReference;
    arguments: Record<MyApi.v2.problem.ParameterId, MyApi.commons.VariableValue>;
    expects?: MyApi.v2.problem.TestCaseExpects;
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: MyApi.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: MyApi.v2.problem.AssertCorrectnessCheck;
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface VoidFunctionDefinition {
    parameters: MyApi.v2.problem.Parameter[];
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: MyApi.v2.problem.Parameter[];
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface VoidFunctionSignature {
    parameters: MyApi.v2.problem.Parameter[];
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: MyApi.v2.problem.Parameter[];
    actualResultType: MyApi.commons.VariableType;
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    getLightweightProblems(): Promise<_Response<MyApi.v2.problem.LightweightProblemInfoV2[], MyApi.v2.problem.getLightweightProblems.Error>>;
    getProblems(): Promise<_Response<MyApi.v2.problem.ProblemInfoV2[], MyApi.v2.problem.getProblems.Error>>;
    getLatestProblem(request: MyApi.v2.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getLatestProblem.Error>>;
    getProblemVersion(request: MyApi.v2.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getProblemVersion.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async getLightweightProblems(): Promise<_Response<MyApi.v2.problem.LightweightProblemInfoV2[], MyApi.v2.problem.getLightweightProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/lightweight-problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.LightweightProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblems(): Promise<_Response<MyApi.v2.problem.ProblemInfoV2[], MyApi.v2.problem.getProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getLatestProblem(request: MyApi.v2.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getLatestProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblemVersion(request: MyApi.v2.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getProblemVersion.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getLightweightProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getLightweightProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getLatestProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getLatestProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblemVersion {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        problemVersion: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getProblemVersion.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                    "name": "_Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
export * from \\"./_Client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BasicAuth, BearerToken } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export namespace _Client {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client {
    constructor(private readonly options: _Client.Options) {
    }

    #problem: MyApi.v2.v3.problem._Client | undefined;

    public get problem(): MyApi.v2.v3.problem._Client {
        return (this.#problem ??= new MyApi.v2.v3.problem._Client({
            _basePath: urlJoin(this.options._origin, \\"/problems-v2\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }
}
",
                    "name": "_Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./_Client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type AssertCorrectnessCheck = 
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
        deepEquality: (value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
            ...value,
            _type: \\"deepEquality\\"
        }),

        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
            ...value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"deepEquality\\": return visitor.deepEquality(value);
                case \\"custom\\": return visitor.custom(value);
                default: return visitor._unknown();
            }
        },

        _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
    } as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>;
    basicTestCaseTemplate: MyApi.v2.v3.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    customFiles: MyApi.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
    testcases: MyApi.v2.v3.problem.TestCaseV2[];
    supportedLanguages: MyApi.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type CustomFiles = 
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends MyApi.v2.v3.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: MyApi.v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
        basic: (value: MyApi.v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
            ...value,
            _type: \\"basic\\"
        }),

        custom: (value: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>): CustomFiles.Custom => ({
            custom: value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"basic\\": return visitor.basic(value);
                case \\"custom\\": return visitor.custom(value.custom);
                default: return visitor._unknown();
            }
        },

        _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
    } as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: MyApi.v2.v3.problem.FileInfoV2;
    relatedTypes: MyApi.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface Files {
    files: MyApi.v2.v3.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<MyApi.commons.Language, MyApi.v2.v3.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type FunctionSignature = 
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends MyApi.v2.v3.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends MyApi.v2.v3.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: MyApi.v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: MyApi.v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
        void: (value: MyApi.v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
            ...value,
            _type: \\"void\\"
        }),

        nonVoid: (value: MyApi.v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
            ...value,
            _type: \\"nonVoid\\"
        }),

        voidThatTakesActualResult: (value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
            ...value,
            _type: \\"voidThatTakesActualResult\\"
        }),

        _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"void\\": return visitor.void(value);
                case \\"nonVoid\\": return visitor.nonVoid(value);
                case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
                default: return visitor._unknown();
            }
        },

        _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
    } as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>;
    other: Record<MyApi.commons.Language, MyApi.v2.v3.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<MyApi.commons.Language, MyApi.v2.v3.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: MyApi.v2.v3.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<MyApi.commons.Language, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: MyApi.v2.v3.problem.TestCaseTemplate;
    testCase: MyApi.v2.v3.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: MyApi.v2.v3.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: MyApi.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: MyApi.v2.v3.problem.Parameter[];
    returnType: MyApi.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface Parameter {
    parameterId: MyApi.v2.v3.problem.ParameterId;
    name: string;
    variableType: MyApi.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: MyApi.commons.Language[];
    customFiles: MyApi.v2.v3.problem.CustomFiles;
    generatedFiles: MyApi.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
    testcases: MyApi.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseFunction = 
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends MyApi.v2.v3.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends MyApi.v2.v3.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
        withActualResult: (value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
            ...value,
            _type: \\"withActualResult\\"
        }),

        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
            ...value,
            _type: \\"custom\\"
        }),

        _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"withActualResult\\": return visitor.withActualResult(value);
                case \\"custom\\": return visitor.custom(value);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
    } as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementation {
    description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
    function: MyApi.v2.v3.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard = 
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: MyApi.v2.v3.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: MyApi.v2.v3.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
        html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
            html: value,
            _type: \\"html\\"
        }),

        paramId: (value: MyApi.v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
            paramId: value,
            _type: \\"paramId\\"
        }),

        _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"html\\": return visitor.html(value.html);
                case \\"paramId\\": return visitor.paramId(value.paramId);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
    } as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationReference = 
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends MyApi.v2.v3.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: MyApi.v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: MyApi.v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
        templateId: (value: MyApi.v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
            templateId: value,
            _type: \\"templateId\\"
        }),

        implementation: (value: MyApi.v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
            ...value,
            _type: \\"implementation\\"
        }),

        _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
            switch (value._type) {
                case \\"templateId\\": return visitor.templateId(value.templateId);
                case \\"implementation\\": return visitor.implementation(value);
                default: return visitor._unknown();
            }
        },

        _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
    } as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseMetadata {
    id: MyApi.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: MyApi.v2.v3.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: MyApi.v2.v3.problem.TestCaseMetadata;
    implementation: MyApi.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<MyApi.v2.v3.problem.ParameterId, MyApi.commons.VariableValue>;
    expects?: MyApi.v2.v3.problem.TestCaseExpects;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: MyApi.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: MyApi.v2.v3.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: MyApi.v2.v3.problem.Parameter[];
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: MyApi.v2.v3.problem.Parameter[];
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: MyApi.v2.v3.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: MyApi.v2.v3.problem.Parameter[];
    actualResultType: MyApi.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BasicAuth, BearerToken, ErrorDetails, _NetworkError, _Response, _UnknownError, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../../..\\";
import urlJoin from \\"url-join\\";

export interface _Client {
    getLightweightProblems(): Promise<_Response<MyApi.v2.v3.problem.LightweightProblemInfoV2[], MyApi.v2.v3.problem.getLightweightProblems.Error>>;
    getProblems(): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2[], MyApi.v2.v3.problem.getProblems.Error>>;
    getLatestProblem(request: MyApi.v2.v3.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getLatestProblem.Error>>;
    getProblemVersion(request: MyApi.v2.v3.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getProblemVersion.Error>>;
}

export declare namespace _Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class _Client implements _Client {
    constructor(private readonly options: _Client.Options) {
    }

    public async getLightweightProblems(): Promise<_Response<MyApi.v2.v3.problem.LightweightProblemInfoV2[], MyApi.v2.v3.problem.getLightweightProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/lightweight-problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.LightweightProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblems(): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2[], MyApi.v2.v3.problem.getProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getLatestProblem(request: MyApi.v2.v3.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getLatestProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblemVersion(request: MyApi.v2.v3.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getProblemVersion.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getLightweightProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getLightweightProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getLatestProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getLatestProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblemVersion {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        problemVersion: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getProblemVersion.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                        "name": "_Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
export * from \\"./_Client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      Object {
        "contents": "export * as MyApi from \\"./api\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": "{
    \\"name\\": \\"@fern-api/my-api-client-v2\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.0\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
        "name": "package.json",
        "type": "file",
      },
      Object {
        "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
        "name": "tsconfig.json",
        "type": "file",
      },
    ],
    "name": "client-v2",
    "type": "directory",
  },
]
`;

exports[`runGenerator trace server 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
        "name": ".npmignore",
        "type": "file",
      },
      Object {
        "contents": "export * as model from \\"./model\\";
export * as services from \\"./services\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type SendTestSubmissionUpdateErrorBody = never;

export declare namespace SendTestSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendTestSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendTestSubmissionUpdateErrorBody, visitor: SendTestSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendTestSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendTestSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendTestSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionUpdate;
}
",
                        "name": "SendTestSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendTestSubmissionUpdateResponse = SendTestSubmissionUpdateResponse.SuccessResponse | SendTestSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendTestSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendTestSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendTestSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SendWorkspaceSubmissionUpdateErrorBody = never;

export declare namespace SendWorkspaceSubmissionUpdateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SendWorkspaceSubmissionUpdateErrorBody = {
    _visit: <Result>(_value: SendWorkspaceSubmissionUpdateErrorBody, visitor: SendWorkspaceSubmissionUpdateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SendWorkspaceSubmissionUpdateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SendWorkspaceSubmissionUpdateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SendWorkspaceSubmissionUpdateRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionUpdate;
}
",
                        "name": "SendWorkspaceSubmissionUpdateRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SendWorkspaceSubmissionUpdateResponse = SendWorkspaceSubmissionUpdateResponse.SuccessResponse | SendWorkspaceSubmissionUpdateResponse.ErrorResponse;

export declare namespace SendWorkspaceSubmissionUpdateResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.SendWorkspaceSubmissionUpdateErrorBody;
    }
}
",
                        "name": "SendWorkspaceSubmissionUpdateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseErrorBody = never;

export declare namespace StoreTracedTestCaseErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseErrorBody, visitor: StoreTracedTestCaseErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseResponse = StoreTracedTestCaseResponse.SuccessResponse | StoreTracedTestCaseResponse.ErrorResponse;

export declare namespace StoreTracedTestCaseResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedTestCaseV2ErrorBody = never;

export declare namespace StoreTracedTestCaseV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedTestCaseV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedTestCaseV2ErrorBody, visitor: StoreTracedTestCaseV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedTestCaseV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedTestCaseV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedTestCaseV2Request {
    submissionId: model.submission.SubmissionId;
    testCaseId: model.v2.problem.TestCaseId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedTestCaseV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedTestCaseV2Response = StoreTracedTestCaseV2Response.SuccessResponse | StoreTracedTestCaseV2Response.ErrorResponse;

export declare namespace StoreTracedTestCaseV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedTestCaseV2ErrorBody;
    }
}
",
                        "name": "StoreTracedTestCaseV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceErrorBody = never;

export declare namespace StoreTracedWorkspaceErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceErrorBody, visitor: StoreTracedWorkspaceErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceResponse = StoreTracedWorkspaceResponse.SuccessResponse | StoreTracedWorkspaceResponse.ErrorResponse;

export declare namespace StoreTracedWorkspaceResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StoreTracedWorkspaceV2ErrorBody = never;

export declare namespace StoreTracedWorkspaceV2ErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StoreTracedWorkspaceV2ErrorBody = {
    _visit: <Result>(_value: StoreTracedWorkspaceV2ErrorBody, visitor: StoreTracedWorkspaceV2ErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StoreTracedWorkspaceV2ErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StoreTracedWorkspaceV2ErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface StoreTracedWorkspaceV2Request {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TraceResponseV2[];
}
",
                        "name": "StoreTracedWorkspaceV2Request.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StoreTracedWorkspaceV2Response = StoreTracedWorkspaceV2Response.SuccessResponse | StoreTracedWorkspaceV2Response.ErrorResponse;

export declare namespace StoreTracedWorkspaceV2Response {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.StoreTracedWorkspaceV2ErrorBody;
    }
}
",
                        "name": "StoreTracedWorkspaceV2Response.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateTestSubmissionStatusErrorBody = never;

export declare namespace UpdateTestSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateTestSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateTestSubmissionStatusErrorBody, visitor: UpdateTestSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateTestSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateTestSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateTestSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.TestSubmissionStatus;
}
",
                        "name": "UpdateTestSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateTestSubmissionStatusResponse = UpdateTestSubmissionStatusResponse.SuccessResponse | UpdateTestSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateTestSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateTestSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateTestSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateWorkspaceSubmissionStatusErrorBody = never;

export declare namespace UpdateWorkspaceSubmissionStatusErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateWorkspaceSubmissionStatusErrorBody = {
    _visit: <Result>(_value: UpdateWorkspaceSubmissionStatusErrorBody, visitor: UpdateWorkspaceSubmissionStatusErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateWorkspaceSubmissionStatusErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateWorkspaceSubmissionStatusErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateWorkspaceSubmissionStatusRequest {
    submissionId: model.submission.SubmissionId;
    body: model.submission.WorkspaceSubmissionStatus;
}
",
                        "name": "UpdateWorkspaceSubmissionStatusRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdateWorkspaceSubmissionStatusResponse = UpdateWorkspaceSubmissionStatusResponse.SuccessResponse | UpdateWorkspaceSubmissionStatusResponse.ErrorResponse;

export declare namespace UpdateWorkspaceSubmissionStatusResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.admin.UpdateWorkspaceSubmissionStatusErrorBody;
    }
}
",
                        "name": "UpdateWorkspaceSubmissionStatusResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedTestCaseRequest {
    submissionId: model.submission.SubmissionId;
    testCaseId: string;
    body: model.admin.StoreTracedTestCaseRequest;
}
",
                        "name": "_StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _StoreTracedWorkspaceRequest {
    submissionId: model.submission.SubmissionId;
    body: model.admin.StoreTracedWorkspaceRequest;
}
",
                        "name": "_StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./UpdateTestSubmissionStatusRequest\\";
export * from \\"./UpdateTestSubmissionStatusErrorBody\\";
export * from \\"./UpdateTestSubmissionStatusResponse\\";
export * from \\"./SendTestSubmissionUpdateRequest\\";
export * from \\"./SendTestSubmissionUpdateErrorBody\\";
export * from \\"./SendTestSubmissionUpdateResponse\\";
export * from \\"./UpdateWorkspaceSubmissionStatusRequest\\";
export * from \\"./UpdateWorkspaceSubmissionStatusErrorBody\\";
export * from \\"./UpdateWorkspaceSubmissionStatusResponse\\";
export * from \\"./SendWorkspaceSubmissionUpdateRequest\\";
export * from \\"./SendWorkspaceSubmissionUpdateErrorBody\\";
export * from \\"./SendWorkspaceSubmissionUpdateResponse\\";
export * from \\"./_StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedTestCaseErrorBody\\";
export * from \\"./StoreTracedTestCaseResponse\\";
export * from \\"./StoreTracedTestCaseV2Request\\";
export * from \\"./StoreTracedTestCaseV2ErrorBody\\";
export * from \\"./StoreTracedTestCaseV2Response\\";
export * from \\"./_StoreTracedWorkspaceRequest\\";
export * from \\"./StoreTracedWorkspaceErrorBody\\";
export * from \\"./StoreTracedWorkspaceResponse\\";
export * from \\"./StoreTracedWorkspaceV2Request\\";
export * from \\"./StoreTracedWorkspaceV2ErrorBody\\";
export * from \\"./StoreTracedWorkspaceV2Response\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "AdminService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./AdminService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedTestCaseRequest {
    result: model.submission.TestCaseResultWithStdout;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: model.submission.WorkspaceRunDetails;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: model.commons.NodeId;
    fullTree: model.commons.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    right: model.commons.NodeId | null | undefined;
    left: model.commons.NodeId | null | undefined;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BinaryTreeValue {
    root: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugKeyValuePairs {
    key: model.commons.DebugVariableValue;
    value: model.commons.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DebugMapValue {
    keyValuePairs: model.commons.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type DebugVariableValue =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

export declare namespace DebugVariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.DebugMapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends commons.BinaryTreeNodeAndTreeValue {
        _type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends commons.SinglyLinkedListNodeAndListValue {
        _type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends commons.DoublyLinkedListNodeAndListValue {
        _type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        _type: \\"undefinedValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    interface GenericValue extends commons.GenericValue {
        _type: \\"genericValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.DebugMapValue) => Result;
        listValue: (value: commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: commons.GenericValue) => Result;
        _unknown: () => Result;
    }
}

export const DebugVariableValue = {
    integerValue: (value: number): DebugVariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): DebugVariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): DebugVariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.DebugMapValue): DebugVariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeNodeValue: (value: commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
        ...value,
        _type: \\"binaryTreeNodeValue\\"
    }),

    singlyLinkedListNodeValue: (value: commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
        ...value,
        _type: \\"singlyLinkedListNodeValue\\"
    }),

    doublyLinkedListNodeValue: (value: commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
        ...value,
        _type: \\"doublyLinkedListNodeValue\\"
    }),

    undefinedValue: (): DebugVariableValue.UndefinedValue => ({
        _type: \\"undefinedValue\\"
    }),

    nullValue: (): DebugVariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    genericValue: (value: commons.GenericValue): DebugVariableValue.GenericValue => ({
        ...value,
        _type: \\"genericValue\\"
    }),

    _visit: <Result>(value: DebugVariableValue, visitor: DebugVariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeNodeValue\\": return visitor.binaryTreeNodeValue(value);
            case \\"singlyLinkedListNodeValue\\": return visitor.singlyLinkedListNodeValue(value);
            case \\"doublyLinkedListNodeValue\\": return visitor.doublyLinkedListNodeValue(value);
            case \\"undefinedValue\\": return visitor.undefinedValue();
            case \\"nullValue\\": return visitor.nullValue();
            case \\"genericValue\\": return visitor.genericValue(value);
            default: return visitor._unknown();
        }
    },

    _types: (): DebugVariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeNodeValue\\", \\"singlyLinkedListNodeValue\\", \\"doublyLinkedListNodeValue\\", \\"undefinedValue\\", \\"nullValue\\", \\"genericValue\\"],
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
    prev: model.commons.NodeId | null | undefined;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface DoublyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericValue {
    stringifiedType: string | null | undefined;
    stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface KeyValuePair {
    key: model.commons.VariableValue;
    value: model.commons.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type Language =
    | \\"JAVA\\"
    | \\"JAVASCRIPT\\"
    | \\"PYTHON\\";

export const Language = {
    Java: \\"JAVA\\",
    Javascript: \\"JAVASCRIPT\\",
    Python: \\"PYTHON\\",

    _visit: <Result>(value: Language, visitor: Language._Visitor<Result>): Result => {
        switch (value) {
            case Language.Java: return visitor.java();
            case Language.Javascript: return visitor.javascript();
            case Language.Python: return visitor.python();
            default: return visitor._unknown();
        }
    },

    _values: (): Language[] => [Language.Java, Language.Javascript, Language.Python],
} as const;

export declare namespace Language {
    type Java = \\"JAVA\\";
    type Javascript = \\"JAVASCRIPT\\";
    type Python = \\"PYTHON\\";

    export interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ListType {
    valueType: model.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength: boolean | null | undefined;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapType {
    keyType: model.commons.VariableType;
    valueType: model.commons.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface MapValue {
    keyValuePairs: model.commons.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type NodeId = string;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ProblemId = string;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: model.commons.NodeId;
    fullList: model.commons.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: model.commons.NodeId;
    val: number;
    next: model.commons.NodeId | null | undefined;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SinglyLinkedListValue {
    head: model.commons.NodeId | null | undefined;
    nodes: Record<model.commons.NodeId, model.commons.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCase {
    id: string;
    params: model.commons.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseWithExpectedResult {
    testCase: model.commons.TestCase;
    expectedResult: model.commons.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UserId = string;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableType =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

export declare namespace VariableType {
    interface IntegerType {
        _type: \\"integerType\\";
    }

    interface DoubleType {
        _type: \\"doubleType\\";
    }

    interface BooleanType {
        _type: \\"booleanType\\";
    }

    interface StringType {
        _type: \\"stringType\\";
    }

    interface CharType {
        _type: \\"charType\\";
    }

    interface ListType extends commons.ListType {
        _type: \\"listType\\";
    }

    interface MapType extends commons.MapType {
        _type: \\"mapType\\";
    }

    interface BinaryTreeType {
        _type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        _type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        _type: \\"doublyLinkedListType\\";
    }

    export interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: commons.ListType) => Result;
        mapType: (value: commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: () => Result;
    }
}

export const VariableType = {
    integerType: (): VariableType.IntegerType => ({
        _type: \\"integerType\\"
    }),

    doubleType: (): VariableType.DoubleType => ({
        _type: \\"doubleType\\"
    }),

    booleanType: (): VariableType.BooleanType => ({
        _type: \\"booleanType\\"
    }),

    stringType: (): VariableType.StringType => ({
        _type: \\"stringType\\"
    }),

    charType: (): VariableType.CharType => ({
        _type: \\"charType\\"
    }),

    listType: (value: commons.ListType): VariableType.ListType => ({
        ...value,
        _type: \\"listType\\"
    }),

    mapType: (value: commons.MapType): VariableType.MapType => ({
        ...value,
        _type: \\"mapType\\"
    }),

    binaryTreeType: (): VariableType.BinaryTreeType => ({
        _type: \\"binaryTreeType\\"
    }),

    singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
        _type: \\"singlyLinkedListType\\"
    }),

    doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
        _type: \\"doublyLinkedListType\\"
    }),

    _visit: <Result>(value: VariableType, visitor: VariableType._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerType\\": return visitor.integerType();
            case \\"doubleType\\": return visitor.doubleType();
            case \\"booleanType\\": return visitor.booleanType();
            case \\"stringType\\": return visitor.stringType();
            case \\"charType\\": return visitor.charType();
            case \\"listType\\": return visitor.listType(value);
            case \\"mapType\\": return visitor.mapType(value);
            case \\"binaryTreeType\\": return visitor.binaryTreeType();
            case \\"singlyLinkedListType\\": return visitor.singlyLinkedListType();
            case \\"doublyLinkedListType\\": return visitor.doublyLinkedListType();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableType[\\"_type\\"][] => [\\"integerType\\", \\"doubleType\\", \\"booleanType\\", \\"stringType\\", \\"charType\\", \\"listType\\", \\"mapType\\", \\"binaryTreeType\\", \\"singlyLinkedListType\\", \\"doublyLinkedListType\\"],
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type VariableValue =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

export declare namespace VariableValue {
    interface IntegerValue {
        _type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        _type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        _type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        _type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        _type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends commons.MapValue {
        _type: \\"mapValue\\";
    }

    interface ListValue {
        _type: \\"listValue\\";
        listValue: commons.VariableValue[];
    }

    interface BinaryTreeValue extends commons.BinaryTreeValue {
        _type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends commons.SinglyLinkedListValue {
        _type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends commons.DoublyLinkedListValue {
        _type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        _type: \\"nullValue\\";
    }

    export interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: commons.MapValue) => Result;
        listValue: (value: commons.VariableValue[]) => Result;
        binaryTreeValue: (value: commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: () => Result;
    }
}

export const VariableValue = {
    integerValue: (value: number): VariableValue.IntegerValue => ({
        integerValue: value,
        _type: \\"integerValue\\"
    }),

    booleanValue: (value: boolean): VariableValue.BooleanValue => ({
        booleanValue: value,
        _type: \\"booleanValue\\"
    }),

    doubleValue: (value: number): VariableValue.DoubleValue => ({
        doubleValue: value,
        _type: \\"doubleValue\\"
    }),

    stringValue: (value: string): VariableValue.StringValue => ({
        stringValue: value,
        _type: \\"stringValue\\"
    }),

    charValue: (value: string): VariableValue.CharValue => ({
        charValue: value,
        _type: \\"charValue\\"
    }),

    mapValue: (value: commons.MapValue): VariableValue.MapValue => ({
        ...value,
        _type: \\"mapValue\\"
    }),

    listValue: (value: commons.VariableValue[]): VariableValue.ListValue => ({
        listValue: value,
        _type: \\"listValue\\"
    }),

    binaryTreeValue: (value: commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
        ...value,
        _type: \\"binaryTreeValue\\"
    }),

    singlyLinkedListValue: (value: commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
        ...value,
        _type: \\"singlyLinkedListValue\\"
    }),

    doublyLinkedListValue: (value: commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
        ...value,
        _type: \\"doublyLinkedListValue\\"
    }),

    nullValue: (): VariableValue.NullValue => ({
        _type: \\"nullValue\\"
    }),

    _visit: <Result>(value: VariableValue, visitor: VariableValue._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"integerValue\\": return visitor.integerValue(value.integerValue);
            case \\"booleanValue\\": return visitor.booleanValue(value.booleanValue);
            case \\"doubleValue\\": return visitor.doubleValue(value.doubleValue);
            case \\"stringValue\\": return visitor.stringValue(value.stringValue);
            case \\"charValue\\": return visitor.charValue(value.charValue);
            case \\"mapValue\\": return visitor.mapValue(value);
            case \\"listValue\\": return visitor.listValue(value.listValue);
            case \\"binaryTreeValue\\": return visitor.binaryTreeValue(value);
            case \\"singlyLinkedListValue\\": return visitor.singlyLinkedListValue(value);
            case \\"doublyLinkedListValue\\": return visitor.doublyLinkedListValue(value);
            case \\"nullValue\\": return visitor.nullValue();
            default: return visitor._unknown();
        }
    },

    _types: (): VariableValue[\\"_type\\"][] => [\\"integerValue\\", \\"booleanValue\\", \\"doubleValue\\", \\"stringValue\\", \\"charValue\\", \\"mapValue\\", \\"listValue\\", \\"binaryTreeValue\\", \\"singlyLinkedListValue\\", \\"doublyLinkedListValue\\", \\"nullValue\\"],
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetHomepageProblemsErrorBody = never;

export declare namespace GetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: GetHomepageProblemsErrorBody, visitor: GetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetHomepageProblemsResponse = GetHomepageProblemsResponse.SuccessResponse | GetHomepageProblemsResponse.ErrorResponse;

export declare namespace GetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.commons.ProblemId[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.GetHomepageProblemsErrorBody;
    }
}
",
                        "name": "GetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetHomepageProblemsErrorBody = never;

export declare namespace SetHomepageProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetHomepageProblemsErrorBody = {
    _visit: <Result>(_value: SetHomepageProblemsErrorBody, visitor: SetHomepageProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetHomepageProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetHomepageProblemsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetHomepageProblemsResponse = SetHomepageProblemsResponse.SuccessResponse | SetHomepageProblemsResponse.ErrorResponse;

export declare namespace SetHomepageProblemsResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.homepage.SetHomepageProblemsErrorBody;
    }
}
",
                        "name": "SetHomepageProblemsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetHomepageProblemsErrorBody\\";
export * from \\"./GetHomepageProblemsResponse\\";
export * from \\"./SetHomepageProblemsErrorBody\\";
export * from \\"./SetHomepageProblemsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "HomepageProblemService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./HomepageProblemService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export interface LangServerRequest {
    request: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LangServerResponse {
    response: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "lang-server",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetAttemptedMigrationsErrorBody = never;

export declare namespace GetAttemptedMigrationsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetAttemptedMigrationsErrorBody = {
    _visit: <Result>(_value: GetAttemptedMigrationsErrorBody, visitor: GetAttemptedMigrationsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetAttemptedMigrationsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetAttemptedMigrationsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetAttemptedMigrationsResponse = GetAttemptedMigrationsResponse.SuccessResponse | GetAttemptedMigrationsResponse.ErrorResponse;

export declare namespace GetAttemptedMigrationsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.migration.Migration[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.migration.GetAttemptedMigrationsErrorBody;
    }
}
",
                        "name": "GetAttemptedMigrationsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./GetAttemptedMigrationsErrorBody\\";
export * from \\"./GetAttemptedMigrationsResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "MigrationInfoService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationInfoService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Migration {
    name: string;
    status: model.migration.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type MigrationStatus =
    | \\"RUNNING\\"
    | \\"FAILED\\"
    | \\"FINISHED\\";

export const MigrationStatus = {
    Running: \\"RUNNING\\",
    Failed: \\"FAILED\\",
    Finished: \\"FINISHED\\",

    _visit: <Result>(value: MigrationStatus, visitor: MigrationStatus._Visitor<Result>): Result => {
        switch (value) {
            case MigrationStatus.Running: return visitor.running();
            case MigrationStatus.Failed: return visitor.failed();
            case MigrationStatus.Finished: return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _values: (): MigrationStatus[] => [MigrationStatus.Running, MigrationStatus.Failed, MigrationStatus.Finished],
} as const;

export declare namespace MigrationStatus {
    type Running = \\"RUNNING\\";
    type Failed = \\"FAILED\\";
    type Finished = \\"FINISHED\\";

    export interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistIdNotFoundError {
    playlistId: model.playlist.PlaylistId;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type UnauthorizedError = Record<string, never>;
",
                    "name": "UnauthorizedError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_errors",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreatePlaylistErrorBody = never;

export declare namespace CreatePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreatePlaylistErrorBody = {
    _visit: <Result>(_value: CreatePlaylistErrorBody, visitor: CreatePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreatePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreatePlaylistResponse = CreatePlaylistResponse.SuccessResponse | CreatePlaylistResponse.ErrorResponse;

export declare namespace CreatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.CreatePlaylistErrorBody;
    }
}
",
                        "name": "CreatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeletePlaylistErrorBody = never;

export declare namespace DeletePlaylistErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeletePlaylistErrorBody = {
    _visit: <Result>(_value: DeletePlaylistErrorBody, visitor: DeletePlaylistErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeletePlaylistErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeletePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeletePlaylistRequest {
    playlist_id: model.playlist.PlaylistId;
}
",
                        "name": "DeletePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeletePlaylistResponse = DeletePlaylistResponse.SuccessResponse | DeletePlaylistResponse.ErrorResponse;

export declare namespace DeletePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.DeletePlaylistErrorBody;
    }
}
",
                        "name": "DeletePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type GetPlaylistErrorBody =
    | GetPlaylistErrorBody.PlaylistIdNotFoundError
    | GetPlaylistErrorBody.UnauthorizedError;

export declare namespace GetPlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    interface UnauthorizedError {
        _error: \\"UnauthorizedError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        UnauthorizedError: () => Result;
        _unknown: () => Result;
    }
}

export const GetPlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): GetPlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    unauthorizedError: (): GetPlaylistErrorBody.UnauthorizedError => ({
        _error: \\"UnauthorizedError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: GetPlaylistErrorBody, visitor: GetPlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            case \\"UnauthorizedError\\": return visitor.UnauthorizedError();
            default: return visitor._unknown();
        }
    },

    _types: (): GetPlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\", \\"UnauthorizedError\\"],
} as const;
",
                        "name": "GetPlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetPlaylistRequest {
    playlistId: model.playlist.PlaylistId;
}
",
                        "name": "GetPlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistResponse = GetPlaylistResponse.SuccessResponse | GetPlaylistResponse.ErrorResponse;

export declare namespace GetPlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistErrorBody;
    }
}
",
                        "name": "GetPlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetPlaylistsErrorBody = never;

export declare namespace GetPlaylistsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetPlaylistsErrorBody = {
    _visit: <Result>(_value: GetPlaylistsErrorBody, visitor: GetPlaylistsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetPlaylistsErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetPlaylistsErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetPlaylistsRequest {
    limit: number | null | undefined;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetPlaylistsResponse = GetPlaylistsResponse.SuccessResponse | GetPlaylistsResponse.ErrorResponse;

export declare namespace GetPlaylistsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.GetPlaylistsErrorBody;
    }
}
",
                        "name": "GetPlaylistsResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { playlist } from \\"../../..\\";
import * as uuid from \\"uuid\\";

export type UpdatePlaylistErrorBody =
    | UpdatePlaylistErrorBody.PlaylistIdNotFoundError;

export declare namespace UpdatePlaylistErrorBody {
    interface PlaylistIdNotFoundError extends playlist.PlaylistIdNotFoundError {
        _error: \\"PlaylistIdNotFoundError\\";
        _errorInstanceId: string;
    }

    export interface _Visitor<Result> {
        PlaylistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError) => Result;
        _unknown: () => Result;
    }
}

export const UpdatePlaylistErrorBody = {
    playlistIdNotFoundError: (value: playlist.PlaylistIdNotFoundError): UpdatePlaylistErrorBody.PlaylistIdNotFoundError => ({
        ...value,
        _error: \\"PlaylistIdNotFoundError\\",
        _errorInstanceId: uuid.v4()
    }),

    _visit: <Result>(value: UpdatePlaylistErrorBody, visitor: UpdatePlaylistErrorBody._Visitor<Result>): Result => {
        switch (value._error) {
            case \\"PlaylistIdNotFoundError\\": return visitor.PlaylistIdNotFoundError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): UpdatePlaylistErrorBody[\\"_error\\"][] => [\\"PlaylistIdNotFoundError\\"],
} as const;
",
                        "name": "UpdatePlaylistErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type UpdatePlaylistResponse = UpdatePlaylistResponse.SuccessResponse | UpdatePlaylistResponse.ErrorResponse;

export declare namespace UpdatePlaylistResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.playlist.Playlist | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.playlist.UpdatePlaylistErrorBody;
    }
}
",
                        "name": "UpdatePlaylistResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface _UpdatePlaylistRequest {
    playlistId: model.playlist.PlaylistId;
    body: model.playlist.UpdatePlaylistRequest | null | undefined;
}
",
                        "name": "_UpdatePlaylistRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreatePlaylistErrorBody\\";
export * from \\"./CreatePlaylistResponse\\";
export * from \\"./GetPlaylistsRequest\\";
export * from \\"./GetPlaylistsErrorBody\\";
export * from \\"./GetPlaylistsResponse\\";
export * from \\"./GetPlaylistRequest\\";
export * from \\"./GetPlaylistErrorBody\\";
export * from \\"./GetPlaylistResponse\\";
export * from \\"./_UpdatePlaylistRequest\\";
export * from \\"./UpdatePlaylistErrorBody\\";
export * from \\"./UpdatePlaylistResponse\\";
export * from \\"./DeletePlaylistRequest\\";
export * from \\"./DeletePlaylistErrorBody\\";
export * from \\"./DeletePlaylistResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "PlaylistCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Playlist {
    playlist_id: model.playlist.PlaylistId;
    name: string;
    problems: model.commons.ProblemId[];
    \\"owner-id\\": model.commons.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type PlaylistId = string;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: model.commons.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_errors\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateProblemErrorBody = never;

export declare namespace CreateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateProblemErrorBody = {
    _visit: <Result>(_value: CreateProblemErrorBody, visitor: CreateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type DeleteProblemErrorBody = never;

export declare namespace DeleteProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const DeleteProblemErrorBody = {
    _visit: <Result>(_value: DeleteProblemErrorBody, visitor: DeleteProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): DeleteProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "DeleteProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeleteProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                        "name": "DeleteProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type DeleteProblemResponse = DeleteProblemResponse.SuccessResponse | DeleteProblemResponse.ErrorResponse;

export declare namespace DeleteProblemResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.DeleteProblemErrorBody;
    }
}
",
                        "name": "DeleteProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetDefaultStarterFilesErrorBody = never;

export declare namespace GetDefaultStarterFilesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetDefaultStarterFilesErrorBody = {
    _visit: <Result>(_value: GetDefaultStarterFilesErrorBody, visitor: GetDefaultStarterFilesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetDefaultStarterFilesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetDefaultStarterFilesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type UpdateProblemErrorBody = never;

export declare namespace UpdateProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const UpdateProblemErrorBody = {
    _visit: <Result>(_value: UpdateProblemErrorBody, visitor: UpdateProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): UpdateProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "UpdateProblemErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface UpdateProblemRequest {
    problemId: model.commons.ProblemId;
    body: model.problem.CreateProblemRequest;
}
",
                        "name": "UpdateProblemRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _CreateProblemResponse = _CreateProblemResponse.SuccessResponse | _CreateProblemResponse.ErrorResponse;

export declare namespace _CreateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.CreateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.CreateProblemErrorBody;
    }
}
",
                        "name": "_CreateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _GetDefaultStarterFilesResponse = _GetDefaultStarterFilesResponse.SuccessResponse | _GetDefaultStarterFilesResponse.ErrorResponse;

export declare namespace _GetDefaultStarterFilesResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.GetDefaultStarterFilesResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.GetDefaultStarterFilesErrorBody;
    }
}
",
                        "name": "_GetDefaultStarterFilesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type _UpdateProblemResponse = _UpdateProblemResponse.SuccessResponse | _UpdateProblemResponse.ErrorResponse;

export declare namespace _UpdateProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.problem.UpdateProblemResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.problem.UpdateProblemErrorBody;
    }
}
",
                        "name": "_UpdateProblemResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateProblemErrorBody\\";
export * from \\"./_CreateProblemResponse\\";
export * from \\"./UpdateProblemRequest\\";
export * from \\"./UpdateProblemErrorBody\\";
export * from \\"./_UpdateProblemResponse\\";
export * from \\"./DeleteProblemRequest\\";
export * from \\"./DeleteProblemErrorBody\\";
export * from \\"./DeleteProblemResponse\\";
export * from \\"./GetDefaultStarterFilesErrorBody\\";
export * from \\"./_GetDefaultStarterFilesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ProblemCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { problem } from \\"../..\\";

export type CreateProblemError =
    | CreateProblemError.Generic;

export declare namespace CreateProblemError {
    interface Generic extends problem.GenericCreateProblemError {
        _type: \\"generic\\";
    }

    export interface _Visitor<Result> {
        generic: (value: problem.GenericCreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemError = {
    generic: (value: problem.GenericCreateProblemError): CreateProblemError.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    _visit: <Result>(value: CreateProblemError, visitor: CreateProblemError._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemError[\\"_type\\"][] => [\\"generic\\"],
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { problem, commons } from \\"../..\\";

export type CreateProblemResponse =
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error;

export declare namespace CreateProblemResponse {
    interface Success {
        _type: \\"success\\";
        success: commons.ProblemId;
    }

    interface Error {
        _type: \\"error\\";
        error: problem.CreateProblemError;
    }

    export interface _Visitor<Result> {
        success: (value: commons.ProblemId) => Result;
        error: (value: problem.CreateProblemError) => Result;
        _unknown: () => Result;
    }
}

export const CreateProblemResponse = {
    success: (value: commons.ProblemId): CreateProblemResponse.Success => ({
        success: value,
        _type: \\"success\\"
    }),

    error: (value: problem.CreateProblemError): CreateProblemResponse.Error => ({
        error: value,
        _type: \\"error\\"
    }),

    _visit: <Result>(value: CreateProblemResponse, visitor: CreateProblemResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"success\\": return visitor.success(value.success);
            case \\"error\\": return visitor.error(value.error);
            default: return visitor._unknown();
        }
    },

    _types: (): CreateProblemResponse[\\"_type\\"][] => [\\"success\\", \\"error\\"],
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemDescription {
    boards: model.problem.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { commons } from \\"../..\\";

export type ProblemDescriptionBoard =
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

export declare namespace ProblemDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface Variable {
        _type: \\"variable\\";
        variable: commons.VariableValue;
    }

    interface TestCaseId {
        _type: \\"testCaseId\\";
        testCaseId: string;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: () => Result;
    }
}

export const ProblemDescriptionBoard = {
    html: (value: string): ProblemDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    variable: (value: commons.VariableValue): ProblemDescriptionBoard.Variable => ({
        variable: value,
        _type: \\"variable\\"
    }),

    testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
        testCaseId: value,
        _type: \\"testCaseId\\"
    }),

    _visit: <Result>(value: ProblemDescriptionBoard, visitor: ProblemDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"variable\\": return visitor.variable(value.variable);
            case \\"testCaseId\\": return visitor.testCaseId(value.testCaseId);
            default: return visitor._unknown();
        }
    },

    _types: (): ProblemDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"variable\\", \\"testCaseId\\"],
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemFiles {
    solutionFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ProblemInfo {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<model.commons.Language, model.problem.ProblemFiles>;
    inputParams: model.problem.VariableTypeAndName[];
    outputType: model.commons.VariableType;
    testcases: model.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface VariableTypeAndName {
    variableType: model.commons.VariableType;
    name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type CreateExecutionSessionErrorBody = never;

export declare namespace CreateExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const CreateExecutionSessionErrorBody = {
    _visit: <Result>(_value: CreateExecutionSessionErrorBody, visitor: CreateExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): CreateExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "CreateExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateExecutionSessionRequest {
    language: model.commons.Language;
}
",
                        "name": "CreateExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type CreateExecutionSessionResponse = CreateExecutionSessionResponse.SuccessResponse | CreateExecutionSessionResponse.ErrorResponse;

export declare namespace CreateExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.CreateExecutionSessionErrorBody;
    }
}
",
                        "name": "CreateExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionErrorBody = never;

export declare namespace GetExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionErrorBody, visitor: GetExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface GetExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "GetExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionResponse = GetExecutionSessionResponse.SuccessResponse | GetExecutionSessionResponse.ErrorResponse;

export declare namespace GetExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.ExecutionSessionResponse | null | undefined;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionErrorBody;
    }
}
",
                        "name": "GetExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type GetExecutionSessionsStateErrorBody = never;

export declare namespace GetExecutionSessionsStateErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetExecutionSessionsStateErrorBody = {
    _visit: <Result>(_value: GetExecutionSessionsStateErrorBody, visitor: GetExecutionSessionsStateErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetExecutionSessionsStateErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetExecutionSessionsStateErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetExecutionSessionsStateResponse = GetExecutionSessionsStateResponse.SuccessResponse | GetExecutionSessionsStateResponse.ErrorResponse;

export declare namespace GetExecutionSessionsStateResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.submission.GetExecutionSessionStateResponse;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.GetExecutionSessionsStateErrorBody;
    }
}
",
                        "name": "GetExecutionSessionsStateResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type StopExecutionSessionErrorBody = never;

export declare namespace StopExecutionSessionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const StopExecutionSessionErrorBody = {
    _visit: <Result>(_value: StopExecutionSessionErrorBody, visitor: StopExecutionSessionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): StopExecutionSessionErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "StopExecutionSessionErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface StopExecutionSessionRequest {
    sessionId: string;
}
",
                        "name": "StopExecutionSessionRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type StopExecutionSessionResponse = StopExecutionSessionResponse.SuccessResponse | StopExecutionSessionResponse.ErrorResponse;

export declare namespace StopExecutionSessionResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.submission.StopExecutionSessionErrorBody;
    }
}
",
                        "name": "StopExecutionSessionResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./CreateExecutionSessionRequest\\";
export * from \\"./CreateExecutionSessionErrorBody\\";
export * from \\"./CreateExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionRequest\\";
export * from \\"./GetExecutionSessionErrorBody\\";
export * from \\"./GetExecutionSessionResponse\\";
export * from \\"./StopExecutionSessionRequest\\";
export * from \\"./StopExecutionSessionErrorBody\\";
export * from \\"./StopExecutionSessionResponse\\";
export * from \\"./GetExecutionSessionsStateErrorBody\\";
export * from \\"./GetExecutionSessionsStateResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "ExecutionSesssionManagementService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type ActualResult =
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

export declare namespace ActualResult {
    interface Value {
        _type: \\"value\\";
        value: commons.VariableValue;
    }

    interface Exception extends submission.ExceptionInfo {
        _type: \\"exception\\";
    }

    interface ExceptionV2 {
        _type: \\"exceptionV2\\";
        exceptionV2: submission.ExceptionV2;
    }

    export interface _Visitor<Result> {
        value: (value: commons.VariableValue) => Result;
        exception: (value: submission.ExceptionInfo) => Result;
        exceptionV2: (value: submission.ExceptionV2) => Result;
        _unknown: () => Result;
    }
}

export const ActualResult = {
    value: (value: commons.VariableValue): ActualResult.Value => ({
        value: value,
        _type: \\"value\\"
    }),

    exception: (value: submission.ExceptionInfo): ActualResult.Exception => ({
        ...value,
        _type: \\"exception\\"
    }),

    exceptionV2: (value: submission.ExceptionV2): ActualResult.ExceptionV2 => ({
        exceptionV2: value,
        _type: \\"exceptionV2\\"
    }),

    _visit: <Result>(value: ActualResult, visitor: ActualResult._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"value\\": return visitor.value(value.value);
            case \\"exception\\": return visitor.exception(value);
            case \\"exceptionV2\\": return visitor.exceptionV2(value.exceptionV2);
            default: return visitor._unknown();
        }
    },

    _types: (): ActualResult[\\"_type\\"][] => [\\"value\\", \\"exception\\", \\"exceptionV2\\"],
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface BuildingExecutorResponse {
    submissionId: model.submission.SubmissionId;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type CodeExecutionUpdate =
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends submission.BuildingExecutorResponse {
        _type: \\"buildingExecutor\\";
    }

    interface Running extends submission.RunningResponse {
        _type: \\"running\\";
    }

    interface Errored extends submission.ErroredResponse {
        _type: \\"errored\\";
    }

    interface Stopped extends submission.StoppedResponse {
        _type: \\"stopped\\";
    }

    interface Graded extends submission.GradedResponse {
        _type: \\"graded\\";
    }

    interface GradedV2 extends submission.GradedResponseV2 {
        _type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends submission.WorkspaceRanResponse {
        _type: \\"workspaceRan\\";
    }

    interface Recording extends submission.RecordingResponseNotification {
        _type: \\"recording\\";
    }

    interface Recorded extends submission.RecordedResponseNotification {
        _type: \\"recorded\\";
    }

    interface InvalidRequest extends submission.InvalidRequestResponse {
        _type: \\"invalidRequest\\";
    }

    interface Finished extends submission.FinishedResponse {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        buildingExecutor: (value: submission.BuildingExecutorResponse) => Result;
        running: (value: submission.RunningResponse) => Result;
        errored: (value: submission.ErroredResponse) => Result;
        stopped: (value: submission.StoppedResponse) => Result;
        graded: (value: submission.GradedResponse) => Result;
        gradedV2: (value: submission.GradedResponseV2) => Result;
        workspaceRan: (value: submission.WorkspaceRanResponse) => Result;
        recording: (value: submission.RecordingResponseNotification) => Result;
        recorded: (value: submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: submission.InvalidRequestResponse) => Result;
        finished: (value: submission.FinishedResponse) => Result;
        _unknown: () => Result;
    }
}

export const CodeExecutionUpdate = {
    buildingExecutor: (value: submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
        ...value,
        _type: \\"buildingExecutor\\"
    }),

    running: (value: submission.RunningResponse): CodeExecutionUpdate.Running => ({
        ...value,
        _type: \\"running\\"
    }),

    errored: (value: submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
        ...value,
        _type: \\"errored\\"
    }),

    stopped: (value: submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
        ...value,
        _type: \\"stopped\\"
    }),

    graded: (value: submission.GradedResponse): CodeExecutionUpdate.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
        ...value,
        _type: \\"gradedV2\\"
    }),

    workspaceRan: (value: submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
        ...value,
        _type: \\"workspaceRan\\"
    }),

    recording: (value: submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
        ...value,
        _type: \\"recording\\"
    }),

    recorded: (value: submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
        ...value,
        _type: \\"recorded\\"
    }),

    invalidRequest: (value: submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
        ...value,
        _type: \\"invalidRequest\\"
    }),

    finished: (value: submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
        ...value,
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: CodeExecutionUpdate, visitor: CodeExecutionUpdate._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"buildingExecutor\\": return visitor.buildingExecutor(value);
            case \\"running\\": return visitor.running(value);
            case \\"errored\\": return visitor.errored(value);
            case \\"stopped\\": return visitor.stopped(value);
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value);
            case \\"workspaceRan\\": return visitor.workspaceRan(value);
            case \\"recording\\": return visitor.recording(value);
            case \\"recorded\\": return visitor.recorded(value);
            case \\"invalidRequest\\": return visitor.invalidRequest(value);
            case \\"finished\\": return visitor.finished(value);
            default: return visitor._unknown();
        }
    },

    _types: (): CodeExecutionUpdate[\\"_type\\"][] => [\\"buildingExecutor\\", \\"running\\", \\"errored\\", \\"stopped\\", \\"graded\\", \\"gradedV2\\", \\"workspaceRan\\", \\"recording\\", \\"recorded\\", \\"invalidRequest\\", \\"finished\\"],
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface CompileError {
    message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface CustomTestCasesUnsupported {
    problemId: model.commons.ProblemId;
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ErrorInfo =
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError;

export declare namespace ErrorInfo {
    interface CompileError extends submission.CompileError {
        _type: \\"compileError\\";
    }

    interface RuntimeError extends submission.RuntimeError {
        _type: \\"runtimeError\\";
    }

    interface InternalError extends submission.InternalError {
        _type: \\"internalError\\";
    }

    export interface _Visitor<Result> {
        compileError: (value: submission.CompileError) => Result;
        runtimeError: (value: submission.RuntimeError) => Result;
        internalError: (value: submission.InternalError) => Result;
        _unknown: () => Result;
    }
}

export const ErrorInfo = {
    compileError: (value: submission.CompileError): ErrorInfo.CompileError => ({
        ...value,
        _type: \\"compileError\\"
    }),

    runtimeError: (value: submission.RuntimeError): ErrorInfo.RuntimeError => ({
        ...value,
        _type: \\"runtimeError\\"
    }),

    internalError: (value: submission.InternalError): ErrorInfo.InternalError => ({
        ...value,
        _type: \\"internalError\\"
    }),

    _visit: <Result>(value: ErrorInfo, visitor: ErrorInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"compileError\\": return visitor.compileError(value);
            case \\"runtimeError\\": return visitor.runtimeError(value);
            case \\"internalError\\": return visitor.internalError(value);
            default: return visitor._unknown();
        }
    },

    _types: (): ErrorInfo[\\"_type\\"][] => [\\"compileError\\", \\"runtimeError\\", \\"internalError\\"],
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ErroredResponse {
    submissionId: model.submission.SubmissionId;
    errorInfo: model.submission.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type ExceptionV2 =
    | ExceptionV2.Generic
    | ExceptionV2.Timeout;

export declare namespace ExceptionV2 {
    interface Generic extends submission.ExceptionInfo {
        _type: \\"generic\\";
    }

    interface Timeout {
        _type: \\"timeout\\";
    }

    export interface _Visitor<Result> {
        generic: (value: submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: () => Result;
    }
}

export const ExceptionV2 = {
    generic: (value: submission.ExceptionInfo): ExceptionV2.Generic => ({
        ...value,
        _type: \\"generic\\"
    }),

    timeout: (): ExceptionV2.Timeout => ({
        _type: \\"timeout\\"
    }),

    _visit: <Result>(value: ExceptionV2, visitor: ExceptionV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"generic\\": return visitor.generic(value);
            case \\"timeout\\": return visitor.timeout();
            default: return visitor._unknown();
        }
    },

    _types: (): ExceptionV2[\\"_type\\"][] => [\\"generic\\", \\"timeout\\"],
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExecutionSessionState {
    lastTimeContacted: string | null | undefined;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId: string | null | undefined;
    language: model.commons.Language;
    status: model.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ExecutionSessionStatus =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
    CreatingContainer: \\"CREATING_CONTAINER\\",
    ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
    PendingContainer: \\"PENDING_CONTAINER\\",
    RunningContainer: \\"RUNNING_CONTAINER\\",
    LiveContainer: \\"LIVE_CONTAINER\\",
    FailedToLaunch: \\"FAILED_TO_LAUNCH\\",

    _visit: <Result>(value: ExecutionSessionStatus, visitor: ExecutionSessionStatus._Visitor<Result>): Result => {
        switch (value) {
            case ExecutionSessionStatus.CreatingContainer: return visitor.creatingContainer();
            case ExecutionSessionStatus.ProvisioningContainer: return visitor.provisioningContainer();
            case ExecutionSessionStatus.PendingContainer: return visitor.pendingContainer();
            case ExecutionSessionStatus.RunningContainer: return visitor.runningContainer();
            case ExecutionSessionStatus.LiveContainer: return visitor.liveContainer();
            case ExecutionSessionStatus.FailedToLaunch: return visitor.failedToLaunch();
            default: return visitor._unknown();
        }
    },

    _values: (): ExecutionSessionStatus[] => [ExecutionSessionStatus.CreatingContainer, ExecutionSessionStatus.ProvisioningContainer, ExecutionSessionStatus.PendingContainer, ExecutionSessionStatus.RunningContainer, ExecutionSessionStatus.LiveContainer, ExecutionSessionStatus.FailedToLaunch],
} as const;

export declare namespace ExecutionSessionStatus {
    type CreatingContainer = \\"CREATING_CONTAINER\\";
    type ProvisioningContainer = \\"PROVISIONING_CONTAINER\\";
    type PendingContainer = \\"PENDING_CONTAINER\\";
    type RunningContainer = \\"RUNNING_CONTAINER\\";
    type LiveContainer = \\"LIVE_CONTAINER\\";
    type FailedToLaunch = \\"FAILED_TO_LAUNCH\\";

    export interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface FinishedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, model.submission.ExecutionSessionState>;
    numWarmingInstances: number | null | undefined;
    warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted: string | null | undefined;
    submission: string;
    language: model.commons.Language;
    submissionTypeState: model.submission.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface GetTraceResponsesPageRequest {
    offset: number | null | undefined;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponse {
    submissionId: model.submission.SubmissionId;
    testCases: Record<string, model.submission.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedResponseV2 {
    submissionId: model.submission.SubmissionId;
    testCases: Record<model.v2.problem.TestCaseId, model.submission.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    grade: model.submission.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InitializeProblemRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InternalError {
    exceptionInfo: model.submission.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type InvalidRequestCause =
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends submission.SubmissionIdNotFound {
        _type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends submission.CustomTestCasesUnsupported {
        _type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends submission.UnexpectedLanguageError {
        _type: \\"unexpectedLanguage\\";
    }

    export interface _Visitor<Result> {
        submissionIdNotFound: (value: submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: submission.UnexpectedLanguageError) => Result;
        _unknown: () => Result;
    }
}

export const InvalidRequestCause = {
    submissionIdNotFound: (value: submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
        ...value,
        _type: \\"submissionIdNotFound\\"
    }),

    customTestCasesUnsupported: (value: submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
        ...value,
        _type: \\"customTestCasesUnsupported\\"
    }),

    unexpectedLanguage: (value: submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
        ...value,
        _type: \\"unexpectedLanguage\\"
    }),

    _visit: <Result>(value: InvalidRequestCause, visitor: InvalidRequestCause._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"submissionIdNotFound\\": return visitor.submissionIdNotFound(value);
            case \\"customTestCasesUnsupported\\": return visitor.customTestCasesUnsupported(value);
            case \\"unexpectedLanguage\\": return visitor.unexpectedLanguage(value);
            default: return visitor._unknown();
        }
    },

    _types: (): InvalidRequestCause[\\"_type\\"][] => [\\"submissionIdNotFound\\", \\"customTestCasesUnsupported\\", \\"unexpectedLanguage\\"],
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface InvalidRequestResponse {
    request: model.submission.SubmissionRequest;
    cause: model.submission.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedResponseNotification {
    submissionId: model.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId: string | null | undefined;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: model.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RecordingResponseNotification {
    submissionId: model.submission.SubmissionId;
    testCaseId: string | null | undefined;
    lineNumber: number;
    lightweightStackInfo: model.submission.LightweightStackframeInformation;
    tracedFile: model.submission.TracedFile | null | undefined;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface RunningResponse {
    submissionId: model.submission.SubmissionId;
    state: model.submission.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type RunningSubmissionState =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
    QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
    KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
    WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
    CompilingSubmission: \\"COMPILING_SUBMISSION\\",
    RunningSubmission: \\"RUNNING_SUBMISSION\\",

    _visit: <Result>(value: RunningSubmissionState, visitor: RunningSubmissionState._Visitor<Result>): Result => {
        switch (value) {
            case RunningSubmissionState.QueueingSubmission: return visitor.queueingSubmission();
            case RunningSubmissionState.KillingHistoricalSubmissions: return visitor.killingHistoricalSubmissions();
            case RunningSubmissionState.WritingSubmissionToFile: return visitor.writingSubmissionToFile();
            case RunningSubmissionState.CompilingSubmission: return visitor.compilingSubmission();
            case RunningSubmissionState.RunningSubmission: return visitor.runningSubmission();
            default: return visitor._unknown();
        }
    },

    _values: (): RunningSubmissionState[] => [RunningSubmissionState.QueueingSubmission, RunningSubmissionState.KillingHistoricalSubmissions, RunningSubmissionState.WritingSubmissionToFile, RunningSubmissionState.CompilingSubmission, RunningSubmissionState.RunningSubmission],
} as const;

export declare namespace RunningSubmissionState {
    type QueueingSubmission = \\"QUEUEING_SUBMISSION\\";
    type KillingHistoricalSubmissions = \\"KILLING_HISTORICAL_SUBMISSIONS\\";
    type WritingSubmissionToFile = \\"WRITING_SUBMISSION_TO_FILE\\";
    type CompilingSubmission = \\"COMPILING_SUBMISSION\\";
    type RunningSubmission = \\"RUNNING_SUBMISSION\\";

    export interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface RuntimeError {
    message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface Scope {
    variables: Record<string, model.commons.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ShareId = string;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: model.submission.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame: model.submission.StackFrame | null | undefined;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StderrResponse {
    submissionId: model.submission.SubmissionId;
    stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StdoutResponse {
    submissionId: model.submission.SubmissionId;
    stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StopRequest {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface StoppedResponse {
    submissionId: model.submission.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type SubmissionId = string;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: model.submission.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionRequest =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends submission.InitializeProblemRequest {
        _type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        _type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends submission.SubmitRequestV2 {
        _type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends submission.WorkspaceSubmitRequest {
        _type: \\"workspaceSubmit\\";
    }

    interface Stop extends submission.StopRequest {
        _type: \\"stop\\";
    }

    export interface _Visitor<Result> {
        initializeProblemRequest: (value: submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: submission.WorkspaceSubmitRequest) => Result;
        stop: (value: submission.StopRequest) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionRequest = {
    initializeProblemRequest: (value: submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
        ...value,
        _type: \\"initializeProblemRequest\\"
    }),

    initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
        _type: \\"initializeWorkspaceRequest\\"
    }),

    submitV2: (value: submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
        ...value,
        _type: \\"submitV2\\"
    }),

    workspaceSubmit: (value: submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
        ...value,
        _type: \\"workspaceSubmit\\"
    }),

    stop: (value: submission.StopRequest): SubmissionRequest.Stop => ({
        ...value,
        _type: \\"stop\\"
    }),

    _visit: <Result>(value: SubmissionRequest, visitor: SubmissionRequest._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"initializeProblemRequest\\": return visitor.initializeProblemRequest(value);
            case \\"initializeWorkspaceRequest\\": return visitor.initializeWorkspaceRequest();
            case \\"submitV2\\": return visitor.submitV2(value);
            case \\"workspaceSubmit\\": return visitor.workspaceSubmit(value);
            case \\"stop\\": return visitor.stop(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionRequest[\\"_type\\"][] => [\\"initializeProblemRequest\\", \\"initializeWorkspaceRequest\\", \\"submitV2\\", \\"workspaceSubmit\\", \\"stop\\"],
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission, commons } from \\"../..\\";

export type SubmissionResponse =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

export declare namespace SubmissionResponse {
    interface ServerInitialized {
        _type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        _type: \\"problemInitialized\\";
        problemInitialized: commons.ProblemId;
    }

    interface WorkspaceInitialized {
        _type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends submission.ExceptionInfo {
        _type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        _type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: submission.CodeExecutionUpdate;
    }

    interface Terminated extends submission.TerminatedResponse {
        _type: \\"terminated\\";
    }

    export interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: submission.CodeExecutionUpdate) => Result;
        terminated: (value: submission.TerminatedResponse) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionResponse = {
    serverInitialized: (): SubmissionResponse.ServerInitialized => ({
        _type: \\"serverInitialized\\"
    }),

    problemInitialized: (value: commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
        problemInitialized: value,
        _type: \\"problemInitialized\\"
    }),

    workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
        _type: \\"workspaceInitialized\\"
    }),

    serverErrored: (value: submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
        ...value,
        _type: \\"serverErrored\\"
    }),

    codeExecutionUpdate: (value: submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
        codeExecutionUpdate: value,
        _type: \\"codeExecutionUpdate\\"
    }),

    terminated: (value: submission.TerminatedResponse): SubmissionResponse.Terminated => ({
        ...value,
        _type: \\"terminated\\"
    }),

    _visit: <Result>(value: SubmissionResponse, visitor: SubmissionResponse._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"serverInitialized\\": return visitor.serverInitialized();
            case \\"problemInitialized\\": return visitor.problemInitialized(value.problemInitialized);
            case \\"workspaceInitialized\\": return visitor.workspaceInitialized();
            case \\"serverErrored\\": return visitor.serverErrored(value);
            case \\"codeExecutionUpdate\\": return visitor.codeExecutionUpdate(value.codeExecutionUpdate);
            case \\"terminated\\": return visitor.terminated(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionResponse[\\"_type\\"][] => [\\"serverInitialized\\", \\"problemInitialized\\", \\"workspaceInitialized\\", \\"serverErrored\\", \\"codeExecutionUpdate\\", \\"terminated\\"],
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusForTestCase =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends submission.TestCaseResultWithStdout {
        _type: \\"graded\\";
    }

    interface GradedV2 {
        _type: \\"gradedV2\\";
        gradedV2: submission.TestCaseGrade;
    }

    interface Traced extends submission.TracedTestCase {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        graded: (value: submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: submission.TestCaseGrade) => Result;
        traced: (value: submission.TracedTestCase) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusForTestCase = {
    graded: (value: submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
        ...value,
        _type: \\"graded\\"
    }),

    gradedV2: (value: submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
        gradedV2: value,
        _type: \\"gradedV2\\"
    }),

    traced: (value: submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: SubmissionStatusForTestCase, visitor: SubmissionStatusForTestCase._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"graded\\": return visitor.graded(value);
            case \\"gradedV2\\": return visitor.gradedV2(value.gradedV2);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusForTestCase[\\"_type\\"][] => [\\"graded\\", \\"gradedV2\\", \\"traced\\"],
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionStatusV2 =
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace;

export declare namespace SubmissionStatusV2 {
    interface Test extends submission.TestSubmissionStatusV2 {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionStatusV2 {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionStatusV2) => Result;
        workspace: (value: submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionStatusV2 = {
    test: (value: submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionStatusV2, visitor: SubmissionStatusV2._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionStatusV2[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum =
    | \\"TEST\\";

export const SubmissionTypeEnum = {
    Test: \\"TEST\\",

    _visit: <Result>(value: SubmissionTypeEnum, visitor: SubmissionTypeEnum._Visitor<Result>): Result => {
        switch (value) {
            case SubmissionTypeEnum.Test: return visitor.test();
            default: return visitor._unknown();
        }
    },

    _values: (): SubmissionTypeEnum[] => [SubmissionTypeEnum.Test],
} as const;

export declare namespace SubmissionTypeEnum {
    type Test = \\"TEST\\";

    export interface _Visitor<Result> {
        test: () => Result;
        _unknown: () => Result;
    }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type SubmissionTypeState =
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace;

export declare namespace SubmissionTypeState {
    interface Test extends submission.TestSubmissionState {
        _type: \\"test\\";
    }

    interface Workspace extends submission.WorkspaceSubmissionState {
        _type: \\"workspace\\";
    }

    export interface _Visitor<Result> {
        test: (value: submission.TestSubmissionState) => Result;
        workspace: (value: submission.WorkspaceSubmissionState) => Result;
        _unknown: () => Result;
    }
}

export const SubmissionTypeState = {
    test: (value: submission.TestSubmissionState): SubmissionTypeState.Test => ({
        ...value,
        _type: \\"test\\"
    }),

    workspace: (value: submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
        ...value,
        _type: \\"workspace\\"
    }),

    _visit: <Result>(value: SubmissionTypeState, visitor: SubmissionTypeState._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"test\\": return visitor.test(value);
            case \\"workspace\\": return visitor.workspace(value);
            default: return visitor._unknown();
        }
    },

    _types: (): SubmissionTypeState[\\"_type\\"][] => [\\"test\\", \\"workspace\\"],
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface SubmitRequestV2 {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    problemId: model.commons.ProblemId;
    problemVersion: number | null | undefined;
    userId: string | null | undefined;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TerminatedResponse {
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestCaseGrade =
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden;

export declare namespace TestCaseGrade {
    interface Hidden extends submission.TestCaseHiddenGrade {
        _type: \\"hidden\\";
    }

    interface NonHidden extends submission.TestCaseNonHiddenGrade {
        _type: \\"nonHidden\\";
    }

    export interface _Visitor<Result> {
        hidden: (value: submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: submission.TestCaseNonHiddenGrade) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseGrade = {
    hidden: (value: submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
        ...value,
        _type: \\"hidden\\"
    }),

    nonHidden: (value: submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
        ...value,
        _type: \\"nonHidden\\"
    }),

    _visit: <Result>(value: TestCaseGrade, visitor: TestCaseGrade._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"hidden\\": return visitor.hidden(value);
            case \\"nonHidden\\": return visitor.nonHidden(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseGrade[\\"_type\\"][] => [\\"hidden\\", \\"nonHidden\\"],
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult: model.commons.VariableValue | null | undefined;
    exception: model.submission.ExceptionV2 | null | undefined;
    stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResult {
    expectedResult: model.commons.VariableValue;
    actualResult: model.submission.ActualResult;
    passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestCaseResultWithStdout {
    result: model.submission.TestCaseResult;
    stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionState {
    problemId: model.commons.ProblemId;
    defaultTestCases: model.commons.TestCase[];
    customTestCases: model.commons.TestCase[];
    status: model.submission.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionStatus =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

export declare namespace TestSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface TestCaseIdToState {
        _type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, submission.SubmissionStatusForTestCase>;
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>) => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionStatus = {
    stopped: (): TestSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    testCaseIdToState: (value: Record<string, submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
        testCaseIdToState: value,
        _type: \\"testCaseIdToState\\"
    }),

    _visit: <Result>(value: TestSubmissionStatus, visitor: TestSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"testCaseIdToState\\": return visitor.testCaseIdToState(value.testCaseIdToState);
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"testCaseIdToState\\"],
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionStatusV2 {
    updates: model.submission.TestSubmissionUpdate[];
    problemId: model.commons.ProblemId;
    problemVersion: number;
    problemInfo: model.v2.problem.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type TestSubmissionUpdateInfo =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

export declare namespace TestSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface GradedTestCase extends submission.GradedTestCaseUpdate {
        _type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends submission.RecordedTestCaseUpdate {
        _type: \\"recordedTestCase\\";
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        gradedTestCase: (value: submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const TestSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    stopped: (): TestSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    gradedTestCase: (value: submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
        ...value,
        _type: \\"gradedTestCase\\"
    }),

    recordedTestCase: (value: submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
        ...value,
        _type: \\"recordedTestCase\\"
    }),

    finished: (): TestSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: TestSubmissionUpdateInfo, visitor: TestSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"gradedTestCase\\": return visitor.gradedTestCase(value);
            case \\"recordedTestCase\\": return visitor.recordedTestCase(value);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): TestSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"stopped\\", \\"errored\\", \\"gradedTestCase\\", \\"recordedTestCase\\", \\"finished\\"],
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponse {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponseV2 {
    submissionId: model.submission.SubmissionId;
    lineNumber: number;
    file: model.submission.TracedFile;
    returnValue: model.commons.DebugVariableValue | null | undefined;
    expressionLocation: model.submission.ExpressionLocation | null | undefined;
    stack: model.submission.StackInformation;
    stdout: string | null | undefined;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset: number | null | undefined;
    traceResponses: model.submission.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface TracedTestCase {
    result: model.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: model.commons.Language;
    actualLanguage: model.commons.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceFiles {
    mainFile: model.commons.FileInfo;
    readOnlyFiles: model.commons.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRanResponse {
    submissionId: model.submission.SubmissionId;
    runDetails: model.submission.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceRunDetails {
    exceptionV2: model.submission.ExceptionV2 | null | undefined;
    exception: model.submission.ExceptionInfo | null | undefined;
    stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<model.commons.Language, model.submission.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionState {
    status: model.submission.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionStatus =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Traced extends submission.WorkspaceRunDetails {
        _type: \\"traced\\";
    }

    export interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: submission.ErrorInfo) => Result;
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        traced: (value: submission.WorkspaceRunDetails) => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionStatus = {
    stopped: (): WorkspaceSubmissionStatus.Stopped => ({
        _type: \\"stopped\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    traced: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
        ...value,
        _type: \\"traced\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionStatus, visitor: WorkspaceSubmissionStatus._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"stopped\\": return visitor.stopped();
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"traced\\": return visitor.traced(value);
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionStatus[\\"_type\\"][] => [\\"stopped\\", \\"errored\\", \\"running\\", \\"ran\\", \\"traced\\"],
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: model.submission.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: model.submission.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { submission } from \\"../..\\";

export type WorkspaceSubmissionUpdateInfo =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running {
        _type: \\"running\\";
        running: submission.RunningSubmissionState;
    }

    interface Ran extends submission.WorkspaceRunDetails {
        _type: \\"ran\\";
    }

    interface Stopped {
        _type: \\"stopped\\";
    }

    interface Traced {
        _type: \\"traced\\";
    }

    interface TracedV2 extends submission.WorkspaceTracedUpdate {
        _type: \\"tracedV2\\";
    }

    interface Errored {
        _type: \\"errored\\";
        errored: submission.ErrorInfo;
    }

    interface Finished {
        _type: \\"finished\\";
    }

    export interface _Visitor<Result> {
        running: (value: submission.RunningSubmissionState) => Result;
        ran: (value: submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: submission.WorkspaceTracedUpdate) => Result;
        errored: (value: submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: () => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
    running: (value: submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
        running: value,
        _type: \\"running\\"
    }),

    ran: (value: submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
        ...value,
        _type: \\"ran\\"
    }),

    stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
        _type: \\"stopped\\"
    }),

    traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
        _type: \\"traced\\"
    }),

    tracedV2: (value: submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
        ...value,
        _type: \\"tracedV2\\"
    }),

    errored: (value: submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
        errored: value,
        _type: \\"errored\\"
    }),

    finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
        _type: \\"finished\\"
    }),

    _visit: <Result>(value: WorkspaceSubmissionUpdateInfo, visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"running\\": return visitor.running(value.running);
            case \\"ran\\": return visitor.ran(value);
            case \\"stopped\\": return visitor.stopped();
            case \\"traced\\": return visitor.traced();
            case \\"tracedV2\\": return visitor.tracedV2(value);
            case \\"errored\\": return visitor.errored(value.errored);
            case \\"finished\\": return visitor.finished();
            default: return visitor._unknown();
        }
    },

    _types: (): WorkspaceSubmissionUpdateInfo[\\"_type\\"][] => [\\"running\\", \\"ran\\", \\"stopped\\", \\"traced\\", \\"tracedV2\\", \\"errored\\", \\"finished\\"],
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as model from \\"../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: model.submission.SubmissionId;
    language: model.commons.Language;
    submissionFiles: model.submission.SubmissionFileInfo[];
    userId: string | null | undefined;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export type GetNumWarmInstancesErrorBody = never;

export declare namespace GetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: GetNumWarmInstancesErrorBody, visitor: GetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "GetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type GetNumWarmInstancesResponse = GetNumWarmInstancesResponse.SuccessResponse | GetNumWarmInstancesResponse.ErrorResponse;

export declare namespace GetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
        body: Record<model.commons.Language, number>;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.GetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "GetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type SetNumWarmInstancesErrorBody = never;

export declare namespace SetNumWarmInstancesErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const SetNumWarmInstancesErrorBody = {
    _visit: <Result>(_value: SetNumWarmInstancesErrorBody, visitor: SetNumWarmInstancesErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): SetNumWarmInstancesErrorBody[\\"_error\\"][] => [],
} as const;
",
                        "name": "SetNumWarmInstancesErrorBody.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface SetNumWarmInstancesRequest {
    language: model.commons.Language;
    numWarmInstances: number;
}
",
                        "name": "SetNumWarmInstancesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export type SetNumWarmInstancesResponse = SetNumWarmInstancesResponse.SuccessResponse | SetNumWarmInstancesResponse.ErrorResponse;

export declare namespace SetNumWarmInstancesResponse {
    export interface SuccessResponse {
        ok: true;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.sysprop.SetNumWarmInstancesErrorBody;
    }
}
",
                        "name": "SetNumWarmInstancesResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./SetNumWarmInstancesRequest\\";
export * from \\"./SetNumWarmInstancesErrorBody\\";
export * from \\"./SetNumWarmInstancesResponse\\";
export * from \\"./GetNumWarmInstancesErrorBody\\";
export * from \\"./GetNumWarmInstancesResponse\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "SysPropCrudService",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./SysPropCrudService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "_service-types",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./_service-types\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLatestProblemErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                            "name": "GetLatestProblemRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLatestProblemErrorBody;
    }
}
",
                            "name": "GetLatestProblemResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetLightweightProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetLightweightProblemsErrorBody;
    }
}
",
                            "name": "GetLightweightProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemVersionErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                            "name": "GetProblemVersionRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemVersionErrorBody;
    }
}
",
                            "name": "GetProblemVersionResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                            "name": "GetProblemsErrorBody.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.problem.GetProblemsErrorBody;
    }
}
",
                            "name": "GetProblemsResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "ProblemInfoServicV2",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_service-types",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.problem.Files>;
    basicTestCaseTemplate: model.v2.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.problem.CustomFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2, commons } from \\"../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Files {
    files: model.v2.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.problem.Files>;
    other: Record<model.commons.Language, model.v2.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.problem.NonVoidFunctionSignature;
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface Parameter {
    parameterId: model.v2.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.problem.CustomFiles;
    generatedFiles: model.v2.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.problem.TestCaseTemplate[];
    testcases: model.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementation {
    description: model.v2.problem.TestCaseImplementationDescription;
    function: model.v2.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { v2 } from \\"../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseMetadata {
    id: model.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.problem.TestCaseMetadata;
    implementation: model.v2.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.problem.TestCaseExpects | null | undefined;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.problem.Parameter[];
    code: model.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as model from \\"../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "_types",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": Array [
                              Object {
                                "contents": "export type GetLatestProblemErrorBody = never;

export declare namespace GetLatestProblemErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLatestProblemErrorBody = {
    _visit: <Result>(_value: GetLatestProblemErrorBody, visitor: GetLatestProblemErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLatestProblemErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLatestProblemErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetLatestProblemRequest {
    problemId: model.commons.ProblemId;
}
",
                                "name": "GetLatestProblemRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLatestProblemResponse = GetLatestProblemResponse.SuccessResponse | GetLatestProblemResponse.ErrorResponse;

export declare namespace GetLatestProblemResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLatestProblemErrorBody;
    }
}
",
                                "name": "GetLatestProblemResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetLightweightProblemsErrorBody = never;

export declare namespace GetLightweightProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetLightweightProblemsErrorBody = {
    _visit: <Result>(_value: GetLightweightProblemsErrorBody, visitor: GetLightweightProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetLightweightProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetLightweightProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetLightweightProblemsResponse = GetLightweightProblemsResponse.SuccessResponse | GetLightweightProblemsResponse.ErrorResponse;

export declare namespace GetLightweightProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.LightweightProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetLightweightProblemsErrorBody;
    }
}
",
                                "name": "GetLightweightProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemVersionErrorBody = never;

export declare namespace GetProblemVersionErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemVersionErrorBody = {
    _visit: <Result>(_value: GetProblemVersionErrorBody, visitor: GetProblemVersionErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemVersionErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemVersionErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export interface GetProblemVersionRequest {
    problemId: model.commons.ProblemId;
    problemVersion: number;
}
",
                                "name": "GetProblemVersionRequest.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemVersionResponse = GetProblemVersionResponse.SuccessResponse | GetProblemVersionResponse.ErrorResponse;

export declare namespace GetProblemVersionResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2;
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemVersionErrorBody;
    }
}
",
                                "name": "GetProblemVersionResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export type GetProblemsErrorBody = never;

export declare namespace GetProblemsErrorBody {
    export interface _Visitor<Result> {
        _unknown: () => Result;
    }
}

export const GetProblemsErrorBody = {
    _visit: <Result>(_value: GetProblemsErrorBody, visitor: GetProblemsErrorBody._Visitor<Result>): Result => {
        return visitor._unknown();
    },

    _types: (): GetProblemsErrorBody[\\"_error\\"][] => [],
} as const;
",
                                "name": "GetProblemsErrorBody.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "import * as model from \\"../../../../..\\";

export type GetProblemsResponse = GetProblemsResponse.SuccessResponse | GetProblemsResponse.ErrorResponse;

export declare namespace GetProblemsResponse {
    export interface SuccessResponse {
        ok: true;
        body: model.v2.v3.problem.ProblemInfoV2[];
    }

    export interface ErrorResponse {
        ok: false;
        error: model.v2.v3.problem.GetProblemsErrorBody;
    }
}
",
                                "name": "GetProblemsResponse.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": "export * from \\"./GetLightweightProblemsErrorBody\\";
export * from \\"./GetLightweightProblemsResponse\\";
export * from \\"./GetProblemsErrorBody\\";
export * from \\"./GetProblemsResponse\\";
export * from \\"./GetLatestProblemRequest\\";
export * from \\"./GetLatestProblemErrorBody\\";
export * from \\"./GetLatestProblemResponse\\";
export * from \\"./GetProblemVersionRequest\\";
export * from \\"./GetProblemVersionErrorBody\\";
export * from \\"./GetProblemVersionResponse\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                            ],
                            "name": "ProblemInfoServicV2",
                            "type": "directory",
                          },
                          Object {
                            "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_service-types",
                        "type": "directory",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type AssertCorrectnessCheck =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends v2.v3.problem.DeepEqualityCorrectnessCheck {
        _type: \\"deepEquality\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const AssertCorrectnessCheck = {
    deepEquality: (value: v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
        ...value,
        _type: \\"deepEquality\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: AssertCorrectnessCheck, visitor: AssertCorrectnessCheck._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"deepEquality\\": return visitor.deepEquality(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): AssertCorrectnessCheck[\\"_type\\"][] => [\\"deepEquality\\", \\"custom\\"],
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    basicTestCaseTemplate: model.v2.v3.problem.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: model.problem.ProblemDescription;
    customFiles: model.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    supportedLanguages: model.commons.Language[];
    isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2, commons } from \\"../../../..\\";

export type CustomFiles =
    | CustomFiles.Basic
    | CustomFiles.Custom;

export declare namespace CustomFiles {
    interface Basic extends v2.v3.problem.BasicCustomFiles {
        _type: \\"basic\\";
    }

    interface Custom {
        _type: \\"custom\\";
        custom: Record<commons.Language, v2.v3.problem.Files>;
    }

    export interface _Visitor<Result> {
        basic: (value: v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<commons.Language, v2.v3.problem.Files>) => Result;
        _unknown: () => Result;
    }
}

export const CustomFiles = {
    basic: (value: v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
        ...value,
        _type: \\"basic\\"
    }),

    custom: (value: Record<commons.Language, v2.v3.problem.Files>): CustomFiles.Custom => ({
        custom: value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: CustomFiles, visitor: CustomFiles._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"basic\\": return visitor.basic(value);
            case \\"custom\\": return visitor.custom(value.custom);
            default: return visitor._unknown();
        }
    },

    _types: (): CustomFiles[\\"_type\\"][] => [\\"basic\\", \\"custom\\"],
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: model.v2.v3.problem.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: model.v2.v3.problem.FileInfoV2;
    relatedTypes: model.commons.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Files {
    files: model.v2.v3.problem.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface FunctionImplementation {
    impl: string;
    imports: string | null | undefined;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<model.commons.Language, model.v2.v3.problem.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type FunctionSignature =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult;

export declare namespace FunctionSignature {
    interface Void extends v2.v3.problem.VoidFunctionSignature {
        _type: \\"void\\";
    }

    interface NonVoid extends v2.v3.problem.NonVoidFunctionSignature {
        _type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends v2.v3.problem.VoidFunctionSignatureThatTakesActualResult {
        _type: \\"voidThatTakesActualResult\\";
    }

    export interface _Visitor<Result> {
        void: (value: v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: () => Result;
    }
}

export const FunctionSignature = {
    void: (value: v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
        ...value,
        _type: \\"void\\"
    }),

    nonVoid: (value: v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
        ...value,
        _type: \\"nonVoid\\"
    }),

    voidThatTakesActualResult: (value: v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
        ...value,
        _type: \\"voidThatTakesActualResult\\"
    }),

    _visit: <Result>(value: FunctionSignature, visitor: FunctionSignature._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"void\\": return visitor.void(value);
            case \\"nonVoid\\": return visitor.nonVoid(value);
            case \\"voidThatTakesActualResult\\": return visitor.voidThatTakesActualResult(value);
            default: return visitor._unknown();
        }
    },

    _types: (): FunctionSignature[\\"_type\\"][] => [\\"void\\", \\"nonVoid\\", \\"voidThatTakesActualResult\\"],
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<model.commons.Language, model.v2.v3.problem.Files>;
    other: Record<model.commons.Language, model.v2.v3.problem.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<model.commons.Language, model.v2.v3.problem.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: model.v2.v3.problem.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<model.commons.Language, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate | null | undefined;
    testCase: model.v2.v3.problem.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: model.v2.v3.problem.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: model.commons.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: model.v2.v3.problem.NonVoidFunctionSignature;
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
    returnType: model.commons.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface Parameter {
    parameterId: model.v2.v3.problem.ParameterId;
    name: string;
    variableType: model.commons.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type ParameterId = string;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: model.commons.ProblemId;
    problemDescription: model.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: model.commons.Language[];
    customFiles: model.v2.v3.problem.CustomFiles;
    generatedFiles: model.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: model.v2.v3.problem.TestCaseTemplate[];
    testcases: model.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export interface TestCaseExpects {
    expectedStdout: string | null | undefined;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseFunction =
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom;

export declare namespace TestCaseFunction {
    interface WithActualResult extends v2.v3.problem.TestCaseWithActualResultImplementation {
        _type: \\"withActualResult\\";
    }

    interface Custom extends v2.v3.problem.VoidFunctionDefinition {
        _type: \\"custom\\";
    }

    export interface _Visitor<Result> {
        withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseFunction = {
    withActualResult: (value: v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
        ...value,
        _type: \\"withActualResult\\"
    }),

    custom: (value: v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
        ...value,
        _type: \\"custom\\"
    }),

    _visit: <Result>(value: TestCaseFunction, visitor: TestCaseFunction._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"withActualResult\\": return visitor.withActualResult(value);
            case \\"custom\\": return visitor.custom(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseFunction[\\"_type\\"][] => [\\"withActualResult\\", \\"custom\\"],
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseId = string;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementation {
    description: model.v2.v3.problem.TestCaseImplementationDescription;
    function: model.v2.v3.problem.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: model.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html {
        _type: \\"html\\";
        html: string;
    }

    interface ParamId {
        _type: \\"paramId\\";
        paramId: v2.v3.problem.ParameterId;
    }

    export interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: v2.v3.problem.ParameterId) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
    html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
        html: value,
        _type: \\"html\\"
    }),

    paramId: (value: v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
        paramId: value,
        _type: \\"paramId\\"
    }),

    _visit: <Result>(value: TestCaseImplementationDescriptionBoard, visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"html\\": return visitor.html(value.html);
            case \\"paramId\\": return visitor.paramId(value.paramId);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationDescriptionBoard[\\"_type\\"][] => [\\"html\\", \\"paramId\\"],
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import { v2 } from \\"../../../..\\";

export type TestCaseImplementationReference =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

export declare namespace TestCaseImplementationReference {
    interface TemplateId {
        _type: \\"templateId\\";
        templateId: v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends v2.v3.problem.TestCaseImplementation {
        _type: \\"implementation\\";
    }

    export interface _Visitor<Result> {
        templateId: (value: v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: () => Result;
    }
}

export const TestCaseImplementationReference = {
    templateId: (value: v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
        templateId: value,
        _type: \\"templateId\\"
    }),

    implementation: (value: v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
        ...value,
        _type: \\"implementation\\"
    }),

    _visit: <Result>(value: TestCaseImplementationReference, visitor: TestCaseImplementationReference._Visitor<Result>): Result => {
        switch (value._type) {
            case \\"templateId\\": return visitor.templateId(value.templateId);
            case \\"implementation\\": return visitor.implementation(value);
            default: return visitor._unknown();
        }
    },

    _types: (): TestCaseImplementationReference[\\"_type\\"][] => [\\"templateId\\", \\"implementation\\"],
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseMetadata {
    id: model.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: model.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: model.v2.v3.problem.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export type TestCaseTemplateId = string;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: model.v2.v3.problem.TestCaseMetadata;
    implementation: model.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<model.v2.v3.problem.ParameterId, model.commons.VariableValue>;
    expects: model.v2.v3.problem.TestCaseExpects | null | undefined;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: model.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: model.v2.v3.problem.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: model.v2.v3.problem.Parameter[];
    code: model.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: model.v2.v3.problem.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "import * as model from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: model.v2.v3.problem.Parameter[];
    actualResultType: model.commons.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "_types",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./_types\\";
export * from \\"./_service-types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "model",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"name\\": \\"@fern-api/my-api-server\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"uuid\\": \\"8.3.2\\",
        \\"@types/uuid\\": \\"8.3.4\\",
        \\"express\\": \\"4.18.1\\",
        \\"@types/express\\": \\"4.17.13\\"
    },
    \\"peerDependencies\\": {
        \\"express\\": \\"*\\",
        \\"@types/express\\": \\"*\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
        "name": "package.json",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface AdminService {
    updateTestSubmissionStatus(request: model.admin.UpdateTestSubmissionStatusRequest): model.admin.UpdateTestSubmissionStatusResponse | Promise<model.admin.UpdateTestSubmissionStatusResponse>;
    sendTestSubmissionUpdate(request: model.admin.SendTestSubmissionUpdateRequest): model.admin.SendTestSubmissionUpdateResponse | Promise<model.admin.SendTestSubmissionUpdateResponse>;
    updateWorkspaceSubmissionStatus(request: model.admin.UpdateWorkspaceSubmissionStatusRequest): model.admin.UpdateWorkspaceSubmissionStatusResponse | Promise<model.admin.UpdateWorkspaceSubmissionStatusResponse>;
    sendWorkspaceSubmissionUpdate(request: model.admin.SendWorkspaceSubmissionUpdateRequest): model.admin.SendWorkspaceSubmissionUpdateResponse | Promise<model.admin.SendWorkspaceSubmissionUpdateResponse>;
    storeTracedTestCase(request: model.admin._StoreTracedTestCaseRequest): model.admin.StoreTracedTestCaseResponse | Promise<model.admin.StoreTracedTestCaseResponse>;
    storeTracedTestCaseV2(request: model.admin.StoreTracedTestCaseV2Request): model.admin.StoreTracedTestCaseV2Response | Promise<model.admin.StoreTracedTestCaseV2Response>;
    storeTracedWorkspace(request: model.admin._StoreTracedWorkspaceRequest): model.admin.StoreTracedWorkspaceResponse | Promise<model.admin.StoreTracedWorkspaceResponse>;
    storeTracedWorkspaceV2(request: model.admin.StoreTracedWorkspaceV2Request): model.admin.StoreTracedWorkspaceV2Response | Promise<model.admin.StoreTracedWorkspaceV2Response>;
}

export const AdminService = {
    expressMiddleware: (impl: AdminService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/admin/store-test-submission-status/:submissionId\\", async (request, response) => {
            const result = await impl.updateTestSubmissionStatus({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-submission-status-v2/:submissionId\\", async (request, response) => {
            const result = await impl.sendTestSubmissionUpdate({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-submission-status/:submissionId\\", async (request, response) => {
            const result = await impl.updateWorkspaceSubmissionStatus({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-submission-status-v2/:submissionId\\", async (request, response) => {
            const result = await impl.sendWorkspaceSubmissionUpdate({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-trace/submission/:submissionId/testCase/:testCaseId\\", async (request, response) => {
            const result = await impl.storeTracedTestCase({
                submissionId: request.params.submissionId,
                testCaseId: request.params.testCaseId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-test-trace-v2/submission/:submissionId/testCase/:testCaseId\\", async (request, response) => {
            const result = await impl.storeTracedTestCaseV2({
                submissionId: request.params.submissionId,
                testCaseId: request.params.testCaseId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-trace/submission/:submissionId\\", async (request, response) => {
            const result = await impl.storeTracedWorkspace({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/admin/store-workspace-trace-v2/submission/:submissionId\\", async (request, response) => {
            const result = await impl.storeTracedWorkspaceV2({
                submissionId: request.params.submissionId,
                body: request.body
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "AdminService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./AdminService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface HomepageProblemService {
    getHomepageProblems(): model.homepage.GetHomepageProblemsResponse | Promise<model.homepage.GetHomepageProblemsResponse>;
    setHomepageProblems(request: model.commons.ProblemId[]): model.homepage.SetHomepageProblemsResponse | Promise<model.homepage.SetHomepageProblemsResponse>;
}

export const HomepageProblemService = {
    expressMiddleware: (impl: HomepageProblemService): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/homepage-problems/\\", async (_request, response) => {
            const result = await impl.getHomepageProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/homepage-problems/\\", async (request, response) => {
            const result = await impl.setHomepageProblems(request.body);
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "HomepageProblemService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./HomepageProblemService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as sysprop from \\"./sysprop\\";
export * as v2 from \\"./v2\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface MigrationInfoService {
    getAttemptedMigrations(): model.migration.GetAttemptedMigrationsResponse | Promise<model.migration.GetAttemptedMigrationsResponse>;
}

export const MigrationInfoService = {
    expressMiddleware: (impl: MigrationInfoService): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/migration-info/all\\", async (_request, response) => {
            const result = await impl.getAttemptedMigrations();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "MigrationInfoService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationInfoService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface PlaylistCrudService {
    createPlaylist(request: model.playlist.PlaylistCreateRequest): model.playlist.CreatePlaylistResponse | Promise<model.playlist.CreatePlaylistResponse>;
    getPlaylists(request: model.playlist.GetPlaylistsRequest): model.playlist.GetPlaylistsResponse | Promise<model.playlist.GetPlaylistsResponse>;
    getPlaylist(request: model.playlist.GetPlaylistRequest): model.playlist.GetPlaylistResponse | Promise<model.playlist.GetPlaylistResponse>;
    updatePlaylist(request: model.playlist._UpdatePlaylistRequest): model.playlist.UpdatePlaylistResponse | Promise<model.playlist.UpdatePlaylistResponse>;
    deletePlaylist(request: model.playlist.DeletePlaylistRequest): model.playlist.DeletePlaylistResponse | Promise<model.playlist.DeletePlaylistResponse>;
}

export const PlaylistCrudService = {
    expressMiddleware: (impl: PlaylistCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/v2/playlist/create\\", async (request, response) => {
            const result = await impl.createPlaylist(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/v2/playlist/all\\", async (request, response) => {
            const result = await impl.getPlaylists({
                limit: request.query.limit != null ? Number(request.query.limit) : undefined
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/v2/playlist/:playlistId\\", async (request, response) => {
            const result = await impl.getPlaylist({
                playlistId: request.params.playlistId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                const statusCode = model.playlist.GetPlaylistErrorBody._visit(result.error, {
                    PlaylistIdNotFoundError: () => 404,
                    UnauthorizedError: () => 401,
                    _unknown: () => 500
                });
                response.status(statusCode).send(result.error);
            }
        });
        app.put(\\"/v2/playlist/:playlistId\\", async (request, response) => {
            const result = await impl.updatePlaylist({
                playlistId: request.params.playlistId,
                body: request.body
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                const statusCode = model.playlist.UpdatePlaylistErrorBody._visit(result.error, {
                    PlaylistIdNotFoundError: () => 404,
                    _unknown: () => 500
                });
                response.status(statusCode).send(result.error);
            }
        });
        app.delete(\\"/v2/playlist/:playlist_id\\", async (request, response) => {
            const result = await impl.deletePlaylist({
                playlist_id: request.params.playlist_id
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "PlaylistCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemCrudService {
    createProblem(request: model.problem.CreateProblemRequest): model.problem._CreateProblemResponse | Promise<model.problem._CreateProblemResponse>;
    updateProblem(request: model.problem.UpdateProblemRequest): model.problem._UpdateProblemResponse | Promise<model.problem._UpdateProblemResponse>;
    deleteProblem(request: model.problem.DeleteProblemRequest): model.problem.DeleteProblemResponse | Promise<model.problem.DeleteProblemResponse>;
    getDefaultStarterFiles(request: model.problem.GetDefaultStarterFilesRequest): model.problem._GetDefaultStarterFilesResponse | Promise<model.problem._GetDefaultStarterFilesResponse>;
}

export const ProblemCrudService = {
    expressMiddleware: (impl: ProblemCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/problem-crud/create\\", async (request, response) => {
            const result = await impl.createProblem(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/problem-crud/update/:problemId\\", async (request, response) => {
            const result = await impl.updateProblem({
                problemId: request.params.problemId,
                body: request.body
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.delete(\\"/problem-crud/delete/:problemId\\", async (request, response) => {
            const result = await impl.deleteProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.post(\\"/problem-crud/default-starter-files\\", async (request, response) => {
            const result = await impl.getDefaultStarterFiles(request.body);
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "ProblemCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface ExecutionSesssionManagementService {
    createExecutionSession(request: model.submission.CreateExecutionSessionRequest): model.submission.CreateExecutionSessionResponse | Promise<model.submission.CreateExecutionSessionResponse>;
    getExecutionSession(request: model.submission.GetExecutionSessionRequest): model.submission.GetExecutionSessionResponse | Promise<model.submission.GetExecutionSessionResponse>;
    stopExecutionSession(request: model.submission.StopExecutionSessionRequest): model.submission.StopExecutionSessionResponse | Promise<model.submission.StopExecutionSessionResponse>;
    getExecutionSessionsState(): model.submission.GetExecutionSessionsStateResponse | Promise<model.submission.GetExecutionSessionsStateResponse>;
}

export const ExecutionSesssionManagementService = {
    expressMiddleware: (impl: ExecutionSesssionManagementService): Express => {
        const app = express();
        app.use(express.json());
        app.post(\\"/sessions/create-session/:language\\", async (request, response) => {
            const result = await impl.createExecutionSession({
                language: request.params.language as model.commons.Language
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sessions/:sessionId\\", async (request, response) => {
            const result = await impl.getExecutionSession({
                sessionId: request.params.sessionId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.delete(\\"/sessions/stop/:sessionId\\", async (request, response) => {
            const result = await impl.stopExecutionSession({
                sessionId: request.params.sessionId
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sessions/execution-sessions-state\\", async (_request, response) => {
            const result = await impl.getExecutionSessionsState();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "ExecutionSesssionManagementService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ExecutionSesssionManagementService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as model from \\"../../model\\";
import express, { Express } from \\"express\\";

export interface SysPropCrudService {
    setNumWarmInstances(request: model.sysprop.SetNumWarmInstancesRequest): model.sysprop.SetNumWarmInstancesResponse | Promise<model.sysprop.SetNumWarmInstancesResponse>;
    getNumWarmInstances(): model.sysprop.GetNumWarmInstancesResponse | Promise<model.sysprop.GetNumWarmInstancesResponse>;
}

export const SysPropCrudService = {
    expressMiddleware: (impl: SysPropCrudService): Express => {
        const app = express();
        app.use(express.json());
        app.put(\\"/sysprop/num-warm-instances/:language/:numWarmInstances\\", async (request, response) => {
            const result = await impl.setNumWarmInstances({
                language: request.params.language as model.commons.Language,
                numWarmInstances: Number(request.params.numWarmInstances)
            });
            if (result.ok) {
                response.end();
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/sysprop/num-warm-instances\\", async (_request, response) => {
            const result = await impl.getNumWarmInstances();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                "name": "SysPropCrudService.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SysPropCrudService\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as model from \\"../../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): model.v2.problem.GetLightweightProblemsResponse | Promise<model.v2.problem.GetLightweightProblemsResponse>;
    getProblems(): model.v2.problem.GetProblemsResponse | Promise<model.v2.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.problem.GetLatestProblemRequest): model.v2.problem.GetLatestProblemResponse | Promise<model.v2.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.problem.GetProblemVersionRequest): model.v2.problem.GetProblemVersionResponse | Promise<model.v2.problem.GetProblemVersionResponse>;
}

export const ProblemInfoServicV2 = {
    expressMiddleware: (impl: ProblemInfoServicV2): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/problems-v2/lightweight-problem-info\\", async (_request, response) => {
            const result = await impl.getLightweightProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info\\", async (_request, response) => {
            const result = await impl.getProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId\\", async (request, response) => {
            const result = await impl.getLatestProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId/version/:problemVersion\\", async (request, response) => {
            const result = await impl.getProblemVersion({
                problemId: request.params.problemId,
                problemVersion: Number(request.params.problemVersion)
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                    "name": "ProblemInfoServicV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import * as model from \\"../../../../model\\";
import express, { Express } from \\"express\\";

export interface ProblemInfoServicV2 {
    getLightweightProblems(): model.v2.v3.problem.GetLightweightProblemsResponse | Promise<model.v2.v3.problem.GetLightweightProblemsResponse>;
    getProblems(): model.v2.v3.problem.GetProblemsResponse | Promise<model.v2.v3.problem.GetProblemsResponse>;
    getLatestProblem(request: model.v2.v3.problem.GetLatestProblemRequest): model.v2.v3.problem.GetLatestProblemResponse | Promise<model.v2.v3.problem.GetLatestProblemResponse>;
    getProblemVersion(request: model.v2.v3.problem.GetProblemVersionRequest): model.v2.v3.problem.GetProblemVersionResponse | Promise<model.v2.v3.problem.GetProblemVersionResponse>;
}

export const ProblemInfoServicV2 = {
    expressMiddleware: (impl: ProblemInfoServicV2): Express => {
        const app = express();
        app.use(express.json());
        app.get(\\"/problems-v2/lightweight-problem-info\\", async (_request, response) => {
            const result = await impl.getLightweightProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info\\", async (_request, response) => {
            const result = await impl.getProblems();
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId\\", async (request, response) => {
            const result = await impl.getLatestProblem({
                problemId: request.params.problemId
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        app.get(\\"/problems-v2/problem-info/:problemId/version/:problemVersion\\", async (request, response) => {
            const result = await impl.getProblemVersion({
                problemId: request.params.problemId,
                problemVersion: Number(request.params.problemVersion)
            });
            if (result.ok) {
                response.send(result.body);
            }
            else {
                response.sendStatus(500);
            }
        });
        return app;
    }
};
",
                        "name": "ProblemInfoServicV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./ProblemInfoServicV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                ],
                "name": "v3",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "services",
        "type": "directory",
      },
      Object {
        "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
        "name": "tsconfig.json",
        "type": "file",
      },
    ],
    "name": "server",
    "type": "directory",
  },
]
`;

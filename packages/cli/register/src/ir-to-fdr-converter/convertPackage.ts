import { assertNever, isNonNullish, isPlainObject, MediaType } from "@fern-api/core-utils";
import { FdrAPI as FdrCjsSdk } from "@fern-api/fdr-sdk";
import {
    AutogeneratedEndpointExample,
    ExampleCodeSample,
    IntermediateRepresentation,
    FernIr as Ir,
    UserSpecifiedEndpointExample,
    V2HttpEndpointExample
} from "@fern-api/ir-sdk";
import { generateEndpointV1Example as generateEndpointExample } from "@fern-api/ir-utils";
import { noop, startCase } from "lodash-es";

import { convertTypeReference } from "./convertTypeShape";

export function convertPackage(
    irPackage: Ir.ir.Package,
    ir: Ir.ir.IntermediateRepresentation
): FdrCjsSdk.api.v1.register.ApiDefinitionPackage {
    const service = irPackage.service != null ? ir.services[irPackage.service] : undefined;
    const webhooks = irPackage.webhooks != null ? ir.webhookGroups[irPackage.webhooks] : undefined;
    const websocket =
        irPackage.websocket != null && ir.websocketChannels != null
            ? ir.websocketChannels[irPackage.websocket]
            : undefined;
    return {
        endpoints: service != null ? convertService(service, ir) : [],
        webhooks: webhooks != null ? convertWebhookGroup(webhooks) : [],
        websockets: websocket != null ? [convertWebSocketChannel(websocket, ir)] : [],
        types: irPackage.types.map((typeId) => FdrCjsSdk.TypeId(typeId)),
        subpackages: irPackage.subpackages.map((subpackageId) => FdrCjsSdk.api.v1.SubpackageId(subpackageId)),
        pointsTo:
            irPackage.navigationConfig != null
                ? FdrCjsSdk.api.v1.SubpackageId(irPackage.navigationConfig.pointsTo)
                : undefined
    };
}

function convertWebhookGroup(webhookGroup: Ir.webhooks.WebhookGroup): FdrCjsSdk.api.v1.register.WebhookDefinition[] {
    return webhookGroup.map((webhook) => {
        const webhookExamples: FdrCjsSdk.api.v1.register.ExampleWebhookPayload[] = [];
        if (webhook.v2Examples != null) {
            webhookExamples.push(...Object.values(webhook.v2Examples.userSpecifiedExamples));
            webhookExamples.push(...Object.values(webhook.v2Examples.autogeneratedExamples));
        } else {
            // webhookExamples.push(...(webhook.examples ?? []));
            webhookExamples.push(
                ...(webhook.examples?.map((example) => {
                    return { payload: example.payload.jsonExample };
                }) ?? [])
            );
        }
        return {
            description: webhook.docs ?? undefined,
            id: FdrCjsSdk.WebhookId(webhook.name.originalName),
            path: [],
            method: webhook.method,
            name: webhook.displayName ?? startCase(webhook.name.originalName),
            headers: webhook.headers.map(
                (header): FdrCjsSdk.api.v1.register.Header => ({
                    description: header.docs ?? undefined,
                    key: header.name.wireValue,
                    type: convertTypeReference(header.valueType),
                    availability: convertIrAvailability(header.availability)
                })
            ),
            payload: convertWebhookPayload(webhook.payload),
            examples: webhookExamples
        };
    });
}

function convertService(
    irService: Ir.http.HttpService,
    ir: Ir.ir.IntermediateRepresentation
): FdrCjsSdk.api.v1.register.EndpointDefinition[] {
    const endpoints: FdrCjsSdk.api.v1.register.EndpointDefinition[] = [];
    for (const irEndpoint of irService.endpoints) {
        const autogeneratedExample = irEndpoint.autogeneratedExamples[0];
        const examples: FdrCjsSdk.api.v1.register.ExampleEndpointCall[] = [];
        if (irEndpoint.v2Examples != null) {
            let endpointExample: FdrCjsSdk.api.v1.register.ExampleEndpointCall | undefined;
            const userSpecifiedExamples = irEndpoint.v2Examples.userSpecifiedExamples;
            const autogeneratedExamples = irEndpoint.v2Examples.autogeneratedExamples;
            // We only want to disambiguate multiple user-specified examples with the same status code.
            const shouldUseUserSpecifiedExampleName =
                Object.values(userSpecifiedExamples)
                    .map((example) => example.response?.statusCode)
                    .filter((statusCode, index, array) => array.indexOf(statusCode) !== index).length > 0;
            for (const [exampleName, example] of Object.entries(userSpecifiedExamples)) {
                endpointExample = convertV2HttpEndpointExample({
                    shouldUseExampleName: shouldUseUserSpecifiedExampleName,
                    exampleName: example.displayName ?? exampleName,
                    example,
                    irEndpoint,
                    irService,
                    ir
                });
                if (endpointExample != null) {
                    examples.push(endpointExample);
                }
            }
            // Similarly, we only want to disambiguate multiple autogenerated examples with the same status code.
            const shouldUseAutogeneratedExampleName =
                Object.values(autogeneratedExamples)
                    .map((example) => example.response?.statusCode)
                    .filter((statusCode, index, array) => array.indexOf(statusCode) !== index).length > 0;

            for (const [exampleName, example] of Object.entries(autogeneratedExamples)) {
                endpointExample = convertV2HttpEndpointExample({
                    shouldUseExampleName: shouldUseAutogeneratedExampleName,
                    exampleName: example.displayName ?? exampleName,
                    example,
                    irEndpoint,
                    irService,
                    ir
                });
                if (endpointExample != null) {
                    examples.push(endpointExample);
                }
            }
        } else {
            if (irEndpoint.userSpecifiedExamples.length > 0) {
                examples.push(
                    ...irEndpoint.userSpecifiedExamples
                        .map((userSpecifiedExample) =>
                            convertHttpEndpointExample({
                                userSpecifiedExample,
                                ...(autogeneratedExample != null && { autogeneratedExample }),
                                irEndpoint,
                                ir
                            })
                        )
                        .filter(isNonNullish)
                );
            } else if (autogeneratedExample != null) {
                const endpointExample = convertHttpEndpointExample({
                    autogeneratedExample,
                    irEndpoint,
                    ir
                });
                if (endpointExample != null) {
                    examples.push(endpointExample);
                }
            } else if (irEndpoint.response?.body?.type === "fileDownload") {
                const example = generateEndpointExample({
                    ir,
                    service: irService,
                    endpoint: { ...irEndpoint, response: undefined },
                    typeDeclarations: ir.types,
                    skipOptionalRequestProperties: true,
                    generationResponse: { type: "success" }
                });
                if (example.type === "success") {
                    const endpointExample = convertHttpEndpointExample({
                        autogeneratedExample: example,
                        irEndpoint,
                        ir
                    });
                    if (endpointExample != null) {
                        const convertedExample: FdrCjsSdk.api.v1.register.ExampleEndpointCall = {
                            ...endpointExample,
                            responseBodyV3: { type: "filename", value: "<bytes>" }
                        };
                        examples.push(convertedExample);
                    }
                }
            }
        }
        const endpoint: FdrCjsSdk.api.v1.register.EndpointDefinition = {
            slug: undefined,
            availability: convertIrAvailability(irEndpoint.availability ?? irService.availability),
            auth: irEndpoint.auth,
            authV2: convertEndpointSecurity(irEndpoint.security),
            description: irEndpoint.docs ?? undefined,
            method: convertHttpMethod(irEndpoint.method),
            defaultEnvironment:
                ir.environments?.defaultEnvironment != null
                    ? FdrCjsSdk.EnvironmentId(ir.environments.defaultEnvironment)
                    : undefined,
            environments:
                ir.environments != null
                    ? convertIrEnvironments({ environmentsConfig: ir.environments, endpoint: irEndpoint })
                    : undefined,
            id: FdrCjsSdk.EndpointId(irEndpoint.name.originalName),
            originalEndpointId: irEndpoint.id,
            name: irEndpoint.displayName ?? startCase(irEndpoint.name.originalName),
            path:
                irEndpoint.basePath != null
                    ? {
                          pathParameters: irEndpoint.pathParameters.map(
                              (pathParameter): FdrCjsSdk.api.v1.register.PathParameter =>
                                  ({
                                      description: pathParameter.docs ?? undefined,
                                      key: FdrCjsSdk.PropertyKey(pathParameter.name.originalName),
                                      type: convertTypeReference(pathParameter.valueType),
                                      availability: undefined,
                                      ...(pathParameter.explode !== undefined ? { explode: pathParameter.explode } : {})
                                      // biome-ignore lint/suspicious/noExplicitAny: FDR SDK types don't include explode field yet
                                  }) as any
                          ),
                          parts: [...convertHttpPath(irEndpoint.basePath), ...convertHttpPath(irEndpoint.path)]
                      }
                    : {
                          pathParameters: [
                              ...ir.pathParameters,
                              ...irService.pathParameters,
                              ...irEndpoint.pathParameters
                          ].map(
                              (pathParameter): FdrCjsSdk.api.v1.register.PathParameter =>
                                  ({
                                      description: pathParameter.docs ?? undefined,
                                      key: FdrCjsSdk.PropertyKey(pathParameter.name.originalName),
                                      type: convertTypeReference(pathParameter.valueType),
                                      availability: undefined,
                                      ...(pathParameter.explode !== undefined ? { explode: pathParameter.explode } : {})
                                      // biome-ignore lint/suspicious/noExplicitAny: FDR SDK types don't include explode field yet
                                  }) as any
                          ),
                          parts: [
                              ...(ir.basePath != null ? convertHttpPath(ir.basePath) : []),
                              ...convertHttpPath(irService.basePath),
                              ...convertHttpPath(irEndpoint.path)
                          ]
                      },
            queryParameters: irEndpoint.queryParameters.map(
                (queryParameter): FdrCjsSdk.api.v1.register.QueryParameter =>
                    ({
                        description: queryParameter.docs ?? undefined,
                        key: queryParameter.name.wireValue,
                        type: convertTypeReference(queryParameter.valueType),
                        availability: convertIrAvailability(queryParameter.availability),
                        ...(queryParameter.explode !== undefined ? { explode: queryParameter.explode } : {})
                        // biome-ignore lint/suspicious/noExplicitAny: FDR SDK types don't include explode field yet
                    }) as any
            ),
            headers: [...irService.headers, ...irEndpoint.headers].map(
                (header): FdrCjsSdk.api.v1.register.Header => ({
                    description: header.docs ?? undefined,
                    key: header.name.wireValue,
                    type: convertTypeReference(header.valueType),
                    availability: convertIrAvailability(header.availability)
                })
            ),
            request: irEndpoint.requestBody != null ? convertRequestBody(irEndpoint.requestBody) : undefined,
            requestsV2: {
                requests: irEndpoint.v2RequestBodies?.requestBodies?.map(convertRequestBody).filter(isNonNullish)
            },
            response: irEndpoint.response != null ? convertResponse(irEndpoint.response) : undefined,
            responsesV2: {
                responses: irEndpoint.v2Responses?.responses?.map(convertResponse).filter(isNonNullish)
            },
            errors: undefined,
            errorsV2: convertResponseErrorsV2(irEndpoint.errors, ir),
            examples,
            protocol: irEndpoint.source?._visit<FdrCjsSdk.api.v1.Protocol | undefined>({
                openapi: () => {
                    return { type: "rest" };
                },
                openrpc: () => {
                    return { type: "openrpc", methodName: irEndpoint.id };
                },
                proto: (protoSource) => {
                    return { type: "grpc", methodName: irEndpoint.id, methodType: protoSource.methodType };
                },
                _other: () => undefined
            }),
            includeInApiExplorer: undefined
        };
        endpoints.push(endpoint);
    }
    return endpoints;
}

function convertWebSocketChannel(
    channel: Ir.websocket.WebSocketChannel,
    ir: Ir.ir.IntermediateRepresentation
): FdrCjsSdk.api.v1.register.WebSocketChannel {
    let examples: FdrCjsSdk.api.v1.register.ExampleWebSocketSession[] = [];
    if (
        channel.v2Examples != null &&
        (Object.keys(channel.v2Examples.userSpecifiedExamples).length > 0 ||
            Object.keys(channel.v2Examples.autogeneratedExamples).length > 0)
    ) {
        const userSpecifiedExamples = Object.values(channel.v2Examples.userSpecifiedExamples);
        const autogeneratedExamples = Object.values(channel.v2Examples.autogeneratedExamples);
        const firstExample = userSpecifiedExamples.length > 0 ? userSpecifiedExamples[0] : autogeneratedExamples[0];
        if (firstExample != null) {
            examples.push({
                name: "",
                description: "",
                path: firstExample.baseUrl ?? "",
                pathParameters: firstExample.pathParameters ?? {},
                queryParameters: firstExample.queryParameters ?? {},
                headers: firstExample.headers ?? {},
                messages:
                    firstExample.messages?.map((message) => ({
                        type: FdrCjsSdk.api.v1.WebSocketMessageId(message.type),
                        body: message.body
                    })) ?? []
            });
        }
    } else {
        examples = channel.examples.map(
            (example): FdrCjsSdk.api.v1.register.ExampleWebSocketSession => ({
                name: example.name?.originalName,
                description: example.docs,
                path: example.url,
                pathParameters: example.pathParameters.reduce<
                    FdrCjsSdk.api.v1.register.ExampleWebSocketSession["pathParameters"]
                >((pathParameters, irPathParameterExample) => {
                    pathParameters[FdrCjsSdk.PropertyKey(irPathParameterExample.name.originalName)] =
                        irPathParameterExample.value.jsonExample;
                    return pathParameters;
                }, {}),
                queryParameters: example.queryParameters.reduce<
                    FdrCjsSdk.api.v1.register.ExampleWebSocketSession["queryParameters"]
                >((queryParameters, irQueryParameterExample) => {
                    queryParameters[irQueryParameterExample.name.wireValue] = irQueryParameterExample.value.jsonExample;
                    return queryParameters;
                }, {}),
                headers: example.headers.reduce<FdrCjsSdk.api.v1.register.ExampleWebSocketSession["headers"]>(
                    (headers, irHeaderExample) => {
                        headers[irHeaderExample.name.wireValue] = irHeaderExample.value.jsonExample;
                        return headers;
                    },
                    {}
                ),
                messages: example.messages.map(
                    (message): FdrCjsSdk.api.v1.register.ExampleWebSocketMessage => ({
                        type: FdrCjsSdk.api.v1.WebSocketMessageId(message.type),
                        body: message.body.jsonExample
                    })
                )
            })
        );
    }
    return {
        auth: channel.auth,
        availability: convertIrAvailability(channel.availability),
        description: channel.docs ?? undefined,
        defaultEnvironment:
            ir.environments?.defaultEnvironment != null
                ? FdrCjsSdk.EnvironmentId(ir.environments.defaultEnvironment)
                : undefined,
        environments:
            ir.environments != null
                ? convertIrWebSocketEnvironments({ environmentsConfig: ir.environments, channel })
                : [],
        id: FdrCjsSdk.WebSocketId(channel.name.originalName),
        name: channel.displayName ?? startCase(channel.name.originalName),
        path: {
            pathParameters: channel.pathParameters.map(
                (pathParameter): FdrCjsSdk.api.v1.register.PathParameter =>
                    ({
                        description: pathParameter.docs ?? undefined,
                        key: FdrCjsSdk.PropertyKey(pathParameter.name.originalName),
                        type: convertTypeReference(pathParameter.valueType),
                        availability: undefined,
                        ...(pathParameter.explode !== undefined ? { explode: pathParameter.explode } : {})
                        // biome-ignore lint/suspicious/noExplicitAny: FDR SDK types don't include explode field yet
                    }) as any
            ),
            parts: convertHttpPath(channel.path)
        },
        headers: channel.headers.map(
            (header): FdrCjsSdk.api.v1.register.Header => ({
                key: header.name.wireValue,
                type: convertTypeReference(header.valueType),
                description: header.docs,
                availability: convertIrAvailability(header.availability)
            })
        ),
        queryParameters: channel.queryParameters.map(
            (queryParameter): FdrCjsSdk.api.v1.register.QueryParameter =>
                ({
                    description: queryParameter.docs ?? undefined,
                    key: queryParameter.name.wireValue,
                    type: convertTypeReference(queryParameter.valueType),
                    availability: convertIrAvailability(queryParameter.availability),
                    ...(queryParameter.explode !== undefined ? { explode: queryParameter.explode } : {})
                    // biome-ignore lint/suspicious/noExplicitAny: FDR SDK types don't include explode field yet
                }) as any
        ),
        messages: channel.messages.map(
            (message): FdrCjsSdk.api.v1.register.WebSocketMessage => ({
                type: FdrCjsSdk.api.v1.WebSocketMessageId(message.type),
                displayName: message.displayName,
                origin: message.origin,
                body: convertMessageBody(message.body),
                description: message.docs,
                availability: convertIrAvailability(message.availability)
            })
        ),
        examples
    };
}

function convertEndpointSecurity(
    security: Ir.http.HttpEndpointSecurityItem[] | undefined
): FdrCjsSdk.AuthSchemeId[] | undefined {
    if (security == null) {
        return undefined;
    }

    if (security.length === 0) {
        return [];
    }

    const authSchemeKeys = new Set(security.flatMap((item) => Object.keys(item)));

    return Array.from(authSchemeKeys).map((key) => FdrCjsSdk.AuthSchemeId(key));
}

export function convertIrAvailability(availability: Ir.Availability | undefined): FdrCjsSdk.Availability | undefined {
    if (availability == null) {
        return undefined;
    }
    switch (availability.status) {
        case "DEPRECATED":
            return FdrCjsSdk.Availability.Deprecated;
        case "PRE_RELEASE":
            return FdrCjsSdk.Availability.Beta;
        case "GENERAL_AVAILABILITY":
            return FdrCjsSdk.Availability.GenerallyAvailable;
        case "IN_DEVELOPMENT":
            return FdrCjsSdk.Availability.Beta;
        default:
            assertNever(availability.status);
    }
}

function convertIrEnvironments({
    environmentsConfig,
    endpoint
}: {
    environmentsConfig: Ir.environment.EnvironmentsConfig;
    endpoint: Ir.http.HttpEndpoint;
}): FdrCjsSdk.api.v1.commons.Environment[] {
    const environmentsConfigValue = environmentsConfig.environments;
    const endpointBaseUrlId = endpoint.baseUrl;
    const endpointBaseUrlIds = endpoint.v2BaseUrls;
    switch (environmentsConfigValue.type) {
        case "singleBaseUrl":
            return environmentsConfigValue.environments.map((singleBaseUrlEnvironment) => {
                return {
                    id: FdrCjsSdk.EnvironmentId(singleBaseUrlEnvironment.id),
                    baseUrl: singleBaseUrlEnvironment.url
                };
            });
        case "multipleBaseUrls":
            if (endpointBaseUrlIds != null) {
                const environments = endpointBaseUrlIds.flatMap((baseUrlId) => {
                    return environmentsConfigValue.environments.map((singleBaseUrlEnvironment) => {
                        const endpointBaseUrl = singleBaseUrlEnvironment.urls[baseUrlId];
                        if (endpointBaseUrl == null) {
                            throw new Error(
                                `Encountered undefined server name "${baseUrlId}" at endpoint ${endpoint.method.toUpperCase()} ${endpoint.path}. Expected environment ${singleBaseUrlEnvironment.id} to contain url for ${baseUrlId}`
                            );
                        }
                        return {
                            id: FdrCjsSdk.EnvironmentId(baseUrlId),
                            baseUrl: endpointBaseUrl
                        };
                    });
                });
                return environments.filter(
                    (environment, index, self) =>
                        index === self.findIndex((t) => t.id === environment.id && t.baseUrl === environment.baseUrl)
                );
            }
            if (endpointBaseUrlId == null) {
                throw new Error(`Expected endpoint ${endpoint.name.originalName} to have base url.`);
            }
            return environmentsConfigValue.environments.map((singleBaseUrlEnvironment) => {
                const endpointBaseUrl = singleBaseUrlEnvironment.urls[endpointBaseUrlId];
                if (endpointBaseUrl == null) {
                    throw new Error(
                        `Encountered undefined server name "${endpointBaseUrlId}" at endpoint ${endpoint.method.toUpperCase()} ${endpoint.path.head}. Expected environment ${singleBaseUrlEnvironment.id} to contain url for ${endpointBaseUrlId}`
                    );
                }
                return {
                    id: FdrCjsSdk.EnvironmentId(singleBaseUrlEnvironment.id),
                    baseUrl: endpointBaseUrl
                };
            });
        default:
            assertNever(environmentsConfigValue);
    }
}

function convertIrWebSocketEnvironments({
    environmentsConfig,
    channel
}: {
    environmentsConfig: Ir.environment.EnvironmentsConfig;
    channel: Ir.websocket.WebSocketChannel;
}): FdrCjsSdk.api.v1.commons.Environment[] {
    const environmentsConfigValue = environmentsConfig.environments;
    const channelBaseUrlId = channel.baseUrl;
    switch (environmentsConfigValue.type) {
        case "singleBaseUrl":
            return environmentsConfigValue.environments.map((singleBaseUrlEnvironment) => {
                return {
                    id: FdrCjsSdk.EnvironmentId(singleBaseUrlEnvironment.id),
                    baseUrl: replaceProtocol(singleBaseUrlEnvironment.url, "wss")
                };
            });
        case "multipleBaseUrls":
            if (channelBaseUrlId == null) {
                throw new Error(`Expected channel ${channel.name.originalName} to have base url.`);
            }
            return environmentsConfigValue.environments.map((singleBaseUrlEnvironment) => {
                const channelBaseUrl = singleBaseUrlEnvironment.urls[channelBaseUrlId];
                if (channelBaseUrl == null) {
                    throw new Error(
                        `Encountered undefined server name ${channelBaseUrl} at channel ${channel.name.originalName} ${channel.path.head}. Expected environment ${singleBaseUrlEnvironment.id} to contain url for ${channelBaseUrlId}`
                    );
                }
                return {
                    id: FdrCjsSdk.EnvironmentId(singleBaseUrlEnvironment.id),
                    baseUrl: channelBaseUrl
                };
            });
        default:
            assertNever(environmentsConfigValue);
    }
}

function replaceProtocol(url: string, protocol: string): string {
    return url.replace(/^[^:]+/, protocol);
}

function convertHttpMethod(method: Ir.http.HttpMethod): FdrCjsSdk.HttpMethod {
    return Ir.http.HttpMethod._visit<FdrCjsSdk.HttpMethod>(method, {
        get: () => FdrCjsSdk.HttpMethod.Get,
        post: () => FdrCjsSdk.HttpMethod.Post,
        put: () => FdrCjsSdk.HttpMethod.Put,
        patch: () => FdrCjsSdk.HttpMethod.Patch,
        delete: () => FdrCjsSdk.HttpMethod.Delete,
        head: () => FdrCjsSdk.HttpMethod.Head,
        _other: () => {
            throw new Error("Unknown http method: " + method);
        }
    });
}

function convertHttpPath(irPath: Ir.http.HttpPath): FdrCjsSdk.api.v1.register.EndpointPathPart[] {
    const endpointPaths: FdrCjsSdk.api.v1.register.EndpointPathPart[] = irPath.parts.flatMap((part) => [
        {
            type: "pathParameter",
            value: FdrCjsSdk.PropertyKey(part.pathParameter)
        },
        {
            type: "literal",
            value: part.tail
        }
    ]);
    return [
        {
            type: "literal",
            value: irPath.head
        },
        ...endpointPaths
    ];
}

function convertRequestBody(irRequest: Ir.http.HttpRequestBody): FdrCjsSdk.api.v1.register.HttpRequest | undefined {
    const requestBodyShape = Ir.http.HttpRequestBody._visit<FdrCjsSdk.api.v1.register.HttpRequestBodyShape | undefined>(
        irRequest,
        {
            inlinedRequestBody: (inlinedRequestBody): FdrCjsSdk.api.v1.register.HttpRequestBodyShape.Json => {
                return {
                    type: "json",
                    contentType: inlinedRequestBody.contentType ?? MediaType.APPLICATION_JSON,
                    shape: {
                        type: "object",
                        extends: inlinedRequestBody.extends.map((extension) => FdrCjsSdk.TypeId(extension.typeId)),
                        properties: inlinedRequestBody.properties.map(
                            (property): FdrCjsSdk.api.v1.register.ObjectProperty => ({
                                description: property.docs ?? undefined,
                                key: FdrCjsSdk.PropertyKey(property.name.wireValue),
                                valueType: convertTypeReference(property.valueType),
                                availability: convertIrAvailability(property.availability),
                                propertyAccess: property.propertyAccess
                            })
                        ),
                        extraProperties: inlinedRequestBody.extraProperties ? { type: "unknown" } : undefined
                    }

                    // TODO: add support for description in FDR SDK
                    // description: inlinedRequestBody.docs ?? undefined,
                };
            },
            reference: (reference) => {
                return {
                    type: "json",
                    contentType: reference.contentType ?? MediaType.APPLICATION_JSON,
                    shape: {
                        type: "reference",
                        value: convertTypeReference(reference.requestBodyType)
                    },
                    description: reference.docs ?? undefined
                };
            },
            fileUpload: (fileUpload) => ({
                type: "fileUpload",
                value: {
                    name: fileUpload.name.originalName,
                    // TODO: support description and availability
                    description: undefined,
                    availability: undefined,
                    properties: fileUpload.properties
                        .map((property) => {
                            return property._visit<FdrCjsSdk.api.v1.register.FormDataProperty | undefined>({
                                file: (file) => {
                                    const fileValue = file._visit<
                                        FdrCjsSdk.api.v1.register.FormDataFileProperty | undefined
                                    >({
                                        file: (singleFile) => ({
                                            type: "file",
                                            key: FdrCjsSdk.PropertyKey(singleFile.key.wireValue),
                                            isOptional: singleFile.isOptional,
                                            contentType: singleFile.contentType,
                                            description: singleFile.docs ?? undefined,
                                            availability: undefined
                                        }),
                                        fileArray: (multipleFiles) => ({
                                            type: "fileArray",
                                            key: FdrCjsSdk.PropertyKey(multipleFiles.key.wireValue),
                                            isOptional: multipleFiles.isOptional,
                                            contentType: multipleFiles.contentType,
                                            description: multipleFiles.docs ?? undefined,
                                            availability: undefined
                                        }),
                                        _other: () => undefined
                                    });
                                    if (fileValue == null) {
                                        return;
                                    }
                                    return { type: "file", value: fileValue };
                                },
                                bodyProperty: (bodyProperty) => ({
                                    type: "bodyProperty",
                                    key: FdrCjsSdk.PropertyKey(bodyProperty.name.wireValue),
                                    valueType: convertTypeReference(bodyProperty.valueType),
                                    contentType: bodyProperty.contentType,
                                    description: bodyProperty.docs ?? undefined,
                                    availability: convertIrAvailability(bodyProperty.availability),
                                    exploded: bodyProperty.style === "exploded",
                                    propertyAccess: undefined
                                }),
                                _other: () => undefined
                            });
                        })
                        .filter(isNonNullish)
                },
                contentType: fileUpload.contentType,
                description: fileUpload.docs ?? undefined
            }),
            bytes: (bytes) => ({
                type: "bytes",
                // TODO: support description and availability
                description: bytes.docs ?? undefined,
                availability: undefined,
                isOptional: bytes.isOptional,
                contentType: bytes.contentType
            }),
            _other: () => {
                throw new Error("Unknown HttpRequestBody: " + irRequest.type);
            }
        }
    );
    return requestBodyShape != null ? { type: requestBodyShape, description: irRequest.docs } : undefined;
}

function convertResponse(irResponse: Ir.http.HttpResponse): FdrCjsSdk.api.v1.register.HttpResponse | undefined {
    if (irResponse.body == null) {
        return undefined;
    }
    let description;
    const type = Ir.http.HttpResponseBody._visit<FdrCjsSdk.api.v1.register.HttpResponseBodyShape | undefined>(
        irResponse.body,
        {
            fileDownload: (fileDownload) => {
                description = fileDownload.docs;
                return {
                    type: "fileDownload",
                    contentType: undefined
                };
            },
            json: (jsonResponse) => {
                description = jsonResponse.docs;
                return {
                    type: "reference",
                    value: convertTypeReference(jsonResponse.responseBodyType)
                };
            },
            text: () => undefined, // TODO: support text/plain in FDR
            bytes: () => undefined, // TODO: support text/plain in FDR
            streamParameter: () => undefined, // TODO: support stream parameter in FDR
            streaming: (streamingResponse) => {
                if (streamingResponse.type === "text") {
                    description = streamingResponse.docs;
                    return {
                        type: "streamingText"
                    };
                } else if (streamingResponse.type === "json") {
                    description = streamingResponse.docs;
                    return {
                        type: "stream",
                        shape: { type: "reference", value: convertTypeReference(streamingResponse.payload) },
                        terminator: streamingResponse.terminator
                    };
                    // TODO(dsinghvi): update FDR with SSE.
                } else if (streamingResponse.type === "sse") {
                    description = streamingResponse.docs;
                    return {
                        type: "stream",
                        shape: { type: "reference", value: convertTypeReference(streamingResponse.payload) },
                        terminator: streamingResponse.terminator
                    };
                }

                return undefined;
            },
            _other: () => {
                throw new Error("Unknown HttpResponse: " + irResponse.body);
            }
        }
    );
    if (type != null) {
        return { type, statusCode: irResponse.statusCode, description };
    } else if (irResponse.statusCode != null) {
        return {
            statusCode: irResponse.statusCode,
            description,
            type: { type: "object", extends: [], properties: [], extraProperties: undefined }
        };
    } else {
        return undefined;
    }
}

function convertResponseErrorsV2(
    irResponseErrors: Ir.http.ResponseErrors,
    ir: IntermediateRepresentation
): FdrCjsSdk.api.v1.register.ErrorDeclarationV2[] {
    const errors: FdrCjsSdk.api.v1.register.ErrorDeclarationV2[] = [];
    if (ir.errorDiscriminationStrategy.type === "statusCode") {
        for (const irResponseError of irResponseErrors) {
            const errorDeclaration = ir.errors[irResponseError.error.errorId];
            if (errorDeclaration) {
                errors.push({
                    type:
                        errorDeclaration.type == null
                            ? undefined
                            : {
                                  type: "alias",
                                  value: convertTypeReference(errorDeclaration.type)
                              },
                    statusCode: errorDeclaration.statusCode,
                    description: errorDeclaration.docs ?? undefined,
                    name: errorDeclaration.displayName ?? errorDeclaration.name.name.originalName,
                    availability: undefined,
                    examples: getErrorExamplesFromDeclaration(errorDeclaration)
                });
            }
        }
    } else {
        for (const irResponseError of irResponseErrors) {
            const errorDeclaration = ir.errors[irResponseError.error.errorId];
            if (errorDeclaration) {
                const properties: FdrCjsSdk.api.v1.register.ObjectProperty[] = [
                    {
                        key: FdrCjsSdk.PropertyKey(ir.errorDiscriminationStrategy.discriminant.wireValue),
                        valueType: {
                            type: "literal",
                            value: {
                                type: "stringLiteral",
                                value: errorDeclaration.discriminantValue.name.originalName
                            }
                        },
                        description: errorDeclaration.docs,
                        availability: undefined,
                        propertyAccess: undefined
                    }
                ];

                if (errorDeclaration.type != null) {
                    properties.push({
                        key: FdrCjsSdk.PropertyKey(ir.errorDiscriminationStrategy.contentProperty.wireValue),
                        valueType: convertTypeReference(errorDeclaration.type),
                        description: errorDeclaration.docs,
                        availability: undefined,
                        propertyAccess: undefined
                    });
                }

                errors.push({
                    type:
                        errorDeclaration.type == null
                            ? undefined
                            : {
                                  type: "object",
                                  extends: [],
                                  properties,
                                  extraProperties: undefined
                              },
                    statusCode: errorDeclaration.statusCode,
                    description: errorDeclaration.docs ?? undefined,
                    availability: undefined,
                    name: errorDeclaration.displayName ?? errorDeclaration.name.name.originalName,
                    examples: errorDeclaration.examples.map((irExample) => {
                        return {
                            name: irExample.name?.originalName,
                            responseBody: { type: "json", value: irExample.jsonExample },
                            description: irExample.docs
                        };
                    })
                });
            }
        }
    }
    return errors;
}

function convertV2HttpEndpointExample({
    shouldUseExampleName,
    exampleName,
    example,
    irEndpoint,
    irService,
    ir
}: {
    shouldUseExampleName: boolean;
    exampleName: string;
    example: V2HttpEndpointExample;
    irEndpoint: Ir.http.HttpEndpoint;
    irService: Ir.http.HttpService;
    ir: Ir.ir.IntermediateRepresentation;
}): FdrCjsSdk.api.v1.register.ExampleEndpointCall | undefined {
    if (example == null) {
        return undefined;
    }

    // Extract literal values from headers (global + service + endpoint headers)
    const extractLiteralHeaderValue = (header: Ir.http.HttpHeader): string | undefined => {
        // Handle direct literal: container -> literal
        if (header.valueType.type === "container" && header.valueType.container.type === "literal") {
            return header.valueType.container.literal._visit({
                boolean: (val: boolean) => `${val}`,
                string: (val: string) => val,
                _other: () => undefined
            });
        }

        // Handle optional literal: container -> optional -> container -> literal
        if (
            header.valueType.type === "container" &&
            header.valueType.container.type === "optional" &&
            header.valueType.container.optional.type === "container" &&
            header.valueType.container.optional.container.type === "literal"
        ) {
            return header.valueType.container.optional.container.literal._visit({
                boolean: (val: boolean) => `${val}`,
                string: (val: string) => val,
                _other: () => undefined
            });
        }

        return undefined;
    };

    const requiredHeaders: Record<string, unknown> = {};

    // Process global headers
    ir.headers.forEach((header) => {
        const value = extractLiteralHeaderValue(header);
        if (value != null) {
            requiredHeaders[header.name.wireValue] = value;
        }
    });

    // Process service headers
    irService.headers.forEach((header) => {
        const value = extractLiteralHeaderValue(header);
        if (value != null) {
            requiredHeaders[header.name.wireValue] = value;
        }
    });

    // Process endpoint headers
    irEndpoint.headers.forEach((header) => {
        const value = extractLiteralHeaderValue(header);
        if (value != null) {
            requiredHeaders[header.name.wireValue] = value;
        }
    });

    const responseBodyValue = example.response?.body != null ? example.response.body.value : undefined;
    return {
        name: shouldUseExampleName ? exampleName : undefined,
        description: "",
        path: example.request?.endpoint.path ?? "",
        pathParameters: example.request?.pathParameters ?? {},
        queryParameters: example.request?.queryParameters ?? {},
        headers: (() => {
            const exampleHeaders = example.request?.headers ?? {};
            const mergedHeaders = { ...exampleHeaders };

            // Override null/undefined values with extracted literal values
            for (const [key, value] of Object.entries(requiredHeaders)) {
                if (mergedHeaders[key] === null || mergedHeaders[key] === undefined) {
                    mergedHeaders[key] = value;
                }
            }

            return mergedHeaders;
        })(),
        requestBody: example.request?.requestBody,
        requestBodyV3: irEndpoint.requestBody?._visit<FdrCjsSdk.api.v1.register.ExampleEndpointRequest | undefined>({
            inlinedRequestBody: () =>
                example.request != null ? { type: "json", value: example.request.requestBody } : undefined,
            reference: () =>
                example.request != null ? { type: "json", value: example.request.requestBody } : undefined,
            fileUpload: (fileUploadSchema) => {
                if (example.request == null) {
                    return undefined;
                }

                const value: Record<string, FdrCjsSdk.api.v1.register.FormValue> = {};

                if (isPlainObject(example.request.requestBody)) {
                    const fullExample = example.request.requestBody;
                    for (const property of fileUploadSchema.properties) {
                        property._visit({
                            file: (file) => {
                                const maybeFile = fullExample[file.key.wireValue];
                                // TODO: support filename with data in examples
                                if (file.type === "file") {
                                    value[file.key.wireValue] = {
                                        type: "filename",
                                        value: typeof maybeFile === "string" ? maybeFile : "<file1>"
                                    };
                                } else if (file.type === "fileArray") {
                                    const filenames = (Array.isArray(maybeFile) ? maybeFile : [maybeFile]).filter(
                                        (filename) => typeof filename === "string"
                                    ) as string[];
                                    value[file.key.wireValue] = {
                                        type: "filenames",
                                        value: filenames
                                    };
                                }
                            },
                            bodyProperty: (bodyProperty) => {
                                if (bodyProperty.style === "exploded") {
                                    const example = fullExample[bodyProperty.name.wireValue];
                                    value[bodyProperty.name.wireValue] = {
                                        type: "exploded",
                                        value: Array.isArray(example) ? example : [example]
                                    };
                                } else {
                                    value[bodyProperty.name.wireValue] = {
                                        type: "json",
                                        value: fullExample[bodyProperty.name.wireValue]
                                    };
                                }
                            },
                            _other: noop
                        });
                    }
                }

                return { type: "form", value };
            },
            // TODO: support bytes
            bytes: () => undefined,
            _other: () => undefined
        }),
        responseStatusCode: example.response?.statusCode ?? irEndpoint.response?.statusCode ?? 200,
        responseBody: responseBodyValue != null ? responseBodyValue : undefined,
        responseBodyV3:
            responseBodyValue != null
                ? example.response?.body?._visit<FdrCjsSdk.api.v1.register.ExampleEndpointResponse | undefined>({
                      json: (value: unknown) => {
                          return { type: "json", value };
                      },
                      stream: (value: unknown[]) => {
                          // If every value is an object with "event" and "data" properties, treat as SSE, else as stream
                          const isSse =
                              Array.isArray(value) && value.length > 0 && value.every(isExampleServerSentEvent);
                          if (isSse) {
                              return {
                                  type: "sse",
                                  value: value
                              };
                          } else {
                              return {
                                  type: "stream",
                                  value
                              };
                          }
                      },
                      error: () => {
                          return undefined;
                      },
                      _other: () => {
                          throw new Error("Unknown ExampleResponseBody: " + example.response?.body?.type);
                      }
                  })
                : undefined,
        codeSamples: example.codeSamples
            ?.map((codeSample) => ({
                name: codeSample.name,
                description: codeSample.docs ?? undefined,
                install: undefined,
                language: codeSample.language,
                code: codeSample.code
            }))
            .filter(isNonNullish)
    };
}

function isExampleServerSentEvent(obj: unknown): obj is { event: string; data: unknown } {
    return (
        typeof obj === "object" &&
        obj !== null &&
        "event" in obj &&
        // biome-ignore lint/suspicious/noExplicitAny: legacy type usage
        typeof (obj as any)?.event === "string" &&
        "data" in obj
    );
}

function convertHttpEndpointExample({
    userSpecifiedExample,
    autogeneratedExample,
    irEndpoint,
    ir
}: {
    userSpecifiedExample?: UserSpecifiedEndpointExample;
    autogeneratedExample?: AutogeneratedEndpointExample;
    irEndpoint: Ir.http.HttpEndpoint;
    ir: Ir.ir.IntermediateRepresentation;
}): FdrCjsSdk.api.v1.register.ExampleEndpointCall | undefined {
    const requiredGlobalHeaders: Ir.ExampleHeader[] = ir.headers
        .map((header) => {
            let value: string | undefined;

            // Handle direct literal: container -> literal
            if (header.valueType.type === "container" && header.valueType.container.type === "literal") {
                value = header.valueType.container.literal._visit<string | undefined>({
                    boolean: (val) => `${val}`,
                    string: (val) => val,
                    _other: () => undefined
                });
            }
            // Handle optional literal: container -> optional -> container -> literal
            else if (
                header.valueType.type === "container" &&
                header.valueType.container.type === "optional" &&
                header.valueType.container.optional.type === "container" &&
                header.valueType.container.optional.container.type === "literal"
            ) {
                value = header.valueType.container.optional.container.literal._visit<string | undefined>({
                    boolean: (val) => `${val}`,
                    string: (val) => val,
                    _other: () => undefined
                });
            }
            if (value != null) {
                return {
                    name: header.name,
                    value: {
                        jsonExample: value,
                        shape: Ir.ExampleTypeReferenceShape.primitive(Ir.ExamplePrimitive.string({ original: value }))
                    }
                };
            }
            return undefined;
        })
        .filter(isNonNullish);
    const example = userSpecifiedExample?.example ?? autogeneratedExample?.example;
    if (example == null) {
        return undefined;
    }
    const { codeSamples } = userSpecifiedExample ?? { codeSamples: [] };
    return {
        name: example.name?.originalName,
        description: example.docs,
        path: example.url,
        pathParameters: [
            ...example.rootPathParameters,
            ...example.servicePathParameters,
            ...example.endpointPathParameters
        ].reduce<FdrCjsSdk.api.v1.register.ExampleEndpointCall["pathParameters"]>(
            (pathParameters, irPathParameterExample) => {
                pathParameters[FdrCjsSdk.PropertyKey(irPathParameterExample.name.originalName)] =
                    irPathParameterExample.value.jsonExample;
                return pathParameters;
            },
            {}
        ),
        queryParameters: example.queryParameters.reduce<
            FdrCjsSdk.api.v1.register.ExampleEndpointCall["queryParameters"]
        >((queryParameters, irQueryParameterExample) => {
            queryParameters[irQueryParameterExample.name.wireValue] = irQueryParameterExample.value.jsonExample;
            return queryParameters;
        }, {}),
        headers: [...requiredGlobalHeaders, ...example.serviceHeaders, ...example.endpointHeaders].reduce<
            FdrCjsSdk.api.v1.register.ExampleEndpointCall["headers"]
        >((headers, irHeaderExample) => {
            headers[irHeaderExample.name.wireValue] = irHeaderExample.value.jsonExample;
            return headers;
        }, {}),
        requestBody: example.request?.jsonExample,
        requestBodyV3: irEndpoint.requestBody?._visit<FdrCjsSdk.api.v1.register.ExampleEndpointRequest | undefined>({
            inlinedRequestBody: () =>
                example.request != null ? { type: "json", value: example.request.jsonExample } : undefined,
            reference: () =>
                example.request != null ? { type: "json", value: example.request.jsonExample } : undefined,
            fileUpload: (fileUploadSchema) => {
                if (example.request == null) {
                    return undefined;
                }

                const value: Record<string, FdrCjsSdk.api.v1.register.FormValue> = {};

                if (isPlainObject(example.request.jsonExample)) {
                    const fullExample = example.request.jsonExample;
                    for (const property of fileUploadSchema.properties) {
                        property._visit({
                            file: (file) => {
                                const maybeFile = fullExample[file.key.wireValue];
                                // TODO: support filename with data in examples
                                if (file.type === "file") {
                                    value[file.key.wireValue] = {
                                        type: "filename",
                                        value: typeof maybeFile === "string" ? maybeFile : "<file1>"
                                    };
                                } else if (file.type === "fileArray") {
                                    const filenames = (Array.isArray(maybeFile) ? maybeFile : [maybeFile]).filter(
                                        (filename) => typeof filename === "string"
                                    ) as string[];
                                    value[file.key.wireValue] = {
                                        type: "filenames",
                                        value: filenames
                                    };
                                }
                            },
                            bodyProperty: (bodyProperty) => {
                                if (bodyProperty.style === "exploded") {
                                    const example = fullExample[bodyProperty.name.wireValue];
                                    value[bodyProperty.name.wireValue] = {
                                        type: "exploded",
                                        value: Array.isArray(example) ? example : [example]
                                    };
                                } else {
                                    value[bodyProperty.name.wireValue] = {
                                        type: "json",
                                        value: fullExample[bodyProperty.name.wireValue]
                                    };
                                }
                            },
                            _other: noop
                        });
                    }
                }

                return { type: "form", value };
            },
            // TODO: support bytes
            bytes: () => undefined,
            _other: () => undefined
        }),
        responseStatusCode:
            irEndpoint.response?.statusCode ??
            Ir.http.ExampleResponse._visit(example.response, {
                ok: (ok) =>
                    ok._visit({
                        body: (body) => (body != null ? 200 : 204),
                        stream: (stream) => (stream.length > 0 ? 200 : 204),
                        sse: (stream) => (stream.length > 0 ? 200 : 204),
                        _other: () => {
                            throw new Error("Unknown ExampleResponseBody: " + ok.type);
                        }
                    }),
                error: ({ error: errorName }) => {
                    const error = ir.errors[errorName.errorId];
                    if (error == null) {
                        throw new Error("Cannot find error " + errorName.errorId);
                    }
                    return error.statusCode;
                },
                _other: () => {
                    throw new Error("Unknown ExampleResponse: " + example.response.type);
                }
            }),
        responseBody: example.response._visit({
            ok: (ok) =>
                ok._visit({
                    body: (body) => body?.jsonExample,
                    stream: () => undefined,
                    sse: () => undefined,
                    _other: () => undefined
                }),
            error: (error) => error.body?.jsonExample,
            _other: () => undefined
        }),
        responseBodyV3: example.response._visit<FdrCjsSdk.api.v1.register.ExampleEndpointResponse | undefined>({
            ok: (ok) =>
                ok._visit<FdrCjsSdk.api.v1.register.ExampleEndpointResponse | undefined>({
                    body: (body) => (body != null ? { type: "json", value: body.jsonExample } : undefined),
                    stream: (stream) => ({ type: "stream", value: stream.map((stream) => stream.jsonExample) }),
                    sse: (sse) => ({
                        type: "sse",
                        value: sse.map(({ event, data }) => ({ event, data: data.jsonExample }))
                    }),
                    _other: () => {
                        throw new Error("Unknown ExampleResponseBody: " + ok.type);
                    }
                }),
            error: (error) => (error.body != null ? { type: "json", value: error.body.jsonExample } : undefined),
            _other: () => {
                throw new Error("Unknown ExampleResponse: " + example.response.type);
            }
        }),
        // irExample.response.body != null ? { type: "json", value: irExample.response.body.jsonExample } : undefined,
        codeSamples: codeSamples
            ?.map((codeSample) =>
                ExampleCodeSample._visit<FdrCjsSdk.api.v1.register.CustomCodeSample | undefined>(codeSample, {
                    language: (value) => ({
                        language: value.language,
                        code: value.code,
                        name: value.name?.originalName,
                        description: value.docs ?? undefined,
                        install: value.install
                    }),
                    sdk: (value) => ({
                        // TODO: switch to storing as SDK
                        language: value.sdk,
                        code: value.code,
                        name: value.name?.originalName,
                        description: value.docs ?? undefined,
                        install: undefined
                    }),
                    _other: () => undefined
                })
            )
            .filter(isNonNullish)
    };
}

function convertWebhookPayload(irWebhookPayload: Ir.webhooks.WebhookPayload): FdrCjsSdk.api.v1.register.WebhookPayload {
    switch (irWebhookPayload.type) {
        case "inlinedPayload":
            return {
                type: {
                    type: "object",
                    extends: irWebhookPayload.extends.map((extension) => FdrCjsSdk.TypeId(extension.typeId)),
                    properties: irWebhookPayload.properties.map(
                        (property): FdrCjsSdk.api.v1.register.ObjectProperty => ({
                            description: property.docs ?? undefined,
                            key: FdrCjsSdk.PropertyKey(property.name.wireValue),
                            valueType: convertTypeReference(property.valueType),
                            availability: convertIrAvailability(property.availability),
                            propertyAccess: undefined
                        })
                    ),
                    // TODO: add support for extraProperties in IR
                    extraProperties: undefined
                },
                description: undefined
            };
        case "reference":
            return {
                type: {
                    type: "reference",
                    value: convertTypeReference(irWebhookPayload.payloadType)
                },
                description: irWebhookPayload.docs
            };
        default:
            assertNever(irWebhookPayload);
    }
}

function convertMessageBody(
    irWebSocketBody: Ir.websocket.WebSocketMessageBody
): FdrCjsSdk.api.v1.register.WebSocketMessageBodyShape {
    switch (irWebSocketBody.type) {
        case "inlinedBody":
            return {
                type: "object",
                extends: irWebSocketBody.extends.map((extension) => FdrCjsSdk.TypeId(extension.typeId)),
                properties: irWebSocketBody.properties.map(
                    (property): FdrCjsSdk.api.v1.register.ObjectProperty => ({
                        description: property.docs ?? undefined,
                        key: FdrCjsSdk.PropertyKey(property.name.wireValue),
                        valueType: convertTypeReference(property.valueType),
                        availability: convertIrAvailability(property.availability),
                        propertyAccess: undefined
                    })
                ),
                // TODO: add support for extraProperties in IR
                extraProperties: undefined
            };
        case "reference":
            return {
                type: "reference",
                value: convertTypeReference(irWebSocketBody.bodyType)
            };
        default:
            assertNever(irWebSocketBody);
    }
}

function getErrorExamplesFromDeclaration(
    errorDeclaration: Ir.ErrorDeclaration
): FdrCjsSdk.api.v1.register.ErrorExample[] {
    const v2UserSpecifiedExamples = errorDeclaration.v2Examples?.userSpecifiedExamples;
    const v2AutogeneratedExamples = errorDeclaration.v2Examples?.autogeneratedExamples;
    const v1Examples = errorDeclaration.examples;

    if (v2UserSpecifiedExamples != null && Object.keys(v2UserSpecifiedExamples).length > 0) {
        return Object.entries(v2UserSpecifiedExamples).map(([name, example]) => ({
            name,
            responseBody: { type: "json" as const, value: example },
            description: undefined
        }));
    } else if (v2AutogeneratedExamples != null && Object.keys(v2AutogeneratedExamples).length > 0) {
        return Object.entries(v2AutogeneratedExamples).map(([name, example]) => ({
            name,
            responseBody: { type: "json" as const, value: example },
            description: undefined
        }));
    } else if (v1Examples.length > 0) {
        return v1Examples.map((irExample) => ({
            name: irExample.name?.originalName,
            responseBody: { type: "json" as const, value: irExample.jsonExample },
            description: irExample.docs
        }));
    }

    return [];
}

// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`fern generate with settings > dependencies-based api 1`] = `
[
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

from .resources import spec_1, spec_2

__all__ = ["spec_1", "spec_2"]
",
    "name": "__init__.py",
    "type": "file",
  },
  {
    "contents": [
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

from .datetime_utils import serialize_datetime
from .pydantic_utilities import (
    IS_PYDANTIC_V2,
    UniversalBaseModel,
    UniversalRootModel,
    deep_union_pydantic_dicts,
    parse_obj_as,
    universal_field_validator,
    universal_root_validator,
    update_forward_refs,
)

__all__ = [
    "IS_PYDANTIC_V2",
    "UniversalBaseModel",
    "UniversalRootModel",
    "deep_union_pydantic_dicts",
    "parse_obj_as",
    "serialize_datetime",
    "universal_field_validator",
    "universal_root_validator",
    "update_forward_refs",
]
",
        "name": "__init__.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

import datetime as dt


def serialize_datetime(v: dt.datetime) -> str:
    """
    Serialize a datetime including timezone info.

    Uses the timezone info provided if present, otherwise uses the current runtime's timezone info.

    UTC datetimes end in "Z" while all other timezones are represented as offset from UTC, e.g. +05:00.
    """

    def _serialize_zoned_datetime(v: dt.datetime) -> str:
        if v.tzinfo is not None and v.tzinfo.tzname(None) == dt.timezone.utc.tzname(None):
            # UTC is a special case where we use "Z" at the end instead of "+00:00"
            return v.isoformat().replace("+00:00", "Z")
        else:
            # Delegate to the typical +/- offset format
            return v.isoformat()

    if v.tzinfo is not None:
        return _serialize_zoned_datetime(v)
    else:
        local_tz = dt.datetime.now().astimezone().tzinfo
        localized_dt = v.replace(tzinfo=local_tz)
        return _serialize_zoned_datetime(localized_dt)
",
        "name": "datetime_utils.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

# nopycln: file
import datetime as dt
import typing
from collections import defaultdict
from functools import wraps

import pydantic

from .datetime_utils import serialize_datetime

IS_PYDANTIC_V2 = pydantic.VERSION.startswith("2.")

if IS_PYDANTIC_V2:
    # isort will try to reformat the comments on these imports, which breaks mypy
    # isort: off
    from pydantic.v1.datetime_parse import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_date as parse_date,
    )
    from pydantic.v1.datetime_parse import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_datetime as parse_datetime,
    )
    from pydantic.v1.json import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        ENCODERS_BY_TYPE as encoders_by_type,
    )
    from pydantic.v1.typing import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        get_args as get_args,
    )
    from pydantic.v1.typing import get_origin as get_origin  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.typing import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        is_literal_type as is_literal_type,
    )
    from pydantic.v1.typing import is_union as is_union  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.fields import ModelField as ModelField  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
else:
    from pydantic.datetime_parse import parse_date as parse_date  # type: ignore # Pydantic v1
    from pydantic.datetime_parse import parse_datetime as parse_datetime  # type: ignore # Pydantic v1
    from pydantic.fields import ModelField as ModelField  # type: ignore # Pydantic v1
    from pydantic.json import ENCODERS_BY_TYPE as encoders_by_type  # type: ignore # Pydantic v1
    from pydantic.typing import get_args as get_args  # type: ignore # Pydantic v1
    from pydantic.typing import get_origin as get_origin  # type: ignore # Pydantic v1
    from pydantic.typing import is_literal_type as is_literal_type  # type: ignore # Pydantic v1
    from pydantic.typing import is_union as is_union  # type: ignore # Pydantic v1

    # isort: on


T = typing.TypeVar("T")
Model = typing.TypeVar("Model", bound=pydantic.BaseModel)


def deep_union_pydantic_dicts(
    source: typing.Dict[str, typing.Any], destination: typing.Dict[str, typing.Any]
) -> typing.Dict[str, typing.Any]:
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            deep_union_pydantic_dicts(value, node)
        else:
            destination[key] = value

    return destination


def parse_obj_as(type_: typing.Type[T], object_: typing.Any) -> T:
    if IS_PYDANTIC_V2:
        adapter = pydantic.TypeAdapter(type_)  # type: ignore # Pydantic v2
        return adapter.validate_python(object_)
    else:
        return pydantic.parse_obj_as(type_, object_)


def to_jsonable_with_fallback(
    obj: typing.Any, fallback_serializer: typing.Callable[[typing.Any], typing.Any]
) -> typing.Any:
    if IS_PYDANTIC_V2:
        from pydantic_core import to_jsonable_python

        return to_jsonable_python(obj, fallback=fallback_serializer)
    else:
        return fallback_serializer(obj)


class UniversalBaseModel(pydantic.BaseModel):
    class Config:
        populate_by_name = True
        smart_union = True
        allow_population_by_field_name = True
        json_encoders = {dt.datetime: serialize_datetime}

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        if IS_PYDANTIC_V2:
            return super().model_dump_json(**kwargs_with_defaults)  # type: ignore # Pydantic v2
        else:
            return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        if IS_PYDANTIC_V2:
            return deep_union_pydantic_dicts(
                super().model_dump(**kwargs_with_defaults_exclude_unset),  # type: ignore # Pydantic v2
                super().model_dump(**kwargs_with_defaults_exclude_none),  # type: ignore # Pydantic v2
            )
        else:
            return deep_union_pydantic_dicts(
                super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
            )


UniversalRootModel: typing.Type[typing.Any]
if IS_PYDANTIC_V2:

    class V2RootModel(UniversalBaseModel, pydantic.RootModel):  # type: ignore # Pydantic v2
        pass

    UniversalRootModel = V2RootModel
else:
    UniversalRootModel = UniversalBaseModel


def encode_by_type(o: typing.Any) -> typing.Any:
    encoders_by_class_tuples: typing.Dict[
        typing.Callable[[typing.Any], typing.Any], typing.Tuple[typing.Any, ...]
    ] = defaultdict(tuple)
    for type_, encoder in encoders_by_type.items():
        encoders_by_class_tuples[encoder] += (type_,)

    if type(o) in encoders_by_type:
        return encoders_by_type[type(o)](o)
    for encoder, classes_tuple in encoders_by_class_tuples.items():
        if isinstance(o, classes_tuple):
            return encoder(o)


def update_forward_refs(model: typing.Type["Model"], **localns: typing.Any) -> None:
    if IS_PYDANTIC_V2:
        model.model_rebuild(force=True)  # type: ignore # Pydantic v2
    else:
        model.update_forward_refs(**localns)


# Mirrors Pydantic's internal typing
AnyCallable = typing.Callable[..., typing.Any]


def universal_root_validator(pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.model_validator("before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.root_validator(pre=pre)(func)  # type: ignore # Pydantic v1

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator


def universal_field_validator(field_name: str, pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.field_validator(field_name, mode="before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.validator(field_name, pre=pre)(func)

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator
",
        "name": "pydantic_utilities.py",
        "type": "file",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  {
    "contents": [
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

from . import spec_1, spec_2

__all__ = ["spec_1", "spec_2"]
",
        "name": "__init__.py",
        "type": "file",
      },
      {
        "contents": [
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

from .booking import Booking
from .booking_payment import BookingPayment
from .booking_payment_currency import BookingPaymentCurrency
from .booking_payment_source import BookingPaymentSource
from .booking_payment_source_account_type import BookingPaymentSourceAccountType
from .booking_payment_source_account_type_account_type import BookingPaymentSourceAccountTypeAccountType
from .booking_payment_status import BookingPaymentStatus
from .card import Card
from .links_booking import LinksBooking
from .links_pagination import LinksPagination
from .links_self import LinksSelf
from .oauth_scope import OauthScope
from .station import Station
from .trip import Trip
from .wrapper_collection import WrapperCollection

__all__ = [
    "Booking",
    "BookingPayment",
    "BookingPaymentCurrency",
    "BookingPaymentSource",
    "BookingPaymentSourceAccountType",
    "BookingPaymentSourceAccountTypeAccountType",
    "BookingPaymentStatus",
    "Card",
    "LinksBooking",
    "LinksPagination",
    "LinksSelf",
    "OauthScope",
    "Station",
    "Trip",
    "WrapperCollection",
]
",
            "name": "__init__.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Booking(UniversalBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unique identifier for the booking
    """

    trip_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Identifier of the booked trip
    """

    passenger_name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of the passenger
    """

    has_bicycle: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Indicates whether the passenger has a bicycle.
    """

    has_dog: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Indicates whether the passenger has a dog.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "booking.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .booking_payment_currency import BookingPaymentCurrency
from .booking_payment_source import BookingPaymentSource
from .booking_payment_status import BookingPaymentStatus


class BookingPayment(UniversalBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unique identifier for the payment. This will be a unique identifier for the payment, and is used to reference the payment in other objects.
    """

    amount: typing.Optional[float] = pydantic.Field(default=None)
    """
    Amount intended to be collected by this payment. A positive decimal figure describing the amount to be collected.
    """

    currency: typing.Optional[BookingPaymentCurrency] = pydantic.Field(default=None)
    """
    Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
    """

    source: typing.Optional[BookingPaymentSource] = pydantic.Field(default=None)
    """
    The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
    """

    status: typing.Optional[BookingPaymentStatus] = pydantic.Field(default=None)
    """
    The status of the payment, one of \`pending\`, \`succeeded\`, or \`failed\`.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "booking_payment.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

BookingPaymentCurrency = typing.Union[
    typing.Literal["bam", "bgn", "chf", "eur", "gbp", "nok", "sek", "try"], typing.Any
]
",
            "name": "booking_payment_currency.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

from .booking_payment_source_account_type import BookingPaymentSourceAccountType
from .card import Card

BookingPaymentSource = typing.Union[Card, BookingPaymentSourceAccountType]
",
            "name": "booking_payment_source.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .booking_payment_source_account_type_account_type import BookingPaymentSourceAccountTypeAccountType


class BookingPaymentSourceAccountType(UniversalBaseModel):
    """
    A bank account to take payment from. Must be able to make payments in the currency specified in the payment.
    """

    object: typing.Optional[typing.Literal["bank_account"]] = None
    name: str
    number: str = pydantic.Field()
    """
    The account number for the bank account, in string form. Must be a current account.
    """

    sort_code: typing.Optional[str] = pydantic.Field(default=None)
    """
    The sort code for the bank account, in string form. Must be a six-digit number.
    """

    account_type: BookingPaymentSourceAccountTypeAccountType = pydantic.Field()
    """
    The type of entity that holds the account. This can be either \`individual\` or \`company\`.
    """

    bank_name: str = pydantic.Field()
    """
    The name of the bank associated with the routing number.
    """

    country: str = pydantic.Field()
    """
    Two-letter country code (ISO 3166-1 alpha-2).
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "booking_payment_source_account_type.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

BookingPaymentSourceAccountTypeAccountType = typing.Union[typing.Literal["individual", "company"], typing.Any]
",
            "name": "booking_payment_source_account_type_account_type.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

BookingPaymentStatus = typing.Union[typing.Literal["pending", "succeeded", "failed"], typing.Any]
",
            "name": "booking_payment_status.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Card(UniversalBaseModel):
    """
    A card (debit or credit) to take payment from.
    """

    object: typing.Optional[typing.Literal["card"]] = None
    name: str = pydantic.Field()
    """
    Cardholder's full name as it appears on the card.
    """

    number: str = pydantic.Field()
    """
    The card number, as a string without any separators. On read all but the last four digits will be masked for security.
    """

    cvc: int = pydantic.Field()
    """
    Card security code, 3 or 4 digits usually found on the back of the card.
    """

    exp_month: int = pydantic.Field()
    """
    Two-digit number representing the card's expiration month.
    """

    exp_year: int = pydantic.Field()
    """
    Four-digit number representing the card's expiration year.
    """

    address_line_1: typing.Optional[str] = pydantic.Field(alias="address_line1", default=None)
    address_line_2: typing.Optional[str] = pydantic.Field(alias="address_line2", default=None)
    address_city: typing.Optional[str] = None
    address_country: str
    address_post_code: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "card.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class LinksBooking(UniversalBaseModel):
    booking: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "links_booking.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class LinksPagination(UniversalBaseModel):
    next: typing.Optional[str] = None
    prev: typing.Optional[str] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "links_pagination.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class LinksSelf(UniversalBaseModel):
    self_: typing.Optional[str] = pydantic.Field(alias="self", default=None)

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "links_self.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

OauthScope = typing.Union[typing.Literal["read", "write"], typing.Any]
",
            "name": "oauth_scope.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Station(UniversalBaseModel):
    id: str = pydantic.Field()
    """
    Unique identifier for the station.
    """

    name: str = pydantic.Field()
    """
    The name of the station
    """

    address: str = pydantic.Field()
    """
    The address of the station.
    """

    country_code: str = pydantic.Field()
    """
    The country code of the station.
    """

    timezone: typing.Optional[str] = pydantic.Field(default=None)
    """
    The timezone of the station in the [IANA Time Zone Database format](https://www.iana.org/time-zones).
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "station.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Trip(UniversalBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unique identifier for the trip
    """

    origin: typing.Optional[str] = pydantic.Field(default=None)
    """
    The starting station of the trip
    """

    destination: typing.Optional[str] = pydantic.Field(default=None)
    """
    The destination station of the trip
    """

    departure_time: typing.Optional[dt.datetime] = pydantic.Field(default=None)
    """
    The date and time when the trip departs
    """

    arrival_time: typing.Optional[dt.datetime] = pydantic.Field(default=None)
    """
    The date and time when the trip arrives
    """

    operator: typing.Optional[str] = pydantic.Field(default=None)
    """
    The name of the operator of the trip
    """

    price: typing.Optional[float] = pydantic.Field(default=None)
    """
    The cost of the trip
    """

    bicycles_allowed: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Indicates whether bicycles are allowed on the trip
    """

    dogs_allowed: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Indicates whether dogs are allowed on the trip
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "trip.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class WrapperCollection(UniversalBaseModel):
    """
    This is a generic request/response wrapper which contains both data and links which serve as hypermedia controls (HATEOAS).
    """

    data: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = pydantic.Field(default=None)
    """
    The wrapper for a collection is an array of objects.
    """

    links: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(default=None)
    """
    A set of hypermedia links which serve as controls for the client.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "wrapper_collection.py",
            "type": "file",
          },
        ],
        "name": "spec_1",
        "type": "directory",
      },
      {
        "contents": [
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

from .error import Error
from .file import File
from .prediction import Prediction
from .results import Results
from .source import Source
from .source_file import SourceFile
from .source_result import SourceResult
from .source_url import SourceUrl
from .url import Url

__all__ = ["Error", "File", "Prediction", "Results", "Source", "SourceFile", "SourceResult", "SourceUrl", "Url"]
",
            "name": "__init__.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Error(UniversalBaseModel):
    message: str = pydantic.Field()
    """
    An error message.
    """

    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "error.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class File(UniversalBaseModel):
    filename: typing.Optional[str] = pydantic.Field(default=None)
    """
    The name of the file.
    """

    content_type: typing.Optional[str] = pydantic.Field(default=None)
    """
    The content type of the file.
    """

    md_5_sum: str = pydantic.Field(alias="md5sum")
    """
    The MD5 checksum of the file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "file.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Prediction(UniversalBaseModel):
    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "prediction.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .error import Error
from .prediction import Prediction


class Results(UniversalBaseModel):
    predictions: typing.List[Prediction]
    errors: typing.List[Error]

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "results.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

from .source_file import SourceFile
from .source_url import SourceUrl

Source = typing.Union[SourceUrl, SourceFile]
",
            "name": "source.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2
from .file import File


class SourceFile(File):
    type: typing.Literal["file"] = "file"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "source_file.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .results import Results
from .source import Source


class SourceResult(UniversalBaseModel):
    source: Source
    results: typing.Optional[Results] = None
    error: typing.Optional[str] = pydantic.Field(default=None)
    """
    An error message.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "source_result.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2
from .url import Url


class SourceUrl(Url):
    type: typing.Literal["url"] = "url"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "source_url.py",
            "type": "file",
          },
          {
            "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Url(UniversalBaseModel):
    url: str = pydantic.Field()
    """
    The URL of the source media file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
            "name": "url.py",
            "type": "file",
          },
        ],
        "name": "spec_2",
        "type": "directory",
      },
    ],
    "name": "resources",
    "type": "directory",
  },
]
`;

exports[`fern generate with settings > single api 1`] = `
[
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

from .error import Error
from .file import File
from .prediction import Prediction
from .results import Results
from .source import Source
from .source_file import SourceFile
from .source_result import SourceResult
from .source_url import SourceUrl
from .url import Url

__all__ = ["Error", "File", "Prediction", "Results", "Source", "SourceFile", "SourceResult", "SourceUrl", "Url"]
",
    "name": "__init__.py",
    "type": "file",
  },
  {
    "contents": [
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

from .datetime_utils import serialize_datetime
from .pydantic_utilities import (
    IS_PYDANTIC_V2,
    UniversalBaseModel,
    UniversalRootModel,
    deep_union_pydantic_dicts,
    parse_obj_as,
    universal_field_validator,
    universal_root_validator,
    update_forward_refs,
)

__all__ = [
    "IS_PYDANTIC_V2",
    "UniversalBaseModel",
    "UniversalRootModel",
    "deep_union_pydantic_dicts",
    "parse_obj_as",
    "serialize_datetime",
    "universal_field_validator",
    "universal_root_validator",
    "update_forward_refs",
]
",
        "name": "__init__.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

import datetime as dt


def serialize_datetime(v: dt.datetime) -> str:
    """
    Serialize a datetime including timezone info.

    Uses the timezone info provided if present, otherwise uses the current runtime's timezone info.

    UTC datetimes end in "Z" while all other timezones are represented as offset from UTC, e.g. +05:00.
    """

    def _serialize_zoned_datetime(v: dt.datetime) -> str:
        if v.tzinfo is not None and v.tzinfo.tzname(None) == dt.timezone.utc.tzname(None):
            # UTC is a special case where we use "Z" at the end instead of "+00:00"
            return v.isoformat().replace("+00:00", "Z")
        else:
            # Delegate to the typical +/- offset format
            return v.isoformat()

    if v.tzinfo is not None:
        return _serialize_zoned_datetime(v)
    else:
        local_tz = dt.datetime.now().astimezone().tzinfo
        localized_dt = v.replace(tzinfo=local_tz)
        return _serialize_zoned_datetime(localized_dt)
",
        "name": "datetime_utils.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

# nopycln: file
import datetime as dt
import typing
from collections import defaultdict
from functools import wraps

import pydantic

from .datetime_utils import serialize_datetime

IS_PYDANTIC_V2 = pydantic.VERSION.startswith("2.")

if IS_PYDANTIC_V2:
    # isort will try to reformat the comments on these imports, which breaks mypy
    # isort: off
    from pydantic.v1.datetime_parse import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_date as parse_date,
    )
    from pydantic.v1.datetime_parse import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_datetime as parse_datetime,
    )
    from pydantic.v1.json import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        ENCODERS_BY_TYPE as encoders_by_type,
    )
    from pydantic.v1.typing import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        get_args as get_args,
    )
    from pydantic.v1.typing import get_origin as get_origin  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.typing import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        is_literal_type as is_literal_type,
    )
    from pydantic.v1.typing import is_union as is_union  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.fields import ModelField as ModelField  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
else:
    from pydantic.datetime_parse import parse_date as parse_date  # type: ignore # Pydantic v1
    from pydantic.datetime_parse import parse_datetime as parse_datetime  # type: ignore # Pydantic v1
    from pydantic.fields import ModelField as ModelField  # type: ignore # Pydantic v1
    from pydantic.json import ENCODERS_BY_TYPE as encoders_by_type  # type: ignore # Pydantic v1
    from pydantic.typing import get_args as get_args  # type: ignore # Pydantic v1
    from pydantic.typing import get_origin as get_origin  # type: ignore # Pydantic v1
    from pydantic.typing import is_literal_type as is_literal_type  # type: ignore # Pydantic v1
    from pydantic.typing import is_union as is_union  # type: ignore # Pydantic v1

    # isort: on


T = typing.TypeVar("T")
Model = typing.TypeVar("Model", bound=pydantic.BaseModel)


def deep_union_pydantic_dicts(
    source: typing.Dict[str, typing.Any], destination: typing.Dict[str, typing.Any]
) -> typing.Dict[str, typing.Any]:
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            deep_union_pydantic_dicts(value, node)
        else:
            destination[key] = value

    return destination


def parse_obj_as(type_: typing.Type[T], object_: typing.Any) -> T:
    if IS_PYDANTIC_V2:
        adapter = pydantic.TypeAdapter(type_)  # type: ignore # Pydantic v2
        return adapter.validate_python(object_)
    else:
        return pydantic.parse_obj_as(type_, object_)


def to_jsonable_with_fallback(
    obj: typing.Any, fallback_serializer: typing.Callable[[typing.Any], typing.Any]
) -> typing.Any:
    if IS_PYDANTIC_V2:
        from pydantic_core import to_jsonable_python

        return to_jsonable_python(obj, fallback=fallback_serializer)
    else:
        return fallback_serializer(obj)


class UniversalBaseModel(pydantic.BaseModel):
    class Config:
        populate_by_name = True
        smart_union = True
        allow_population_by_field_name = True
        json_encoders = {dt.datetime: serialize_datetime}

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        if IS_PYDANTIC_V2:
            return super().model_dump_json(**kwargs_with_defaults)  # type: ignore # Pydantic v2
        else:
            return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        if IS_PYDANTIC_V2:
            return deep_union_pydantic_dicts(
                super().model_dump(**kwargs_with_defaults_exclude_unset),  # type: ignore # Pydantic v2
                super().model_dump(**kwargs_with_defaults_exclude_none),  # type: ignore # Pydantic v2
            )
        else:
            return deep_union_pydantic_dicts(
                super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
            )


UniversalRootModel: typing.Type[typing.Any]
if IS_PYDANTIC_V2:

    class V2RootModel(UniversalBaseModel, pydantic.RootModel):  # type: ignore # Pydantic v2
        pass

    UniversalRootModel = V2RootModel
else:
    UniversalRootModel = UniversalBaseModel


def encode_by_type(o: typing.Any) -> typing.Any:
    encoders_by_class_tuples: typing.Dict[
        typing.Callable[[typing.Any], typing.Any], typing.Tuple[typing.Any, ...]
    ] = defaultdict(tuple)
    for type_, encoder in encoders_by_type.items():
        encoders_by_class_tuples[encoder] += (type_,)

    if type(o) in encoders_by_type:
        return encoders_by_type[type(o)](o)
    for encoder, classes_tuple in encoders_by_class_tuples.items():
        if isinstance(o, classes_tuple):
            return encoder(o)


def update_forward_refs(model: typing.Type["Model"], **localns: typing.Any) -> None:
    if IS_PYDANTIC_V2:
        model.model_rebuild(force=True)  # type: ignore # Pydantic v2
    else:
        model.update_forward_refs(**localns)


# Mirrors Pydantic's internal typing
AnyCallable = typing.Callable[..., typing.Any]


def universal_root_validator(pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.model_validator("before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.root_validator(pre=pre)(func)  # type: ignore # Pydantic v1

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator


def universal_field_validator(field_name: str, pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.field_validator(field_name, mode="before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.validator(field_name, pre=pre)(func)

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator
",
        "name": "pydantic_utilities.py",
        "type": "file",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Error(UniversalBaseModel):
    message: str = pydantic.Field()
    """
    An error message.
    """

    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "error.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class File(UniversalBaseModel):
    filename: typing.Optional[str] = pydantic.Field(default=None)
    """
    The name of the file.
    """

    content_type: typing.Optional[str] = pydantic.Field(default=None)
    """
    The content type of the file.
    """

    md_5_sum: str = pydantic.Field(alias="md5sum")
    """
    The MD5 checksum of the file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "file.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Prediction(UniversalBaseModel):
    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "prediction.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .error import Error
from .prediction import Prediction


class Results(UniversalBaseModel):
    predictions: typing.List[Prediction]
    errors: typing.List[Error]

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "results.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

from .source_file import SourceFile
from .source_url import SourceUrl

Source = typing.Union[SourceUrl, SourceFile]
",
    "name": "source.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2
from .file import File


class SourceFile(File):
    type: typing.Literal["file"] = "file"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_file.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .results import Results
from .source import Source


class SourceResult(UniversalBaseModel):
    source: Source
    results: typing.Optional[Results] = None
    error: typing.Optional[str] = pydantic.Field(default=None)
    """
    An error message.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_result.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2
from .url import Url


class SourceUrl(Url):
    type: typing.Literal["url"] = "url"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_url.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Url(UniversalBaseModel):
    url: str = pydantic.Field()
    """
    The URL of the source media file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "url.py",
    "type": "file",
  },
]
`;

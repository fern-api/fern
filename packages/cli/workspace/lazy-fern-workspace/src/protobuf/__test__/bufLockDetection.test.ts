import { AbsoluteFilePath, join, RelativeFilePath } from "@fern-api/fs-utils";
import { access, cp, mkdir, readFile, rm, writeFile } from "fs/promises";
import tmp from "tmp-promise";

describe("buf.lock detection", () => {
    it("copies buf.lock file when copying proto root directory", async () => {
        // Create a temporary source directory with buf.lock
        const sourceDir = AbsoluteFilePath.of((await tmp.dir()).path);
        const destDir = AbsoluteFilePath.of((await tmp.dir()).path);

        // Create buf.yaml and buf.lock in source directory
        const bufYamlContent = `version: v1
deps:
  - buf.build/googleapis/googleapis
`;
        const bufLockContent = `# Generated by buf. DO NOT EDIT.
version: v1
deps:
  - remote: buf.build
    owner: googleapis
    repository: googleapis
    commit: 004180b77378443887d3b55cabc00384
    digest: shake256:d26c7c2fd95f0873761af33ca4a0c0d92c8577122b6feb74eb3b0a57ebe47a98ab24a209a0e91945ac4c77204e9da0c2de0020b2cedc27bdbcdea6c431eec69b
`;

        await writeFile(join(sourceDir, RelativeFilePath.of("buf.yaml")), bufYamlContent);
        await writeFile(join(sourceDir, RelativeFilePath.of("buf.lock")), bufLockContent);

        // Copy the directory (this is what ProtobufOpenAPIGenerator does)
        await cp(sourceDir, destDir, { recursive: true });

        // Verify buf.lock was copied
        const destBufLockPath = join(destDir, RelativeFilePath.of("buf.lock"));

        // Check if buf.lock exists in destination
        let bufLockExists = false;
        try {
            await access(destBufLockPath);
            bufLockExists = true;
        } catch {
            bufLockExists = false;
        }

        expect(bufLockExists).toBe(true);

        // Verify the content is correct
        const copiedContent = await readFile(destBufLockPath, "utf-8");
        expect(copiedContent).toBe(bufLockContent);

        // Cleanup
        await rm(sourceDir, { recursive: true, force: true });
        await rm(destDir, { recursive: true, force: true });
    });

    it("detects buf.lock file using access() function", async () => {
        const tempDir = AbsoluteFilePath.of((await tmp.dir()).path);
        const bufLockPath = join(tempDir, RelativeFilePath.of("buf.lock"));

        // Initially, buf.lock should not exist
        let bufLockExists = false;
        try {
            await access(bufLockPath);
            bufLockExists = true;
        } catch {
            bufLockExists = false;
        }
        expect(bufLockExists).toBe(false);

        // Create buf.lock
        await writeFile(bufLockPath, "# test buf.lock");

        // Now buf.lock should exist
        try {
            await access(bufLockPath);
            bufLockExists = true;
        } catch {
            bufLockExists = false;
        }
        expect(bufLockExists).toBe(true);

        // Cleanup
        await rm(tempDir, { recursive: true, force: true });
    });

    it("copies nested proto directory with buf.lock", async () => {
        // This test simulates the actual structure: protos/grpc-with-deps/buf.lock
        const sourceDir = AbsoluteFilePath.of((await tmp.dir()).path);
        const destDir = AbsoluteFilePath.of((await tmp.dir()).path);

        // Create nested structure
        const nestedDir = join(sourceDir, RelativeFilePath.of("grpc-with-deps"));
        await mkdir(nestedDir, { recursive: true });

        const bufLockContent = `# Generated by buf. DO NOT EDIT.
version: v1
deps:
  - remote: buf.build
    owner: googleapis
    repository: googleapis
    commit: 004180b77378443887d3b55cabc00384
`;

        await writeFile(join(nestedDir, RelativeFilePath.of("buf.yaml")), "version: v1\n");
        await writeFile(join(nestedDir, RelativeFilePath.of("buf.lock")), bufLockContent);
        await writeFile(join(nestedDir, RelativeFilePath.of("service.proto")), "syntax = \"proto3\";\n");

        // Copy the nested directory (simulating what happens when root is ./protos/grpc-with-deps/)
        await cp(nestedDir, destDir, { recursive: true });

        // Verify buf.lock was copied to the destination root
        const destBufLockPath = join(destDir, RelativeFilePath.of("buf.lock"));

        let bufLockExists = false;
        try {
            await access(destBufLockPath);
            bufLockExists = true;
        } catch {
            bufLockExists = false;
        }

        expect(bufLockExists).toBe(true);

        // Verify content
        const copiedContent = await readFile(destBufLockPath, "utf-8");
        expect(copiedContent).toBe(bufLockContent);

        // Cleanup
        await rm(sourceDir, { recursive: true, force: true });
        await rm(destDir, { recursive: true, force: true });
    });
});

import { DescriptorProto } from "@bufbuild/protobuf/wkt";

import * as FernIr from "@fern-api/ir-sdk";
import { Type } from "@fern-api/ir-sdk";
import { AbstractConverter } from "@fern-api/v2-importer-commons";

import { ProtofileConverterContext } from "../ProtofileConverterContext";
import { convertFields } from "../utils/ConvertFields";
import { EnumOrMessageConverter } from "./EnumOrMessageConverter";

export declare namespace MessageConverter {
    export interface Args extends AbstractConverter.Args<ProtofileConverterContext> {
        message: DescriptorProto;
    }

    export interface Output {
        convertedSchema: EnumOrMessageConverter.ConvertedSchema;
        inlinedTypes: Record<FernIr.TypeId, EnumOrMessageConverter.ConvertedSchema>;
    }
}

export class MessageConverter extends AbstractConverter<ProtofileConverterContext, MessageConverter.Output> {
    private readonly message: DescriptorProto;
    constructor({ context, breadcrumbs, message }: MessageConverter.Args) {
        super({ context, breadcrumbs });
        this.message = message;
    }

    public convert(): MessageConverter.Output | undefined {
        // TODO: convert message (i.e. convert schema)

        let inlinedTypes: Record<FernIr.TypeId, EnumOrMessageConverter.ConvertedSchema> = {};

        // Step 1: Convert all fields
        const { convertedFields, referencedTypes, propertiesByAudience } = convertFields({
            fields: this.message.field,
            breadcrumbs: this.breadcrumbs,
            context: this.context
        });

        // Step 2: Convert all nested messages and enums
        for (const nestedEnumOrMessage of [...this.message.nestedType, ...this.message.enumType]) {
            const enumOrMessageConverter = new EnumOrMessageConverter({
                context: this.context,
                breadcrumbs: this.breadcrumbs,
                schema: nestedEnumOrMessage
            });
            const convertedNestedEnumOrMessage = enumOrMessageConverter.convert();
            if (convertedNestedEnumOrMessage != null) {
                inlinedTypes = {
                    ...inlinedTypes,
                    [`${this.message.name}.${nestedEnumOrMessage.name}`]: convertedNestedEnumOrMessage.convertedSchema
                };
            }
        }
        // Step 3: Convert all oneofs
        for (const oneof of this.message.oneofDecl) {
            // TODO: convert oneofs
        }

        return {
            convertedSchema: {
                typeDeclaration: this.createTypeDeclaration({
                    shape: Type.object({
                        properties: convertedFields,
                        extends: [],
                        extendedProperties: [],
                        extraProperties: false
                    }),
                    referencedTypes
                }),
                audiences: [],
                propertiesByAudience
            },
            inlinedTypes
        };
    }

    public createTypeDeclaration({
        shape,
        referencedTypes,
        omitV2Examples
    }: {
        shape: FernIr.Type;
        referencedTypes: Set<string>;
        omitV2Examples?: boolean;
    }): FernIr.TypeDeclaration {
        return {
            name: this.convertDeclaredTypeName(),
            shape,
            autogeneratedExamples: [],
            userProvidedExamples: [],
            encoding: undefined,
            availability: undefined,
            docs: undefined,
            referencedTypes,
            source: undefined,
            inline: false,
            v2Examples: undefined
        };
    }

    public convertDeclaredTypeName(): FernIr.DeclaredTypeName {
        return {
            typeId: this.message.name,
            fernFilepath: this.context.createFernFilepath(),
            name: this.context.casingsGenerator.generateName(this.message.name),
            displayName: undefined
        };
    }
}

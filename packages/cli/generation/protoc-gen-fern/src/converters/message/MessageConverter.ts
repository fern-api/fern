import { DescriptorProto, FieldDescriptorProto_Type } from "@bufbuild/protobuf/wkt";

import * as FernIr from "@fern-api/ir-sdk";
import { Type } from "@fern-api/ir-sdk";
import { AbstractConverter, AbstractConverterContext, Converters } from "@fern-api/v2-importer-commons";

import { isNonNullish } from "../../../../../../commons/core-utils/lib/isNonNullish";
import { ProtobufConverterContext } from "../../ProtobufConverterContext";
import { convertFields } from "../utils/ConvertFields";
import { EnumConverter } from "./EnumConverter";
import { EnumOrMessageConverter } from "./EnumOrMessageConverter";

export declare namespace MessageConverter {
    export interface Args extends AbstractConverter.AbstractArgs {
        message: DescriptorProto;
    }

    export interface Output {
        convertedSchema: EnumOrMessageConverter.ConvertedSchema;
        inlinedTypes: Record<FernIr.TypeId, EnumOrMessageConverter.ConvertedSchema>;
    }
}

export class MessageConverter extends AbstractConverter<AbstractConverterContext<object>, MessageConverter.Output> {
    private readonly message: DescriptorProto;

    constructor({ context, breadcrumbs, message }: MessageConverter.Args) {
        super({ context, breadcrumbs });
        this.message = message;
    }

    public convert(): MessageConverter.Output | undefined {
        // TODO: convert message (i.e. convert schema)

        // Step 1: Convert all fields
        if (this.message.field.length > 0) {
            const { convertedFields, inlinedTypesFromFields, referencedTypes, propertiesByAudience } = convertFields({
                fields: this.message.field,
                breadcrumbs: this.breadcrumbs,
                context: this.context
            });
            return {
                convertedSchema: {
                    typeDeclaration: this.createTypeDeclaration({
                        shape: Type.object({
                            properties: convertedFields,
                            extends: [],
                            extendedProperties: [],
                            extraProperties: false
                        }),
                        referencedTypes
                    }),
                    audiences: [],
                    propertiesByAudience
                },
                inlinedTypes: inlinedTypesFromFields
            };
        }

        // Step 2: Convert all nested messages and enums
        for (const nestedMessage of [...this.message.nestedType, ...this.message.enumType]) {
            const enumOrMessageConverter = new EnumOrMessageConverter({
                context: this.context,
                breadcrumbs: this.breadcrumbs,
                schema: nestedMessage
            });
            const convertedSchema = enumOrMessageConverter.convert();
        }
        // Step 3: Convert all oneofs
        for (const oneof of this.message.oneofDecl) {
            this.context.logger.info("Oneof", oneof.name);
        }

        return undefined;
    }

    public createTypeDeclaration({
        shape,
        referencedTypes,
        omitV2Examples
    }: {
        shape: FernIr.Type;
        referencedTypes: Set<string>;
        omitV2Examples?: boolean;
    }): FernIr.TypeDeclaration {
        return {
            name: this.convertDeclaredTypeName(),
            shape,
            autogeneratedExamples: [],
            userProvidedExamples: [],
            encoding: undefined,
            availability: undefined,
            docs: undefined,
            referencedTypes,
            source: undefined,
            inline: false,
            v2Examples: undefined
        };
    }

    public convertDeclaredTypeName(): FernIr.DeclaredTypeName {
        return {
            typeId: this.message.name,
            fernFilepath: this.context.createFernFilepath(),
            name: this.context.casingsGenerator.generateName(this.message.name),
            displayName: undefined
        };
    }
}

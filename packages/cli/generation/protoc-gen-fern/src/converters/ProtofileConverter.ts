import { camelCase } from "lodash-es";

import { AutogeneratedEndpointExample, FernIr, HttpRequestBodyReference, IntermediateRepresentation, Package } from "@fern-api/ir-sdk";
import { AbstractSpecConverter } from "@fern-api/v2-importer-commons";

import { ProtofileConverterContext } from "./ProtofileConverterContext";
import { EnumOrMessageConverter } from "./message/EnumOrMessageConverter";
import { ServiceConverter } from "./service/ServiceConverter";
import { PATH_FIELD_NUMBERS, SOURCE_CODE_INFO_PATH_STARTERS } from "./utils/PathFieldNumbers";
import { ExampleConverter } from "./message/ExampleConverter";

export declare namespace ProtofileConverter {
    interface Args extends AbstractSpecConverter.Args<ProtofileConverterContext> {}
}

export class ProtofileConverter extends AbstractSpecConverter<ProtofileConverterContext, IntermediateRepresentation> {
    constructor({ breadcrumbs, context, audiences }: ProtofileConverter.Args) {
        super({ breadcrumbs, context, audiences });
    }

    public convert(): IntermediateRepresentation | undefined {
        this.convertOptions();
        this.convertEnumsAndMessages();
        this.convertServices();
        this.generateExamplesForServices();
        return this.finalizeIr();
    }

    private convertOptions() {
        // TODO: convert options
    }

    private convertEnumsAndMessages() {
        for (const [index, schema] of this.context.spec.enumType.entries()) {
            const enumConverter = new EnumOrMessageConverter({
                context: this.context,
                breadcrumbs: [...this.breadcrumbs, this.context.spec.package],
                schema,
                sourceCodeInfoPath: [SOURCE_CODE_INFO_PATH_STARTERS.ENUM, index],
                schemaIndex: index
            });
            const convertedEnum = enumConverter.convert();
            if (convertedEnum != null) {
                this.addTypesToIr({
                    ...convertedEnum.inlinedTypes,
                    [this.context.maybePrependPackageName(schema.name)]: convertedEnum.convertedSchema
                });
            }
        }

        for (const [index, schema] of this.context.spec.messageType.entries()) {
            const messageConverter = new EnumOrMessageConverter({
                context: this.context,
                breadcrumbs: [...this.breadcrumbs, this.context.spec.package],
                schema,
                sourceCodeInfoPath: [SOURCE_CODE_INFO_PATH_STARTERS.MESSAGE, index],
                schemaIndex: index
            });
            const convertedMessage = messageConverter.convert();
            if (convertedMessage != null) {
                this.addTypesToIr({
                    ...convertedMessage.inlinedTypes,
                    [this.context.maybePrependPackageName(schema.name)]: convertedMessage.convertedSchema
                });
            }
        }
    }

    private convertServices() {
        for (const [index, service] of this.context.spec.service.entries()) {
            const serviceConverter = new ServiceConverter({
                context: this.context,
                breadcrumbs: this.breadcrumbs,
                service,
                sourceCodeInfoPath: [SOURCE_CODE_INFO_PATH_STARTERS.SERVICE, index]
            });
            const convertedService = serviceConverter.convert();
            if (convertedService != null) {
                for (const endpoint of convertedService.endpoints) {
                    this.addEndpointToIr({
                        endpointGroup: endpoint.group,
                        endpoint: endpoint.endpoint,
                        audiences: [],
                        serviceName: convertedService.serviceName
                    });
                }
            }
        }
    }

    private generateExamplesForServices() {
        for (const [serviceName, service] of Object.entries(this.ir.services)) {
            for (const [endpointName, endpoint] of Object.entries(service.endpoints)) {

                let endpointExample = {
                    request: {},
                    response: {},
                    codeSamples: []
                }

                const requestBodyTypeId = ((endpoint.requestBody as HttpRequestBodyReference).requestBodyType as FernIr.TypeReference.Named).typeId
                const resolvedRequestBodyType = this.context.resolveTypeIdToProtoFile(requestBodyTypeId);
                if (resolvedRequestBodyType != null) {
                    const requestBodyExampleConverter = new ExampleConverter({
                        context: this.context,
                        breadcrumbs: this.breadcrumbs,
                        message: resolvedRequestBodyType,
                        type: "request"
                    });
                    const requestBodyExample = requestBodyExampleConverter.convert();

                    if (requestBodyExample.isValid) {
                        endpointExample = {
                            ...endpointExample,
                            request: requestBodyExample.validExample as any
                        }
                    }
                }
                const responseBodyTypeId = ((endpoint.response?.body as FernIr.HttpResponseBody.Json).value.responseBodyType as FernIr.TypeReference.Named).typeId
                const resolvedResponseBodyType = this.context.resolveTypeIdToProtoFile(responseBodyTypeId);
                if (resolvedResponseBodyType != null) {
                    const responseBodyExampleConverter = new ExampleConverter({
                        context: this.context,
                        breadcrumbs: this.breadcrumbs,
                        message: resolvedResponseBodyType,
                        type: "response"
                    });
                    const responseBodyExample = responseBodyExampleConverter.convert();
                    if (responseBodyExample.isValid) {
                        endpointExample = {
                            ...endpointExample,
                            response: responseBodyExample.validExample as any
                        }
                    }
                }
                const finalV2EndpointExample: FernIr.V2HttpEndpointExample = {
                    request: endpointExample.request,
                    response: endpointExample.response,
                    codeSamples: endpointExample.codeSamples
                }

                this.context.logger.info(JSON.stringify(finalV2EndpointExample, null, 2));
            }
        }
    }
    protected addEndpointToIr({
        endpoint,
        audiences,
        endpointGroup,
        endpointGroupDisplayName,
        serviceName
    }: {
        endpoint: FernIr.HttpEndpoint;
        audiences: string[];
        endpointGroup?: string[];
        endpointGroupDisplayName?: string;
        serviceName?: string;
    }): void {
        const group = this.context.getGroup({
            groupParts: endpointGroup,
            namespace: this.context.namespace
        });

        const pkg = this.getOrCreatePackage({ group: endpointGroup });

        const allParts = [...group].map((part) => this.context.casingsGenerator.generateName(part));
        const finalpart = allParts[allParts.length - 1];

        if (pkg.service == null) {
            pkg.service = serviceName ?? `service_${group.map((part) => camelCase(part)).join("/")}`;
        }

        if (this.ir.services[pkg.service] == null) {
            this.ir.services[pkg.service] = this.createNewService({ allParts, finalpart, endpointGroupDisplayName });
        }
        this.ir.services[pkg.service]?.endpoints.push(endpoint);

        const service = this.ir.services[pkg.service];
        if (service != null) {
            this.irGraph.addEndpoint(service, endpoint);
            // TODO: This method should be "markEndpointsForAudience"
            this.irGraph.markEndpointForAudience(service.name, [endpoint], audiences);
        }
    }

    protected getOrCreatePackage({ group }: { group?: string[] }): Package {
        const groupParts = [];
        if (this.context.namespace != null) {
            groupParts.push(this.context.namespace);
        }
        groupParts.push(...(group ?? []));

        if (groupParts.length == 0) {
            return this.ir.rootPackage;
        }

        let pkg = this.ir.rootPackage;
        for (let i = 0; i < groupParts.length; i++) {
            const name = groupParts[i] ?? "";
            const groupPartsSubset = groupParts.slice(0, i + 1);
            const subpackageId = `subpackage_${groupPartsSubset.join("/")}`;
            if (this.ir.subpackages[subpackageId] == null) {
                this.ir.subpackages[subpackageId] = {
                    name: this.context.casingsGenerator.generateName(name),
                    ...this.createPackage({ name })
                };
            }
            const curr = this.ir.subpackages[subpackageId];
            if (!pkg.subpackages.includes(subpackageId)) {
                pkg.subpackages.push(subpackageId);
            }
            pkg = curr;
        }
        return pkg;
    }

    protected finalizeIr(): IntermediateRepresentation {
        return {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            },
            audiences: this.audiences.type === "select" ? this.audiences.audiences : undefined
        };
    }
}

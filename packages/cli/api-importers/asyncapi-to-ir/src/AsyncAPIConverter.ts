import { OpenAPIV3 } from "openapi-types";

import { FernIr, IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, ErrorCollector, Extensions } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "./2.x";
import { ChannelConverter2_X } from "./2.x/channel/ChannelConverter2_X";
import { ServersConverter2_X } from "./2.x/servers/ServersConverter2_X";
import { AsyncAPIV3 } from "./3.0";
import { ChannelConverter3_0 } from "./3.0/channel/ChannelConverter3_0";
import { ServersConverter3_0 } from "./3.0/servers/ServersConverter3_0";
import { AsyncAPIConverterContext } from "./AsyncAPIConverterContext";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace AsyncAPIConverter {
    type Args = AbstractConverter.Args<AsyncAPIConverterContext>

    type AbstractArgs = AbstractConverter.Args<AsyncAPIConverterContext>;
}

export class AsyncAPIConverter extends AbstractConverter<AsyncAPIConverterContext, IntermediateRepresentation> {

    constructor({ context, breadcrumbs }: AsyncAPIConverter.Args) {
        super({ context, breadcrumbs });
    }

    public async convert({
        errorCollector
    }: {
        errorCollector: ErrorCollector;
    }): Promise<IntermediateRepresentation> {
        
        this.context.spec = this.removeXFernIgnores({
            document: this.context.spec,
            context: this.context,
            errorCollector
        }) as AsyncAPIV2.DocumentV2 | AsyncAPIV3.DocumentV3;

        if (this.isAsyncAPIV3(this.context)) {
            await this.convertChannelMessages({ errorCollector });
        } else {
            await this.convertComponentMessages({ errorCollector });
        }

        await this.convertSchemas({ errorCollector });

        await this.convertServers({ errorCollector });

        await this.convertChannels({ errorCollector });

        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };

        return ir;
    }

    private isAsyncAPIV3(context: AsyncAPIConverterContext): boolean {
        return parseFloat(context.spec.asyncapi) >= 3;
    }

    private async convertChannelMessages({
        errorCollector
    }: {
        errorCollector: ErrorCollector;
    }): Promise<void> {
        const spec = this.context.spec as AsyncAPIV3.DocumentV3;
        for (const [channelPath, channel] of Object.entries(spec.channels ?? {})) {
            for (const [messageId, message] of Object.entries(channel.messages ?? {})) {
                if (!this.context.isMessageWithPayload(message) && !this.context.isReferenceObject(message)) {
                    continue;
                }

                let messageSchema: OpenAPIV3.SchemaObject | undefined = undefined;
                if (this.context.isMessageWithPayload(message)) {
                    if (this.context.isReferenceObject(message.payload)) {
                        const resolved = await this.context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                        if (resolved.resolved) {
                            messageSchema = resolved.value;
                        }
                    } else {
                        messageSchema = message.payload;
                    }
                } else if (this.context.isReferenceObject(message)) {
                    const resolved = await this.context.resolveReference<AsyncAPIV3.ChannelMessage>(message);
                    if (resolved.resolved) {
                        const resolvedPayload = resolved.value.payload;
                        if (this.context.isReferenceObject(resolvedPayload)) {
                            const resolvedPayloadResolved =
                                await this.context.resolveReference<OpenAPIV3.SchemaObject>(resolvedPayload);
                            if (resolvedPayloadResolved.resolved) {
                                messageSchema = resolvedPayloadResolved.value;
                            }
                        } else {
                            messageSchema = resolvedPayload;
                        }
                    }
                }
                if (messageSchema == null) {
                    continue;
                }
                const typeId = `${channelPath}_${messageId}`;
                const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                    context: this.context,
                    id: typeId,
                    breadcrumbs: ["channels", channelPath, "messages", messageId],
                    schema: messageSchema
                });
                const convertedSchema = await schemaConverter.convert({ context, errorCollector });
                if (convertedSchema != null) {
                    this.ir.rootPackage.types.push(typeId);
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedSchema.inlinedTypes,
                        [typeId]: convertedSchema.typeDeclaration
                    };
                }
            }
        }
    }

    private async convertComponentMessages({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [id, message] of Object.entries(context.spec.components?.messages ?? {})) {
            if (message.payload == null) {
                continue;
            }

            let payloadSchema: OpenAPIV3.SchemaObject | undefined = undefined;
            if (context.isReferenceObject(message.payload)) {
                const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                if (resolved.resolved) {
                    payloadSchema = resolved.value;
                }
            } else {
                payloadSchema = message.payload;
            }
            if (payloadSchema == null) {
                continue;
            }

            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "messages", id],
                schema: payloadSchema
            });

            const convertedSchema = await schemaConverter.convert({
                errorCollector
            });

            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertSchemas({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [id, schema] of Object.entries(context.spec.components?.schemas ?? {})) {
            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert({ context, errorCollector });
            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertServers({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        if (this.isAsyncAPIV3(context)) {
            const servers = context.spec.servers as Record<string, AsyncAPIV3.ServerV3>;
            const serversConverter = new ServersConverter3_0({
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert({ context, errorCollector });
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        } else {
            const servers = context.spec.servers as Record<string, AsyncAPIV2.ServerV2>;
            const serversConverter = new ServersConverter2_X({
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert({ context, errorCollector });
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        }
    }

    private async convertChannels({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [channelPath, channel] of Object.entries(context.spec.channels ?? {})) {
            const groupNameExtension = new Extensions.SdkGroupNameExtension({
                breadcrumbs: ["channels", channelPath],
                operation: channel
            });
            const group = groupNameExtension.convert({ context, errorCollector })?.groups;

            if (this.isAsyncAPIV3(context)) {
                const spec = context.spec as AsyncAPIV3.DocumentV3;
                const operations = spec.operations ?? {};

                const channelConverter = new ChannelConverter3_0({
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    operations,
                    group
                });
                const convertedChannel = await channelConverter.convert({ context, errorCollector });
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            } else {
                const channelConverter = new ChannelConverter2_X({
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    group
                });
                const convertedChannel = await channelConverter.convert({ context, errorCollector });
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            }
        }
        this.addWebsocketsToIr({ websocketChannels: this.ir.websocketChannels, context });
    }

    private addWebsocketsToIr({
        websocketChannels,
        context
    }: {
        websocketChannels: Record<string, FernIr.WebSocketChannel> | undefined;
        context: AsyncAPIConverterContext;
    }): void {
        if (websocketChannels == null) {
            return;
        }

        for (const [channelPath, _] of Object.entries(websocketChannels)) {
            if (channelPath !== "") {
                if (this.ir.subpackages[channelPath] == null) {
                    this.ir.subpackages[channelPath] = {
                        name: context.casingsGenerator.generateName(channelPath),
                        ...context.createPackage({ name: channelPath })
                    };
                }
                this.ir.subpackages[channelPath].websocket = channelPath;
                this.ir.rootPackage.subpackages.push(channelPath);
            } else {
                this.ir.rootPackage.websocket = channelPath;
            }
        }
    }
}

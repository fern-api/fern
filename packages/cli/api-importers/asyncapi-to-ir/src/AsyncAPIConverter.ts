import { OpenAPIV3 } from "openapi-types";

import { FernIr, IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples, injectAutogeneratedV2Examples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, Extensions } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "./2.x";
import { ChannelConverter2_X } from "./2.x/channel/ChannelConverter2_X";
import { ServersConverter2_X } from "./2.x/servers/ServersConverter2_X";
import { AsyncAPIV3 } from "./3.0";
import { ChannelConverter3_0 } from "./3.0/channel/ChannelConverter3_0";
import { ServersConverter3_0 } from "./3.0/servers/ServersConverter3_0";
import { AsyncAPIConverterContext } from "./AsyncAPIConverterContext";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace AsyncAPIConverter {
    type Args = AbstractConverter.Args<AsyncAPIConverterContext>;

    type AbstractArgs = AbstractConverter.Args<AsyncAPIConverterContext>;
}

export class AsyncAPIConverter extends AbstractConverter<AsyncAPIConverterContext, IntermediateRepresentation> {
    constructor({ context, breadcrumbs }: AsyncAPIConverter.Args) {
        super({ context, breadcrumbs });
    }

    public async convert(): Promise<IntermediateRepresentation> {
        this.context.spec = this.removeXFernIgnores({
            document: this.context.spec,
            context: this.context
        }) as AsyncAPIV2.DocumentV2 | AsyncAPIV3.DocumentV3;

        if (this.isAsyncAPIV3(this.context)) {
            await this.convertChannelMessages();
        } else {
            await this.convertComponentMessages();
        }

        await this.convertSchemas();

        await this.convertServers();

        await this.convertChannels();

        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs }),
            ...injectAutogeneratedV2Examples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };

        return ir;
    }

    private isAsyncAPIV3(context: AsyncAPIConverterContext): boolean {
        return parseFloat(context.spec.asyncapi) >= 3;
    }

    private async convertChannelMessages(): Promise<void> {
        const spec = this.context.spec as AsyncAPIV3.DocumentV3;
        for (const [channelPath, channel] of Object.entries(spec.channels ?? {})) {
            for (const [messageId, message] of Object.entries(channel.messages ?? {})) {
                if (!this.context.isMessageWithPayload(message) && !this.context.isReferenceObject(message)) {
                    continue;
                }

                let messageSchema: OpenAPIV3.SchemaObject | undefined = undefined;
                if (this.context.isMessageWithPayload(message)) {
                    if (this.context.isReferenceObject(message.payload)) {
                        const resolved = await this.context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                        if (resolved.resolved) {
                            messageSchema = resolved.value;
                        }
                    } else {
                        messageSchema = message.payload;
                    }
                } else if (this.context.isReferenceObject(message)) {
                    const resolved = await this.context.resolveReference<AsyncAPIV3.ChannelMessage>(message);
                    if (resolved.resolved) {
                        const resolvedPayload = resolved.value.payload;
                        if (this.context.isReferenceObject(resolvedPayload)) {
                            const resolvedPayloadResolved =
                                await this.context.resolveReference<OpenAPIV3.SchemaObject>(resolvedPayload);
                            if (resolvedPayloadResolved.resolved) {
                                messageSchema = resolvedPayloadResolved.value;
                            }
                        } else {
                            messageSchema = resolvedPayload;
                        }
                    }
                }
                if (messageSchema == null) {
                    continue;
                }
                const typeId = `${channelPath}_${messageId}`;
                const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                    context: this.context,
                    id: typeId,
                    breadcrumbs: ["channels", channelPath, "messages", messageId],
                    schema: messageSchema
                });
                const convertedSchema = await schemaConverter.convert();
                if (convertedSchema != null) {
                    this.ir.rootPackage.types.push(typeId);
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedSchema.inlinedTypes,
                        [typeId]: convertedSchema.typeDeclaration
                    };
                }
            }
        }
    }

    private async convertComponentMessages(): Promise<void> {
        for (const [id, message] of Object.entries(this.context.spec.components?.messages ?? {})) {
            if (message.payload == null) {
                continue;
            }

            let payloadSchema: OpenAPIV3.SchemaObject | undefined = undefined;
            if (this.context.isReferenceObject(message.payload)) {
                const resolved = await this.context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                if (resolved.resolved) {
                    payloadSchema = resolved.value;
                }
            } else {
                payloadSchema = message.payload;
            }
            if (payloadSchema == null) {
                continue;
            }

            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "messages", id],
                schema: payloadSchema
            });

            const convertedSchema = await schemaConverter.convert();

            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertSchemas(): Promise<void> {
        for (const [id, schema] of Object.entries(this.context.spec.components?.schemas ?? {})) {
            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert();
            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertServers(): Promise<void> {
        if (this.isAsyncAPIV3(this.context)) {
            const servers = this.context.spec.servers as Record<string, AsyncAPIV3.ServerV3>;
            const serversConverter = new ServersConverter3_0({
                context: this.context,
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert();
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        } else {
            const servers = this.context.spec.servers as Record<string, AsyncAPIV2.ServerV2>;
            const serversConverter = new ServersConverter2_X({
                context: this.context,
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert();
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        }
    }

    private async convertChannels(): Promise<void> {
        for (const [channelPath, channel] of Object.entries(this.context.spec.channels ?? {})) {
            const groupNameExtension = new Extensions.SdkGroupNameExtension({
                breadcrumbs: ["channels", channelPath],
                operation: channel,
                context: this.context
            });
            const group = groupNameExtension.convert()?.groups;

            if (this.isAsyncAPIV3(this.context)) {
                const spec = this.context.spec as AsyncAPIV3.DocumentV3;
                const operations = spec.operations ?? {};

                const channelConverter = new ChannelConverter3_0({
                    context: this.context,
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    operations,
                    group
                });
                const convertedChannel = await channelConverter.convert();
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            } else {
                const channelConverter = new ChannelConverter2_X({
                    context: this.context,
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    group
                });
                const convertedChannel = await channelConverter.convert();
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            }
        }
        this.addWebsocketsToIr({ websocketChannels: this.ir.websocketChannels });
    }

    private addWebsocketsToIr({
        websocketChannels
    }: {
        websocketChannels: Record<string, FernIr.WebSocketChannel> | undefined;
    }): void {
        if (websocketChannels == null) {
            return;
        }

        for (const [channelPath, _] of Object.entries(websocketChannels)) {
            if (channelPath !== "") {
                if (this.ir.subpackages[channelPath] == null) {
                    this.ir.subpackages[channelPath] = {
                        name: this.context.casingsGenerator.generateName(channelPath),
                        ...this.context.createPackage({ name: channelPath })
                    };
                }
                this.ir.subpackages[channelPath].websocket = channelPath;
                this.ir.rootPackage.subpackages.push(channelPath);
            } else {
                this.ir.rootPackage.websocket = channelPath;
            }
        }
    }
}

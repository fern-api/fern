import { OpenAPIV3 } from "openapi-types";

import { FernIr, IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples, injectAutogeneratedV2Examples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, Extensions } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "./2.x";
import { ChannelConverter2_X } from "./2.x/channel/ChannelConverter2_X";
import { ServersConverter2_X } from "./2.x/servers/ServersConverter2_X";
import { AsyncAPIV3 } from "./3.0";
import { ChannelConverter3_0 } from "./3.0/channel/ChannelConverter3_0";
import { ServersConverter3_0 } from "./3.0/servers/ServersConverter3_0";
import { AsyncAPIConverterContext } from "./AsyncAPIConverterContext";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace AsyncAPIConverter {
    type Args = AbstractConverter.Args<AsyncAPIConverterContext>;

    type AbstractArgs = AbstractConverter.Args<AsyncAPIConverterContext>;
}

export class AsyncAPIConverter extends AbstractConverter<AsyncAPIConverterContext, IntermediateRepresentation> {
    constructor({ context, breadcrumbs }: AsyncAPIConverter.Args) {
        super({ context, breadcrumbs });
    }

    public async convert(): Promise<IntermediateRepresentation> {
        this.context.spec = this.removeXFernIgnores({
            document: this.context.spec,
            context: this.context
        }) as AsyncAPIV2.DocumentV2 | AsyncAPIV3.DocumentV3;

        if (this.isAsyncAPIV3(this.context)) {
            await this.convertChannelMessages();
        } else {
            await this.convertComponentMessages();
        }

        await this.convertSchemas();

        await this.convertServers();

        await this.convertChannels();

        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs }),
            ...injectAutogeneratedV2Examples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };

        return ir;
    }

    private isAsyncAPIV3(context: AsyncAPIConverterContext): boolean {
        return parseFloat(context.spec.asyncapi) >= 3;
    }

    private async convertChannelMessages(): Promise<void> {
        const spec = this.context.spec as AsyncAPIV3.DocumentV3;
        for (const [channelPath, channel] of Object.entries(spec.channels ?? {})) {
            for (const [messageId, message] of Object.entries(channel.messages ?? {})) {
                if (!this.context.isMessageWithPayload(message) && !this.context.isReferenceObject(message)) {
                    continue;
                }
                const messageBreadcrumbs = ["channels", channelPath, "messages", messageId];

                const resolvedMessage = await this.context.resolveMaybeReference<AsyncAPIV3.ChannelMessage>({
                    schemaOrReference: message,
                    breadcrumbs: messageBreadcrumbs
                });
                if (!this.context.isMessageWithPayload(resolvedMessage)) {
                    continue;
                }
                const messageSchema = await this.context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: resolvedMessage.payload,
                    breadcrumbs: messageBreadcrumbs
                });
                if (messageSchema == null) {
                    continue;
                }
                const typeId = `${channelPath}_${messageId}`;
                await this.convertSchema({
                    id: typeId,
                    breadcrumbs: messageBreadcrumbs,
                    schema: messageSchema
                });
            }
        }
    }

    private async convertComponentMessages(): Promise<void> {
        for (const [id, message] of Object.entries(this.context.spec.components?.messages ?? {})) {
            if (message.payload == null) {
                continue;
            }
            const componentBreadcrumbs = ["components", "messages", id];
            const payloadSchema: OpenAPIV3.SchemaObject | undefined =
                await this.context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: message.payload,
                    breadcrumbs: componentBreadcrumbs
                });
            if (payloadSchema == null) {
                continue;
            }

            await this.convertSchema({
                id,
                breadcrumbs: componentBreadcrumbs,
                schema: payloadSchema
            });
        }
    }

    private async convertSchemas(): Promise<void> {
        for (const [id, schema] of Object.entries(this.context.spec.components?.schemas ?? {})) {
            await this.convertSchema({
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
        }
    }

    private async convertSchema({
        id,
        breadcrumbs,
        schema
    }: {
        id: string;
        breadcrumbs: string[];
        schema: OpenAPIV3.SchemaObject;
    }): Promise<void> {
        const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
            context: this.context,
            id,
            breadcrumbs,
            schema
        });
        const convertedSchema = await schemaConverter.convert();
        if (convertedSchema != null) {
            this.ir.rootPackage.types.push(id);
            this.ir.types = {
                ...this.ir.types,
                ...convertedSchema.inlinedTypes,
                [id]: convertedSchema.typeDeclaration
            };
        }
    }

    private async convertServers(): Promise<void> {
        if (this.isAsyncAPIV3(this.context)) {
            const servers = this.context.spec.servers as Record<string, AsyncAPIV3.ServerV3>;
            const serversConverter = new ServersConverter3_0({
                context: this.context,
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert();
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        } else {
            const servers = this.context.spec.servers as Record<string, AsyncAPIV2.ServerV2>;
            const serversConverter = new ServersConverter2_X({
                context: this.context,
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert();
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        }
    }

    private async convertChannels(): Promise<void> {
        for (const [channelPath, channel] of Object.entries(this.context.spec.channels ?? {})) {
            const groupNameExtension = new Extensions.SdkGroupNameExtension({
                breadcrumbs: ["channels", channelPath],
                operation: channel,
                context: this.context
            });
            const group = groupNameExtension.convert()?.groups;

            if (this.isAsyncAPIV3(this.context)) {
                const spec = this.context.spec as AsyncAPIV3.DocumentV3;
                const operations = spec.operations ?? {};

                const channelConverter = new ChannelConverter3_0({
                    context: this.context,
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    operations,
                    group
                });
                const convertedChannel = await channelConverter.convert();
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            } else {
                const channelConverter = new ChannelConverter2_X({
                    context: this.context,
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    group
                });
                const convertedChannel = await channelConverter.convert();
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            }
        }
        this.addWebsocketsToIr({ websocketChannels: this.ir.websocketChannels });
    }

    private addWebsocketsToIr({
        websocketChannels
    }: {
        websocketChannels: Record<string, FernIr.WebSocketChannel> | undefined;
    }): void {
        if (websocketChannels == null) {
            return;
        }

        for (const [channelPath, _] of Object.entries(websocketChannels)) {
            if (channelPath !== "") {
                if (this.ir.subpackages[channelPath] == null) {
                    this.ir.subpackages[channelPath] = {
                        name: this.context.casingsGenerator.generateName(channelPath),
                        ...this.context.createPackage({ name: channelPath })
                    };
                }
                this.ir.subpackages[channelPath].websocket = channelPath;
                this.ir.rootPackage.subpackages.push(channelPath);
            } else {
                this.ir.rootPackage.websocket = channelPath;
            }
        }
    }
}

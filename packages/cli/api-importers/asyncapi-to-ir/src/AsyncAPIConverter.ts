import { OpenAPIV3 } from "openapi-types";

import { FernIr, IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples } from "@fern-api/ir-utils";
import { AbstractConverter, ErrorCollector, Extensions } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "./2.x";
import { ChannelConverter2_X } from "./2.x/channel/ChannelConverter2_X";
import { ServersConverter2_X } from "./2.x/servers/ServersConverter2_X";
import { AsyncAPIV3 } from "./3.0";
import { ChannelConverter3_0 } from "./3.0/channel/ChannelConverter3_0";
import { ServersConverter3_0 } from "./3.0/servers/ServersConverter3_0";
import { AsyncAPIConverterContext } from "./AsyncAPIConverterContext";
import { SchemaConverter } from "./core/schema/SchemaConverter";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace OpenAPIConverter {
    export interface Args extends AbstractConverter.Args {
        context: AsyncAPIConverterContext;
    }
}

export class AsyncAPIConverter extends AbstractConverter<AsyncAPIConverterContext, IntermediateRepresentation> {
    private ir: BaseIntermediateRepresentation;

    constructor({ breadcrumbs, context }: OpenAPIConverter.Args) {
        super({ breadcrumbs });
        this.ir = {
            auth: {
                docs: undefined,
                requirement: FernIr.AuthSchemesRequirement.All,
                schemes: []
            },
            types: {},
            services: {},
            errors: {},
            webhookGroups: {},
            websocketChannels: undefined,
            headers: [],
            idempotencyHeaders: [],
            apiVersion: undefined,
            apiDisplayName: undefined,
            apiDocs: undefined,
            basePath: undefined,
            pathParameters: [],
            errorDiscriminationStrategy: FernIr.ErrorDiscriminationStrategy.statusCode(),
            variables: [],
            serviceTypeReferenceInfo: {
                sharedTypes: [],
                typesReferencedOnlyByService: {}
            },
            readmeConfig: undefined,
            sourceConfig: undefined,
            publishConfig: undefined,
            dynamic: undefined,
            environments: undefined,
            fdrApiDefinitionId: undefined,
            rootPackage: context.createPackage(),
            subpackages: {},
            sdkConfig: {
                hasFileDownloadEndpoints: false,
                hasPaginatedEndpoints: false,
                hasStreamingEndpoints: false,
                isAuthMandatory: true,
                platformHeaders: {
                    language: "",
                    sdkName: "",
                    sdkVersion: "",
                    userAgent: undefined
                }
            }
        };
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<IntermediateRepresentation> {
        context.spec = this.removeXFernIgnores({
            document: context.spec,
            context,
            errorCollector
        }) as AsyncAPIV2.DocumentV2 | AsyncAPIV3.DocumentV3;

        if (this.isAsyncAPIV3(context)) {
            context.spec = this.deduplicateChannelMessages({
                document: context.spec as AsyncAPIV3.DocumentV3,
                context,
                errorCollector
            }) as AsyncAPIV3.DocumentV3;
            await this.convertChannelMessages({ context, errorCollector });
        } else {
            await this.convertComponentMessages({ context, errorCollector });
        }

        await this.convertSchemas({ context, errorCollector });

        await this.convertServers({ context, errorCollector });

        await this.convertChannels({ context, errorCollector });

        let ir = {
            ...this.ir,
            apiName: context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: { disabled: false } })
        };

        return ir;
    }

    private isAsyncAPIV3(context: AsyncAPIConverterContext): boolean {
        return parseFloat(context.spec.asyncapi) >= 3;
    }

    private removeXFernIgnores({
        document,
        context,
        errorCollector,
        breadcrumbs = []
    }: {
        document: unknown;
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        breadcrumbs?: string[];
    }): unknown {
        if (Array.isArray(document)) {
            return document
                .filter((item, index) => {
                    const shouldIgnore = new Extensions.FernIgnoreExtension({
                        breadcrumbs: [...breadcrumbs, String(index)],
                        operation: item
                    }).convert({ context, errorCollector });
                    return !shouldIgnore;
                })
                .map((item, index) =>
                    this.removeXFernIgnores({
                        document: item,
                        context,
                        errorCollector,
                        breadcrumbs: [...breadcrumbs, String(index)]
                    })
                );
        } else if (document != null && typeof document === "object") {
            return Object.fromEntries(
                Object.entries(document)
                    .filter(([key, value]) => {
                        const shouldIgnore = new Extensions.FernIgnoreExtension({
                            breadcrumbs: [...breadcrumbs, key],
                            operation: value
                        }).convert({ context, errorCollector });
                        return !shouldIgnore;
                    })
                    .map(([key, value]) => [
                        key,
                        this.removeXFernIgnores({
                            document: value,
                            context,
                            errorCollector,
                            breadcrumbs: [...breadcrumbs, key]
                        })
                    ])
            );
        }
        return document;
    }

    private deduplicateChannelMessages({
        document,
        context,
        errorCollector
    }: {
        document: AsyncAPIV3.DocumentV3;
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): AsyncAPIV3.DocumentV3 {
        const seenMessages: Record<string, Array<{ channelPath: string; message: AsyncAPIV3.MessageV3 }>> = {};
        for (const [channelPath, channel] of Object.entries(document.channels ?? {})) {
            for (const [messageId, message] of Object.entries(channel.messages ?? {})) {
                if (!seenMessages[messageId]) {
                    seenMessages[messageId] = [];
                }
                seenMessages[messageId].push({
                    channelPath,
                    message
                });
            }
        }

        const deduplicatedDocument = { ...document };
        deduplicatedDocument.channels = { ...document.channels };

        for (const [messageId, occurrences] of Object.entries(seenMessages)) {
            if (occurrences.length === 1) {
                continue;
            }

            for (const { channelPath, message } of occurrences) {
                const channel = deduplicatedDocument.channels[channelPath];
                if (channel == null || channel.messages == null) {
                    continue;
                }

                const newMessageId = `${channelPath}_${messageId}`;
                const updatedMessages = {
                    ...channel.messages,
                    [newMessageId]: message
                };

                const { [messageId]: _, ...remainingMessages } = updatedMessages;
                channel.messages = remainingMessages;
            }
        }
        return deduplicatedDocument;
    }

    private async convertChannelMessages({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        const spec = context.spec as AsyncAPIV3.DocumentV3;
        for (const [channelPath, channel] of Object.entries(spec.channels ?? {})) {
            for (const [messageId, message] of Object.entries(channel.messages ?? {})) {
                if (message.payload == null) {
                    continue;
                }

                let payloadSchema: OpenAPIV3.SchemaObject | undefined = undefined;
                if (context.isReferenceObject(message.payload)) {
                    const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                    if (resolved.resolved) {
                        payloadSchema = resolved.value;
                    }
                } else {
                    payloadSchema = message.payload;
                }
                if (payloadSchema == null) {
                    continue;
                }
                const schemaConverter = new SchemaConverter({
                    id: messageId,
                    breadcrumbs: ["channels", channelPath, "messages", messageId],
                    schema: payloadSchema
                });
                const convertedSchema = await schemaConverter.convert({ context, errorCollector });
                if (convertedSchema != null) {
                    this.ir.rootPackage.types.push(messageId);
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedSchema.inlinedTypes,
                        [messageId]: convertedSchema.typeDeclaration
                    };
                }
            }
        }
    }

    private async convertComponentMessages({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [id, message] of Object.entries(context.spec.components?.messages ?? {})) {
            if (message.payload == null) {
                continue;
            }

            let payloadSchema: OpenAPIV3.SchemaObject | undefined = undefined;
            if (context.isReferenceObject(message.payload)) {
                const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(message.payload);
                if (resolved.resolved) {
                    payloadSchema = resolved.value;
                }
            } else {
                payloadSchema = message.payload;
            }
            if (payloadSchema == null) {
                continue;
            }

            const schemaConverter = new SchemaConverter({
                id,
                breadcrumbs: ["components", "messages", id],
                schema: payloadSchema
            });

            const convertedSchema = await schemaConverter.convert({
                context,
                errorCollector
            });

            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertSchemas({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [id, schema] of Object.entries(context.spec.components?.schemas ?? {})) {
            const schemaConverter = new SchemaConverter({
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert({ context, errorCollector });
            if (convertedSchema != null) {
                this.ir.rootPackage.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertServers({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        if (this.isAsyncAPIV3(context)) {
            const servers = context.spec.servers as Record<string, AsyncAPIV3.ServerV3>;
            const serversConverter = new ServersConverter3_0({
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert({ context, errorCollector });
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        } else {
            const servers = context.spec.servers as Record<string, AsyncAPIV2.ServerV2>;
            const serversConverter = new ServersConverter2_X({
                breadcrumbs: ["servers"],
                servers
            });
            const convertedServers = serversConverter.convert({ context, errorCollector });
            if (convertedServers != null) {
                this.ir.environments = convertedServers;
            }
        }
    }

    private async convertChannels({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        for (const [channelPath, channel] of Object.entries(context.spec.channels ?? {})) {
            const groupNameExtension = new Extensions.SdkGroupNameExtension({
                breadcrumbs: ["channels", channelPath],
                operation: channel
            });
            const group = groupNameExtension.convert({ context, errorCollector })?.groups;

            if (this.isAsyncAPIV3(context)) {
                const spec = context.spec as AsyncAPIV3.DocumentV3;
                const operations = spec.operations ?? {};

                const channelConverter = new ChannelConverter3_0({
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    operations,
                    group
                });
                const convertedChannel = await channelConverter.convert({ context, errorCollector });
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            } else {
                const channelConverter = new ChannelConverter2_X({
                    breadcrumbs: ["channels", channelPath],
                    channel,
                    channelPath,
                    group
                });
                const convertedChannel = await channelConverter.convert({ context, errorCollector });
                if (convertedChannel != null) {
                    this.ir.websocketChannels = {
                        ...this.ir.websocketChannels,
                        [group ? group.join(".") : channelPath]: convertedChannel.channel
                    };
                    this.ir.types = {
                        ...this.ir.types,
                        ...convertedChannel.inlinedTypes
                    };
                }
            }
        }
        this.addWebsocketsToIr({ websocketChannels: this.ir.websocketChannels, context });
    }

    private addWebsocketsToIr({
        websocketChannels,
        context
    }: {
        websocketChannels: Record<string, FernIr.WebSocketChannel> | undefined;
        context: AsyncAPIConverterContext;
    }): void {
        if (websocketChannels == null) {
            return;
        }

        for (const [channelPath, _] of Object.entries(websocketChannels)) {
            if (channelPath !== "") {
                if (this.ir.subpackages[channelPath] == null) {
                    this.ir.subpackages[channelPath] = {
                        name: context.casingsGenerator.generateName(channelPath),
                        ...context.createPackage({ name: channelPath })
                    };
                }
                this.ir.subpackages[channelPath].websocket = channelPath;
                this.ir.rootPackage.subpackages.push(channelPath);
            } else {
                this.ir.rootPackage.websocket = channelPath;
            }
        }
    }
}

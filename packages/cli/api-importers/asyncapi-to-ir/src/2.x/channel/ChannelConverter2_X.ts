import { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";

import {
    HttpHeader,
    PathParameter,
    QueryParameter,
    TypeDeclaration,
    TypeReference,
    WebSocketMessage,
    WebSocketMessageBody
} from "@fern-api/ir-sdk";
import { Converters, ErrorCollector } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "..";
import { AsyncAPIConverterContext } from "../../AsyncAPIConverterContext";
import { AbstractChannelConverter } from "../../converters/AbstractChannelConverter";
import { ParameterConverter } from "../../converters/ParameterConverter";

export declare namespace ChannelConverter2_X {
    export interface Args extends AbstractChannelConverter.Args<AsyncAPIV2.ChannelV2> {}
}

export class ChannelConverter2_X extends AbstractChannelConverter<AsyncAPIV2.ChannelV2> {
    protected inlinedTypes: Record<string, TypeDeclaration> = {};

    constructor({ breadcrumbs, channel, channelPath, group }: ChannelConverter2_X.Args) {
        super({ breadcrumbs, channel, channelPath, group });
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<AbstractChannelConverter.Output | undefined> {
        const pathParameters: PathParameter[] = [];
        const queryParameters: QueryParameter[] = [];
        const headers: HttpHeader[] = [];

        const displayName = this.group ? this.group.join(".") : this.channelPath;

        if (this.channel.parameters) {
            await this.convertQueryParameters({
                context,
                errorCollector,
                queryParameters
            });
        }

        if (this.channel.bindings?.ws != null) {
            await this.convertHeaders({
                context,
                errorCollector,
                headers
            });

            await this.convertBindingQueryParameters({
                context,
                errorCollector,
                queryParameters
            });
        }

        let subscribeMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.subscribe != null) {
            subscribeMessage = await this.convertMessage({
                context,
                errorCollector,
                origin: "server",
                operation: this.channel.subscribe,
                defaultId: "subscribeEvent",
                breadcrumbName: "subscribeEvent"
            });
        }

        let publishMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.publish != null) {
            publishMessage = await this.convertMessage({
                context,
                errorCollector,
                origin: "client",
                operation: this.channel.publish,
                defaultId: "publishEvent",
                breadcrumbName: "publishEvent"
            });
        }

        const messages: WebSocketMessage[] = [];
        if (subscribeMessage != null) {
            messages.push(subscribeMessage);
        }
        if (publishMessage != null) {
            messages.push(publishMessage);
        }

        const baseUrl = this.channel.servers?.[0] ?? Object.keys(context.spec.servers ?? {})[0];
        const pathHead = this.transformToValidPath(this.channel.address ?? this.channelPath);

        return {
            channel: {
                name: context.casingsGenerator.generateName(displayName),
                displayName,
                baseUrl,
                path: {
                    head: pathHead,
                    parts: []
                },
                auth: false,
                headers,
                queryParameters,
                pathParameters,
                messages,
                availability: await context.getAvailability({
                    node: this.channel,
                    breadcrumbs: this.breadcrumbs,
                    errorCollector
                }),
                docs: this.channel.description,
                examples: [],
                v2Examples: {
                    autogeneratedExamples: {},
                    userSpecifiedExamples: this.convertExamples({
                        pathHead,
                        baseUrl,
                        context,
                        errorCollector
                    })
                }
            },
            inlinedTypes: this.inlinedTypes
        };
    }

    private async convertMessage({
        context,
        errorCollector,
        origin,
        operation,
        defaultId,
        breadcrumbName
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        origin: "server" | "client";
        operation: AsyncAPIV2.PublishEvent | AsyncAPIV2.SubscribeEvent;
        defaultId: string;
        breadcrumbName: string;
    }): Promise<WebSocketMessage | undefined> {
        let convertedSchema: TypeDeclaration | undefined = undefined;

        if (context.isReferenceObject(operation.message)) {
            const resolved = await context.resolveReference<OpenAPIV3.SchemaObject | AsyncAPIV2.MessageV2>(
                operation.message as OpenAPIV3.ReferenceObject
            );
            if (resolved.resolved) {
                operation.message = resolved.value;
            }
        }

        if ("oneOf" in operation.message) {
            const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                breadcrumbs: [...this.breadcrumbs, breadcrumbName],
                schemaOrReference: operation.message,
                schemaIdOverride: operation.operationId ?? defaultId
            });
            const schemaOrReferenceConverterOutput = await schemaOrReferenceConverter.convert({
                context,
                errorCollector
            });
            if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                convertedSchema = schemaOrReferenceConverterOutput.schema;
                this.inlinedTypes = {
                    ...this.inlinedTypes,
                    ...schemaOrReferenceConverterOutput.inlinedTypes
                };
            }
        } else if (context.isMessageWithPayload(operation.message)) {
            let payloadSchema: OpenAPIV3.SchemaObject | undefined = undefined;
            if (context.isReferenceObject(operation.message.payload)) {
                const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(operation.message.payload);
                if (resolved.resolved) {
                    payloadSchema = resolved.value;
                }
            } else {
                payloadSchema = operation.message.payload;
            }
            if (payloadSchema != null) {
                const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                    breadcrumbs: [...this.breadcrumbs, breadcrumbName],
                    schemaOrReference: payloadSchema,
                    schemaIdOverride: operation.operationId ?? defaultId
                });
                const schemaOrReferenceConverterOutput = await schemaOrReferenceConverter.convert({
                    context,
                    errorCollector
                });
                if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                    convertedSchema = schemaOrReferenceConverterOutput.schema;
                    this.inlinedTypes = {
                        ...this.inlinedTypes,
                        ...schemaOrReferenceConverterOutput.inlinedTypes
                    };
                }
            }
        }

        if (convertedSchema != null) {
            const convertedTypeDeclaration = convertedSchema;

            const typeReference = TypeReference.named({
                fernFilepath: context.createFernFilepath(),
                name: convertedTypeDeclaration.name.name,
                typeId: convertedTypeDeclaration.name.typeId,
                default: undefined,
                inline: false
            });

            const body = WebSocketMessageBody.reference({
                bodyType: typeReference,
                docs: operation.description
            });

            return {
                type: convertedTypeDeclaration.name.typeId,
                displayName: convertedTypeDeclaration.name.name.originalName,
                origin,
                body,
                availability: await context.getAvailability({
                    node: operation,
                    breadcrumbs: this.breadcrumbs,
                    errorCollector
                }),
                docs: operation.description
            };
        }

        return undefined;
    }

    private async convertQueryParameters({
        context,
        errorCollector,
        queryParameters
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        queryParameters: QueryParameter[];
    }): Promise<void> {
        for (const [name, parameter] of Object.entries(this.channel.parameters ?? {})) {
            let parameterObject = parameter as OpenAPIV3_1.ParameterObject;
            if (context.isReferenceObject(parameter)) {
                const resolvedReference = await context.resolveReference<OpenAPIV3_1.ParameterObject>(parameter);
                if (resolvedReference.resolved) {
                    parameterObject = resolvedReference.value;
                } else {
                    continue;
                }
            }
            const parameterConverter = new ParameterConverter({
                breadcrumbs: this.breadcrumbs,
                parameter: {
                    ...parameterObject,
                    name,
                    in: "query",
                    description: parameter.description,
                    required: parameter.required ?? false
                }
            });
            const convertedParameter = await parameterConverter.convert({ context, errorCollector });
            if (convertedParameter != null) {
                this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                if (convertedParameter.type === "query") {
                    queryParameters.push(convertedParameter.parameter);
                }
            }
        }
    }

    private async convertHeaders({
        context,
        errorCollector,
        headers
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        headers: HttpHeader[];
    }): Promise<void> {
        if (this.channel.bindings?.ws?.headers != null) {
            const required = this.channel.bindings.ws.headers.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.headers.properties ?? {})) {
                let resolvedHeader = schema;
                if (context.isReferenceObject(schema)) {
                    const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(schema);
                    if (!resolved.resolved) {
                        continue;
                    }
                    resolvedHeader = resolved.value;
                }

                const parameterConverter = new ParameterConverter({
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "header",
                        required: required.includes(name),
                        schema: resolvedHeader,
                        description: "description" in resolvedHeader ? resolvedHeader.description : undefined
                    }
                });

                const convertedParameter = await parameterConverter.convert({ context, errorCollector });
                if (convertedParameter != null && convertedParameter.type === "header") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    headers.push(convertedParameter.parameter);
                }
            }
        }
    }

    private async convertBindingQueryParameters({
        context,
        errorCollector,
        queryParameters
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        queryParameters: QueryParameter[];
    }): Promise<void> {
        if (this.channel.bindings?.ws?.query != null) {
            const required = this.channel.bindings.ws.query.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.query.properties ?? {})) {
                let resolvedQuery = schema;
                if (context.isReferenceObject(schema)) {
                    const resolved = await context.resolveReference<OpenAPIV3.SchemaObject>(schema);
                    if (!resolved.resolved) {
                        continue;
                    }
                    resolvedQuery = resolved.value;
                }

                const parameterConverter = new ParameterConverter({
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "query",
                        required: required.includes(name),
                        schema: resolvedQuery,
                        description: "description" in resolvedQuery ? resolvedQuery.description : undefined
                    }
                });

                const convertedParameter = await parameterConverter.convert({ context, errorCollector });
                if (convertedParameter != null && convertedParameter.type === "query") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    queryParameters.push(convertedParameter.parameter);
                }
            }
        }
    }
}

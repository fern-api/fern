import {
    HttpHeader,
    PathParameter,
    QueryParameter,
    TypeReference,
    WebSocketMessage,
    WebSocketMessageBody
} from "@fern-api/ir-sdk";
import { constructHttpPath } from "@fern-api/ir-utils";
import { Converters } from "@fern-api/v3-importer-commons";
import { camelCase, startCase } from "lodash-es";
import { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";
import { AsyncAPIConverterContext } from "../../AsyncAPIConverterContext";
import { AbstractChannelConverter } from "../../converters/AbstractChannelConverter";
import { ParameterConverter } from "../../converters/ParameterConverter";
import { ChannelAddressExtension } from "../../extensions/x-fern-channel-address";
import { DisplayNameExtension } from "../../extensions/x-fern-display-name";
import { FernRetriesExtension } from "../../extensions/x-fern-retries";
import { AsyncAPIV2 } from "..";

export declare namespace ChannelConverter2_X {
    export interface Args extends AbstractChannelConverter.Args<AsyncAPIV2.ChannelV2> {}
}

export class ChannelConverter2_X extends AbstractChannelConverter<AsyncAPIV2.ChannelV2> {
    protected inlinedTypes: Record<string, Converters.SchemaConverters.SchemaConverter.ConvertedSchema> = {};

    constructor({ context, breadcrumbs, websocketGroup, channel, channelPath }: ChannelConverter2_X.Args) {
        super({ context, breadcrumbs, websocketGroup, channel, channelPath });
    }

    public convert(): AbstractChannelConverter.Output | undefined {
        const pathParameters: PathParameter[] = [];
        const queryParameters: QueryParameter[] = [];
        const headers: HttpHeader[] = [];

        const displayNameExtension = new DisplayNameExtension({
            breadcrumbs: this.breadcrumbs,
            channel: this.channel,
            context: this.context
        });
        const displayName = displayNameExtension.convert() ?? this.websocketGroup?.join(".");

        const retriesExtension = new FernRetriesExtension({
            breadcrumbs: this.breadcrumbs,
            operation: this.channel,
            context: this.context
        });
        retriesExtension.convert();

        if (this.channel.parameters) {
            this.convertPathParameters({
                context: this.context,
                pathParameters
            });
        }

        if (this.channel.bindings?.ws != null) {
            this.convertHeaders({
                context: this.context,
                headers
            });
            this.convertBindingQueryParameters({
                context: this.context,
                queryParameters
            });
        }

        let subscribeMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.subscribe != null) {
            subscribeMessage = this.convertMessage({
                context: this.context,
                operation: this.channel.subscribe,
                origin: "server"
            });
        }

        let publishMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.publish != null) {
            publishMessage = this.convertMessage({
                context: this.context,
                operation: this.channel.publish,
                origin: "client"
            });
        }

        const messages: WebSocketMessage[] = [];
        if (subscribeMessage != null) {
            messages.push(subscribeMessage);
        }
        if (publishMessage != null) {
            messages.push(publishMessage);
        }

        const channelAddressExtension = new ChannelAddressExtension({
            breadcrumbs: this.breadcrumbs,
            channel: this.channel,
            context: this.context
        });
        const channelAddressExtensionValue = channelAddressExtension.convert();
        const channelAddress = this.transformToValidPath(channelAddressExtensionValue ?? this.channelPath);
        const baseUrl = this.channel.servers?.[0] ?? Object.keys(this.context.spec.servers ?? {})[0];
        const path = constructHttpPath(channelAddress);
        const groupName = camelCase(this.channelPath);

        const audiences =
            this.context.getAudiences({
                operation: this.channel,
                breadcrumbs: this.breadcrumbs
            }) ?? [];

        return {
            channel: {
                name: this.context.casingsGenerator.generateName(groupName),
                displayName,
                baseUrl,
                path,
                auth: false,
                headers,
                queryParameters,
                pathParameters,
                messages,
                availability: this.context.getAvailability({
                    node: this.channel,
                    breadcrumbs: this.breadcrumbs
                }),
                docs: this.channel.description,
                examples: [],
                v2Examples: {
                    autogeneratedExamples: {},
                    userSpecifiedExamples: this.convertExamples({
                        fullPath: channelAddress,
                        baseUrl,
                        asyncApiVersion: "v2"
                    })
                }
            },
            audiences,
            inlinedTypes: this.inlinedTypes
        };
    }

    private convertMessage({
        context,
        operation,
        origin
    }: {
        context: AsyncAPIConverterContext;
        operation: AsyncAPIV2.PublishEvent | AsyncAPIV2.SubscribeEvent;
        origin: "server" | "client";
    }): WebSocketMessage | undefined {
        let convertedSchema: Converters.SchemaConverters.SchemaConverter.ConvertedSchema | undefined = undefined;
        const action = origin === "server" ? "subscribe" : "publish";
        const breadcrumbs = [...this.breadcrumbs, action];

        const retriesExtension = new FernRetriesExtension({
            breadcrumbs,
            operation: operation as object,
            context: this.context
        });
        retriesExtension.convert();

        const resolvedMessage = context.resolveMaybeReference<OpenAPIV3.SchemaObject | AsyncAPIV2.MessageV2>({
            schemaOrReference: operation.message,
            breadcrumbs
        });
        if (resolvedMessage != null) {
            operation.message = resolvedMessage;
        }

        const schemaId = startCase(camelCase(`${this.channelPath}_${action}`)).replace(/ /g, "");

        if ("oneOf" in operation.message) {
            const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                context: this.context,
                breadcrumbs,
                schemaOrReference: operation.message,
                schemaIdOverride: schemaId
            });
            const schemaOrReferenceConverterOutput = schemaOrReferenceConverter.convert();
            if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                convertedSchema = schemaOrReferenceConverterOutput.schema;
                this.inlinedTypes = {
                    ...this.inlinedTypes,
                    ...schemaOrReferenceConverterOutput.inlinedTypes
                };
            }
        } else if (context.isMessageWithPayload(operation.message)) {
            const payloadSchema = context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                schemaOrReference: operation.message.payload,
                breadcrumbs
            });
            if (payloadSchema != null) {
                const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                    context: this.context,
                    breadcrumbs,
                    schemaOrReference: payloadSchema,
                    schemaIdOverride: schemaId
                });
                const schemaOrReferenceConverterOutput = schemaOrReferenceConverter.convert();
                if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                    convertedSchema = schemaOrReferenceConverterOutput.schema;
                    this.inlinedTypes = {
                        ...this.inlinedTypes,
                        ...schemaOrReferenceConverterOutput.inlinedTypes
                    };
                }
            }
        }

        if (convertedSchema != null) {
            const convertedTypeDeclaration = convertedSchema;

            const typeReference = TypeReference.named({
                fernFilepath: context.createFernFilepath(),
                name: convertedTypeDeclaration.typeDeclaration.name.name,
                typeId: convertedTypeDeclaration.typeDeclaration.name.typeId,
                displayName: undefined,
                default: undefined,
                inline: false
            });

            const body = WebSocketMessageBody.reference({
                bodyType: typeReference,
                docs: operation.description
            });

            const messageType = origin === "server" ? "subscribe" : "publish";
            return {
                type: messageType,
                displayName: messageType,
                origin,
                body,
                availability: context.getAvailability({
                    node: operation,
                    breadcrumbs: this.breadcrumbs
                }),
                docs: operation.description
            };
        }

        return undefined;
    }

    private convertPathParameters({
        context,
        pathParameters
    }: {
        context: AsyncAPIConverterContext;
        pathParameters: PathParameter[];
    }): void {
        for (const [name, parameter] of Object.entries(this.channel.parameters ?? {})) {
            const parameterObject = context.resolveMaybeReference<OpenAPIV3_1.ParameterObject>({
                schemaOrReference: parameter,
                breadcrumbs: this.breadcrumbs
            });
            if (parameterObject == null) {
                continue;
            }
            const parameterConverter = new ParameterConverter({
                context: this.context,
                breadcrumbs: this.breadcrumbs,
                parameter: {
                    ...parameterObject,
                    name,
                    in: "path",
                    description: parameterObject.description,
                    required: parameterObject.required ?? true
                }
            });
            const convertedParameter = parameterConverter.convert();
            if (convertedParameter != null) {
                this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                if (convertedParameter.type === "path") {
                    pathParameters.push(convertedParameter.parameter);
                }
            }
        }
    }

    private convertHeaders({ context, headers }: { context: AsyncAPIConverterContext; headers: HttpHeader[] }): void {
        if (this.channel.bindings?.ws?.headers != null) {
            const required = this.channel.bindings.ws.headers.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.headers.properties ?? {})) {
                const resolvedHeader = context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: schema,
                    breadcrumbs: [...this.breadcrumbs, name]
                });
                if (resolvedHeader == null) {
                    continue;
                }

                const parameterConverter = new ParameterConverter({
                    context: this.context,
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "header",
                        required: required.includes(name),
                        schema: resolvedHeader,
                        description: "description" in resolvedHeader ? resolvedHeader.description : undefined
                    }
                });

                const convertedParameter = parameterConverter.convert();
                if (convertedParameter != null && convertedParameter.type === "header") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    headers.push(convertedParameter.parameter);
                }
            }
        }
    }

    private convertBindingQueryParameters({
        context,
        queryParameters
    }: {
        context: AsyncAPIConverterContext;
        queryParameters: QueryParameter[];
    }): void {
        if (this.channel.bindings?.ws?.query != null) {
            const required = this.channel.bindings.ws.query.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.query.properties ?? {})) {
                const resolvedQuery = context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: schema,
                    breadcrumbs: [...this.breadcrumbs, name]
                });
                if (resolvedQuery == null) {
                    continue;
                }

                const parameterConverter = new ParameterConverter({
                    context: this.context,
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "query",
                        required: required.includes(name),
                        schema: resolvedQuery,
                        description: "description" in resolvedQuery ? resolvedQuery.description : undefined,
                        deprecated: resolvedQuery.deprecated ?? false
                    }
                });

                const convertedParameter = parameterConverter.convert();
                if (convertedParameter != null && convertedParameter.type === "query") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    queryParameters.push(convertedParameter.parameter);
                }
            }
        }
    }
}

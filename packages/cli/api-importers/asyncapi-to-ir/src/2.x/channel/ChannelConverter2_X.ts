import { camelCase, startCase } from "lodash-es";
import { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";

import {
    HttpHeader,
    PathParameter,
    QueryParameter,
    TypeDeclaration,
    TypeReference,
    WebSocketMessage,
    WebSocketMessageBody
} from "@fern-api/ir-sdk";
import { Converters } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "..";
import { AsyncAPIConverterContext } from "../../AsyncAPIConverterContext";
import { AbstractChannelConverter } from "../../converters/AbstractChannelConverter";
import { ParameterConverter } from "../../converters/ParameterConverter";
import { ChannelAddressExtension } from "../../extensions/x-fern-channel-address";
import { DisplayNameExtension } from "../../extensions/x-fern-display-name";

export declare namespace ChannelConverter2_X {
    export interface Args extends AbstractChannelConverter.Args<AsyncAPIV2.ChannelV2> {}
}

export class ChannelConverter2_X extends AbstractChannelConverter<AsyncAPIV2.ChannelV2> {
    protected inlinedTypes: Record<string, TypeDeclaration> = {};

    constructor({ context, breadcrumbs, channel, channelPath, group }: ChannelConverter2_X.Args) {
        super({ context, breadcrumbs, channel, channelPath, group });
    }

    public async convert(): Promise<AbstractChannelConverter.Output | undefined> {
        const pathParameters: PathParameter[] = [];
        const queryParameters: QueryParameter[] = [];
        const headers: HttpHeader[] = [];

        const displayNameExtension = new DisplayNameExtension({
            breadcrumbs: this.breadcrumbs,
            channel: this.channel,
            context: this.context
        });
        const displayName = displayNameExtension.convert() ?? this.channelPath;

        if (this.channel.parameters) {
            await this.convertQueryParameters({
                context: this.context,
                queryParameters
            });
        }

        if (this.channel.bindings?.ws != null) {
            await this.convertHeaders({
                context: this.context,
                headers
            });

            await this.convertBindingQueryParameters({
                context: this.context,
                queryParameters
            });
        }

        let subscribeMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.subscribe != null) {
            subscribeMessage = await this.convertMessage({
                context: this.context,
                operation: this.channel.subscribe,
                origin: "server"
            });
        }

        let publishMessage: WebSocketMessage | undefined = undefined;
        if (this.channel.publish != null) {
            publishMessage = await this.convertMessage({
                context: this.context,
                operation: this.channel.publish,
                origin: "client"
            });
        }

        const messages: WebSocketMessage[] = [];
        if (subscribeMessage != null) {
            messages.push(subscribeMessage);
        }
        if (publishMessage != null) {
            messages.push(publishMessage);
        }

        const channelAddressExtension = new ChannelAddressExtension({
            breadcrumbs: this.breadcrumbs,
            channel: this.channel,
            context: this.context
        });
        const channelAddress = channelAddressExtension.convert();
        const baseUrl = this.channel.servers?.[0] ?? Object.keys(this.context.spec.servers ?? {})[0];
        const pathHead = channelAddress != null ? channelAddress : this.transformToValidPath(this.channelPath);
        const groupName = camelCase(this.channelPath);

        return {
            channel: {
                name: this.context.casingsGenerator.generateName(groupName),
                displayName,
                baseUrl,
                path: {
                    head: pathHead,
                    parts: []
                },
                auth: false,
                headers,
                queryParameters,
                pathParameters,
                messages,
                availability: await this.context.getAvailability({
                    node: this.channel,
                    breadcrumbs: this.breadcrumbs
                }),
                docs: this.channel.description,
                examples: [],
                v2Examples: {
                    autogeneratedExamples: {},
                    userSpecifiedExamples: this.convertExamples({
                        pathHead,
                        baseUrl
                    })
                }
            },
            inlinedTypes: this.inlinedTypes
        };
    }

    private async convertMessage({
        context,
        operation,
        origin
    }: {
        context: AsyncAPIConverterContext;
        operation: AsyncAPIV2.PublishEvent | AsyncAPIV2.SubscribeEvent;
        origin: "server" | "client";
    }): Promise<WebSocketMessage | undefined> {
        let convertedSchema: TypeDeclaration | undefined = undefined;
        const action = origin === "server" ? "subscribe" : "publish";
        const breadcrumbs = [...this.breadcrumbs, action];

        const resolvedMessage = await context.resolveMaybeReference<OpenAPIV3.SchemaObject | AsyncAPIV2.MessageV2>({
            schemaOrReference: operation.message,
            breadcrumbs
        });
        if (resolvedMessage != null) {
            operation.message = resolvedMessage;
        }

        const schemaId = startCase(camelCase(`${this.channelPath}_${action}`)).replace(/ /g, "");

        if ("oneOf" in operation.message) {
            const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                context: this.context,
                breadcrumbs,
                schemaOrReference: operation.message,
                schemaIdOverride: schemaId
            });
            const schemaOrReferenceConverterOutput = await schemaOrReferenceConverter.convert();
            if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                convertedSchema = schemaOrReferenceConverterOutput.schema;
                this.inlinedTypes = {
                    ...this.inlinedTypes,
                    ...schemaOrReferenceConverterOutput.inlinedTypes
                };
            }
        } else if (context.isMessageWithPayload(operation.message)) {
            const payloadSchema = await context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                schemaOrReference: operation.message.payload,
                breadcrumbs
            });
            if (payloadSchema != null) {
                const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
                    context: this.context,
                    breadcrumbs,
                    schemaOrReference: payloadSchema,
                    schemaIdOverride: schemaId
                });
                const schemaOrReferenceConverterOutput = await schemaOrReferenceConverter.convert();
                if (schemaOrReferenceConverterOutput != null && schemaOrReferenceConverterOutput.schema != null) {
                    convertedSchema = schemaOrReferenceConverterOutput.schema;
                    this.inlinedTypes = {
                        ...this.inlinedTypes,
                        ...schemaOrReferenceConverterOutput.inlinedTypes
                    };
                }
            }
        }

        if (convertedSchema != null) {
            const convertedTypeDeclaration = convertedSchema;

            const typeReference = TypeReference.named({
                fernFilepath: context.createFernFilepath(),
                name: convertedTypeDeclaration.name.name,
                typeId: convertedTypeDeclaration.name.typeId,
                default: undefined,
                inline: false
            });

            const body = WebSocketMessageBody.reference({
                bodyType: typeReference,
                docs: operation.description
            });

            const messageType = origin === "server" ? "subscribe" : "publish";
            return {
                type: messageType,
                displayName: messageType,
                origin,
                body,
                availability: await context.getAvailability({
                    node: operation,
                    breadcrumbs: this.breadcrumbs
                }),
                docs: operation.description
            };
        }

        return undefined;
    }

    private async convertQueryParameters({
        context,
        queryParameters
    }: {
        context: AsyncAPIConverterContext;
        queryParameters: QueryParameter[];
    }): Promise<void> {
        for (const [name, parameter] of Object.entries(this.channel.parameters ?? {})) {
            const parameterObject = await context.resolveMaybeReference<OpenAPIV3_1.ParameterObject>({
                schemaOrReference: parameter,
                breadcrumbs: this.breadcrumbs
            });
            if (parameterObject == null) {
                continue;
            }
            const parameterConverter = new ParameterConverter({
                context: this.context,
                breadcrumbs: this.breadcrumbs,
                parameter: {
                    ...parameterObject,
                    name,
                    in: "query",
                    description: parameter.description,
                    required: parameter.required ?? false
                }
            });
            const convertedParameter = await parameterConverter.convert();
            if (convertedParameter != null) {
                this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                if (convertedParameter.type === "query") {
                    queryParameters.push(convertedParameter.parameter);
                }
            }
        }
    }

    private async convertHeaders({
        context,
        headers
    }: {
        context: AsyncAPIConverterContext;
        headers: HttpHeader[];
    }): Promise<void> {
        if (this.channel.bindings?.ws?.headers != null) {
            const required = this.channel.bindings.ws.headers.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.headers.properties ?? {})) {
                const resolvedHeader = await context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: schema,
                    breadcrumbs: [...this.breadcrumbs, name]
                });
                if (resolvedHeader == null) {
                    continue;
                }

                const parameterConverter = new ParameterConverter({
                    context: this.context,
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "header",
                        required: required.includes(name),
                        schema: resolvedHeader,
                        description: "description" in resolvedHeader ? resolvedHeader.description : undefined
                    }
                });

                const convertedParameter = await parameterConverter.convert();
                if (convertedParameter != null && convertedParameter.type === "header") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    headers.push(convertedParameter.parameter);
                }
            }
        }
    }

    private async convertBindingQueryParameters({
        context,
        queryParameters
    }: {
        context: AsyncAPIConverterContext;
        queryParameters: QueryParameter[];
    }): Promise<void> {
        if (this.channel.bindings?.ws?.query != null) {
            const required = this.channel.bindings.ws.query.required ?? [];
            for (const [name, schema] of Object.entries(this.channel.bindings.ws.query.properties ?? {})) {
                const resolvedQuery = await context.resolveMaybeReference<OpenAPIV3.SchemaObject>({
                    schemaOrReference: schema,
                    breadcrumbs: [...this.breadcrumbs, name]
                });
                if (resolvedQuery == null) {
                    continue;
                }

                const parameterConverter = new ParameterConverter({
                    context: this.context,
                    breadcrumbs: [...this.breadcrumbs, name],
                    parameter: {
                        name,
                        in: "query",
                        required: required.includes(name),
                        schema: resolvedQuery,
                        description: "description" in resolvedQuery ? resolvedQuery.description : undefined
                    }
                });

                const convertedParameter = await parameterConverter.convert();
                if (convertedParameter != null && convertedParameter.type === "query") {
                    this.inlinedTypes = { ...this.inlinedTypes, ...convertedParameter.inlinedTypes };
                    queryParameters.push(convertedParameter.parameter);
                }
            }
        }
    }
}

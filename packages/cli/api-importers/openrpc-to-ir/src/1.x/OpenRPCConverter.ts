import { MethodObject, OpenrpcDocument, ServerObject } from "@open-rpc/meta-schema";

import { HttpHeader, IntermediateRepresentation, PathParameter, QueryParameter } from "@fern-api/ir-sdk";
import { constructHttpPath, injectAutogeneratedExamples, injectAutogeneratedV2Examples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, ServersConverter } from "@fern-api/v2-importer-commons";

import { OpenRPCConverterContext3_1 } from "./OpenRPCConverterContext3_1";
import { ParameterConverter } from "./ParameterConverter";
import { FernParametersExtension } from "./extensions/x-fern-parameters";
import { MethodConverter } from "./methods/MethodConverter";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace OpenRPCConverter {
    type Args = AbstractConverter.Args<OpenRPCConverterContext3_1>;
}

export class OpenRPCConverter extends AbstractConverter<OpenRPCConverterContext3_1, IntermediateRepresentation> {
    constructor({ context, breadcrumbs }: OpenRPCConverter.Args) {
        super({ context, breadcrumbs });
    }

    public async convert(): Promise<IntermediateRepresentation> {
        this.context.spec = this.removeXFernIgnores({
            document: this.context.spec,
            context: this.context
        }) as OpenrpcDocument;

        this.convertServers({});

        await this.convertSchemas();

        await this.convertMethods();

        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs }),
            ...injectAutogeneratedV2Examples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };

        return ir;
    }

    private convertServers({ endpointLevelServers }: { endpointLevelServers?: ServerObject[] }): void {
        const serversConverter = new ServersConverter({
            context: this.context,
            breadcrumbs: ["servers"],
            servers: this.context.spec.servers,
            endpointLevelServers
        });
        const convertedServers = serversConverter.convert();
        if (convertedServers != null) {
            this.ir.environments = convertedServers.value;
        }
    }

    private async convertSchemas(): Promise<void> {
        const group = this.context.getGroup({
            groupParts: [],
            namespace: this.context.namespace
        });

        const pkg = this.getOrCreatePackage({
            group
        });

        for (const [id, schema] of Object.entries(this.context.spec.components?.schemas ?? {})) {
            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert();
            if (convertedSchema != null) {
                pkg.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertMethods(): Promise<void> {
        // Import the FernParametersExtension to handle custom parameters
        const fernParametersExtension = new FernParametersExtension({
            context: this.context,
            breadcrumbs: ["methods"],
            operation: this.context.spec
        });

        const customParameters = fernParametersExtension.convert();
        // Process custom parameters from x-fern-parameters extension
        const pathParameters: PathParameter[] = [];
        const queryParameters: QueryParameter[] = [];
        const headers: HttpHeader[] = [];

        if (customParameters && customParameters.length > 0) {
            for (const [index, parameter] of customParameters.entries()) {
                const parameterConverter = new ParameterConverter({
                    context: this.context,
                    breadcrumbs: [...this.breadcrumbs, `x-fern-parameters[${index}]`],
                    parameter
                });

                const convertedParameter = await parameterConverter.convert();
                if (convertedParameter == null) {
                    continue;
                }
                switch (convertedParameter.type) {
                    case "path": {
                        pathParameters.push(convertedParameter.parameter);
                        break;
                    }
                    case "query": {
                        queryParameters.push(convertedParameter.parameter);
                        break;
                    }
                    case "header": {
                        headers.push(convertedParameter.parameter);
                        break;
                    }
                }
            }
        }

        const group = this.context.getGroup({
            groupParts: [],
            namespace: this.context.namespace
        });

        const pkg = this.getOrCreatePackage({
            group
        });

        for (const method of this.context.spec.methods ?? []) {
            const resolvedMethod = await this.context.resolveMaybeReference<MethodObject>({
                schemaOrReference: method,
                breadcrumbs: ["methods"]
            });
            if (resolvedMethod == null) {
                continue;
            }

            const methodConverter = new MethodConverter({
                context: this.context,
                breadcrumbs: ["methods"],
                method: resolvedMethod,
                pathParameters,
                queryParameters,
                headers
            });

            const convertedMethod = await methodConverter.convert();

            if (convertedMethod != null) {
                if (pkg.service == null) {
                    pkg.service = "service_root";
                }

                const allParts = [...group].map((part) => this.context.casingsGenerator.generateName(part));
                const finalpart = allParts[allParts.length - 1];

                if (this.ir.services[pkg.service] == null) {
                    this.ir.services[pkg.service] = {
                        name: {
                            fernFilepath: {
                                allParts,
                                packagePath: allParts.slice(0, -1),
                                file: finalpart
                            }
                        },
                        displayName: undefined,
                        basePath: constructHttpPath(""),
                        headers: [],
                        pathParameters: [],
                        availability: undefined,
                        endpoints: [],
                        transport: undefined,
                        encoding: undefined
                    };
                }

                this.ir.services[pkg.service]?.endpoints.push(convertedMethod.endpoint);

                this.ir.types = {
                    ...this.ir.types,
                    ...convertedMethod.inlinedTypes
                };
            }
        }
    }
}

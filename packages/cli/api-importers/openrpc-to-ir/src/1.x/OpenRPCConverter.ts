import { OpenrpcDocument } from "@open-rpc/meta-schema";

import { IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, ErrorCollector } from "@fern-api/v2-importer-commons";

import { OpenRPCConverterContext3_1 } from "./OpenRPCConverterContext3_1";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace OpenRPCConverter {
    type Args = AbstractConverter.Args<OpenRPCConverterContext3_1>;
}

export class OpenRPCConverter extends AbstractConverter<OpenRPCConverterContext3_1, IntermediateRepresentation> {
    constructor({ context, breadcrumbs }: OpenRPCConverter.Args) {
        super({ context, breadcrumbs });
    }

    public async convert({ errorCollector }: { errorCollector: ErrorCollector }): Promise<IntermediateRepresentation> {
        this.context.spec = this.removeXFernIgnores({
            document: this.context.spec,
            context: this.context,
            errorCollector
        }) as OpenrpcDocument;

        await this.convertSchemas({ errorCollector });

        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };

        return ir;
    }

    private async convertSchemas({ errorCollector }: { errorCollector: ErrorCollector }): Promise<void> {
        const group = this.context.getGroup({
            groupParts: [],
            namespace: this.context.namespace
        });

        const pkg = this.getOrCreatePackage({
            group
        });

        for (const [id, schema] of Object.entries(this.context.spec.components?.schemas ?? {})) {
            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                context: this.context,
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert({ errorCollector });
            if (convertedSchema != null) {
                pkg.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }
}

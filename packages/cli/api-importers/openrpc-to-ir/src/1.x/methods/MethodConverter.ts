import { ContentDescriptorObject, MethodObject } from "@open-rpc/meta-schema";
import { OpenAPIV3 } from "openapi-types";

import {
    HttpEndpoint,
    HttpPath,
    PathParameter,
    PrimitiveTypeV2,
    TypeDeclaration,
    TypeId,
    TypeReference
} from "@fern-api/ir-sdk";
import { AbstractConverter, Converters, ErrorCollector } from "@fern-api/v2-importer-commons";

import { OpenRPCConverter } from "../OpenRPCConverter";
import { OpenRPCConverterContext3_1 } from "../OpenRPCConverterContext3_1";

export declare namespace MethodConverter {
    export interface Args extends OpenRPCConverter.Args {
        method: MethodObject;
        endpoint: HttpEndpoint;
    }

    export interface Output {
        endpoint: HttpEndpoint;
        inlinedTypes: Record<TypeId, TypeDeclaration>;
    }
}

export class MethodConverter extends AbstractConverter<OpenRPCConverterContext3_1, MethodConverter.Output> {
    public static STRING = TypeReference.primitive({
        v1: "STRING",
        v2: PrimitiveTypeV2.string({
            default: undefined,
            validation: undefined
        })
    });

    private readonly method: MethodObject;

    constructor({ context, breadcrumbs, method }: MethodConverter.Args) {
        super({ context, breadcrumbs });
        this.method = method;
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: OpenRPCConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<MethodConverter.Output | undefined> {
        const inlinedTypes: Record<TypeId, TypeDeclaration> = {};

        const apiKeyPathParameter: PathParameter = {
            name: context.casingsGenerator.generateName("apiKey"),
            docs: undefined,
            valueType: MethodConverter.STRING,
            location: "ENDPOINT",
            variable: undefined,
            v2Examples: undefined
        };
        const path: HttpPath = {
            head: "/",
            parts: [
                {
                    pathParameter: "apiKey",
                    tail: ""
                }
            ]
        };

        for (const param of this.method.params) {
            let resolvedParam: ContentDescriptorObject;
            if (this.context.isReferenceObject(param)) {
                const resolvedParamResponse = await this.context.resolveReference<ContentDescriptorObject>(param);
                if (resolvedParamResponse.resolved) {
                    resolvedParam = resolvedParamResponse.value;
                } else {
                    continue;
                }
            } else {
                resolvedParam = param;
            }

            const parameterSchemaConverter = new Converters.SchemaConverters.SchemaConverter({
                breadcrumbs: [...this.breadcrumbs, "params"],
                context: this.context,
                schema: resolvedParam.schema as OpenAPIV3.SchemaObject,
                inlined: true,
                id: ""
            });
            const schema = await parameterSchemaConverter.convert({ errorCollector });
        }

        const endpoint: HttpEndpoint = {
            baseUrl: undefined,
            basePath: undefined,
            auth: false,
            method: "POST",
            id: this.method.name,
            docs: this.method.description,
            name: context.casingsGenerator.generateName(this.method.name),
            headers: [],
            displayName: this.method.name,
            pathParameters: [apiKeyPathParameter],
            queryParameters: [],
            allPathParameters: [apiKeyPathParameter],
            path,
            fullPath: path,
            requestBody: undefined,
            sdkRequest: undefined,
            response: undefined,
            errors: [],
            idempotent: false,
            pagination: undefined,
            userSpecifiedExamples: [],
            autogeneratedExamples: [],
            v2Examples: undefined,
            transport: undefined,
            availability: undefined
        };

        return {
            endpoint,
            inlinedTypes
        };
    }
}

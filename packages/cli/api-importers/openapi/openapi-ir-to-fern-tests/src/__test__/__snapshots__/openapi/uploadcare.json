{
  "absoluteFilePath": "/DUMMY_PATH",
  "importedDefinitions": {},
  "namedDefinitionFiles": {
    "__package__.yml": {
      "absoluteFilepath": "/DUMMY_PATH",
      "contents": {
        "errors": {
          "BadRequestError": {
            "docs": "Request failed input parameters validation.",
            "examples": [
              {
                "docs": undefined,
                "name": "request-fields-number-limit-exceeded",
                "value": "The request contains too many HTTP POST fields.",
              },
              {
                "docs": undefined,
                "name": "post-request-parser-failed",
                "value": "HTTP POST request parsing failed.",
              },
              {
                "docs": undefined,
                "name": "null-characters-forbidden",
                "value": "Null characters are not allowed.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-key-duplicate",
                "value": "File's metadata key `subsystem` has a duplicate.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-key-empty",
                "value": "File's metadata key can not be empty.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-key-forbidden",
                "value": "File's metadata key `subsystem` contains symbols not allowed by the metadata key format.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-key-length-too-big",
                "value": "Length of file metadata key `aaa...` can not be more than 64 symbols.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-value-empty",
                "value": "Value of the file metadata key `subsystem` can not be empty.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-value-forbidden",
                "value": "Value of file metadata key `subsystem` contains symbols not allowed by the metadata value format.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-value-length-too-big",
                "value": "Value of file metadata's key `subsystem` can not be more than 512 symbols in length.",
              },
              {
                "docs": undefined,
                "name": "file-metadata-keys-number-too-big",
                "value": "A file can not have more than 50 metadata keys.",
              },
              {
                "docs": undefined,
                "name": "signature-required",
                "value": "`signature` is required.",
              },
              {
                "docs": undefined,
                "name": "signature-expiration-required",
                "value": "`expire` is required.",
              },
              {
                "docs": undefined,
                "name": "signature-expiration-invalid",
                "value": "`expire` must be a UNIX timestamp.",
              },
              {
                "docs": undefined,
                "name": "files-required",
                "value": "Request does not contain files.",
              },
              {
                "docs": undefined,
                "name": "file-size-limit-exceeded",
                "value": "File is too large.",
              },
              {
                "docs": undefined,
                "name": "file-type-forbidden",
                "value": "Uploading of these file types is not allowed.",
              },
              {
                "docs": undefined,
                "name": "file-infected",
                "value": "The file is infected by Win.Test.EICAR_HDB-1 virus.",
              },
              {
                "docs": undefined,
                "name": "request-param-required",
                "value": "filename is required.",
              },
              {
                "docs": undefined,
                "name": "multipart-size-invalid",
                "value": "size should be integer.",
              },
              {
                "docs": undefined,
                "name": "multipart-file-size-limit-exceeded",
                "value": "File size exceeds project limit.",
              },
              {
                "docs": undefined,
                "name": "multipart-file-size-too-small",
                "value": "File size can not be less than 10485760 bytes. Please use direct upload instead of multipart.",
              },
              {
                "docs": undefined,
                "name": "multipart-part-size-invalid",
                "value": "Multipart Upload Part Size should be an integer.",
              },
              {
                "docs": undefined,
                "name": "multipart-part-size-too-small",
                "value": "Multipart Upload Part Size can not be less than 5242880 bytes.",
              },
              {
                "docs": undefined,
                "name": "multipart-part-size-too-big",
                "value": "Multipart Upload Part Size can not be more than 5368709120 bytes.",
              },
              {
                "docs": undefined,
                "name": "multipart-file-id-required",
                "value": "uuid is required.",
              },
              {
                "docs": undefined,
                "name": "uuid-invalid",
                "value": "uuid is invalid.",
              },
              {
                "docs": undefined,
                "name": "multipart-file-already-uploaded",
                "value": "File is already uploaded.",
              },
              {
                "docs": undefined,
                "name": "multipart-upload-size-too-large",
                "value": "Uploaded size is more than expected.",
              },
              {
                "docs": undefined,
                "name": "multipart-upload-size-too-small",
                "value": "File size mismatch. Not all parts uploaded?",
              },
              {
                "docs": undefined,
                "name": "multipart-file-completion-failed",
                "value": "Can not complete upload. Wrong parts size?",
              },
              {
                "docs": undefined,
                "name": "source-url-required",
                "value": "source_url is required.",
              },
              {
                "docs": undefined,
                "name": "url-parsing-failed",
                "value": "Failed to parse URL.",
              },
              {
                "docs": undefined,
                "name": "url-scheme-required",
                "value": "No URL scheme supplied.",
              },
              {
                "docs": undefined,
                "name": "url-scheme-invalid",
                "value": "Invalid URL scheme.",
              },
              {
                "docs": undefined,
                "name": "url-host-required",
                "value": "No URL host supplied.",
              },
              {
                "docs": undefined,
                "name": "url-blacklisted",
                "value": "Source is blacklisted.",
              },
              {
                "docs": undefined,
                "name": "hostname-not-found",
                "value": "Host does not exist.",
              },
              {
                "docs": undefined,
                "name": "url-host-malformed",
                "value": "URL host is malformed.",
              },
              {
                "docs": undefined,
                "name": "url-host-private-ip-forbidden",
                "value": "Only public IPs are allowed.",
              },
              {
                "docs": undefined,
                "name": "token-required",
                "value": "token is required.",
              },
              {
                "docs": undefined,
                "name": "file-id-required",
                "value": "file_id is required.",
              },
              {
                "docs": undefined,
                "name": "file-id-invalid",
                "value": "file_id is invalid.",
              },
              {
                "docs": undefined,
                "name": "group-files-invalid",
                "value": "This is not valid file url: wrong-uuid.",
              },
              {
                "docs": undefined,
                "name": "group-file-url-parsing-failed",
                "value": "No files[N] parameters found.",
              },
              {
                "docs": undefined,
                "name": "group-files-not-found",
                "value": "Some files not found.",
              },
              {
                "docs": undefined,
                "name": "group-id-required",
                "value": "group_id is required.",
              },
            ],
            "status-code": 400,
            "type": "unknown",
          },
          "ContentTooLargeError": {
            "docs": "The size of the request is too large.",
            "examples": [
              {
                "docs": undefined,
                "name": undefined,
                "value": "The size of the request is too large.",
              },
            ],
            "status-code": 413,
            "type": "string",
          },
          "ForbiddenError": {
            "docs": "Request was not allowed.",
            "examples": [
              {
                "docs": undefined,
                "name": "public-key-is-required",
                "value": "UPLOADCARE_PUB_KEY is required.",
              },
              {
                "docs": undefined,
                "name": "public-key-is-invalid",
                "value": "UPLOADCARE_PUB_KEY is invalid.",
              },
              {
                "docs": undefined,
                "name": "auto-store-is-disabled",
                "value": "Autostore is disabled.",
              },
              {
                "docs": undefined,
                "name": "project-public-key-removed",
                "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
              },
              {
                "docs": undefined,
                "name": "account-blocked",
                "value": "Account has been blocked.",
              },
              {
                "docs": undefined,
                "name": "account-unpaid",
                "value": "Account has been blocked for non payment.",
              },
              {
                "docs": undefined,
                "name": "upload-failed",
                "value": "Upload failed.",
              },
              {
                "docs": undefined,
                "name": "account-limits-exceeded",
                "value": "Account has reached its limits.",
              },
              {
                "docs": undefined,
                "name": "signature-expiration",
                "value": "Expired signature.",
              },
              {
                "docs": undefined,
                "name": "signature-invalid",
                "value": "Invalid signature.",
              },
              {
                "docs": undefined,
                "name": "public-key-is-required",
                "value": "pub_key is required.",
              },
              {
                "docs": undefined,
                "name": "public-key-is-invalid",
                "value": "pub_key is invalid.",
              },
            ],
            "status-code": 403,
            "type": "unknown",
          },
          "NotFoundError": {
            "docs": "File with specified UUID was not found.",
            "examples": [
              {
                "docs": undefined,
                "name": "file-not-found",
                "value": "File is not found.",
              },
              {
                "docs": undefined,
                "name": "group-not-found",
                "value": "group_id is invalid.",
              },
            ],
            "status-code": 404,
            "type": "unknown",
          },
          "TooManyRequestsError": {
            "docs": "Request was throttled.",
            "examples": [
              {
                "docs": undefined,
                "name": undefined,
                "value": "Request was throttled.",
              },
            ],
            "status-code": 429,
            "type": "string",
          },
        },
        "types": {
          "AccountBlockedError": {
            "type": "string",
          },
          "AccountLimitsExceededError": {
            "type": "string",
          },
          "AccountUnpaidError": {
            "type": "string",
          },
          "AutoStoreDisabledError": {
            "type": "string",
          },
          "BadRequestErrorBody": {
            "discriminated": false,
            "docs": undefined,
            "encoding": undefined,
            "inline": undefined,
            "source": {
              "openapi": "../openapi.json",
            },
            "union": [
              "NullCharactersForbiddenError",
              "GroupIdRequiredError",
            ],
          },
          "ContentInfo": {
            "docs": "Information about file content.",
            "inline": undefined,
            "properties": {
              "image": "optional<SchemasImageInfo>",
              "mime": {
                "docs": "MIME type.",
                "type": "optional<ContentInfoMime>",
              },
              "video": "optional<VideoInfo>",
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "ContentInfoMime": {
            "docs": "MIME type.",
            "inline": true,
            "properties": {
              "mime": {
                "docs": "Full MIME type.",
                "type": "string",
              },
              "subtype": {
                "docs": "Subtype of MIME type.",
                "type": "string",
              },
              "type": {
                "docs": "Type of MIME type.",
                "type": "string",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "ExpireType": {
            "docs": "`expire` must be sent along with your upload request if you would like to use signed uploads.
The parameter defines the time during which your signature is valid. It's a UNIX timestamp.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
            "type": "double",
          },
          "FileIdInvalidError": {
            "type": "string",
          },
          "FileIdRequiredError": {
            "type": "string",
          },
          "FileInfectedError": {
            "type": "string",
          },
          "FileMetadataKeyDuplicatedError": {
            "type": "string",
          },
          "FileMetadataKeyEmptyError": {
            "type": "string",
          },
          "FileMetadataKeyForbiddenError": {
            "type": "string",
          },
          "FileMetadataKeyLengthTooBigError": {
            "type": "string",
          },
          "FileMetadataKeysNumberTooBigError": {
            "type": "string",
          },
          "FileMetadataValueEmptyError": {
            "type": "string",
          },
          "FileMetadataValueForbiddenError": {
            "type": "string",
          },
          "FileMetadataValueLengthTooBigError": {
            "type": "string",
          },
          "FileNotFoundError": {
            "type": "string",
          },
          "FileSizeLimitExceededError": {
            "type": "string",
          },
          "FileTypeForbiddenError": {
            "type": "string",
          },
          "FileUploadInfo": {
            "docs": "Information about an uploaded file.",
            "inline": undefined,
            "properties": {
              "content_info": "optional<ContentInfo>",
              "done": {
                "docs": "Same as `size`.",
                "type": "integer",
              },
              "file_id": {
                "docs": "Same as `uuid`",
                "type": "string",
                "validation": {
                  "format": "uuid",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
              "filename": {
                "docs": "Sanitized `original_filename`.",
                "type": "string",
              },
              "image_info": "optional<ImageInfo>",
              "is_image": {
                "docs": "True if the uploaded file is an image of a supported file format.",
                "type": "boolean",
              },
              "is_ready": {
                "docs": "True if the file is ready to be fetched from Uploadcare's CDN.",
                "type": "boolean",
              },
              "is_stored": {
                "docs": "True if the file has been marked as stored.",
                "type": "boolean",
              },
              "metadata": "optional<Metadata>",
              "mime_type": {
                "docs": "File's MIME-type.",
                "type": "string",
              },
              "original_filename": {
                "docs": "Original file of the uploaded file.",
                "type": "string",
              },
              "s3_bucket": {
                "docs": "Name of an AWS S3 bucket where the file is stored. Only available if you associate a Foreign Storage Bucket with your project.",
                "type": "optional<string>",
              },
              "size": {
                "docs": "File's size in bytes.",
                "type": "integer",
              },
              "total": {
                "docs": "Same as `size`.",
                "type": "integer",
              },
              "uuid": {
                "docs": "File's unique ID.",
                "type": "string",
                "validation": {
                  "format": "uuid",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
              "video_info": "optional<LegacyVideoInfo>",
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoErrorStatus": {
            "docs": undefined,
            "inline": undefined,
            "properties": {
              "error": {
                "docs": "Human readable description of the issue with the fetch/upload task.
",
                "type": "optional<string>",
              },
              "error_code": {
                "docs": "Machine readable error code.

Note: See the [Errors > FromURL upload errors](#tag/Errors) section of this
page for a full list of all possible error codes.
",
                "type": "optional<string>",
              },
              "status": {
                "docs": "The system failed to fetch and/or upload the file.
",
                "type": "optional<literal<"error">>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoFromUrl": {
            "docs": undefined,
            "extends": [
              "FileUploadInfo",
            ],
            "inline": undefined,
            "properties": {
              "type": "optional<literal<"file_info">>",
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoProgressStatus": {
            "docs": undefined,
            "inline": undefined,
            "properties": {
              "done": {
                "docs": "How many bytes of the file have been fetched so far.
",
                "type": "optional<double>",
              },
              "status": {
                "docs": "The system is fetching/uploading the file.
",
                "type": "optional<literal<"progress">>",
              },
              "total": {
                "docs": "The expected size of the fetched file (in bytes).

**Note:** the value can be missing if the server we are fetching the file from
does not provide the information or if the server is returning the file in, for
example, [compressed form](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding).
",
                "type": "optional<double>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoSuccessStatus": {
            "docs": undefined,
            "extends": [
              "FileUploadInfo",
            ],
            "inline": undefined,
            "properties": {
              "status": {
                "docs": "The file has been fetched/uploaded successfully.",
                "type": "optional<literal<"success">>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoUnknownStatus": {
            "docs": undefined,
            "inline": undefined,
            "properties": {
              "status": {
                "docs": "The system does not have information about the task.

Note: Uploadcare stores information about the `/from_url/` tasks for a limited
period of time only. The endpoint can return the status `unknown` for the tasks
that are tool old (or that have not been created at all).
",
                "type": "optional<literal<"unknown">>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FileUploadInfoWaitingStatus": {
            "docs": undefined,
            "inline": undefined,
            "properties": {
              "status": {
                "docs": "The system is preparing to handle the request.
",
                "type": "optional<literal<"waiting">>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FilesRequiredError": {
            "type": "string",
          },
          "ForbiddenErrorBody": {
            "discriminated": false,
            "docs": undefined,
            "encoding": undefined,
            "inline": undefined,
            "source": {
              "openapi": "../openapi.json",
            },
            "union": [
              "PublicKeyRequiredError",
              "PublicKeyInvalidError",
            ],
          },
          "FromUrlUploadResponseSchema": {
            "docs": "`/from_url/` upload response.",
            "inline": undefined,
            "properties": {
              "token": {
                "docs": "Token to identify a `/from_url/` request.",
                "type": "optional<string>",
                "validation": {
                  "format": "uuid",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
              "type": "optional<literal<"token">>",
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "GroupFileUrlParsingFailedError": {
            "type": "string",
          },
          "GroupFilesInvalidError": {
            "type": "string",
          },
          "GroupFilesNotFoundError": {
            "type": "string",
          },
          "GroupIdRequiredError": {
            "type": "string",
          },
          "GroupInfo": {
            "docs": "File group information object.",
            "inline": undefined,
            "properties": {
              "cdn_url": {
                "docs": "Group's CDN URL.",
                "type": "optional<string>",
                "validation": {
                  "format": "uri",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
              "datetime_created": {
                "docs": "ISO-8601 date and time when the group was created.",
                "type": "optional<datetime>",
              },
              "datetime_stored": {
                "availability": "deprecated",
                "docs": "ISO-8601 date and time when the group was marked as stored.",
                "type": "optional<datetime>",
              },
              "files": {
                "docs": "The list of files in the group. An array may contain null values if a file has been removed.
",
                "type": "optional<list<unknown>>",
              },
              "files_count": {
                "docs": "Number of the files in the group.",
                "type": "optional<double>",
              },
              "id": {
                "docs": "Group's unique ID.",
                "type": "optional<string>",
              },
              "url": {
                "docs": "Group's API resource URL. See the [REST API](/api-refs/rest-api/) documentation for details.",
                "type": "optional<string>",
                "validation": {
                  "format": "uri",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "GroupNotFoundError": {
            "type": "string",
          },
          "HostnameNotFoundError": {
            "type": "string",
          },
          "ImageInfo": {
            "docs": "Image metadata.",
            "inline": undefined,
            "properties": {
              "color_mode": {
                "docs": "Image color mode.",
                "type": "ImageInfoColorMode",
              },
              "datetime_original": {
                "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
                "type": "optional<datetime>",
              },
              "dpi": {
                "docs": "Image DPI for two dimensions.",
                "type": "optional<list<double>>",
              },
              "format": {
                "docs": "Image format.",
                "type": "string",
              },
              "geo_location": {
                "docs": "Geo-location of image from EXIF.",
                "type": "optional<ImageInfoGeoLocation>",
              },
              "height": {
                "docs": "Image height in pixels.",
                "type": "integer",
              },
              "orientation": {
                "docs": "Image orientation from EXIF.",
                "type": "optional<integer>",
                "validation": {
                  "exclusiveMax": undefined,
                  "exclusiveMin": undefined,
                  "max": 8,
                  "min": 0,
                  "multipleOf": undefined,
                },
              },
              "sequence": {
                "docs": "Set to true if a file contains a sequence of images (GIF for example).",
                "type": "boolean",
              },
              "width": {
                "docs": "Image width in pixels.",
                "type": "integer",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "ImageInfoColorMode": {
            "docs": "Image color mode.",
            "enum": [
              "RGB",
              "RGBA",
              "RGBX",
              "L",
              "LA",
              "P",
              "PA",
              "CMYK",
              "YCbCr",
              "HSV",
              "LAB",
            ],
            "inline": true,
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "ImageInfoGeoLocation": {
            "docs": "Geo-location of image from EXIF.",
            "inline": true,
            "properties": {
              "latitude": {
                "docs": "Location latitude.",
                "type": "double",
              },
              "longitude": {
                "docs": "Location longitude.",
                "type": "double",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "LegacyVideoInfo": {
            "docs": "Video metadata.",
            "inline": undefined,
            "properties": {
              "audio": {
                "docs": "Audio stream's metadata.",
                "type": "optional<LegacyVideoInfoAudio>",
              },
              "bitrate": {
                "docs": "Video file's bitrate.",
                "type": "optional<double>",
              },
              "duration": {
                "docs": "Video file's duration in milliseconds.",
                "type": "optional<double>",
              },
              "format": {
                "docs": "Video file's format.",
                "type": "optional<string>",
              },
              "video": {
                "docs": "Video stream's metadata.",
                "type": "optional<LegacyVideoInfoVideo>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "LegacyVideoInfoAudio": {
            "docs": "Audio stream's metadata.",
            "inline": true,
            "properties": {
              "bitrate": {
                "docs": "Audio stream's bitrate.",
                "type": "optional<double>",
              },
              "channels": {
                "docs": "Audio stream's number of channels.",
                "type": "optional<string>",
              },
              "codec": {
                "docs": "Audio stream's codec.",
                "type": "optional<string>",
              },
              "sample_rate": {
                "docs": "Audio stream's sample rate.",
                "type": "optional<double>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "LegacyVideoInfoVideo": {
            "docs": "Video stream's metadata.",
            "inline": true,
            "properties": {
              "bitrate": {
                "docs": "Video stream's bitrate.",
                "type": "optional<double>",
              },
              "codec": {
                "docs": "Video stream codec.",
                "type": "optional<string>",
              },
              "frame_rate": {
                "docs": "Video stream's frame rate.",
                "type": "optional<double>",
              },
              "height": {
                "docs": "Video stream's image height.",
                "type": "optional<double>",
              },
              "width": {
                "docs": "Video stream's image width.",
                "type": "optional<double>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "Metadata": {
            "docs": "Arbitrary metadata associated with a file.",
            "type": "optional<map<string, unknown>>",
          },
          "MetadataValue": {
            "docs": "Arbitrary metadata associated with the file.
See [docs](https://uploadcare.com/docs/file-metadata/) and [REST API v0.7](/api-refs/rest-api/v0.7.0/#tag/File-metadata) for more information.
",
            "type": "string",
            "validation": {
              "format": undefined,
              "maxLength": 512,
              "minLength": 1,
              "pattern": undefined,
            },
          },
          "MultipartFileAlreadyUploadedError": {
            "type": "string",
          },
          "MultipartFileCompletionFailedError": {
            "type": "string",
          },
          "MultipartFileIdRequiredError": {
            "type": "string",
          },
          "MultipartFileSizeLimitExceededError": {
            "type": "string",
          },
          "MultipartFileSizeTooSmallError": {
            "type": "string",
          },
          "MultipartPartSizeInvalidError": {
            "type": "string",
          },
          "MultipartPartSizeTooBigError": {
            "type": "string",
          },
          "MultipartPartSizeTooSmallError": {
            "type": "string",
          },
          "MultipartSizeInvalidError": {
            "type": "string",
          },
          "MultipartUploadSizeTooLargeError": {
            "type": "string",
          },
          "MultipartUploadSizeTooSmallError": {
            "type": "string",
          },
          "NullCharactersForbiddenError": {
            "type": "string",
          },
          "PostRequestParserFailedError": {
            "type": "string",
          },
          "ProjectPublicKeyRemovedError": {
            "type": "string",
          },
          "ProjectPublicKeyType": {
            "docs": "Public key identifying an Uploadcare project your uploads will go to.",
            "type": "string",
          },
          "PublicKeyInvalidError": {
            "type": "string",
          },
          "PublicKeyRequiredError": {
            "type": "string",
          },
          "RequestFiledsNumberLimitExceededError": {
            "type": "string",
          },
          "RequestParamRequiredError": {
            "type": "string",
          },
          "SchemasImageInfo": {
            "docs": "Image metadata.",
            "inline": undefined,
            "properties": {
              "color_mode": {
                "docs": "Image color mode.",
                "type": "SchemasImageInfoColorMode",
              },
              "datetime_original": {
                "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
                "type": "optional<datetime>",
              },
              "dpi": {
                "docs": "Image DPI for two dimensions.",
                "type": "optional<list<double>>",
              },
              "format": {
                "docs": "Image format.",
                "type": "string",
              },
              "geo_location": {
                "docs": "Geo-location of image from EXIF.",
                "type": "optional<SchemasImageInfoGeoLocation>",
              },
              "height": {
                "docs": "Image height in pixels.",
                "type": "integer",
              },
              "orientation": {
                "docs": "Image orientation from EXIF.",
                "type": "optional<integer>",
                "validation": {
                  "exclusiveMax": undefined,
                  "exclusiveMin": undefined,
                  "max": 8,
                  "min": 0,
                  "multipleOf": undefined,
                },
              },
              "sequence": {
                "docs": "Set to true if a file contains a sequence of images (GIF for example).",
                "type": "boolean",
              },
              "width": {
                "docs": "Image width in pixels.",
                "type": "integer",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "SchemasImageInfoColorMode": {
            "docs": "Image color mode.",
            "enum": [
              "RGB",
              "RGBA",
              "RGBX",
              "L",
              "LA",
              "P",
              "PA",
              "CMYK",
              "YCbCr",
              "HSV",
              "LAB",
            ],
            "inline": true,
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "SchemasImageInfoGeoLocation": {
            "docs": "Geo-location of image from EXIF.",
            "inline": true,
            "properties": {
              "latitude": {
                "docs": "Location latitude.",
                "type": "double",
              },
              "longitude": {
                "docs": "Location longitude.",
                "type": "double",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "SignatureExpirationError": {
            "type": "string",
          },
          "SignatureExpirationInvalidError": {
            "type": "string",
          },
          "SignatureExpirationRequiredError": {
            "type": "string",
          },
          "SignatureInvalidError": {
            "type": "string",
          },
          "SignatureRequiredError": {
            "type": "string",
          },
          "SignatureType": {
            "docs": "`signature` must be sent along with your upload request if you would like to use signed uploads.
The signature should be generated on your backend.
**Note**: the process requires knowledge of your Uploadcare Project's Secret key.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
            "type": "string",
          },
          "SourceUrlRequiredError": {
            "type": "string",
          },
          "StoreType": {
            "default": "auto",
            "docs": "Determines if an uploaded file should be marked as temporary or permanent.

The parameter can have the following values:
- `0` - do not mark an uploaded file as stored and remove it after 24 hours
- `1` - mark the uploaded file as stored
- `auto` - delegate the choice of the file-storing behavior to a project-wide setting called
  [auto-store](https://app.uploadcare.com/projects/-/settings/#storage).

The default value depends on the user registration date.

For all users registered after February 12, 2024 (UTC 13:30), the default value is `auto`. 
File-storing behavior depends entirely on what is set in the 
[storage settings](https://app.uploadcare.com/projects/-/settings/#storage) in the Dashboard.

For users registered before February 12, 2024, the default value is `0`. 
To ensure that file storage in the project matches the settings in the Dashboard,
change the value to `auto`.
",
            "enum": [
              {
                "name": "Zero",
                "value": "0",
              },
              {
                "name": "One",
                "value": "1",
              },
              "auto",
            ],
            "inline": undefined,
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "TokenRequiredError": {
            "type": "string",
          },
          "UploadFailedError": {
            "type": "string",
          },
          "UploadcarePublicKeyInvalidError": {
            "type": "string",
          },
          "UploadcarePublicKeyRequiredError": {
            "type": "string",
          },
          "UrlBlacklistedError": {
            "type": "string",
          },
          "UrlHostMalformedError": {
            "type": "string",
          },
          "UrlHostPrivateIpForbiddenError": {
            "type": "string",
          },
          "UrlHostRequiredError": {
            "type": "string",
          },
          "UrlParsingFailedError": {
            "type": "string",
          },
          "UrlSchemeInvalidError": {
            "type": "string",
          },
          "UrlSchemeRequiredError": {
            "type": "string",
          },
          "UuidInvalidError": {
            "type": "string",
          },
          "VideoInfo": {
            "docs": "Video metadata.",
            "inline": undefined,
            "properties": {
              "audio": "list<VideoInfoAudioItem>",
              "bitrate": {
                "docs": "Video file's bitrate.",
                "type": "optional<integer>",
              },
              "duration": {
                "docs": "Video file's duration in milliseconds.",
                "type": "optional<integer>",
              },
              "format": {
                "docs": "Video file's format.",
                "type": "string",
              },
              "video": "list<VideoInfoVideoItem>",
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "VideoInfoAudioItem": {
            "docs": "Audio stream's metadata.",
            "inline": true,
            "properties": {
              "bitrate": {
                "docs": "Audio stream's bitrate.",
                "type": "optional<integer>",
              },
              "channels": {
                "docs": "Audio stream's number of channels.",
                "type": "optional<integer>",
              },
              "codec": {
                "docs": "Audio stream's codec.",
                "type": "optional<string>",
              },
              "sample_rate": {
                "docs": "Audio stream's sample rate.",
                "type": "optional<integer>",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "VideoInfoVideoItem": {
            "docs": "Video stream's metadata.",
            "inline": true,
            "properties": {
              "bitrate": {
                "docs": "Video stream's bitrate.",
                "type": "optional<integer>",
              },
              "codec": {
                "docs": "Video stream's codec.",
                "type": "optional<string>",
              },
              "frame_rate": {
                "docs": "Video stream's frame rate.",
                "type": "double",
              },
              "height": {
                "docs": "Video stream's image height.",
                "type": "integer",
              },
              "width": {
                "docs": "Video stream's image width.",
                "type": "integer",
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
        },
      },
      "rawContents": "types:
  BadRequestErrorBody:
    discriminated: false
    union:
      - NullCharactersForbiddenError
      - GroupIdRequiredError
    source:
      openapi: ../openapi.json
  ForbiddenErrorBody:
    discriminated: false
    union:
      - PublicKeyRequiredError
      - PublicKeyInvalidError
    source:
      openapi: ../openapi.json
  SignatureType:
    type: string
    docs: >
      `signature` must be sent along with your upload request if you would like
      to use signed uploads.

      The signature should be generated on your backend.

      **Note**: the process requires knowledge of your Uploadcare Project's
      Secret key.

      See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/)
      for details.
  ExpireType:
    type: double
    docs: >
      `expire` must be sent along with your upload request if you would like to
      use signed uploads.

      The parameter defines the time during which your signature is valid. It's
      a UNIX timestamp.

      See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/)
      for details.
  StoreType:
    enum:
      - value: '0'
        name: Zero
      - value: '1'
        name: One
      - auto
    docs: >
      Determines if an uploaded file should be marked as temporary or permanent.


      The parameter can have the following values:

      - `0` - do not mark an uploaded file as stored and remove it after 24
      hours

      - `1` - mark the uploaded file as stored

      - `auto` - delegate the choice of the file-storing behavior to a
      project-wide setting called
        [auto-store](https://app.uploadcare.com/projects/-/settings/#storage).

      The default value depends on the user registration date.


      For all users registered after February 12, 2024 (UTC 13:30), the default
      value is `auto`. 

      File-storing behavior depends entirely on what is set in the 

      [storage
      settings](https://app.uploadcare.com/projects/-/settings/#storage) in the
      Dashboard.


      For users registered before February 12, 2024, the default value is `0`. 

      To ensure that file storage in the project matches the settings in the
      Dashboard,

      change the value to `auto`.
    default: auto
    source:
      openapi: ../openapi.json
  ProjectPublicKeyType:
    type: string
    docs: Public key identifying an Uploadcare project your uploads will go to.
  FileUploadInfo:
    docs: Information about an uploaded file.
    properties:
      uuid:
        type: string
        docs: File's unique ID.
        validation:
          format: uuid
      file_id:
        type: string
        docs: Same as `uuid`
        validation:
          format: uuid
      size:
        type: integer
        docs: File's size in bytes.
      total:
        type: integer
        docs: Same as `size`.
      done:
        type: integer
        docs: Same as `size`.
      original_filename:
        type: string
        docs: Original file of the uploaded file.
      filename:
        type: string
        docs: Sanitized `original_filename`.
      mime_type:
        type: string
        docs: File's MIME-type.
      image_info: optional<ImageInfo>
      video_info: optional<LegacyVideoInfo>
      content_info: optional<ContentInfo>
      metadata: optional<Metadata>
      is_image:
        type: boolean
        docs: True if the uploaded file is an image of a supported file format.
      is_stored:
        type: boolean
        docs: True if the file has been marked as stored.
      is_ready:
        type: boolean
        docs: True if the file is ready to be fetched from Uploadcare's CDN.
      s3_bucket:
        type: optional<string>
        docs: >-
          Name of an AWS S3 bucket where the file is stored. Only available if
          you associate a Foreign Storage Bucket with your project.
    source:
      openapi: ../openapi.json
  FileUploadInfoWaitingStatus:
    properties:
      status:
        type: optional<literal<"waiting">>
        docs: |
          The system is preparing to handle the request.
    source:
      openapi: ../openapi.json
  FileUploadInfoProgressStatus:
    properties:
      status:
        type: optional<literal<"progress">>
        docs: |
          The system is fetching/uploading the file.
      total:
        type: optional<double>
        docs: >
          The expected size of the fetched file (in bytes).


          **Note:** the value can be missing if the server we are fetching the
          file from

          does not provide the information or if the server is returning the
          file in, for

          example, [compressed
          form](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding).
      done:
        type: optional<double>
        docs: |
          How many bytes of the file have been fetched so far.
    source:
      openapi: ../openapi.json
  FileUploadInfoSuccessStatus:
    properties:
      status:
        type: optional<literal<"success">>
        docs: The file has been fetched/uploaded successfully.
    extends:
      - FileUploadInfo
    source:
      openapi: ../openapi.json
  FileUploadInfoErrorStatus:
    properties:
      status:
        type: optional<literal<"error">>
        docs: |
          The system failed to fetch and/or upload the file.
      error:
        type: optional<string>
        docs: |
          Human readable description of the issue with the fetch/upload task.
      error_code:
        type: optional<string>
        docs: >
          Machine readable error code.


          Note: See the [Errors > FromURL upload errors](#tag/Errors) section of
          this

          page for a full list of all possible error codes.
    source:
      openapi: ../openapi.json
  FileUploadInfoUnknownStatus:
    properties:
      status:
        type: optional<literal<"unknown">>
        docs: >
          The system does not have information about the task.


          Note: Uploadcare stores information about the `/from_url/` tasks for a
          limited

          period of time only. The endpoint can return the status `unknown` for
          the tasks

          that are tool old (or that have not been created at all).
    source:
      openapi: ../openapi.json
  FileUploadInfoFromUrl:
    properties:
      type: optional<literal<"file_info">>
    extends:
      - FileUploadInfo
    source:
      openapi: ../openapi.json
  FromUrlUploadResponseSchema:
    docs: '`/from_url/` upload response.'
    properties:
      type: optional<literal<"token">>
      token:
        type: optional<string>
        docs: Token to identify a `/from_url/` request.
        validation:
          format: uuid
    source:
      openapi: ../openapi.json
  GroupInfo:
    docs: File group information object.
    properties:
      id:
        type: optional<string>
        docs: Group's unique ID.
      datetime_created:
        type: optional<datetime>
        docs: ISO-8601 date and time when the group was created.
      datetime_stored:
        type: optional<datetime>
        docs: ISO-8601 date and time when the group was marked as stored.
        availability: deprecated
      files_count:
        type: optional<double>
        docs: Number of the files in the group.
      cdn_url:
        type: optional<string>
        docs: Group's CDN URL.
        validation:
          format: uri
      url:
        type: optional<string>
        docs: >-
          Group's API resource URL. See the [REST API](/api-refs/rest-api/)
          documentation for details.
        validation:
          format: uri
      files:
        type: optional<list<unknown>>
        docs: >
          The list of files in the group. An array may contain null values if a
          file has been removed.
    source:
      openapi: ../openapi.json
  MetadataValue:
    type: string
    docs: >
      Arbitrary metadata associated with the file.

      See [docs](https://uploadcare.com/docs/file-metadata/) and [REST API
      v0.7](/api-refs/rest-api/v0.7.0/#tag/File-metadata) for more information.
    validation:
      minLength: 1
      maxLength: 512
  AutoStoreDisabledError:
    type: string
  UploadcarePublicKeyRequiredError:
    type: string
  PublicKeyRequiredError:
    type: string
  UploadcarePublicKeyInvalidError:
    type: string
  PublicKeyInvalidError:
    type: string
  ProjectPublicKeyRemovedError:
    type: string
  AccountBlockedError:
    type: string
  AccountUnpaidError:
    type: string
  UploadFailedError:
    type: string
  AccountLimitsExceededError:
    type: string
  SignatureExpirationError:
    type: string
  SignatureInvalidError:
    type: string
  RequestFiledsNumberLimitExceededError:
    type: string
  PostRequestParserFailedError:
    type: string
  NullCharactersForbiddenError:
    type: string
  FileMetadataKeyDuplicatedError:
    type: string
  FileMetadataKeyEmptyError:
    type: string
  FileMetadataKeyForbiddenError:
    type: string
  FileMetadataKeyLengthTooBigError:
    type: string
  FileMetadataValueEmptyError:
    type: string
  FileMetadataValueForbiddenError:
    type: string
  FileMetadataValueLengthTooBigError:
    type: string
  FileMetadataKeysNumberTooBigError:
    type: string
  FilesRequiredError:
    type: string
  FileSizeLimitExceededError:
    type: string
  FileTypeForbiddenError:
    type: string
  FileInfectedError:
    type: string
  RequestParamRequiredError:
    type: string
  MultipartSizeInvalidError:
    type: string
  MultipartFileSizeLimitExceededError:
    type: string
  MultipartFileSizeTooSmallError:
    type: string
  MultipartPartSizeInvalidError:
    type: string
  MultipartPartSizeTooSmallError:
    type: string
  MultipartPartSizeTooBigError:
    type: string
  MultipartFileIdRequiredError:
    type: string
  MultipartFileAlreadyUploadedError:
    type: string
  MultipartUploadSizeTooLargeError:
    type: string
  MultipartUploadSizeTooSmallError:
    type: string
  MultipartFileCompletionFailedError:
    type: string
  UuidInvalidError:
    type: string
  SourceUrlRequiredError:
    type: string
  UrlParsingFailedError:
    type: string
  UrlSchemeRequiredError:
    type: string
  UrlSchemeInvalidError:
    type: string
  UrlHostRequiredError:
    type: string
  UrlBlacklistedError:
    type: string
  HostnameNotFoundError:
    type: string
  UrlHostMalformedError:
    type: string
  UrlHostPrivateIpForbiddenError:
    type: string
  TokenRequiredError:
    type: string
  FileIdRequiredError:
    type: string
  FileIdInvalidError:
    type: string
  FileNotFoundError:
    type: string
  GroupFilesInvalidError:
    type: string
  GroupFileUrlParsingFailedError:
    type: string
  GroupFilesNotFoundError:
    type: string
  GroupIdRequiredError:
    type: string
  GroupNotFoundError:
    type: string
  SignatureRequiredError:
    type: string
  SignatureExpirationRequiredError:
    type: string
  SignatureExpirationInvalidError:
    type: string
  ImageInfoColorMode:
    enum:
      - RGB
      - RGBA
      - RGBX
      - L
      - LA
      - P
      - PA
      - CMYK
      - YCbCr
      - HSV
      - LAB
    docs: Image color mode.
    inline: true
    source:
      openapi: ../openapi.json
  ImageInfoGeoLocation:
    docs: Geo-location of image from EXIF.
    properties:
      latitude:
        type: double
        docs: Location latitude.
      longitude:
        type: double
        docs: Location longitude.
    source:
      openapi: ../openapi.json
    inline: true
  ImageInfo:
    docs: Image metadata.
    properties:
      color_mode:
        type: ImageInfoColorMode
        docs: Image color mode.
      orientation:
        type: optional<integer>
        docs: Image orientation from EXIF.
        validation:
          min: 0
          max: 8
      format:
        type: string
        docs: Image format.
      sequence:
        type: boolean
        docs: Set to true if a file contains a sequence of images (GIF for example).
      height:
        type: integer
        docs: Image height in pixels.
      width:
        type: integer
        docs: Image width in pixels.
      geo_location:
        type: optional<ImageInfoGeoLocation>
        docs: Geo-location of image from EXIF.
      datetime_original:
        type: optional<datetime>
        docs: >-
          Image date and time from EXIF. Please be aware that this data is not
          always formatted and displayed exactly as it appears in the EXIF.
      dpi:
        type: optional<list<double>>
        docs: Image DPI for two dimensions.
    source:
      openapi: ../openapi.json
  LegacyVideoInfoAudio:
    docs: Audio stream's metadata.
    properties:
      bitrate:
        type: optional<double>
        docs: Audio stream's bitrate.
      codec:
        type: optional<string>
        docs: Audio stream's codec.
      sample_rate:
        type: optional<double>
        docs: Audio stream's sample rate.
      channels:
        type: optional<string>
        docs: Audio stream's number of channels.
    source:
      openapi: ../openapi.json
    inline: true
  LegacyVideoInfoVideo:
    docs: Video stream's metadata.
    properties:
      height:
        type: optional<double>
        docs: Video stream's image height.
      width:
        type: optional<double>
        docs: Video stream's image width.
      frame_rate:
        type: optional<double>
        docs: Video stream's frame rate.
      bitrate:
        type: optional<double>
        docs: Video stream's bitrate.
      codec:
        type: optional<string>
        docs: Video stream codec.
    source:
      openapi: ../openapi.json
    inline: true
  LegacyVideoInfo:
    docs: Video metadata.
    properties:
      duration:
        type: optional<double>
        docs: Video file's duration in milliseconds.
      format:
        type: optional<string>
        docs: Video file's format.
      bitrate:
        type: optional<double>
        docs: Video file's bitrate.
      audio:
        type: optional<LegacyVideoInfoAudio>
        docs: Audio stream's metadata.
      video:
        type: optional<LegacyVideoInfoVideo>
        docs: Video stream's metadata.
    source:
      openapi: ../openapi.json
  SchemasImageInfoColorMode:
    enum:
      - RGB
      - RGBA
      - RGBX
      - L
      - LA
      - P
      - PA
      - CMYK
      - YCbCr
      - HSV
      - LAB
    docs: Image color mode.
    inline: true
    source:
      openapi: ../openapi.json
  SchemasImageInfoGeoLocation:
    docs: Geo-location of image from EXIF.
    properties:
      latitude:
        type: double
        docs: Location latitude.
      longitude:
        type: double
        docs: Location longitude.
    source:
      openapi: ../openapi.json
    inline: true
  SchemasImageInfo:
    docs: Image metadata.
    properties:
      color_mode:
        type: SchemasImageInfoColorMode
        docs: Image color mode.
      orientation:
        type: optional<integer>
        docs: Image orientation from EXIF.
        validation:
          min: 0
          max: 8
      format:
        type: string
        docs: Image format.
      sequence:
        type: boolean
        docs: Set to true if a file contains a sequence of images (GIF for example).
      height:
        type: integer
        docs: Image height in pixels.
      width:
        type: integer
        docs: Image width in pixels.
      geo_location:
        type: optional<SchemasImageInfoGeoLocation>
        docs: Geo-location of image from EXIF.
      datetime_original:
        type: optional<datetime>
        docs: >-
          Image date and time from EXIF. Please be aware that this data is not
          always formatted and displayed exactly as it appears in the EXIF.
      dpi:
        type: optional<list<double>>
        docs: Image DPI for two dimensions.
    source:
      openapi: ../openapi.json
  VideoInfoAudioItem:
    docs: Audio stream's metadata.
    properties:
      bitrate:
        type: optional<integer>
        docs: Audio stream's bitrate.
      codec:
        type: optional<string>
        docs: Audio stream's codec.
      sample_rate:
        type: optional<integer>
        docs: Audio stream's sample rate.
      channels:
        type: optional<integer>
        docs: Audio stream's number of channels.
    source:
      openapi: ../openapi.json
    inline: true
  VideoInfoVideoItem:
    docs: Video stream's metadata.
    properties:
      height:
        type: integer
        docs: Video stream's image height.
      width:
        type: integer
        docs: Video stream's image width.
      frame_rate:
        type: double
        docs: Video stream's frame rate.
      bitrate:
        type: optional<integer>
        docs: Video stream's bitrate.
      codec:
        type: optional<string>
        docs: Video stream's codec.
    source:
      openapi: ../openapi.json
    inline: true
  VideoInfo:
    docs: Video metadata.
    properties:
      duration:
        type: optional<integer>
        docs: Video file's duration in milliseconds.
      format:
        type: string
        docs: Video file's format.
      bitrate:
        type: optional<integer>
        docs: Video file's bitrate.
      audio: list<VideoInfoAudioItem>
      video: list<VideoInfoVideoItem>
    source:
      openapi: ../openapi.json
  ContentInfoMime:
    docs: MIME type.
    properties:
      mime:
        type: string
        docs: Full MIME type.
      type:
        type: string
        docs: Type of MIME type.
      subtype:
        type: string
        docs: Subtype of MIME type.
    source:
      openapi: ../openapi.json
    inline: true
  ContentInfo:
    docs: Information about file content.
    properties:
      mime:
        type: optional<ContentInfoMime>
        docs: MIME type.
      image: optional<SchemasImageInfo>
      video: optional<VideoInfo>
    source:
      openapi: ../openapi.json
  Metadata:
    type: optional<map<string, unknown>>
    docs: Arbitrary metadata associated with a file.
errors:
  BadRequestError:
    status-code: 400
    type: unknown
    docs: Request failed input parameters validation.
    examples:
      - value: The request contains too many HTTP POST fields.
        name: request-fields-number-limit-exceeded
      - value: HTTP POST request parsing failed.
        name: post-request-parser-failed
      - value: Null characters are not allowed.
        name: null-characters-forbidden
      - value: File's metadata key `subsystem` has a duplicate.
        name: file-metadata-key-duplicate
      - value: File's metadata key can not be empty.
        name: file-metadata-key-empty
      - value: >-
          File's metadata key `subsystem` contains symbols not allowed by the
          metadata key format.
        name: file-metadata-key-forbidden
      - value: Length of file metadata key `aaa...` can not be more than 64 symbols.
        name: file-metadata-key-length-too-big
      - value: Value of the file metadata key `subsystem` can not be empty.
        name: file-metadata-value-empty
      - value: >-
          Value of file metadata key `subsystem` contains symbols not allowed by
          the metadata value format.
        name: file-metadata-value-forbidden
      - value: >-
          Value of file metadata's key `subsystem` can not be more than 512
          symbols in length.
        name: file-metadata-value-length-too-big
      - value: A file can not have more than 50 metadata keys.
        name: file-metadata-keys-number-too-big
      - value: '`signature` is required.'
        name: signature-required
      - value: '`expire` is required.'
        name: signature-expiration-required
      - value: '`expire` must be a UNIX timestamp.'
        name: signature-expiration-invalid
      - value: Request does not contain files.
        name: files-required
      - value: File is too large.
        name: file-size-limit-exceeded
      - value: Uploading of these file types is not allowed.
        name: file-type-forbidden
      - value: The file is infected by Win.Test.EICAR_HDB-1 virus.
        name: file-infected
      - value: filename is required.
        name: request-param-required
      - value: size should be integer.
        name: multipart-size-invalid
      - value: File size exceeds project limit.
        name: multipart-file-size-limit-exceeded
      - value: >-
          File size can not be less than 10485760 bytes. Please use direct
          upload instead of multipart.
        name: multipart-file-size-too-small
      - value: Multipart Upload Part Size should be an integer.
        name: multipart-part-size-invalid
      - value: Multipart Upload Part Size can not be less than 5242880 bytes.
        name: multipart-part-size-too-small
      - value: Multipart Upload Part Size can not be more than 5368709120 bytes.
        name: multipart-part-size-too-big
      - value: uuid is required.
        name: multipart-file-id-required
      - value: uuid is invalid.
        name: uuid-invalid
      - value: File is already uploaded.
        name: multipart-file-already-uploaded
      - value: Uploaded size is more than expected.
        name: multipart-upload-size-too-large
      - value: File size mismatch. Not all parts uploaded?
        name: multipart-upload-size-too-small
      - value: Can not complete upload. Wrong parts size?
        name: multipart-file-completion-failed
      - value: source_url is required.
        name: source-url-required
      - value: Failed to parse URL.
        name: url-parsing-failed
      - value: No URL scheme supplied.
        name: url-scheme-required
      - value: Invalid URL scheme.
        name: url-scheme-invalid
      - value: No URL host supplied.
        name: url-host-required
      - value: Source is blacklisted.
        name: url-blacklisted
      - value: Host does not exist.
        name: hostname-not-found
      - value: URL host is malformed.
        name: url-host-malformed
      - value: Only public IPs are allowed.
        name: url-host-private-ip-forbidden
      - value: token is required.
        name: token-required
      - value: file_id is required.
        name: file-id-required
      - value: file_id is invalid.
        name: file-id-invalid
      - value: 'This is not valid file url: wrong-uuid.'
        name: group-files-invalid
      - value: No files[N] parameters found.
        name: group-file-url-parsing-failed
      - value: Some files not found.
        name: group-files-not-found
      - value: group_id is required.
        name: group-id-required
  ForbiddenError:
    status-code: 403
    type: unknown
    docs: Request was not allowed.
    examples:
      - value: UPLOADCARE_PUB_KEY is required.
        name: public-key-is-required
      - value: UPLOADCARE_PUB_KEY is invalid.
        name: public-key-is-invalid
      - value: Autostore is disabled.
        name: auto-store-is-disabled
      - value: Project 39e3eb895fdada95e7a9 is marked as removed.
        name: project-public-key-removed
      - value: Account has been blocked.
        name: account-blocked
      - value: Account has been blocked for non payment.
        name: account-unpaid
      - value: Upload failed.
        name: upload-failed
      - value: Account has reached its limits.
        name: account-limits-exceeded
      - value: Expired signature.
        name: signature-expiration
      - value: Invalid signature.
        name: signature-invalid
      - value: pub_key is required.
        name: public-key-is-required
      - value: pub_key is invalid.
        name: public-key-is-invalid
  ContentTooLargeError:
    status-code: 413
    type: string
    docs: The size of the request is too large.
    examples:
      - value: The size of the request is too large.
  TooManyRequestsError:
    status-code: 429
    type: string
    docs: Request was throttled.
    examples:
      - value: Request was throttled.
  NotFoundError:
    status-code: 404
    type: unknown
    docs: File with specified UUID was not found.
    examples:
      - value: File is not found.
        name: file-not-found
      - value: group_id is invalid.
        name: group-not-found
",
    },
    "groups.yml": {
      "absoluteFilepath": "/DUMMY_PATH",
      "contents": {
        "imports": {
          "root": "__package__.yml",
        },
        "service": {
          "auth": false,
          "base-path": "",
          "display-name": "Groups",
          "endpoints": {
            "createFilesGroup": {
              "auth": false,
              "display-name": "Create a file group",
              "docs": "Create a file group from a set of already uploaded files.

The most common use case for creating a file group is when a user uploads
multiple files at once and then wants to display them together.

**Note:** A group itself and files within it MUST belong to the same project.

**Note:** Groups are immutable and the only way to add/remove a file to a group
is to create a new one.
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { group } from '@uploadcare/upload-client'

const result = await group(
  [
    'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
    'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
  ],
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$result = $uploader->groupFiles(['d6d34fa9-addd-472c-868d-2e5c105f9fcd', 'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/']);
echo \sprintf('Response status is %s', $result->getStatusCode());
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_1 = uploadcare.file('d6d34fa9-addd-472c-868d-2e5c105f9fcd')
file_2 = uploadcare.file('b1026315-8116-4632-8364-607e64fca723/-/resize/x800/')
file_group = uploadcare.create_file_group([file_1, file_2])
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

uuids = [
  'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
  'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
]
group = Uploadcare::Group.create(uuids)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let filesIds = ["d6d34fa9-addd-472c-868d-2e5c105f9fcd", "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"]
let group = try await uploadAPI.createFilesGroup(fileIds: filesIds)
print(group)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uuids = listOf(
    "d6d34fa9-addd-472c-868d-2e5c105f9fcd",
    "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"
)
val group = uploadcare.createGroup(fileIds = uuids)
Log.d("TAG", group.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "request": {
                    "files[]": [
                      "files[]",
                    ],
                    "pub_key": "caa9d29da887ee88ffe6",
                  },
                  "response": {
                    "body": {
                      "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                      "datetime_created": "2018-09-12T10:03:38Z",
                      "files": [
                        {
                          "content_info": {
                            "image": {
                              "color_mode": "RGB",
                              "dpi": [
                                72,
                                72,
                              ],
                              "format": "JPEG",
                              "geo_location": {
                                "latitude": 55.62013611111111,
                                "longitude": 37.66299166666666,
                              },
                              "height": 4032,
                              "orientation": 6,
                              "sequence": false,
                              "width": 3024,
                            },
                            "mime": {
                              "mime": "image/jpeg",
                              "subtype": "jpeg",
                              "type": "image",
                            },
                          },
                          "default_effects": "resize/x800/",
                          "done": 2667636,
                          "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                          "filename": "IMG0412_123.JPG",
                          "image_info": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "is_image": true,
                          "is_ready": true,
                          "is_stored": true,
                          "metadata": {
                            "pet": "cat",
                            "subsystem": "uploader",
                          },
                          "mime_type": "image/jpeg",
                          "original_filename": "IMG-0412_123.JPG",
                          "size": 2667636,
                          "total": 2667636,
                          "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        },
                      ],
                      "files_count": 1,
                      "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                      "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    },
                  },
                },
              ],
              "method": "POST",
              "pagination": undefined,
              "path": "/group/",
              "request": {
                "body": {
                  "properties": {
                    "expire": "optional<root.ExpireType>",
                    "files[]": {
                      "docs": "Set of files you want to add to the group.
Each element can be a file UUID with or without the applied image
processing operations.
",
                      "type": "list<string>",
                    },
                    "pub_key": "root.ProjectPublicKeyType",
                    "signature": "optional<root.SignatureType>",
                  },
                },
                "content-type": "multipart/form-data",
                "headers": undefined,
                "name": "CreateFilesGroupRequest",
                "path-parameters": undefined,
                "query-parameters": undefined,
              },
              "response": {
                "docs": "The group was created successfully.",
                "status-code": 200,
                "type": "root.GroupInfo",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "filesGroupInfo": {
              "auth": false,
              "display-name": "Get information about a file group",
              "docs": "Returns a JSON object with information about a file group (when the group was created,
number of the files in the group, etc).
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.NotFoundError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { groupInfo } from '@uploadcare/upload-client'

const result = await groupInfo(
  '0d712319-b970-4602-850c-bae1ced521a6~1',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$groupInfo = $uploader->groupInfo('0d712319-b970-4602-850c-bae1ced521a6~1');
echo $groupInfo->getBody()->getContents();
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_group = uploadcare.file_group('0d712319-b970-4602-850c-bae1ced521a6~1')
print(file_group.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '0d712319-b970-4602-850c-bae1ced521a6~1'
info = Uploadcare::Group.info(uuid)
puts info.inspect
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let group = try await uploadcare.uploadAPI.filesGroupInfo(groupId: "0d712319-b970-4602-850c-bae1ced521a6~1")
print(group)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val group = uploadcare.getUploadedGroup(groupId = "0d712319-b970-4602-850c-bae1ced521a6~1")
Log.d("TAG", group.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "query-parameters": {
                    "group_id": "d52d7136-a2e5-4338-9f45-affbf83b857d~2",
                    "pub_key": "caa9d29da887ee88ffe6",
                  },
                  "response": {
                    "body": {
                      "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                      "datetime_created": "2018-09-12T10:03:38Z",
                      "files": [
                        {
                          "content_info": {
                            "image": {
                              "color_mode": "RGB",
                              "dpi": [
                                72,
                                72,
                              ],
                              "format": "JPEG",
                              "geo_location": {
                                "latitude": 55.62013611111111,
                                "longitude": 37.66299166666666,
                              },
                              "height": 4032,
                              "orientation": 6,
                              "sequence": false,
                              "width": 3024,
                            },
                            "mime": {
                              "mime": "image/jpeg",
                              "subtype": "jpeg",
                              "type": "image",
                            },
                          },
                          "default_effects": "resize/x800/",
                          "done": 2667636,
                          "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                          "filename": "IMG0412_123.JPG",
                          "image_info": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "is_image": true,
                          "is_ready": true,
                          "is_stored": true,
                          "metadata": {
                            "pet": "cat",
                            "subsystem": "uploader",
                          },
                          "mime_type": "image/jpeg",
                          "original_filename": "IMG-0412_123.JPG",
                          "size": 2667636,
                          "total": 2667636,
                          "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        },
                      ],
                      "files_count": 1,
                      "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                      "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    },
                  },
                },
              ],
              "method": "GET",
              "pagination": undefined,
              "path": "/group/info/",
              "request": {
                "name": "FilesGroupInfoRequest",
                "query-parameters": {
                  "group_id": {
                    "docs": "Group's unique ID. Group IDs look like `UUID~N`, where the `~N` part reflects the number of the files in the group.
",
                    "type": "string",
                  },
                  "pub_key": "root.ProjectPublicKeyType",
                },
              },
              "response": {
                "docs": "File group information was retrieved successfully.",
                "status-code": 200,
                "type": "root.GroupInfo",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
          },
          "source": {
            "openapi": "../openapi.json",
          },
        },
      },
      "rawContents": "imports:
  root: __package__.yml
service:
  auth: false
  base-path: ''
  endpoints:
    createFilesGroup:
      path: /group/
      method: POST
      auth: false
      docs: >
        Create a file group from a set of already uploaded files.


        The most common use case for creating a file group is when a user
        uploads

        multiple files at once and then wants to display them together.


        **Note:** A group itself and files within it MUST belong to the same
        project.


        **Note:** Groups are immutable and the only way to add/remove a file to
        a group

        is to create a new one.
      source:
        openapi: ../openapi.json
      display-name: Create a file group
      request:
        name: CreateFilesGroupRequest
        body:
          properties:
            pub_key: root.ProjectPublicKeyType
            files[]:
              docs: >
                Set of files you want to add to the group.

                Each element can be a file UUID with or without the applied
                image

                processing operations.
              type: list<string>
            signature: optional<root.SignatureType>
            expire: optional<root.ExpireType>
        content-type: multipart/form-data
      response:
        docs: The group was created successfully.
        type: root.GroupInfo
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
      examples:
        - request:
            pub_key: caa9d29da887ee88ffe6
            files[]:
              - files[]
          response:
            body:
              id: 0d712319-b970-4602-850c-bae1ced521a6~1
              datetime_created: '2018-09-12T10:03:38Z'
              files_count: 1
              cdn_url: https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/
              url: >-
                https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/
              files:
                - default_effects: resize/x800/
                  uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
                  file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
                  size: 2667636
                  total: 2667636
                  done: 2667636
                  original_filename: IMG-0412_123.JPG
                  filename: IMG0412_123.JPG
                  mime_type: image/jpeg
                  image_info:
                    color_mode: RGB
                    orientation: 6
                    format: JPEG
                    height: 4032
                    width: 3024
                    sequence: false
                    geo_location:
                      latitude: 55.62013611111111
                      longitude: 37.66299166666666
                    dpi:
                      - 72
                      - 72
                  content_info:
                    mime:
                      mime: image/jpeg
                      type: image
                      subtype: jpeg
                    image:
                      color_mode: RGB
                      orientation: 6
                      format: JPEG
                      height: 4032
                      width: 3024
                      sequence: false
                      geo_location:
                        latitude: 55.62013611111111
                        longitude: 37.66299166666666
                      dpi:
                        - 72
                        - 72
                  metadata:
                    subsystem: uploader
                    pet: cat
                  is_image: true
                  is_stored: true
                  is_ready: true
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { group } from '@uploadcare/upload-client'

                const result = await group(
                  [
                    'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
                    'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
                  ],
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $result =
                $uploader->groupFiles(['d6d34fa9-addd-472c-868d-2e5c105f9fcd',
                'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/']);

                echo \sprintf('Response status is %s',
                $result->getStatusCode());
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File, FileGroup


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file_1 = uploadcare.file('d6d34fa9-addd-472c-868d-2e5c105f9fcd')

                file_2 =
                uploadcare.file('b1026315-8116-4632-8364-607e64fca723/-/resize/x800/')

                file_group = uploadcare.create_file_group([file_1, file_2])
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

                uuids = [
                  'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
                  'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
                ]
                group = Uploadcare::Group.create(uuids)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let filesIds = ["d6d34fa9-addd-472c-868d-2e5c105f9fcd",
                "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"]

                let group = try await uploadAPI.createFilesGroup(fileIds:
                filesIds)

                print(group)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uuids = listOf(
                    "d6d34fa9-addd-472c-868d-2e5c105f9fcd",
                    "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"
                )

                val group = uploadcare.createGroup(fileIds = uuids)

                Log.d("TAG", group.toString())
    filesGroupInfo:
      path: /group/info/
      method: GET
      auth: false
      docs: >
        Returns a JSON object with information about a file group (when the
        group was created,

        number of the files in the group, etc).
      source:
        openapi: ../openapi.json
      display-name: Get information about a file group
      request:
        name: FilesGroupInfoRequest
        query-parameters:
          pub_key: root.ProjectPublicKeyType
          group_id:
            type: string
            docs: >
              Group's unique ID. Group IDs look like `UUID~N`, where the `~N`
              part reflects the number of the files in the group.
      response:
        docs: File group information was retrieved successfully.
        type: root.GroupInfo
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.NotFoundError
      examples:
        - query-parameters:
            pub_key: caa9d29da887ee88ffe6
            group_id: d52d7136-a2e5-4338-9f45-affbf83b857d~2
          response:
            body:
              id: 0d712319-b970-4602-850c-bae1ced521a6~1
              datetime_created: '2018-09-12T10:03:38Z'
              files_count: 1
              cdn_url: https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/
              url: >-
                https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/
              files:
                - default_effects: resize/x800/
                  uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
                  file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
                  size: 2667636
                  total: 2667636
                  done: 2667636
                  original_filename: IMG-0412_123.JPG
                  filename: IMG0412_123.JPG
                  mime_type: image/jpeg
                  image_info:
                    color_mode: RGB
                    orientation: 6
                    format: JPEG
                    height: 4032
                    width: 3024
                    sequence: false
                    geo_location:
                      latitude: 55.62013611111111
                      longitude: 37.66299166666666
                    dpi:
                      - 72
                      - 72
                  content_info:
                    mime:
                      mime: image/jpeg
                      type: image
                      subtype: jpeg
                    image:
                      color_mode: RGB
                      orientation: 6
                      format: JPEG
                      height: 4032
                      width: 3024
                      sequence: false
                      geo_location:
                        latitude: 55.62013611111111
                        longitude: 37.66299166666666
                      dpi:
                        - 72
                        - 72
                  metadata:
                    subsystem: uploader
                    pet: cat
                  is_image: true
                  is_stored: true
                  is_ready: true
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { groupInfo } from '@uploadcare/upload-client'

                const result = await groupInfo(
                  '0d712319-b970-4602-850c-bae1ced521a6~1',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $groupInfo =
                $uploader->groupInfo('0d712319-b970-4602-850c-bae1ced521a6~1');

                echo $groupInfo->getBody()->getContents();
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, FileGroup


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file_group =
                uploadcare.file_group('0d712319-b970-4602-850c-bae1ced521a6~1')

                print(file_group.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                uuid = '0d712319-b970-4602-850c-bae1ced521a6~1'
                info = Uploadcare::Group.info(uuid)
                puts info.inspect
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let group = try await
                uploadcare.uploadAPI.filesGroupInfo(groupId:
                "0d712319-b970-4602-850c-bae1ced521a6~1")

                print(group)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val group = uploadcare.getUploadedGroup(groupId =
                "0d712319-b970-4602-850c-bae1ced521a6~1")

                Log.d("TAG", group.toString())
  source:
    openapi: ../openapi.json
  display-name: Groups
",
    },
    "upload.yml": {
      "absoluteFilepath": "/DUMMY_PATH",
      "contents": {
        "imports": {
          "root": "__package__.yml",
        },
        "service": {
          "auth": false,
          "base-path": "",
          "display-name": "Upload",
          "endpoints": {
            "baseUpload": {
              "auth": false,
              "display-name": "Direct uploads",
              "docs": "Direct file uploads comply with the [RFC 7578](https://www.rfc-editor.org/rfc/rfc7578) standard.
In other words, you can perform a direct upload by making an HTTP POST request with the Content-Type
header set to `multipart/form-data`.

**Note**: Direct file uploads support files smaller than 100 megabytes only.
If you would like to upload larger files, please use [Multipart Uploads](/api-refs/upload-api/#operation/multipartFileUploadStart) instead.

File upload example with curl:

```
curl -F "UPLOADCARE_PUB_KEY=YOUR_PUBLIC_KEY" -F "my_file.jpg=@my_file.jpg" "https://upload.uploadcare.com/base/"
```
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.ContentTooLargeError",
                "root.TooManyRequestsError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { base } from '@uploadcare/upload-client'

// fileData must be `Blob` or `File` or `Buffer`
const result = await base(
  fileData,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$fileInfo = $uploader->fromPath(__DIR__ . '/squirrel.jpg', null, null, 'auto', [
    'system' => 'php-uploader',
    'pet' => 'cat',
]);
echo \sprintf("URL: %s, ID: %s, Mime type: %s\n", $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
foreach ($fileInfo->getMetadata() as $key => $value) {
    echo \sprintf("%s: %s\n", $key, $value);
}
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.upload(file_object)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "squirrel", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }
let metadata = ["subsystem": "uploader", "pet": "cat"]

let file = try await uploadcare.uploadFile(data, withName: "random_file_name.jpg", store: .auto) { progress in
  print("progress: \(progress)")
}
prkint(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "request": {
                    "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                  },
                  "response": {
                    "body": {
                      "filename": "filename",
                    },
                  },
                },
              ],
              "method": "POST",
              "pagination": undefined,
              "path": "/base/",
              "request": {
                "body": {
                  "properties": {
                    "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                    "UPLOADCARE_STORE": "optional<root.StoreType>",
                    "expire": "optional<root.ExpireType>",
                    "metadata[{key}]": "optional<root.MetadataValue>",
                    "signature": "optional<root.SignatureType>",
                    "{filename}": {
                      "docs": "File's content",
                      "type": "list<file>",
                    },
                  },
                },
                "content-type": "multipart/form-data",
                "headers": undefined,
                "name": "BaseUploadRequest",
                "path-parameters": undefined,
                "query-parameters": undefined,
              },
              "response": {
                "docs": "The file was uploaded successfully.",
                "status-code": 200,
                "type": "BaseUploadResponse",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "fileUploadInfo": {
              "auth": false,
              "display-name": "Get information about an uploaded file",
              "docs": "Returns a JSON object with information about an uploaded file (file size, MIME type, metadata, etc).
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.NotFoundError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { info } from '@uploadcare/upload-client'

const result = await info(
  'be3b4d5e-179d-460e-8a5d-69112ac86cbb',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$fileInfo = (new Uploadcare\Api($configuration))->file()->fileInfo(string $uuid);
echo \sprintf('URL: %s, ID: %s, Mime type: %s', $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file('740e1b8c-1ad8-4324-b7ec-112c79d8eac2')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '740e1b8c-1ad8-4324-b7ec-112c79d8eac2'
info = Uploadcare::File.info(uuid)
puts info.inspect
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let file = try await uploadcare.uploadAPI.fileInfo(withFileId: "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val file = uploadcare.getUploadedFile(fileId = "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "query-parameters": {
                    "file_id": "67947755-1584-4e3f-902b-d4e2bf76a841",
                    "pub_key": "caa9d29da887ee88ffe6",
                  },
                  "response": {
                    "body": {
                      "content_info": {
                        "image": {
                          "color_mode": "RGB",
                          "datetime_original": "2024-01-15T09:30:00Z",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "mime": {
                          "mime": "image/jpeg",
                          "subtype": "jpeg",
                          "type": "image",
                        },
                        "video": {
                          "audio": [
                            {
                              "bitrate": 78,
                              "channels": 2,
                              "codec": "aac",
                              "sample_rate": 44100,
                            },
                          ],
                          "bitrate": 393,
                          "duration": 261827,
                          "format": "mp4",
                          "video": [
                            {
                              "bitrate": 315,
                              "codec": "h264",
                              "frame_rate": 30,
                              "height": 360,
                              "width": 640,
                            },
                          ],
                        },
                      },
                      "done": 2667636,
                      "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "filename": "IMG0412_123.JPG",
                      "image_info": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "is_image": true,
                      "is_ready": true,
                      "is_stored": true,
                      "metadata": {
                        "pet": "cat",
                        "subsystem": "uploader",
                      },
                      "mime_type": "image/jpeg",
                      "original_filename": "IMG-0412_123.JPG",
                      "s3_bucket": "custom-s3-bucket-name",
                      "size": 2667636,
                      "total": 2667636,
                      "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "video_info": {
                        "audio": {
                          "bitrate": 78,
                          "channels": "2",
                          "codec": "aac",
                          "sample_rate": 44100,
                        },
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": {
                          "bitrate": 315,
                          "codec": "h264",
                          "frame_rate": 30,
                          "height": 360,
                          "width": 640,
                        },
                      },
                    },
                  },
                },
              ],
              "method": "GET",
              "pagination": undefined,
              "path": "/info/",
              "request": {
                "name": "FileUploadInfoRequest",
                "query-parameters": {
                  "file_id": {
                    "docs": "File's unique ID.",
                    "type": "string",
                    "validation": {
                      "format": "uuid",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                  "pub_key": "root.ProjectPublicKeyType",
                },
              },
              "response": {
                "docs": "File information was retrieved successfully.",
                "status-code": 200,
                "type": "root.FileUploadInfo",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "fromURLUpload": {
              "auth": false,
              "display-name": "Upload files from URLs",
              "docs": "Uploadcare can fetch a file from a publicly available URL and then automatically upload the
fetched file to your project.

#### Upload tokens
Requests to the endpoint return a JSON dictionary with a `token` that can be further used
to [check the status](/api-refs/upload-api/#operation/fromURLUploadStatus) of the upload
request.

**Note:** The token is not a file ID and can't be used to address the file directly.
The actual file ID should be retrieved by calling the `/from_url/status/` endpoint.

#### Duplicates prevention
By default, every call to the `/from_url/` endpoint with the same `source_url` results in
a new upload leading to file duplication.

If you would like Uploadcare to keep track of the requested URLs and avoid the duplicate
uploads, pass the `save_URL_duplicates` and `check_URL_duplicates` parameters described below.
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.TooManyRequestsError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \sprintf('Upload from URL \'%s\' has been started. Token is %s', $url, $token);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "type-token",
                  "request": {
                    "pub_key": "caa9d29da887ee88ffe6",
                    "source_url": "source_url",
                  },
                  "response": {
                    "body": {
                      "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                      "type": "token",
                    },
                  },
                },
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \sprintf('Upload from URL \'%s\' has been started. Token is %s', $url, $token);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "type-file-info",
                  "request": {
                    "pub_key": "caa9d29da887ee88ffe6",
                    "source_url": "source_url",
                  },
                  "response": {
                    "body": {
                      "content_info": {
                        "image": {
                          "color_mode": "RGB",
                          "datetime_original": "2024-01-15T09:30:00Z",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "mime": {
                          "mime": "image/jpeg",
                          "subtype": "jpeg",
                          "type": "image",
                        },
                        "video": {
                          "audio": [
                            {
                              "bitrate": 78,
                              "channels": 2,
                              "codec": "aac",
                              "sample_rate": 44100,
                            },
                          ],
                          "bitrate": 393,
                          "duration": 261827,
                          "format": "mp4",
                          "video": [
                            {
                              "bitrate": 315,
                              "codec": "h264",
                              "frame_rate": 30,
                              "height": 360,
                              "width": 640,
                            },
                          ],
                        },
                      },
                      "done": 2667636,
                      "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "filename": "IMG0412_123.JPG",
                      "image_info": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "is_image": true,
                      "is_ready": true,
                      "is_stored": true,
                      "metadata": {
                        "pet": "cat",
                        "subsystem": "uploader",
                      },
                      "mime_type": "image/jpeg",
                      "original_filename": "IMG-0412_123.JPG",
                      "s3_bucket": "custom-s3-bucket-name",
                      "size": 2667636,
                      "total": 2667636,
                      "type": "file_info",
                      "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "video_info": {
                        "audio": {
                          "bitrate": 78,
                          "channels": "2",
                          "codec": "aac",
                          "sample_rate": 44100,
                        },
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": {
                          "bitrate": 315,
                          "codec": "h264",
                          "frame_rate": 30,
                          "height": 360,
                          "width": 640,
                        },
                      },
                    },
                  },
                },
              ],
              "method": "POST",
              "pagination": undefined,
              "path": "/from_url/",
              "request": {
                "body": {
                  "properties": {
                    "check_URL_duplicates": {
                      "default": "0",
                      "docs": "If set to "1", enables the `source_url` duplicates prevention.
Specifically, if the `source_url` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
                      "type": "optional<FromUrlUploadRequestCheckUrlDuplicates>",
                    },
                    "expire": "optional<root.ExpireType>",
                    "filename": {
                      "docs": "Sets the file name of the resource fetched from the source URL.
If not defined, the file name is obtained from either HTTP
response headers or the `source_url`'s path.

**Note:** The filename will be sanitized to only contain the following symbols:
`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._`.
",
                      "type": "optional<string>",
                    },
                    "metadata[{key}]": "optional<root.MetadataValue>",
                    "pub_key": "root.ProjectPublicKeyType",
                    "save_URL_duplicates": {
                      "docs": "Determines if the requested `source_url` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the `check_URL_duplicates` parameter.
",
                      "type": "optional<FromUrlUploadRequestSaveUrlDuplicates>",
                    },
                    "signature": "optional<root.SignatureType>",
                    "source_url": {
                      "docs": "Source URL of the file to fetch and upload.

**Note**: The URL should point to a resource publicly available via HTTP/HTTPS.
",
                      "type": "string",
                      "validation": {
                        "format": "uri",
                        "maxLength": undefined,
                        "minLength": undefined,
                        "pattern": undefined,
                      },
                    },
                    "store": "optional<root.StoreType>",
                  },
                },
                "content-type": "multipart/form-data",
                "headers": undefined,
                "name": "FromUrlUploadRequest",
                "path-parameters": undefined,
                "query-parameters": undefined,
              },
              "response": {
                "docs": "Status Token or File Info of an already downloaded file.",
                "status-code": 200,
                "type": "FromUrlUploadResponse",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "fromURLUploadStatus": {
              "auth": false,
              "display-name": "Check the status of a task to fetch/upload a file from a URL",
              "docs": "The endpoint notifies about the progress of the task by changing the value of the `status` field:
  * the field is set to `waiting` initially
  * once the system starts processing the request, the field is set to `progress`
  * if the file is fetched and uploaded successfully, the `status` field is set to `success`
    and the endpoint returns a JSON object holding information about the uploaded file
  * if the system fails to fetch/upload the file, the `status` field is set to `error` and
    the `error` field is set to the cause of the error.
",
              "errors": [
                "root.BadRequestError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \sprintf('Upload status is %s', $status);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "status-waiting",
                  "query-parameters": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                  },
                  "response": {
                    "body": {
                      "status": "waiting",
                    },
                  },
                },
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \sprintf('Upload status is %s', $status);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "status-progress",
                  "query-parameters": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                  },
                  "response": {
                    "body": {
                      "done": 134427,
                      "status": "progress",
                      "total": 732434,
                    },
                  },
                },
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \sprintf('Upload status is %s', $status);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "status-success",
                  "query-parameters": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                  },
                  "response": {
                    "body": {
                      "content_info": {
                        "image": {
                          "color_mode": "RGB",
                          "datetime_original": "2024-01-15T09:30:00Z",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "mime": {
                          "mime": "image/jpeg",
                          "subtype": "jpeg",
                          "type": "image",
                        },
                        "video": {
                          "audio": [
                            {
                              "bitrate": 78,
                              "channels": 2,
                              "codec": "aac",
                              "sample_rate": 44100,
                            },
                          ],
                          "bitrate": 393,
                          "duration": 261827,
                          "format": "mp4",
                          "video": [
                            {
                              "bitrate": 315,
                              "codec": "h264",
                              "frame_rate": 30,
                              "height": 360,
                              "width": 640,
                            },
                          ],
                        },
                      },
                      "done": 2667636,
                      "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "filename": "IMG0412_123.JPG",
                      "image_info": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "is_image": true,
                      "is_ready": true,
                      "is_stored": true,
                      "metadata": {
                        "pet": "cat",
                        "subsystem": "uploader",
                      },
                      "mime_type": "image/jpeg",
                      "original_filename": "IMG-0412_123.JPG",
                      "s3_bucket": "custom-s3-bucket-name",
                      "size": 2667636,
                      "status": "success",
                      "total": 2667636,
                      "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "video_info": {
                        "audio": {
                          "bitrate": 78,
                          "channels": "2",
                          "codec": "aac",
                          "sample_rate": 44100,
                        },
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": {
                          "bitrate": 315,
                          "codec": "h264",
                          "frame_rate": 30,
                          "height": 360,
                          "width": 640,
                        },
                      },
                    },
                  },
                },
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \sprintf('Upload status is %s', $status);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "status-error",
                  "query-parameters": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                  },
                  "response": {
                    "body": {
                      "error": "HTTP client error: 404.",
                      "error_code": "DownloadFileHTTPClientError",
                      "status": "error",
                    },
                  },
                },
                {
                  "code-samples": [
                    {
                      "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \sprintf('Upload status is %s', $status);
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "name": "status-unknown",
                  "query-parameters": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                  },
                  "response": {
                    "body": {
                      "status": "unknown",
                    },
                  },
                },
              ],
              "method": "GET",
              "pagination": undefined,
              "path": "/from_url/status/",
              "request": {
                "name": "FromUrlUploadStatusRequest",
                "query-parameters": {
                  "token": {
                    "docs": "Token returned by the `/from_url/` endpoint that identifies a request to fetch/upload a file from a URL.",
                    "type": "string",
                    "validation": {
                      "format": "uuid",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                },
              },
              "response": {
                "docs": "Request was processed successfully.
",
                "status-code": 200,
                "type": "FromUrlUploadStatusResponse",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "multipartFileUploadComplete": {
              "auth": false,
              "display-name": "Complete multipart upload",
              "docs": "Once all the file parts have been uploaded successfully, complete the
upload session to assemble all the file parts into a single resulting file.
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.NotFoundError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { multipartComplete } from '@uploadcare/upload-client'

const result = await multipartComplete(
  '67947755-1584-4e3f-902b-d4e2bf76a841',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \filesize($path), // The "size" is the metadata key
]);
echo \sprintf('File uploaded. ID is \'%s\'', $response->getUuid());
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "request": {
                    "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                    "uuid": "uuid",
                  },
                  "response": {
                    "body": {
                      "content_info": {
                        "image": {
                          "color_mode": "RGB",
                          "datetime_original": "2024-01-15T09:30:00Z",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "mime": {
                          "mime": "image/jpeg",
                          "subtype": "jpeg",
                          "type": "image",
                        },
                        "video": {
                          "audio": [
                            {
                              "bitrate": 78,
                              "channels": 2,
                              "codec": "aac",
                              "sample_rate": 44100,
                            },
                          ],
                          "bitrate": 393,
                          "duration": 261827,
                          "format": "mp4",
                          "video": [
                            {
                              "bitrate": 315,
                              "codec": "h264",
                              "frame_rate": 30,
                              "height": 360,
                              "width": 640,
                            },
                          ],
                        },
                      },
                      "done": 2667636,
                      "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "filename": "IMG0412_123.JPG",
                      "image_info": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "is_image": true,
                      "is_ready": true,
                      "is_stored": true,
                      "metadata": {
                        "pet": "cat",
                        "subsystem": "uploader",
                      },
                      "mime_type": "image/jpeg",
                      "original_filename": "IMG-0412_123.JPG",
                      "s3_bucket": "custom-s3-bucket-name",
                      "size": 2667636,
                      "total": 2667636,
                      "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      "video_info": {
                        "audio": {
                          "bitrate": 78,
                          "channels": "2",
                          "codec": "aac",
                          "sample_rate": 44100,
                        },
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": {
                          "bitrate": 315,
                          "codec": "h264",
                          "frame_rate": 30,
                          "height": 360,
                          "width": 640,
                        },
                      },
                    },
                  },
                },
              ],
              "method": "POST",
              "pagination": undefined,
              "path": "/multipart/complete/",
              "request": {
                "body": {
                  "properties": {
                    "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                    "uuid": {
                      "docs": "File's UUID from the `/multipart/start/` endpoint.",
                      "type": "string",
                      "validation": {
                        "format": "uuid",
                        "maxLength": undefined,
                        "minLength": undefined,
                        "pattern": undefined,
                      },
                    },
                  },
                },
                "content-type": "multipart/form-data",
                "headers": undefined,
                "name": "MultipartFileUploadCompleteRequest",
                "path-parameters": undefined,
                "query-parameters": undefined,
              },
              "response": {
                "docs": "The file was uploaded successfully.",
                "status-code": 200,
                "type": "root.FileUploadInfo",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "multipartFileUploadPart": {
              "auth": false,
              "display-name": "Upload individual file parts",
              "docs": "The second phase is about uploading the file parts to the presigned upload URLs returned from the
`/multipart/start/` endpoint.

Each uploaded part should be at least 5 MiB (5242880 bytes) in size except for the last one, which can be smaller.
You can upload the file parts in parallel provided that the byte order stays unchanged.

**Note**: You MUST define `Content-Type` header for your data.
",
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { multipartUpload } from '@uploadcare/upload-client'

// partData is a chunk of the uploaded file's content
// must be `Blob` or `File` or `Buffer`
const result = await multipartUpload(
  partData,
  '<presigned-url-x>'
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \filesize($path), // The "size" is the metadata key
]);
echo \sprintf('File uploaded. ID is \'%s\'', $response->getUuid());
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                },
              ],
              "method": "PUT",
              "pagination": undefined,
              "path": "/<presigned-url-x>",
              "request": {
                "body": "bytes",
                "content-type": "application/octet-stream",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
            "multipartFileUploadStart": {
              "auth": false,
              "display-name": "Start multipart upload",
              "docs": "Multipart uploads should be used if you need to upload files larger than 100 megabytes or if you want to
explicitly trigger [AWS S3 Transfer Acceleration](https://aws.amazon.com/s3/transfer-acceleration/).
When you use Multipart Uploads your files go straight to AWS S3 bypassing our upload instances.

To upload large files, 3 requests are sent in sequence:
1. `/multipart/start/`
2. `<presigned-url-x>`
3. `/multipart/complete/`.

**Note**: Multipart uploads support files larger than 10 megabytes only.
",
              "errors": [
                "root.BadRequestError",
                "root.ForbiddenError",
                "root.TooManyRequestsError",
              ],
              "examples": [
                {
                  "code-samples": [
                    {
                      "code": "import { multipartStart } from '@uploadcare/upload-client'

const result = await multipartStart(
  27796904,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    fileName: 'myfile.mp4',
    contentType: 'video/mp4',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "JavaScript",
                      "name": "JS",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\Uploader\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \filesize($path), // The "size" is the metadata key
]);
echo \sprintf('File uploaded. ID is \'%s\'', $response->getUuid());
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "PHP",
                      "name": "PHP",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Python",
                      "name": "Python",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Ruby",
                      "name": "Ruby",
                    },
                    {
                      "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Swift",
                      "name": "Swift",
                    },
                    {
                      "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                      "docs": undefined,
                      "install": undefined,
                      "language": "Kotlin",
                      "name": "Kotlin",
                    },
                  ],
                  "request": {
                    "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                    "content_type": "content_type",
                    "filename": "filename",
                    "size": 1,
                  },
                  "response": {
                    "body": {
                      "parts": [
                        "<presigned-url-1>",
                        "<presigned-url-2>",
                        "<presigned-url-3>",
                        "<presigned-url-4>",
                        "<presigned-url-5>",
                      ],
                      "uuid": "67947755-1584-4e3f-902b-d4e2bf76a841",
                    },
                  },
                },
              ],
              "method": "POST",
              "pagination": undefined,
              "path": "/multipart/start/",
              "request": {
                "body": {
                  "properties": {
                    "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                    "UPLOADCARE_STORE": "optional<root.StoreType>",
                    "content_type": {
                      "docs": "File's MIME-type.",
                      "type": "string",
                    },
                    "expire": "optional<root.ExpireType>",
                    "filename": {
                      "docs": "Original file name of the uploaded file",
                      "type": "string",
                    },
                    "metadata[{key}]": "optional<root.MetadataValue>",
                    "part_size": {
                      "default": 5242880,
                      "docs": "Multipart Uploads expect that you will split the uploaded file into equally sized
parts (except for the last part) and then will upload them to AWS S3 (possibly in parallel).
By default, we assume that you will upload the files in 5 megabyte chunks,
so we return a list of presigned AWS S3 URLs accordingly.
If you intend to upload large files (for example, larger than a gigabyte),
we recommend to bump the part size and to pass the expected chunk size
to us as a value of the `part_size` parameter (in bytes).
",
                      "type": "optional<integer>",
                      "validation": {
                        "exclusiveMax": undefined,
                        "exclusiveMin": undefined,
                        "max": undefined,
                        "min": 5242880,
                        "multipleOf": undefined,
                      },
                    },
                    "signature": "optional<root.SignatureType>",
                    "size": {
                      "docs": "Precise file size of the uploaded file (in bytes).
**Note**: The size should not exceed max file size cap for your project.
",
                      "type": "integer",
                    },
                  },
                },
                "content-type": "multipart/form-data",
                "docs": "Multipart upload parameters to start multipart uploading.",
                "headers": undefined,
                "name": "MultipartFileUploadStartRequest",
                "path-parameters": undefined,
                "query-parameters": undefined,
              },
              "response": {
                "docs": "Multipart upload started successfully.",
                "status-code": 200,
                "type": "MultipartFileUploadStartResponse",
              },
              "source": {
                "openapi": "../openapi.json",
              },
            },
          },
          "source": {
            "openapi": "../openapi.json",
          },
        },
        "types": {
          "BaseUploadResponse": {
            "docs": "JSON object where the key is the file name of the uploaded file and
the value is the unique ID of the file on our systems.
",
            "inline": undefined,
            "properties": {
              "filename": {
                "type": "optional<string>",
                "validation": {
                  "format": "uuid",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FromUrlUploadRequestCheckUrlDuplicates": {
            "default": "0",
            "docs": "If set to "1", enables the `source_url` duplicates prevention.
Specifically, if the `source_url` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
            "enum": [
              {
                "name": "Zero",
                "value": "0",
              },
              {
                "name": "One",
                "value": "1",
              },
            ],
            "inline": true,
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FromUrlUploadRequestSaveUrlDuplicates": {
            "docs": "Determines if the requested `source_url` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the `check_URL_duplicates` parameter.
",
            "enum": [
              {
                "name": "Zero",
                "value": "0",
              },
              {
                "name": "One",
                "value": "1",
              },
            ],
            "inline": true,
            "source": {
              "openapi": "../openapi.json",
            },
          },
          "FromUrlUploadResponse": {
            "discriminated": false,
            "docs": undefined,
            "encoding": undefined,
            "inline": undefined,
            "source": {
              "openapi": "../openapi.json",
            },
            "union": [
              "root.FromUrlUploadResponseSchema",
              "root.FileUploadInfoFromUrl",
            ],
          },
          "FromUrlUploadStatusResponse": {
            "discriminated": false,
            "docs": undefined,
            "encoding": undefined,
            "inline": undefined,
            "source": {
              "openapi": "../openapi.json",
            },
            "union": [
              "root.FileUploadInfoWaitingStatus",
              "root.FileUploadInfoProgressStatus",
              "root.FileUploadInfoSuccessStatus",
              "root.FileUploadInfoErrorStatus",
              "root.FileUploadInfoUnknownStatus",
            ],
          },
          "MultipartFileUploadStartResponse": {
            "docs": undefined,
            "inline": undefined,
            "properties": {
              "parts": "list<string>",
              "uuid": {
                "docs": "File's UUID.",
                "type": "string",
                "validation": {
                  "format": "uuid",
                  "maxLength": undefined,
                  "minLength": undefined,
                  "pattern": undefined,
                },
              },
            },
            "source": {
              "openapi": "../openapi.json",
            },
          },
        },
      },
      "rawContents": "imports:
  root: __package__.yml
types:
  BaseUploadResponse:
    docs: |
      JSON object where the key is the file name of the uploaded file and
      the value is the unique ID of the file on our systems.
    properties:
      filename:
        type: optional<string>
        validation:
          format: uuid
    source:
      openapi: ../openapi.json
  MultipartFileUploadStartResponse:
    properties:
      uuid:
        type: string
        docs: File's UUID.
        validation:
          format: uuid
      parts: list<string>
    source:
      openapi: ../openapi.json
  FromUrlUploadRequestCheckUrlDuplicates:
    enum:
      - value: '0'
        name: Zero
      - value: '1'
        name: One
    docs: >
      If set to "1", enables the `source_url` duplicates prevention.

      Specifically, if the `source_url` had already been fetched and uploaded
      previously,

      this request will return information about the already uploaded file.
    default: '0'
    inline: true
    source:
      openapi: ../openapi.json
  FromUrlUploadRequestSaveUrlDuplicates:
    enum:
      - value: '0'
        name: Zero
      - value: '1'
        name: One
    docs: |
      Determines if the requested `source_url` should be kept in the history of
      fetched/uploaded URLs. If the value is not defined explicitly, it is set
      to the value of the `check_URL_duplicates` parameter.
    inline: true
    source:
      openapi: ../openapi.json
  FromUrlUploadResponse:
    discriminated: false
    union:
      - root.FromUrlUploadResponseSchema
      - root.FileUploadInfoFromUrl
    source:
      openapi: ../openapi.json
  FromUrlUploadStatusResponse:
    discriminated: false
    union:
      - root.FileUploadInfoWaitingStatus
      - root.FileUploadInfoProgressStatus
      - root.FileUploadInfoSuccessStatus
      - root.FileUploadInfoErrorStatus
      - root.FileUploadInfoUnknownStatus
    source:
      openapi: ../openapi.json
service:
  auth: false
  base-path: ''
  endpoints:
    baseUpload:
      path: /base/
      method: POST
      auth: false
      docs: >
        Direct file uploads comply with the [RFC
        7578](https://www.rfc-editor.org/rfc/rfc7578) standard.

        In other words, you can perform a direct upload by making an HTTP POST
        request with the Content-Type

        header set to `multipart/form-data`.


        **Note**: Direct file uploads support files smaller than 100 megabytes
        only.

        If you would like to upload larger files, please use [Multipart
        Uploads](/api-refs/upload-api/#operation/multipartFileUploadStart)
        instead.


        File upload example with curl:


        ```

        curl -F "UPLOADCARE_PUB_KEY=YOUR_PUBLIC_KEY" -F
        "my_file.jpg=@my_file.jpg" "https://upload.uploadcare.com/base/"

        ```
      source:
        openapi: ../openapi.json
      display-name: Direct uploads
      request:
        name: BaseUploadRequest
        body:
          properties:
            UPLOADCARE_PUB_KEY: root.ProjectPublicKeyType
            UPLOADCARE_STORE: optional<root.StoreType>
            '{filename}':
              type: list<file>
              docs: File's content
            metadata[{key}]: optional<root.MetadataValue>
            signature: optional<root.SignatureType>
            expire: optional<root.ExpireType>
        content-type: multipart/form-data
      response:
        docs: The file was uploaded successfully.
        type: BaseUploadResponse
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.ContentTooLargeError
        - root.TooManyRequestsError
      examples:
        - request:
            UPLOADCARE_PUB_KEY: caa9d29da887ee88ffe6
          response:
            body:
              filename: filename
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { base } from '@uploadcare/upload-client'

                // fileData must be `Blob` or `File` or `Buffer`
                const result = await base(
                  fileData,
                  {
                    publicKey: 'YOUR_PUBLIC_KEY',
                    store: 'auto',
                    metadata: {
                      subsystem: 'uploader',
                      pet: 'cat'
                    }
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $fileInfo = $uploader->fromPath(__DIR__ . '/squirrel.jpg', null,
                null, 'auto', [
                    'system' => 'php-uploader',
                    'pet' => 'cat',
                ]);

                echo \sprintf("URL: %s, ID: %s, Mime type: %s\n",
                $fileInfo->getUrl(), $fileInfo->getUuid(),
                $fileInfo->getMimeType());

                foreach ($fileInfo->getMetadata() as $key => $value) {
                    echo \sprintf("%s: %s\n", $key, $value);
                }
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                with open('test1.txt', 'rb') as file_object:
                    ucare_file = uploadcare.upload(file_object)
            - name: Ruby
              language: Ruby
              code: >
                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"


                source_file = File.open('image.png')

                uploaded_file = Uploadcare::Uploader.upload(source_file, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                guard let url = Bundle.main.url(forResource: "squirrel",
                withExtension: "jpg"),
                      let data = try? Data(contentsOf: url) else { return }
                let metadata = ["subsystem": "uploader", "pet": "cat"]


                let file = try await uploadcare.uploadFile(data, withName:
                "random_file_name.jpg", store: .auto) { progress in
                  print("progress: \(progress)")
                }

                prkint(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uri =
                "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()

                val file = FileUploader(uploadcare, uri = uri, context =
                context).upload()

                Log.d("TAG", file.toString())
    multipartFileUploadStart:
      path: /multipart/start/
      method: POST
      auth: false
      docs: >
        Multipart uploads should be used if you need to upload files larger than
        100 megabytes or if you want to

        explicitly trigger [AWS S3 Transfer
        Acceleration](https://aws.amazon.com/s3/transfer-acceleration/).

        When you use Multipart Uploads your files go straight to AWS S3
        bypassing our upload instances.


        To upload large files, 3 requests are sent in sequence:

        1. `/multipart/start/`

        2. `<presigned-url-x>`

        3. `/multipart/complete/`.


        **Note**: Multipart uploads support files larger than 10 megabytes only.
      source:
        openapi: ../openapi.json
      display-name: Start multipart upload
      request:
        name: MultipartFileUploadStartRequest
        body:
          properties:
            UPLOADCARE_PUB_KEY: root.ProjectPublicKeyType
            UPLOADCARE_STORE: optional<root.StoreType>
            filename:
              type: string
              docs: Original file name of the uploaded file
            size:
              type: integer
              docs: >
                Precise file size of the uploaded file (in bytes).

                **Note**: The size should not exceed max file size cap for your
                project.
            part_size:
              type: optional<integer>
              docs: >
                Multipart Uploads expect that you will split the uploaded file
                into equally sized

                parts (except for the last part) and then will upload them to
                AWS S3 (possibly in parallel).

                By default, we assume that you will upload the files in 5
                megabyte chunks,

                so we return a list of presigned AWS S3 URLs accordingly.

                If you intend to upload large files (for example, larger than a
                gigabyte),

                we recommend to bump the part size and to pass the expected
                chunk size

                to us as a value of the `part_size` parameter (in bytes).
              default: 5242880
              validation:
                min: 5242880
            content_type:
              type: string
              docs: File's MIME-type.
            metadata[{key}]: optional<root.MetadataValue>
            signature: optional<root.SignatureType>
            expire: optional<root.ExpireType>
        content-type: multipart/form-data
        docs: Multipart upload parameters to start multipart uploading.
      response:
        docs: Multipart upload started successfully.
        type: MultipartFileUploadStartResponse
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.TooManyRequestsError
      examples:
        - request:
            UPLOADCARE_PUB_KEY: caa9d29da887ee88ffe6
            filename: filename
            size: 1
            content_type: content_type
          response:
            body:
              uuid: 67947755-1584-4e3f-902b-d4e2bf76a841
              parts:
                - <presigned-url-1>
                - <presigned-url-2>
                - <presigned-url-3>
                - <presigned-url-4>
                - <presigned-url-5>
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { multipartStart } from '@uploadcare/upload-client'

                const result = await multipartStart(
                  27796904,
                  {
                    publicKey: 'YOUR_PUBLIC_KEY',
                    store: 'auto',
                    fileName: 'myfile.mp4',
                    contentType: 'video/mp4',
                    metadata: {
                      subsystem: 'uploader',
                      pet: 'cat'
                    }
                  }
                )
            - name: PHP
              language: PHP
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $path = '/path-to-large-file.zip';

                $handle = \fopen($path, 'rb');

                $response = $uploader->fromResource($handle, null, null, 'auto',
                [
                    'size' => \filesize($path), // The "size" is the metadata key
                ]);

                echo \sprintf('File uploaded. ID is \'%s\'',
                $response->getUuid());
            - name: Python
              language: Python
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                with open('test1.txt', 'rb') as file_object:
                    ucare_file = uploadcare.multipart_upload(file_object)
            - name: Ruby
              language: Ruby
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"


                source_file = File.open('image.png')

                uploaded_file = Uploadcare::Uploader.upload(source_file, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb",
                withExtension: "jpg"),
                      let data = try? Data(contentsOf: url) else { return }

                let metadata = ["subsystem": "uploader", "pet": "cat"]

                let onProgress: (Double)->Void = { (progress) in
                  print("progress: \(progress)")
                }


                let file = try await uploadcare.uploadAPI.multipartUpload(data,
                withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata,
                onProgress)

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uri =
                "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()

                val file = FileUploader(uploadcare, uri = uri, context =
                context).upload()

                Log.d("TAG", file.toString())
    multipartFileUploadPart:
      path: /<presigned-url-x>
      method: PUT
      auth: false
      docs: >
        The second phase is about uploading the file parts to the presigned
        upload URLs returned from the

        `/multipart/start/` endpoint.


        Each uploaded part should be at least 5 MiB (5242880 bytes) in size
        except for the last one, which can be smaller.

        You can upload the file parts in parallel provided that the byte order
        stays unchanged.


        **Note**: You MUST define `Content-Type` header for your data.
      source:
        openapi: ../openapi.json
      display-name: Upload individual file parts
      request:
        body: bytes
        content-type: application/octet-stream
      examples:
        - code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { multipartUpload } from '@uploadcare/upload-client'

                // partData is a chunk of the uploaded file's content
                // must be `Blob` or `File` or `Buffer`
                const result = await multipartUpload(
                  partData,
                  '<presigned-url-x>'
                )
            - name: PHP
              language: PHP
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $path = '/path-to-large-file.zip';

                $handle = \fopen($path, 'rb');

                $response = $uploader->fromResource($handle, null, null, 'auto',
                [
                    'size' => \filesize($path), // The "size" is the metadata key
                ]);

                echo \sprintf('File uploaded. ID is \'%s\'',
                $response->getUuid());
            - name: Python
              language: Python
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                with open('test1.txt', 'rb') as file_object:
                    ucare_file = uploadcare.multipart_upload(file_object)
            - name: Ruby
              language: Ruby
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"


                source_file = File.open('image.png')

                uploaded_file = Uploadcare::Uploader.upload(source_file, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb",
                withExtension: "jpg"),
                      let data = try? Data(contentsOf: url) else { return }

                let metadata = ["subsystem": "uploader", "pet": "cat"]

                let onProgress: (Double)->Void = { (progress) in
                  print("progress: \(progress)")
                }


                let file = try await uploadcare.uploadAPI.multipartUpload(data,
                withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata,
                onProgress)

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uri =
                "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()

                val file = FileUploader(uploadcare, uri = uri, context =
                context).upload()

                Log.d("TAG", file.toString())
    multipartFileUploadComplete:
      path: /multipart/complete/
      method: POST
      auth: false
      docs: >
        Once all the file parts have been uploaded successfully, complete the

        upload session to assemble all the file parts into a single resulting
        file.
      source:
        openapi: ../openapi.json
      display-name: Complete multipart upload
      request:
        name: MultipartFileUploadCompleteRequest
        body:
          properties:
            UPLOADCARE_PUB_KEY: root.ProjectPublicKeyType
            uuid:
              type: string
              docs: File's UUID from the `/multipart/start/` endpoint.
              validation:
                format: uuid
        content-type: multipart/form-data
      response:
        docs: The file was uploaded successfully.
        type: root.FileUploadInfo
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.NotFoundError
      examples:
        - request:
            UPLOADCARE_PUB_KEY: caa9d29da887ee88ffe6
            uuid: uuid
          response:
            body:
              uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              size: 2667636
              total: 2667636
              done: 2667636
              original_filename: IMG-0412_123.JPG
              filename: IMG0412_123.JPG
              mime_type: image/jpeg
              image_info:
                color_mode: RGB
                orientation: 6
                format: JPEG
                sequence: false
                height: 4032
                width: 3024
                geo_location:
                  latitude: 55.62013611111111
                  longitude: 37.66299166666666
                datetime_original: '2024-01-15T09:30:00Z'
                dpi:
                  - 72
                  - 72
              video_info:
                duration: 261827
                format: mp4
                bitrate: 393
                audio:
                  bitrate: 78
                  codec: aac
                  sample_rate: 44100
                  channels: '2'
                video:
                  height: 360
                  width: 640
                  frame_rate: 30
                  bitrate: 315
                  codec: h264
              content_info:
                mime:
                  mime: image/jpeg
                  type: image
                  subtype: jpeg
                image:
                  color_mode: RGB
                  orientation: 6
                  format: JPEG
                  sequence: false
                  height: 4032
                  width: 3024
                  geo_location:
                    latitude: 55.62013611111111
                    longitude: 37.66299166666666
                  datetime_original: '2024-01-15T09:30:00Z'
                  dpi:
                    - 72
                    - 72
                video:
                  duration: 261827
                  format: mp4
                  bitrate: 393
                  audio:
                    - bitrate: 78
                      codec: aac
                      sample_rate: 44100
                      channels: 2
                  video:
                    - height: 360
                      width: 640
                      frame_rate: 30
                      bitrate: 315
                      codec: h264
              metadata:
                subsystem: uploader
                pet: cat
              is_image: true
              is_stored: true
              is_ready: true
              s3_bucket: custom-s3-bucket-name
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { multipartComplete } from '@uploadcare/upload-client'

                const result = await multipartComplete(
                  '67947755-1584-4e3f-902b-d4e2bf76a841',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $path = '/path-to-large-file.zip';

                $handle = \fopen($path, 'rb');

                $response = $uploader->fromResource($handle, null, null, 'auto',
                [
                    'size' => \filesize($path), // The "size" is the metadata key
                ]);

                echo \sprintf('File uploaded. ID is \'%s\'',
                $response->getUuid());
            - name: Python
              language: Python
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                with open('test1.txt', 'rb') as file_object:
                    ucare_file = uploadcare.multipart_upload(file_object)
            - name: Ruby
              language: Ruby
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"


                source_file = File.open('image.png')

                uploaded_file = Uploadcare::Uploader.upload(source_file, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                // Uploadcare lib provides high level API for multipart uploads
                that does everything for you


                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb",
                withExtension: "jpg"),
                      let data = try? Data(contentsOf: url) else { return }

                let metadata = ["subsystem": "uploader", "pet": "cat"]

                let onProgress: (Double)->Void = { (progress) in
                  print("progress: \(progress)")
                }


                let file = try await uploadcare.uploadAPI.multipartUpload(data,
                withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata,
                onProgress)

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uri =
                "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()

                val file = FileUploader(uploadcare, uri = uri, context =
                context).upload()

                Log.d("TAG", file.toString())
    fromURLUpload:
      path: /from_url/
      method: POST
      auth: false
      docs: >
        Uploadcare can fetch a file from a publicly available URL and then
        automatically upload the

        fetched file to your project.


        #### Upload tokens

        Requests to the endpoint return a JSON dictionary with a `token` that
        can be further used

        to [check the
        status](/api-refs/upload-api/#operation/fromURLUploadStatus) of the
        upload

        request.


        **Note:** The token is not a file ID and can't be used to address the
        file directly.

        The actual file ID should be retrieved by calling the
        `/from_url/status/` endpoint.


        #### Duplicates prevention

        By default, every call to the `/from_url/` endpoint with the same
        `source_url` results in

        a new upload leading to file duplication.


        If you would like Uploadcare to keep track of the requested URLs and
        avoid the duplicate

        uploads, pass the `save_URL_duplicates` and `check_URL_duplicates`
        parameters described below.
      source:
        openapi: ../openapi.json
      display-name: Upload files from URLs
      request:
        name: FromUrlUploadRequest
        body:
          properties:
            pub_key: root.ProjectPublicKeyType
            source_url:
              type: string
              docs: >
                Source URL of the file to fetch and upload.


                **Note**: The URL should point to a resource publicly available
                via HTTP/HTTPS.
              validation:
                format: uri
            store: optional<root.StoreType>
            filename:
              type: optional<string>
              docs: >
                Sets the file name of the resource fetched from the source URL.

                If not defined, the file name is obtained from either HTTP

                response headers or the `source_url`'s path.


                **Note:** The filename will be sanitized to only contain the
                following symbols:

                `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._`.
            check_URL_duplicates:
              type: optional<FromUrlUploadRequestCheckUrlDuplicates>
              docs: >
                If set to "1", enables the `source_url` duplicates prevention.

                Specifically, if the `source_url` had already been fetched and
                uploaded previously,

                this request will return information about the already uploaded
                file.
              default: '0'
            save_URL_duplicates:
              type: optional<FromUrlUploadRequestSaveUrlDuplicates>
              docs: >
                Determines if the requested `source_url` should be kept in the
                history of

                fetched/uploaded URLs. If the value is not defined explicitly,
                it is set

                to the value of the `check_URL_duplicates` parameter.
            metadata[{key}]: optional<root.MetadataValue>
            signature: optional<root.SignatureType>
            expire: optional<root.ExpireType>
        content-type: multipart/form-data
      response:
        docs: Status Token or File Info of an already downloaded file.
        type: FromUrlUploadResponse
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.TooManyRequestsError
      examples:
        - name: type-token
          request:
            pub_key: caa9d29da887ee88ffe6
            source_url: source_url
          response:
            body:
              type: token
              token: 945ebb27-1fd6-46c6-a859-b9893712d650
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrl } from '@uploadcare/upload-client'

                const result = await fromUrl(
                  'https://source.unsplash.com/featured',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY',
                    metadata: {
                      subsystem: 'uploader',
                      pet: 'cat'
                    }
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $url = 'https://source.unsplash.com/featured';

                $token = $uploader->fromUrl($url, null, null, 'auto', [
                    'action' => 'upload from URL', // The "Action" is the metadata key
                    'checkDuplicates' => true,
                    'storeDuplicates' => false,
                ]);

                echo \sprintf('Upload from URL \'%s\' has been started. Token is
                %s', $url, $token);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                ucare_file = uploadcare.upload_from_url_sync(
                    "https://source.unsplash.com/featured",
                    check_duplicates=True,
                    save_duplicates=False
                )
            - name: Ruby
              language: Ruby
              code: >
                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"


                source_url = "https://source.unsplash.com/featured"

                uploaded_file = Uploadcare::Uploader.upload(source_url, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let url = URL(string: "https://source.unsplash.com/featured")!

                let task = UploadFromURLTask(sourceUrl: url)
                  .store(.auto)
                  .setMetadata("uploader", forKey: "subsystem")
                  .setMetadata("cat", forKey: "pet")

                let file = try await
                uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uploader = UrlUploader(
                    client = uploadcare,
                    sourceUrl = "https://source.unsplash.com/featured"
                )

                val file = uploader.upload()

                Log.d("TAG", file.toString())
        - name: type-file-info
          request:
            pub_key: caa9d29da887ee88ffe6
            source_url: source_url
          response:
            body:
              uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              size: 2667636
              total: 2667636
              done: 2667636
              original_filename: IMG-0412_123.JPG
              filename: IMG0412_123.JPG
              mime_type: image/jpeg
              image_info:
                color_mode: RGB
                orientation: 6
                format: JPEG
                sequence: false
                height: 4032
                width: 3024
                geo_location:
                  latitude: 55.62013611111111
                  longitude: 37.66299166666666
                datetime_original: '2024-01-15T09:30:00Z'
                dpi:
                  - 72
                  - 72
              video_info:
                duration: 261827
                format: mp4
                bitrate: 393
                audio:
                  bitrate: 78
                  codec: aac
                  sample_rate: 44100
                  channels: '2'
                video:
                  height: 360
                  width: 640
                  frame_rate: 30
                  bitrate: 315
                  codec: h264
              content_info:
                mime:
                  mime: image/jpeg
                  type: image
                  subtype: jpeg
                image:
                  color_mode: RGB
                  orientation: 6
                  format: JPEG
                  sequence: false
                  height: 4032
                  width: 3024
                  geo_location:
                    latitude: 55.62013611111111
                    longitude: 37.66299166666666
                  datetime_original: '2024-01-15T09:30:00Z'
                  dpi:
                    - 72
                    - 72
                video:
                  duration: 261827
                  format: mp4
                  bitrate: 393
                  audio:
                    - bitrate: 78
                      codec: aac
                      sample_rate: 44100
                      channels: 2
                  video:
                    - height: 360
                      width: 640
                      frame_rate: 30
                      bitrate: 315
                      codec: h264
              metadata:
                subsystem: uploader
                pet: cat
              is_image: true
              is_stored: true
              is_ready: true
              s3_bucket: custom-s3-bucket-name
              type: file_info
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrl } from '@uploadcare/upload-client'

                const result = await fromUrl(
                  'https://source.unsplash.com/featured',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY',
                    metadata: {
                      subsystem: 'uploader',
                      pet: 'cat'
                    }
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $url = 'https://source.unsplash.com/featured';

                $token = $uploader->fromUrl($url, null, null, 'auto', [
                    'action' => 'upload from URL', // The "Action" is the metadata key
                    'checkDuplicates' => true,
                    'storeDuplicates' => false,
                ]);

                echo \sprintf('Upload from URL \'%s\' has been started. Token is
                %s', $url, $token);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                ucare_file = uploadcare.upload_from_url_sync(
                    "https://source.unsplash.com/featured",
                    check_duplicates=True,
                    save_duplicates=False
                )
            - name: Ruby
              language: Ruby
              code: >
                require 'uploadcare'

                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"


                source_url = "https://source.unsplash.com/featured"

                uploaded_file = Uploadcare::Uploader.upload(source_url, store:
                auto)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let url = URL(string: "https://source.unsplash.com/featured")!

                let task = UploadFromURLTask(sourceUrl: url)
                  .store(.auto)
                  .setMetadata("uploader", forKey: "subsystem")
                  .setMetadata("cat", forKey: "pet")

                let file = try await
                uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val uploader = UrlUploader(
                    client = uploadcare,
                    sourceUrl = "https://source.unsplash.com/featured"
                )

                val file = uploader.upload()

                Log.d("TAG", file.toString())
    fromURLUploadStatus:
      path: /from_url/status/
      method: GET
      auth: false
      docs: >
        The endpoint notifies about the progress of the task by changing the
        value of the `status` field:
          * the field is set to `waiting` initially
          * once the system starts processing the request, the field is set to `progress`
          * if the file is fetched and uploaded successfully, the `status` field is set to `success`
            and the endpoint returns a JSON object holding information about the uploaded file
          * if the system fails to fetch/upload the file, the `status` field is set to `error` and
            the `error` field is set to the cause of the error.
      source:
        openapi: ../openapi.json
      display-name: Check the status of a task to fetch/upload a file from a URL
      request:
        name: FromUrlUploadStatusRequest
        query-parameters:
          token:
            type: string
            docs: >-
              Token returned by the `/from_url/` endpoint that identifies a
              request to fetch/upload a file from a URL.
            validation:
              format: uuid
      response:
        docs: |
          Request was processed successfully.
        type: FromUrlUploadStatusResponse
        status-code: 200
      errors:
        - root.BadRequestError
      examples:
        - name: status-waiting
          query-parameters:
            token: 945ebb27-1fd6-46c6-a859-b9893712d650
          response:
            body:
              status: waiting
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrlStatus } from '@uploadcare/upload-client'

                const result = await fromUrlStatus(
                  '945ebb27-1fd6-46c6-a859-b9893712d650',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $status =
                $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');

                echo \sprintf('Upload status is %s', $status);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file =
                uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                token = '945ebb27-1fd6-46c6-a859-b9893712d650'
                puts Uploadcare::Uploader.get_upload_from_url_status(token)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let status = try await
                uploadcare.uploadAPI.uploadStatus(forToken:
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                print(status)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val status = uploadcare.getFromUrlStatus(token =
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                Log.d("TAG", status.toString())
        - name: status-progress
          query-parameters:
            token: 945ebb27-1fd6-46c6-a859-b9893712d650
          response:
            body:
              status: progress
              total: 732434
              done: 134427
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrlStatus } from '@uploadcare/upload-client'

                const result = await fromUrlStatus(
                  '945ebb27-1fd6-46c6-a859-b9893712d650',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $status =
                $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');

                echo \sprintf('Upload status is %s', $status);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file =
                uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                token = '945ebb27-1fd6-46c6-a859-b9893712d650'
                puts Uploadcare::Uploader.get_upload_from_url_status(token)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let status = try await
                uploadcare.uploadAPI.uploadStatus(forToken:
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                print(status)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val status = uploadcare.getFromUrlStatus(token =
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                Log.d("TAG", status.toString())
        - name: status-success
          query-parameters:
            token: 945ebb27-1fd6-46c6-a859-b9893712d650
          response:
            body:
              uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              size: 2667636
              total: 2667636
              done: 2667636
              original_filename: IMG-0412_123.JPG
              filename: IMG0412_123.JPG
              mime_type: image/jpeg
              image_info:
                color_mode: RGB
                orientation: 6
                format: JPEG
                sequence: false
                height: 4032
                width: 3024
                geo_location:
                  latitude: 55.62013611111111
                  longitude: 37.66299166666666
                datetime_original: '2024-01-15T09:30:00Z'
                dpi:
                  - 72
                  - 72
              video_info:
                duration: 261827
                format: mp4
                bitrate: 393
                audio:
                  bitrate: 78
                  codec: aac
                  sample_rate: 44100
                  channels: '2'
                video:
                  height: 360
                  width: 640
                  frame_rate: 30
                  bitrate: 315
                  codec: h264
              content_info:
                mime:
                  mime: image/jpeg
                  type: image
                  subtype: jpeg
                image:
                  color_mode: RGB
                  orientation: 6
                  format: JPEG
                  sequence: false
                  height: 4032
                  width: 3024
                  geo_location:
                    latitude: 55.62013611111111
                    longitude: 37.66299166666666
                  datetime_original: '2024-01-15T09:30:00Z'
                  dpi:
                    - 72
                    - 72
                video:
                  duration: 261827
                  format: mp4
                  bitrate: 393
                  audio:
                    - bitrate: 78
                      codec: aac
                      sample_rate: 44100
                      channels: 2
                  video:
                    - height: 360
                      width: 640
                      frame_rate: 30
                      bitrate: 315
                      codec: h264
              metadata:
                subsystem: uploader
                pet: cat
              is_image: true
              is_stored: true
              is_ready: true
              s3_bucket: custom-s3-bucket-name
              status: success
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrlStatus } from '@uploadcare/upload-client'

                const result = await fromUrlStatus(
                  '945ebb27-1fd6-46c6-a859-b9893712d650',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $status =
                $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');

                echo \sprintf('Upload status is %s', $status);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file =
                uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                token = '945ebb27-1fd6-46c6-a859-b9893712d650'
                puts Uploadcare::Uploader.get_upload_from_url_status(token)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let status = try await
                uploadcare.uploadAPI.uploadStatus(forToken:
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                print(status)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val status = uploadcare.getFromUrlStatus(token =
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                Log.d("TAG", status.toString())
        - name: status-error
          query-parameters:
            token: 945ebb27-1fd6-46c6-a859-b9893712d650
          response:
            body:
              status: error
              error: 'HTTP client error: 404.'
              error_code: DownloadFileHTTPClientError
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrlStatus } from '@uploadcare/upload-client'

                const result = await fromUrlStatus(
                  '945ebb27-1fd6-46c6-a859-b9893712d650',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $status =
                $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');

                echo \sprintf('Upload status is %s', $status);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file =
                uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                token = '945ebb27-1fd6-46c6-a859-b9893712d650'
                puts Uploadcare::Uploader.get_upload_from_url_status(token)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let status = try await
                uploadcare.uploadAPI.uploadStatus(forToken:
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                print(status)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val status = uploadcare.getFromUrlStatus(token =
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                Log.d("TAG", status.toString())
        - name: status-unknown
          query-parameters:
            token: 945ebb27-1fd6-46c6-a859-b9893712d650
          response:
            body:
              status: unknown
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { fromUrlStatus } from '@uploadcare/upload-client'

                const result = await fromUrlStatus(
                  '945ebb27-1fd6-46c6-a859-b9893712d650',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $uploader = new Uploadcare\Uploader\Uploader($configuration);

                $status =
                $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');

                echo \sprintf('Upload status is %s', $status);
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file =
                uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                token = '945ebb27-1fd6-46c6-a859-b9893712d650'
                puts Uploadcare::Uploader.get_upload_from_url_status(token)
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let status = try await
                uploadcare.uploadAPI.uploadStatus(forToken:
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                print(status)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val status = uploadcare.getFromUrlStatus(token =
                "945ebb27-1fd6-46c6-a859-b9893712d650")

                Log.d("TAG", status.toString())
    fileUploadInfo:
      path: /info/
      method: GET
      auth: false
      docs: >
        Returns a JSON object with information about an uploaded file (file
        size, MIME type, metadata, etc).
      source:
        openapi: ../openapi.json
      display-name: Get information about an uploaded file
      request:
        name: FileUploadInfoRequest
        query-parameters:
          pub_key: root.ProjectPublicKeyType
          file_id:
            type: string
            docs: File's unique ID.
            validation:
              format: uuid
      response:
        docs: File information was retrieved successfully.
        type: root.FileUploadInfo
        status-code: 200
      errors:
        - root.BadRequestError
        - root.ForbiddenError
        - root.NotFoundError
      examples:
        - query-parameters:
            pub_key: caa9d29da887ee88ffe6
            file_id: 67947755-1584-4e3f-902b-d4e2bf76a841
          response:
            body:
              uuid: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              file_id: be3b4d5e-179d-460e-8a5d-69112ac86cbb
              size: 2667636
              total: 2667636
              done: 2667636
              original_filename: IMG-0412_123.JPG
              filename: IMG0412_123.JPG
              mime_type: image/jpeg
              image_info:
                color_mode: RGB
                orientation: 6
                format: JPEG
                sequence: false
                height: 4032
                width: 3024
                geo_location:
                  latitude: 55.62013611111111
                  longitude: 37.66299166666666
                datetime_original: '2024-01-15T09:30:00Z'
                dpi:
                  - 72
                  - 72
              video_info:
                duration: 261827
                format: mp4
                bitrate: 393
                audio:
                  bitrate: 78
                  codec: aac
                  sample_rate: 44100
                  channels: '2'
                video:
                  height: 360
                  width: 640
                  frame_rate: 30
                  bitrate: 315
                  codec: h264
              content_info:
                mime:
                  mime: image/jpeg
                  type: image
                  subtype: jpeg
                image:
                  color_mode: RGB
                  orientation: 6
                  format: JPEG
                  sequence: false
                  height: 4032
                  width: 3024
                  geo_location:
                    latitude: 55.62013611111111
                    longitude: 37.66299166666666
                  datetime_original: '2024-01-15T09:30:00Z'
                  dpi:
                    - 72
                    - 72
                video:
                  duration: 261827
                  format: mp4
                  bitrate: 393
                  audio:
                    - bitrate: 78
                      codec: aac
                      sample_rate: 44100
                      channels: 2
                  video:
                    - height: 360
                      width: 640
                      frame_rate: 30
                      bitrate: 315
                      codec: h264
              metadata:
                subsystem: uploader
                pet: cat
              is_image: true
              is_stored: true
              is_ready: true
              s3_bucket: custom-s3-bucket-name
          code-samples:
            - name: JS
              language: JavaScript
              code: |
                import { info } from '@uploadcare/upload-client'

                const result = await info(
                  'be3b4d5e-179d-460e-8a5d-69112ac86cbb',
                  {
                    publicKey: 'YOUR_PUBLIC_KEY'
                  }
                )
            - name: PHP
              language: PHP
              code: >
                <?php

                $configuration = Uploadcare\Configuration::create((string)
                $_ENV['UPLOADCARE_PUBLIC_KEY'], (string)
                $_ENV['UPLOADCARE_SECRET_KEY']);


                $fileInfo = (new
                Uploadcare\Api($configuration))->file()->fileInfo(string $uuid);

                echo \sprintf('URL: %s, ID: %s, Mime type: %s',
                $fileInfo->getUrl(), $fileInfo->getUuid(),
                $fileInfo->getMimeType());
            - name: Python
              language: Python
              code: >
                from pyuploadcare import Uploadcare, File


                uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY',
                secret_key='YOUR_SECRET_KEY')

                file = uploadcare.file('740e1b8c-1ad8-4324-b7ec-112c79d8eac2')

                print(file.info)
            - name: Ruby
              language: Ruby
              code: |
                require 'uploadcare'
                Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
                Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

                uuid = '740e1b8c-1ad8-4324-b7ec-112c79d8eac2'
                info = Uploadcare::File.info(uuid)
                puts info.inspect
            - name: Swift
              language: Swift
              code: >
                import Uploadcare


                let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY",
                secretKey: "YOUR_SECRET_KEY")


                let file = try await uploadcare.uploadAPI.fileInfo(withFileId:
                "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")

                print(file)
            - name: Kotlin
              language: Kotlin
              code: >
                import com.uploadcare.android.library.api.UploadcareClient


                val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY",
                secretKey = "YOUR_SECRET_KEY")


                val file = uploadcare.getUploadedFile(fileId =
                "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")

                Log.d("TAG", file.toString())
  source:
    openapi: ../openapi.json
  display-name: Upload
",
    },
  },
  "packageMarkers": {},
  "rootApiFile": {
    "contents": {
      "default-environment": "Default",
      "display-name": "Upload API Reference",
      "environments": {
        "Default": "https://upload.uploadcare.com",
      },
      "error-discrimination": {
        "strategy": "status-code",
      },
      "name": "api",
    },
    "defaultUrl": undefined,
    "rawContents": "name: api
error-discrimination:
  strategy: status-code
display-name: Upload API Reference
environments:
  Default: https://upload.uploadcare.com
default-environment: Default
",
  },
}
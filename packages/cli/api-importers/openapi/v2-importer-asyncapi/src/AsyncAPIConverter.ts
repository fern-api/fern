import { FernIr, IntermediateRepresentation } from "@fern-api/ir-sdk";
import { injectAutogeneratedExamples } from "@fern-api/ir-utils";
import { AbstractConverter, ErrorCollector, Extensions } from "@fern-api/v2-importer-commons";

import { AsyncAPIV2 } from "./2.x";
import { AsyncAPIV3 } from "./3.1";
import { AsyncAPIConverterContext } from "./AsyncAPIConverterContext";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace OpenAPIConverter {
    export interface Args extends AbstractConverter.Args {
        context: AsyncAPIConverterContext;
    }
}

export class AsyncAPIConverter extends AbstractConverter<AsyncAPIConverterContext, IntermediateRepresentation> {
    private ir: BaseIntermediateRepresentation;

    constructor({ breadcrumbs, context }: OpenAPIConverter.Args) {
        super({ breadcrumbs });
        this.ir = {
            auth: {
                docs: undefined,
                requirement: FernIr.AuthSchemesRequirement.All,
                schemes: []
            },
            types: {},
            services: {},
            errors: {},
            webhookGroups: {},
            websocketChannels: undefined,
            headers: [],
            idempotencyHeaders: [],
            apiVersion: undefined,
            apiDisplayName: undefined,
            apiDocs: undefined,
            basePath: undefined,
            pathParameters: [],
            errorDiscriminationStrategy: FernIr.ErrorDiscriminationStrategy.statusCode(),
            variables: [],
            serviceTypeReferenceInfo: {
                sharedTypes: [],
                typesReferencedOnlyByService: {}
            },
            readmeConfig: undefined,
            sourceConfig: undefined,
            publishConfig: undefined,
            dynamic: undefined,
            environments: undefined,
            fdrApiDefinitionId: undefined,
            rootPackage: context.createPackage(),
            subpackages: {},
            sdkConfig: {
                hasFileDownloadEndpoints: false,
                hasPaginatedEndpoints: false,
                hasStreamingEndpoints: false,
                isAuthMandatory: true,
                platformHeaders: {
                    language: "",
                    sdkName: "",
                    sdkVersion: "",
                    userAgent: undefined
                }
            }
        };
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
    }): Promise<IntermediateRepresentation> {
        context.spec = this.removeXFernIgnores({
            document: context.spec,
            context,
            errorCollector
        }) as AsyncAPIV2.DocumentV2 | AsyncAPIV3.DocumentV3;

        let ir = {
            ...this.ir,
            apiName: context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: { disabled: false } })
        };

        return ir;
    }

    private removeXFernIgnores({
        document,
        context,
        errorCollector,
        breadcrumbs = []
    }: {
        document: unknown;
        context: AsyncAPIConverterContext;
        errorCollector: ErrorCollector;
        breadcrumbs?: string[];
    }): unknown {
        if (Array.isArray(document)) {
            return document
                .filter((item, index) => {
                    const shouldIgnore = new Extensions.FernIgnoreExtension({
                        breadcrumbs: [...breadcrumbs, String(index)],
                        operation: item
                    }).convert({ context, errorCollector });
                    return !shouldIgnore;
                })
                .map((item, index) =>
                    this.removeXFernIgnores({
                        document: item,
                        context,
                        errorCollector,
                        breadcrumbs: [...breadcrumbs, String(index)]
                    })
                );
        } else if (document != null && typeof document === "object") {
            return Object.fromEntries(
                Object.entries(document)
                    .filter(([key, value]) => {
                        const shouldIgnore = new Extensions.FernIgnoreExtension({
                            breadcrumbs: [...breadcrumbs, key],
                            operation: value
                        }).convert({ context, errorCollector });
                        return !shouldIgnore;
                    })
                    .map(([key, value]) => [
                        key,
                        this.removeXFernIgnores({
                            document: value,
                            context,
                            errorCollector,
                            breadcrumbs: [...breadcrumbs, key]
                        })
                    ])
            );
        }
        return document;
    }
}

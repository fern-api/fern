import { assertNever, isNonNullish } from "@fern-api/core-utils";
import { RawSchemas } from "@fern-api/fern-definition-schema";
import { Logger } from "@fern-api/logger";
import {
    CustomCodeSample,
    EndpointExample,
    EndpointResponseExample,
    EndpointWithExample,
    FernOpenapiIr,
    FullExample,
    GlobalHeader,
    HeaderExample,
    NamedFullExample,
    PathParameterExample,
    PrimitiveSchemaValueWithExample,
    QueryParameterExample,
    RequestWithExample,
    ResponseWithExample,
    SchemaWithExample,
    SupportedSdkLanguage
} from "@fern-api/openapi-ir";
import * as fs from "fs";
import * as path from "path";

import { ExampleTypeFactory } from "../../../schema/examples/ExampleTypeFactory";
import { convertSchemaToSchemaWithExample } from "../../../schema/utils/convertSchemaToSchemaWithExample";
import { isSchemaRequired } from "../../../schema/utils/isSchemaRequired";
import { shouldSkipReadOnly } from "../../../utils/shouldSkipReadOnly";
import { hasIncompleteExample } from "../hasIncompleteExample";
import { OpenAPIV3ParserContext } from "../OpenAPIV3ParserContext";

type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };

interface MissingExampleRecord {
    endpoint: string;
    method: string;
    type: "request" | "response";
    schemaType: string;
    reason: string;
    operationSummary?: string;
    operationDescription?: string;
    schemaDescription?: string;
    autoGeneratedExample?: JsonValue;
}

export class ExampleEndpointFactory {
    private exampleTypeFactory: ExampleTypeFactory;
    private logger: Logger;
    private missingExamples: MissingExampleRecord[] = [];

    constructor(
        private readonly schemas: Record<string, SchemaWithExample>,
        private readonly context: OpenAPIV3ParserContext,
        private readonly globalHeaders: GlobalHeader[]
    ) {
        this.schemas = schemas;
        this.exampleTypeFactory = new ExampleTypeFactory(schemas, context.nonRequestReferencedSchemas, context);
        this.logger = context.logger;
    }

    private addMissingExampleRecord(
        endpoint: EndpointWithExample,
        type: "request" | "response",
        schemaType: string,
        reason: string,
        options: {
            schemaDescription?: string;
            autoGeneratedExample?: JsonValue;
        } = {}
    ) {
        this.missingExamples.push({
            endpoint: endpoint.path,
            method: endpoint.method.toUpperCase(),
            type,
            schemaType,
            reason,
            operationSummary: endpoint.summary,
            operationDescription: endpoint.description,
            schemaDescription: options.schemaDescription,
            autoGeneratedExample: options.autoGeneratedExample
        });
    }

    private writeMissingExamplesLog() {
        if (this.missingExamples.length === 0) {
            return;
        }

        // Get the directory containing the OpenAPI file
        let logDir: string | undefined;
        if (this.context.source.type === "openapi") {
            const sourceFile = this.context.source.file;
            const sourceDir = path.dirname(sourceFile);

            // Look for fern directory in source directory or parent directories
            let currentDir = sourceDir;
            while (currentDir !== path.dirname(currentDir)) {
                const fernDir = path.join(currentDir, "fern");
                if (fs.existsSync(fernDir) && fs.statSync(fernDir).isDirectory()) {
                    logDir = fernDir;
                    break;
                }
                currentDir = path.dirname(currentDir);
            }

            // If no fern directory found, create log in source directory
            if (!logDir) {
                logDir = sourceDir;
            }
        } else {
            // Fallback to current working directory if not OpenAPI source
            logDir = process.cwd();
        }

        const resolvedLogDir = logDir ?? process.cwd();
        const logPath = path.join(resolvedLogDir, "schemas_missing_examples.txt");

        const logContent = [
            `# Schemas Missing Examples Report`,
            `# Generated on: ${new Date().toISOString()}`,
            `# Total missing examples: ${this.missingExamples.length}`,
            ``,
            ...this.missingExamples.flatMap((record) => {
                const lines: string[] = [];

                // Main record line
                lines.push(
                    `${record.method} ${record.endpoint} - ${record.type.toUpperCase()} (${record.schemaType}): ${record.reason}`
                );

                // Operation summary/description
                if (record.operationSummary) {
                    lines.push(`  Operation: ${record.operationSummary}`);
                }
                if (record.operationDescription && record.operationDescription !== record.operationSummary) {
                    lines.push(`  Description: ${record.operationDescription}`);
                }

                // Schema description
                if (record.schemaDescription) {
                    lines.push(
                        `  ${record.type === "request" ? "Request" : "Response"} Schema: ${record.schemaDescription}`
                    );
                }

                // Auto-generated example
                if (record.autoGeneratedExample) {
                    lines.push(`  Auto-generated example:`);
                    const exampleJson = JSON.stringify(record.autoGeneratedExample, null, 4);
                    // Indent each line of the JSON
                    const indentedExample = exampleJson
                        .split("\n")
                        .map((line) => `    ${line}`)
                        .join("\n");
                    lines.push(indentedExample);
                }

                lines.push(""); // Empty line between records
                return lines;
            }),
            ``
        ].join("\n");

        try {
            fs.writeFileSync(logPath, logContent, "utf8");
            this.logger.info(`Missing examples report written to: ${logPath}`);
        } catch (error) {
            this.logger.warn(`Failed to write missing examples report to ${logPath}:`, String(error));
        }
    }

    public finalize(): void {
        // Write the missing examples report if any examples were missing
        // this.writeMissingExamplesLog(); // Disabled file writing
    }

    private convertExampleToJson(example: FernOpenapiIr.FullExample): JsonValue {
        // Convert FullExample to a plain JSON object for logging
        switch (example.type) {
            case "primitive":
                return example.value as unknown as JsonValue;
            case "array":
                return example.value.map((item) => this.convertExampleToJson(item));
            case "object": {
                const result: Record<string, JsonValue> = {};
                Object.entries(example.properties).forEach(([key, value]) => {
                    result[key] = this.convertExampleToJson(value);
                });
                return result;
            }
            case "map": {
                const mapResult: Record<string, JsonValue> = {};
                example.value.forEach((pair) => {
                    mapResult[String(pair.key)] = this.convertExampleToJson(pair.value);
                });
                return mapResult;
            }
            case "oneOf":
                if (example.value.type === "undiscriminated") {
                    return this.convertExampleToJson(example.value.value);
                } else {
                    // discriminated - convert the record
                    const result: Record<string, JsonValue> = {};
                    Object.entries(example.value.value).forEach(([key, value]) => {
                        result[key] = this.convertExampleToJson(value);
                    });
                    return result;
                }
            case "enum":
                return example.value as unknown as JsonValue;
            case "literal":
                return example.value as unknown as JsonValue;
            case "null":
                return null;
            case "unknown":
                return this.convertExampleToJson(example.value);
            default:
                return example as unknown as JsonValue;
        }
    }

    private getSchemaDescription(schema: SchemaWithExample): string | undefined {
        // Safely extract description from different schema types
        if ("description" in schema) {
            return schema.description;
        }
        return undefined;
    }

    private getSchemaTypeName(schema: SchemaWithExample): string {
        switch (schema.type) {
            case "primitive":
                return `primitive (${schema.schema.type})`;
            case "object":
                return schema.generatedName || "object";
            case "array":
                return "array";
            case "map":
                return "map";
            case "optional":
                return `optional (${this.getSchemaTypeName(schema.value)})`;
            case "nullable":
                return `nullable (${this.getSchemaTypeName(schema.value)})`;
            case "reference":
                return schema.generatedName || "reference";
            case "enum":
                return schema.generatedName || "enum";
            case "literal":
                return "literal";
            case "oneOf":
                return "oneOf";
            case "unknown":
                return "unknown";
            default:
                return "unknown";
        }
    }

    public buildEndpointExample(endpoint: EndpointWithExample): EndpointExample[] {
        // pares down the request/response to only multipart or json schemas.
        // other types are not supported in the builder.
        const requestSchemaIdResponse = getRequestSchema(endpoint.request);
        const responseSchemaIdResponse = getResponseSchema(endpoint.response);

        if (requestSchemaIdResponse?.type === "unsupported" || responseSchemaIdResponse?.type === "unsupported") {
            return [];
        }

        // build the request examples. if there are no examples, build an example from the schema.
        // if all the built examples are null, skip building, warn, and return undefined.
        const requestExamples: [id: string | undefined, example: FernOpenapiIr.FullExample][] = [];
        if (requestSchemaIdResponse != null && requestSchemaIdResponse.type === "present") {
            const required = this.isSchemaRequired(requestSchemaIdResponse.schema);

            if (requestSchemaIdResponse.examples.length === 0) {
                const example = this.exampleTypeFactory.buildExample({
                    skipReadonly: shouldSkipReadOnly(endpoint.method),
                    schema: requestSchemaIdResponse.schema,
                    exampleId: undefined,
                    example: undefined,
                    options: {
                        isParameter: false,
                        ignoreOptionals: true
                        // TODO(dsinghvi): Respect depth on request examples
                        // maxDepth: this.context.options.exampleGeneration?.request?.["max-depth"] ?? 0,
                    }
                });

                if (example != null) {
                    requestExamples.push([undefined, example]);

                    // Log that we auto-generated an example since no user-provided examples were found
                    this.addMissingExampleRecord(
                        endpoint,
                        "request",
                        this.getSchemaTypeName(requestSchemaIdResponse.schema),
                        "No user-provided examples found in OpenAPI spec",
                        {
                            schemaDescription: this.getSchemaDescription(requestSchemaIdResponse.schema),
                            autoGeneratedExample: this.convertExampleToJson(example)
                        }
                    );
                } else {
                    // Log that auto-generation also failed
                    this.addMissingExampleRecord(
                        endpoint,
                        "request",
                        this.getSchemaTypeName(requestSchemaIdResponse.schema),
                        "Auto-generation failed (schema too complex or circular references)",
                        {
                            schemaDescription: this.getSchemaDescription(requestSchemaIdResponse.schema)
                        }
                    );
                }
            } else {
                for (const { name: exampleId, value: rawExample } of requestSchemaIdResponse.examples) {
                    const example = this.exampleTypeFactory.buildExample({
                        skipReadonly: shouldSkipReadOnly(endpoint.method),
                        schema: requestSchemaIdResponse.schema,
                        exampleId,
                        example: rawExample,
                        options: {
                            isParameter: false,
                            ignoreOptionals: true
                            // TODO(dsinghvi): Respect depth on request examples
                            // maxDepth: this.context.options.exampleGeneration?.request?.["max-depth"] ?? 0,
                        }
                    });
                    if (example != null) {
                        requestExamples.push([exampleId, example]);
                    } else {
                        // Log that provided example failed to build
                        this.addMissingExampleRecord(
                            endpoint,
                            "request",
                            this.getSchemaTypeName(requestSchemaIdResponse.schema),
                            `Failed to build example from provided data (example id: ${exampleId})`,
                            {
                                schemaDescription: this.getSchemaDescription(requestSchemaIdResponse.schema)
                            }
                        );
                    }
                }
            }

            if (required && requestExamples.length === 0) {
                this.logger.trace(
                    `Failed to generate required request example for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                );
                return [];
            }
        }

        const responseExamples: [id: string | undefined, example: FernOpenapiIr.EndpointResponseExample][] = [];
        if (responseSchemaIdResponse != null && responseSchemaIdResponse.type === "present") {
            const required = this.isSchemaRequired(responseSchemaIdResponse.schema);

            if (responseSchemaIdResponse.examples.length === 0) {
                const example = this.exampleTypeFactory.buildExample({
                    skipReadonly: false,
                    schema: responseSchemaIdResponse.schema,
                    exampleId: undefined,
                    example: undefined,
                    options: {
                        maxDepth: this.context.options.exampleGeneration?.response?.["max-depth"] ?? 3,
                        isParameter: false,
                        ignoreOptionals: false
                    }
                });

                if (example != null) {
                    if (endpoint.response?.type === "json") {
                        responseExamples.push([undefined, EndpointResponseExample.withoutStreaming(example)]);
                    } else if (
                        endpoint.response?.type === "streamingJson" ||
                        endpoint.response?.type === "streamingSse"
                    ) {
                        responseExamples.push([
                            undefined,
                            EndpointResponseExample.withStreaming({
                                sse: endpoint.response?.type === "streamingSse",
                                events: [example]
                            })
                        ]);
                    }

                    // Log that we auto-generated an example since no user-provided examples were found
                    this.addMissingExampleRecord(
                        endpoint,
                        "response",
                        this.getSchemaTypeName(responseSchemaIdResponse.schema),
                        "No user-provided examples found in OpenAPI spec",
                        {
                            schemaDescription: this.getSchemaDescription(responseSchemaIdResponse.schema),
                            autoGeneratedExample: this.convertExampleToJson(example)
                        }
                    );
                } else {
                    // Log that auto-generation also failed
                    this.addMissingExampleRecord(
                        endpoint,
                        "response",
                        this.getSchemaTypeName(responseSchemaIdResponse.schema),
                        "Auto-generation failed (schema too complex or circular references)",
                        {
                            schemaDescription: this.getSchemaDescription(responseSchemaIdResponse.schema)
                        }
                    );
                }
            } else {
                for (const { name: exampleId, value: rawExample } of responseSchemaIdResponse.examples) {
                    const example = this.exampleTypeFactory.buildExample({
                        skipReadonly: false,
                        schema: responseSchemaIdResponse.schema,
                        exampleId,
                        example: rawExample,
                        options: {
                            maxDepth: this.context.options.exampleGeneration?.response?.["max-depth"] ?? 3,
                            isParameter: false,
                            ignoreOptionals: false
                        }
                    });
                    if (example != null) {
                        if (endpoint.response?.type === "json") {
                            responseExamples.push([exampleId, EndpointResponseExample.withoutStreaming(example)]);
                        } else if (
                            endpoint.response?.type === "streamingJson" ||
                            endpoint.response?.type === "streamingSse"
                        ) {
                            responseExamples.push([
                                undefined,
                                EndpointResponseExample.withStreaming({
                                    sse: endpoint.response?.type === "streamingSse",
                                    events: [example]
                                })
                            ]);
                        }
                    } else {
                        // Log that provided example failed to build
                        this.addMissingExampleRecord(
                            endpoint,
                            "response",
                            this.getSchemaTypeName(responseSchemaIdResponse.schema),
                            `Failed to build example from provided data (example id: ${exampleId})`,
                            {
                                schemaDescription: this.getSchemaDescription(responseSchemaIdResponse.schema)
                            }
                        );
                    }
                }
            }

            if (required && responseExamples.length === 0) {
                this.logger.trace(
                    `Failed to generate required response example for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                );
                return [];
            }
        }

        const pathParameters: PathParameterExample[] = [];
        for (const pathParameter of endpoint.pathParameters) {
            const required = this.isSchemaRequired(pathParameter.schema);
            let example = this.exampleTypeFactory.buildExample({
                schema: pathParameter.schema,
                exampleId: undefined,
                example: undefined,
                options: {
                    name: pathParameter.name,
                    isParameter: true,
                    ignoreOptionals: true
                }
            });
            if (example != null && !isExamplePrimitive(example)) {
                this.logger.debug(
                    `Expected a primitive example but got ${example.type} for path parameter ${
                        pathParameter.name
                    } for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                );
                example = undefined;
            }
            if (required && example == null) {
                return [];
            } else if (example != null) {
                pathParameters.push({
                    name: pathParameter.name,
                    parameterNameOverride: pathParameter.parameterNameOverride,
                    value: example
                });
            }
        }

        const queryParameters: QueryParameterExample[] = [];
        for (const queryParameter of endpoint.queryParameters) {
            const required = this.isSchemaRequired(queryParameter.schema);
            let example = this.exampleTypeFactory.buildExample({
                schema: queryParameter.schema,
                exampleId: undefined,
                example: undefined,
                options: {
                    name: queryParameter.name,
                    isParameter: true,
                    ignoreOptionals: true
                }
            });
            if (example != null) {
                const resolvedSchema = this.getResolvedSchema(queryParameter.schema);
                const isArrayParam = resolvedSchema.type === "array";
                const isValidExample = isExamplePrimitive(example) || (isArrayParam && example.type === "array");
                
                if (!isValidExample) {
                    this.logger.debug(
                        `Expected a primitive example but got ${example.type} for query parameter ${
                            queryParameter.name
                        } for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                    );
                    example = undefined;
                }
            }
            if (required && example == null) {
                return [];
            } else if (example != null) {
                queryParameters.push({
                    name: queryParameter.name,
                    value: example
                });
            }
        }

        const headers: HeaderExample[] = [];
        for (const header of endpoint.headers) {
            const required = this.isSchemaRequired(header.schema);
            let example = this.exampleTypeFactory.buildExample({
                schema: header.schema,
                exampleId: undefined,
                example: undefined,
                options: {
                    name: header.name,
                    isParameter: true,
                    ignoreOptionals: true
                }
            });
            if (example != null && !isExamplePrimitive(example)) {
                this.logger.debug(
                    `Expected a primitive example but got ${example.type} for header ${
                        header.name
                    } for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                );
                example = undefined;
            }
            if (required && example == null) {
                return [];
            } else if (example != null) {
                headers.push({
                    name: header.name,
                    value: example
                });
            }
        }

        // Add global headers to examples
        for (const globalHeader of this.globalHeaders) {
            const schema =
                globalHeader.schema != null
                    ? convertSchemaToSchemaWithExample(globalHeader.schema)
                    : SchemaWithExample.primitive({
                          nameOverride: undefined,
                          generatedName: "",
                          title: undefined,
                          description: undefined,
                          availability: undefined,
                          namespace: undefined,
                          groupName: undefined,
                          schema: PrimitiveSchemaValueWithExample.string({
                              default: undefined,
                              pattern: undefined,
                              maxLength: undefined,
                              minLength: undefined,
                              example: undefined,
                              format: undefined
                          })
                      });

            let example = this.exampleTypeFactory.buildExample({
                schema,
                exampleId: undefined,
                example: undefined,
                options: {
                    name: globalHeader.header,
                    isParameter: true,
                    ignoreOptionals: true
                }
            });

            if (example != null && !isExamplePrimitive(example)) {
                this.logger.debug(
                    `Expected a primitive example but got ${example.type} for global header ${
                        globalHeader.header
                    } for ${endpoint.method.toUpperCase()} ${endpoint.path}`
                );
                example = undefined;
            }
            if (example == null) {
                return [];
            } else if (example != null) {
                headers.push({
                    name: globalHeader.header,
                    value: example
                });
            }
        }

        let requestResponsePairs: RequestResponsePair[] = [];
        if (endpoint.request != null && endpoint.response != null) {
            requestResponsePairs = consolidateRequestResponseExamples(requestExamples, responseExamples);
        } else if (endpoint.request != null) {
            requestResponsePairs = requestExamples.map(([id, example]) => {
                return { id, request: example, response: undefined };
            });
        } else if (endpoint.response != null) {
            requestResponsePairs = responseExamples.map(([id, example]) => {
                return { id, request: undefined, response: example };
            });
        }

        // Get all the code samples from incomplete examples
        const codeSamples = endpoint.examples
            .filter((ex) => hasIncompleteExample(ex))
            .flatMap((ex) => {
                if (ex.type === "unknown") {
                    if (ex.value != null) {
                        const samples = (ex.value as RawSchemas.ExampleEndpointCallSchema)["code-samples"];
                        if (samples != null) {
                            return this.convertCodeSamples(samples);
                        }
                    }
                    return undefined;
                } else {
                    return ex.codeSamples;
                }
            })
            .filter((ex): ex is CustomCodeSample => isNonNullish(ex));

        if (requestResponsePairs.length === 0) {
            return [
                EndpointExample.full({
                    name: undefined,
                    description: undefined,
                    pathParameters,
                    queryParameters,
                    headers,
                    request: undefined,
                    response: undefined,
                    codeSamples
                })
            ];
        }

        return requestResponsePairs.map(({ id: exampleName, request: requestExample, response: responseExample }) => {
            return EndpointExample.full({
                name: exampleName,
                description: undefined,
                pathParameters,
                queryParameters,
                headers,
                request: requestExample,
                response: responseExample,
                codeSamples
            });
        });
    }

    private convertCodeSamples(codeSamples: RawSchemas.ExampleCodeSampleSchema[]): CustomCodeSample[] {
        return codeSamples
            .map((codeSample) => {
                if ("language" in codeSample) {
                    return CustomCodeSample.language({
                        name: codeSample.name ?? undefined,
                        description: codeSample.docs ?? undefined,
                        language: codeSample.language,
                        code: codeSample.code,
                        install: codeSample.install ?? undefined
                    });
                } else {
                    return CustomCodeSample.sdk({
                        name: codeSample.name ?? undefined,
                        description: codeSample.docs ?? undefined,
                        sdk: codeSample.sdk === "c#" ? SupportedSdkLanguage.Csharp : codeSample.sdk,
                        code: codeSample.code
                    });
                }
            })
            .filter(isNonNullish);
    }

    private isSchemaRequired(schema: SchemaWithExample) {
        return isSchemaRequired(this.getResolvedSchema(schema));
    }

    private getResolvedSchema(schema: SchemaWithExample): SchemaWithExample {
        let current = schema;
        const visited = new Set<string>();
        
        while (true) {
            if (current.type === "optional" || current.type === "nullable") {
                current = current.value;
            } else if (current.type === "reference") {
                if (visited.has(current.schema)) {
                    break;
                }
                visited.add(current.schema);
                
                const referencedSchema = this.schemas[current.schema];
                if (referencedSchema != null) {
                    current = referencedSchema;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        return current;
    }
}

interface RequestResponsePair {
    id: string | undefined;
    request: FernOpenapiIr.FullExample | undefined;
    response: FernOpenapiIr.EndpointResponseExample | undefined;
}

// if request has multiple examples and response has only 1 example, the response example will be repeated for each request example
// if response has multiple examples and request has only 1 example, the request example will be repeated for each response example
// if both request and response have multiple examples, the examples will be paired up by `id`. If there is no matching `id`, the examples will be paired up in order.
// if requests.length !== responses.length, the examples that can be paired up will be paired up, and the remaining will match the first `id=undefined` example.
// if all of these conditions fail, then only the first request and response examples will be paired up.
function consolidateRequestResponseExamples(
    requestExamples: [id: string | undefined, example: FernOpenapiIr.FullExample][],
    responseExamples: [id: string | undefined, example: FernOpenapiIr.EndpointResponseExample][]
): RequestResponsePair[] {
    const pairs: RequestResponsePair[] = [];
    if (requestExamples.length <= 1) {
        const [requestId, requestExample] = requestExamples[0] ?? [];

        if (responseExamples.length === 0) {
            pairs.push({
                id: requestId,
                request: requestExample,
                response: undefined
            });
            return pairs;
        } else {
            for (const [responseId, responseExample] of responseExamples) {
                pairs.push({
                    id: responseId ?? requestId,
                    request: requestExample,
                    response: responseExample
                });
            }
        }
        return pairs;
    }

    if (responseExamples.length <= 1) {
        const [responseId, responseExample] = responseExamples[0] ?? [];

        if (responseExamples.length === 0) {
            pairs.push({
                id: responseId,
                request: undefined,
                response: responseExample
            });
            return pairs;
        } else {
            for (const [requestId, requestExample] of requestExamples) {
                pairs.push({
                    id: requestId ?? responseId,
                    request: requestExample,
                    response: responseExample
                });
            }
        }
        return pairs;
    }

    const visitedResponseIdx = new Set<number>();
    for (const [requestId, requestExample] of requestExamples) {
        // If the request has no id, or response cannot be paired, pair the request with the first response example that has no id, falling back to the first response example
        const fallbackResponseExample =
            responseExamples.find(([responseId]) => responseId == null)?.[1] ?? responseExamples[0]?.[1];

        if (requestId == null) {
            if (fallbackResponseExample == null) {
                continue;
            }
            pairs.push({
                id: undefined,
                request: requestExample,
                response: fallbackResponseExample
            });
            continue;
        }

        let paired = false;
        for (let idx = 0; idx < responseExamples.length; idx++) {
            // biome-ignore lint/style/noNonNullAssertion: allow
            const [responseId, responseExample] = responseExamples[idx]!;
            if (responseId == null || visitedResponseIdx.has(idx)) {
                continue;
            }
            if (requestId === responseId) {
                pairs.push({
                    id: requestId,
                    request: requestExample,
                    response: responseExample
                });
                if (responseId != null) {
                    visitedResponseIdx.add(idx);
                }
                paired = true;
            }
        }

        if (!paired && fallbackResponseExample != null) {
            pairs.push({
                id: requestId,
                request: requestExample,
                response: fallbackResponseExample
            });
        }
    }

    for (let idx = 0; idx < responseExamples.length; idx++) {
        if (visitedResponseIdx.has(idx)) {
            continue;
        }
        // biome-ignore lint/style/noNonNullAssertion: allow
        const [responseId, responseExample] = responseExamples[idx]!;

        const requestExample = requestExamples.find(([requestId]) => requestId == null)?.[1] ?? requestExamples[0]?.[1];

        if (requestExample != null) {
            pairs.push({
                id: responseId,
                request: requestExample,
                response: responseExample
            });
        }
    }

    return pairs;
}

type SchemaIdResponse =
    | {
          type: "present";
          schema: SchemaWithExample;
          // in a majority of cases, there should only be 1 or no example, and we
          examples: NamedFullExample[];
      }
    | { type: "unsupported" };

function getRequestSchema(request: RequestWithExample | null | undefined): SchemaIdResponse | undefined {
    if (request == null) {
        return undefined;
    }

    if (request.type === "multipart") {
        return {
            type: "present",
            schema: convertMultipartRequestToSchema(request),
            examples: []
        };
    }

    if (request.type === "json" || request.type === "formUrlEncoded") {
        return { type: "present", schema: request.schema, examples: request.fullExamples ?? [] };
    }

    return { type: "unsupported" };
}

function getResponseSchema(response: ResponseWithExample | null | undefined): SchemaIdResponse | undefined {
    if (response == null) {
        return undefined;
    }
    if (response.type !== "json" && response.type !== "streamingJson" && response.type !== "streamingSse") {
        return { type: "unsupported" };
    }
    return { type: "present", schema: response.schema, examples: response.fullExamples ?? [] };
}

export function isExamplePrimitive(example: FullExample): boolean {
    switch (example.type) {
        case "primitive":
        case "enum":
        case "literal":
            return true;
        case "unknown":
            return isExamplePrimitive(example.value);
        case "array":
        case "object":
        case "map":
            return false;
        case "oneOf":
            switch (example.value.type) {
                case "discriminated":
                    return false;
                case "undiscriminated":
                    return isExamplePrimitive(example.value.value);
                default:
                    return false;
            }
        case "null":
            return true;
        default:
            assertNever(example);
    }
}

export function getNameFromSchemaWithExample(schema: SchemaWithExample): string | undefined {
    switch (schema.type) {
        case "primitive":
        case "enum":
        case "literal":
        case "unknown":
        case "array":
        case "map":
        case "optional":
        case "nullable":
        case "reference":
            return undefined;
        case "object":
            return schema.fullExamples?.[0]?.name ?? undefined;
        case "oneOf":
            switch (schema.value.type) {
                case "discriminated":
                    return undefined;
                case "undiscriminated":
                    return undefined;
                default:
                    return undefined;
            }
        default:
            assertNever(schema);
    }
}
function convertMultipartRequestToSchema(request: RequestWithExample.Multipart): FernOpenapiIr.SchemaWithExample {
    return SchemaWithExample.object({
        properties: request.properties
            .map((property) => {
                if (property.schema.type === "file") {
                    // TODO: Handle file property examples in the Fern Definition
                    return null;
                }
                return {
                    key: property.key,
                    // Convert the schema to a schema with example to ensure that the example is generated
                    // This is a workaround for the fact that the example is not getting parsed upstream
                    // TODO: Fix the example parsing upstream
                    schema: convertSchemaToSchemaWithExample(property.schema.value),
                    audiences: [],
                    conflict: {},
                    generatedName: property.key,
                    nameOverride: undefined,
                    availability: undefined,
                    readonly: undefined,
                    writeonly: undefined,
                    inline: undefined
                };
            })
            .filter(isNonNullish),
        allOf: [],
        allOfPropertyConflicts: [],
        fullExamples: undefined,
        description: request.description,
        nameOverride: undefined,
        generatedName: "",
        title: undefined,
        namespace: undefined,
        groupName: undefined,
        additionalProperties: false,
        availability: undefined,
        source: request.source,
        inline: undefined
    });
}

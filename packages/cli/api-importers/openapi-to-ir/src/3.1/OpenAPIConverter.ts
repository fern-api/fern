import { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";

import { AuthScheme, FernIr, IntermediateRepresentation, Package } from "@fern-api/ir-sdk";
import { constructHttpPath, injectAutogeneratedExamples } from "@fern-api/ir-utils";
import { AbstractConverter, Converters, ErrorCollector, Extensions } from "@fern-api/v2-importer-commons";

import { OpenAPIConverterContext3_1 } from "./OpenAPIConverterContext3_1";
import { PathConverter } from "./paths/PathConverter";
import { WebhookConverter } from "./paths/operations/WebhookConverter";
import { SecuritySchemeConverter } from "./securitySchemes/SecuritySchemeConverter";
import { ServersConverter } from "./servers/ServersConverter";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace OpenAPIConverter {
    export interface Args extends AbstractConverter.Args {
        context: OpenAPIConverterContext3_1;
    }
}

export class OpenAPIConverter extends AbstractConverter<OpenAPIConverterContext3_1, IntermediateRepresentation> {
    private ir: BaseIntermediateRepresentation;

    constructor({ breadcrumbs, context }: OpenAPIConverter.Args) {
        super({ breadcrumbs });
        this.ir = {
            auth: {
                docs: undefined,
                requirement: FernIr.AuthSchemesRequirement.All,
                schemes: []
            },
            types: {},
            services: {},
            errors: {},
            webhookGroups: {},
            websocketChannels: undefined,
            headers: [],
            idempotencyHeaders: [],
            apiVersion: undefined,
            apiDisplayName: undefined,
            apiDocs: undefined,
            basePath: undefined,
            pathParameters: [],
            errorDiscriminationStrategy: FernIr.ErrorDiscriminationStrategy.statusCode(),
            variables: [],
            serviceTypeReferenceInfo: {
                sharedTypes: [],
                typesReferencedOnlyByService: {}
            },
            readmeConfig: undefined,
            sourceConfig: undefined,
            publishConfig: undefined,
            dynamic: undefined,
            environments: undefined,
            fdrApiDefinitionId: undefined,
            rootPackage: context.createPackage(),
            subpackages: {},
            sdkConfig: {
                hasFileDownloadEndpoints: false,
                hasPaginatedEndpoints: false,
                hasStreamingEndpoints: false,
                isAuthMandatory: true,
                platformHeaders: {
                    language: "",
                    sdkName: "",
                    sdkVersion: "",
                    userAgent: undefined
                }
            }
        };
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<IntermediateRepresentation> {
        context.spec = this.removeXFernIgnores({
            document: context.spec,
            context,
            errorCollector
        }) as OpenAPIV3_1.Document;

        await this.convertSecuritySchemes({ context, errorCollector });

        await this.convertSchemas({ context, errorCollector });

        await this.convertWebhooks({ context, errorCollector });

        const { endpointLevelServers } = await this.convertPaths({ context, errorCollector });

        this.convertServers({ context, errorCollector, endpointLevelServers });

        let ir = {
            ...this.ir,
            apiName: context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        ir = {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: { disabled: false } })
        };

        return ir;
    }

    private removeXFernIgnores({
        document,
        context,
        errorCollector,
        breadcrumbs = []
    }: {
        document: unknown;
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
        breadcrumbs?: string[];
    }): unknown {
        if (Array.isArray(document)) {
            return document
                .filter((item, index) => {
                    const shouldIgnore = new Extensions.FernIgnoreExtension({
                        breadcrumbs: [...breadcrumbs, String(index)],
                        operation: item
                    }).convert({ context, errorCollector });
                    return !shouldIgnore;
                })
                .map((item, index) =>
                    this.removeXFernIgnores({
                        document: item,
                        context,
                        errorCollector,
                        breadcrumbs: [...breadcrumbs, String(index)]
                    })
                );
        } else if (document != null && typeof document === "object") {
            return Object.fromEntries(
                Object.entries(document)
                    .filter(([key, value]) => {
                        const shouldIgnore = new Extensions.FernIgnoreExtension({
                            breadcrumbs: [...breadcrumbs, key],
                            operation: value
                        }).convert({ context, errorCollector });
                        return !shouldIgnore;
                    })
                    .map(([key, value]) => [
                        key,
                        this.removeXFernIgnores({
                            document: value,
                            context,
                            errorCollector,
                            breadcrumbs: [...breadcrumbs, key]
                        })
                    ])
            );
        }
        return document;
    }

    private async convertSecuritySchemes({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        const securitySchemes: AuthScheme[] = [];

        for (const [id, securityScheme] of Object.entries(context.spec.components?.securitySchemes ?? {})) {
            let resolvedSecurityScheme: OpenAPIV3_1.SecuritySchemeObject;
            if (context.isReferenceObject(securityScheme)) {
                const resolvedReference =
                    await context.resolveReference<OpenAPIV3_1.SecuritySchemeObject>(securityScheme);
                if (!resolvedReference.resolved) {
                    continue;
                }
                resolvedSecurityScheme = resolvedReference.value;
            } else {
                resolvedSecurityScheme = securityScheme;
            }

            const securitySchemeConverter = new SecuritySchemeConverter({
                breadcrumbs: ["components", "securitySchemes", id],
                securityScheme: resolvedSecurityScheme
            });
            const convertedScheme = securitySchemeConverter.convert({ context, errorCollector });
            if (convertedScheme != null) {
                securitySchemes.push(convertedScheme);
            }
        }

        if (securitySchemes.length > 0) {
            this.ir.auth = {
                requirement: "ANY",
                schemes: securitySchemes,
                docs: undefined
            };
        }
    }

    private convertServers({
        context,
        errorCollector,
        endpointLevelServers
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
        endpointLevelServers?: OpenAPIV3_1.ServerObject[];
    }): void {
        const serversConverter = new ServersConverter({
            breadcrumbs: ["servers"],
            servers: context.spec.servers,
            endpointLevelServers
        });
        const convertedServers = serversConverter.convert({ context, errorCollector });
        if (convertedServers != null) {
            this.ir.environments = convertedServers.value;
        }
    }

    private async convertSchemas({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        const group = this.getGroup({
            groupParts: [],
            namespace: context.namespace
        });

        const pkg = this.getOrCreatePackage({
            context,
            group,
        })

        for (const [id, schema] of Object.entries(context.spec.components?.schemas ?? {})) {
            const schemaConverter = new Converters.SchemaConverters.SchemaConverter({
                id,
                breadcrumbs: ["components", "schemas", id],
                schema
            });
            const convertedSchema = await schemaConverter.convert({ context, errorCollector });
            if (convertedSchema != null) {
                pkg.types.push(id);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedSchema.inlinedTypes,
                    [id]: convertedSchema.typeDeclaration
                };
            }
        }
    }

    private async convertWebhooks({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<void> {
        const groupToWebhooks: Record<string, string[]> = {};

        for (const [, webhookItem] of Object.entries(context.spec.webhooks ?? {})) {
            if (webhookItem == null || !("post" in webhookItem) || !webhookItem.post?.operationId) {
                continue;
            }
            const operationId = webhookItem.post.operationId;
            const webHookConverter = new WebhookConverter({
                breadcrumbs: ["webhooks", operationId],
                operation: webhookItem.post,
                method: OpenAPIV3.HttpMethods.POST,
                path: operationId
            });

            const convertedWebHook = await webHookConverter.convert({ context, errorCollector });

            if (convertedWebHook != null) {
                const group = convertedWebHook.group?.join(".") ?? operationId;
                if (groupToWebhooks[group] == null) {
                    groupToWebhooks[group] = [];
                }
                groupToWebhooks[group].push(operationId);

                if (this.ir.webhookGroups[group] == null) {
                    this.ir.webhookGroups[group] = [];
                }
                this.ir.webhookGroups[group].push(convertedWebHook.webhook);
                this.ir.types = {
                    ...this.ir.types,
                    ...convertedWebHook.inlinedTypes
                };
            }
        }
    }

    private async convertPaths({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<{ endpointLevelServers?: OpenAPIV3_1.ServerObject[] }> {
        const endpointLevelServers: OpenAPIV3_1.ServerObject[] = [];

        for (const [path, pathItem] of Object.entries(context.spec.paths ?? {})) {
            if (pathItem == null) {
                continue;
            }
            const pathConverter = new PathConverter({
                breadcrumbs: ["paths", path],
                pathItem,
                path,
                servers: context.spec.servers
            });
            const convertedPath = await pathConverter.convert({ context, errorCollector });
            if (convertedPath != null) {
                for (const endpoint of convertedPath.endpoints) {
                    const group = this.getGroup({
                        groupParts: endpoint.group,
                        namespace: context.namespace
                    });
                    const groupId = group.join(".");

                    const pkg = this.getOrCreatePackage({
                        context,
                        group: endpoint.group,
                    })

                    const allParts = [...group].map((part) => context.casingsGenerator.generateName(part));
                    const finalpart = allParts[allParts.length - 1];

                    if (pkg.service == null) {
                        pkg.service = `service_${groupId}`;
                    }

                    if (this.ir.services[pkg.service] == null) {
                        this.ir.services[pkg.service] = {
                            name: {
                                fernFilepath: {
                                    allParts,
                                    packagePath: allParts.slice(0, -1),
                                    file: finalpart
                                }
                            },
                            displayName: undefined,
                            basePath: constructHttpPath(""),
                            headers: [],
                            pathParameters: [],
                            availability: undefined,
                            endpoints: [],
                            transport: undefined,
                            encoding: undefined
                        }
                    }
                    this.ir.services[pkg.service]?.endpoints.push(endpoint.endpoint);

                    // Collect endpoint-level servers
                    if (endpoint.servers && endpoint.servers[0] != null) {
                        endpointLevelServers.push(endpoint.servers[0]);
                    }
                }

                for (const webhook of convertedPath.webhooks) {                    
                    const group = this.getGroup({
                        groupParts: webhook.group,
                        namespace: context.namespace
                    });
                    const groupId = group.join(".");

                    const pkg = this.getOrCreatePackage({
                        context,
                        group: webhook.group,
                    })

                    this.ir.webhookGroups[groupId] ??= []; 
                    this.ir.webhookGroups[groupId].push(webhook.webhook);

                    pkg.webhooks = groupId;
                }

                this.ir.types = {
                    ...this.ir.types,
                    ...convertedPath.inlinedTypes
                };
            }
        }
        return { endpointLevelServers };
    }

    /**
     * Gets an existing package or creates a new one if it doesn't exist
     * @param packageName The name of the package to get or create
     * @param context The converter context
     * @returns The package object
     */
    private getOrCreatePackage({
        context,
        group,
    }: {
        context: OpenAPIConverterContext3_1;
        group?: string[];
    }): Package {

        const groupParts = [];
        if (context.namespace != null) {
            groupParts.push(context.namespace);
        }
        groupParts.push(...(group ?? []));

        if (groupParts.length == 0) {
            return this.ir.rootPackage;
        }

        let pkg = this.ir.rootPackage
        for (let i = 0; i < groupParts.length; i++) {
            const name = groupParts[i];
            const subpackageId = groupParts.slice(0, i + 1).join(".");
            if (this.ir.subpackages[subpackageId] == null) {
                this.ir.subpackages[subpackageId] = {
                    name: context.casingsGenerator.generateName(name!),
                    ...context.createPackage({ name })
                };
            }
            const curr = this.ir.subpackages[subpackageId];
            if (!pkg.subpackages.includes(subpackageId)) {
                pkg.subpackages.push(subpackageId);
            }
            pkg = curr;
        }

        return pkg;
    }

    /**
     * Helper function to get a stringified group name from an array of group parts
     * @param groupParts Array of group name parts
     * @param namespace Optional namespace to prepend to the group
     * @returns A dot-separated string representation of the group
     */
    private getGroup({
        groupParts,
        namespace
    }: {
        groupParts: string[] | undefined;
        namespace?: string;
    }): string[] {
        const group = [];
        if (namespace != null) {
            group.push(namespace);
        }
        group.push(...(groupParts ?? []));
        return group;
    }
}

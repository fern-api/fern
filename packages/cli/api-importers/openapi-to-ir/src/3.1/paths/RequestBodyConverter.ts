import { OpenAPIV3_1 } from "openapi-types";

import {
    FileProperty,
    FileUploadRequestProperty,
    HttpRequestBody,
    ObjectProperty,
    TypeDeclaration
} from "@fern-api/ir-sdk";
import { AbstractConverter, Converters, ErrorCollector } from "@fern-api/v2-importer-commons";

import { OpenAPIConverter } from "../OpenAPIConverter";
import { OpenAPIConverterContext3_1 } from "../OpenAPIConverterContext3_1";

export declare namespace RequestBodyConverter {
    export interface Args extends OpenAPIConverter.Args {
        requestBody: OpenAPIV3_1.RequestBodyObject;
        group: string[];
        method: string;
    }

    export interface Output {
        requestBody: HttpRequestBody;
        inlinedTypes: Record<string, TypeDeclaration>;
        examples?: Record<string, OpenAPIV3_1.ExampleObject>;
    }
}

interface ConvertedRequestSchema extends Converters.SchemaConverters.SchemaOrReferenceConverter.Output {
    examples?: Record<string, OpenAPIV3_1.ExampleObject>;
}

export class RequestBodyConverter extends AbstractConverter<
    OpenAPIConverterContext3_1,
    RequestBodyConverter.Output | undefined
> {
    private readonly requestBody: OpenAPIV3_1.RequestBodyObject;
    private readonly group: string[];
    private readonly method: string;

    constructor({ context, breadcrumbs, requestBody, group, method }: RequestBodyConverter.Args) {
        super({ context, breadcrumbs });
        this.requestBody = requestBody;
        this.group = group;
        this.method = method;
    }

    public async convert({
        errorCollector
    }: {
        errorCollector: ErrorCollector;
    }): Promise<RequestBodyConverter.Output | undefined> {
        if (!this.requestBody.content) {
            return undefined;
        }

        const jsonContentTypes = Object.keys(this.requestBody.content).filter((type) => type.includes("json"));
        for (const contentType of jsonContentTypes) {
            const result = this.handleJsonOrFormContent({ contentType, errorCollector });
            if (result != null) {
                return result;
            }
        }

        const multipartContentTypes = Object.keys(this.requestBody.content).filter((type) =>
            type.includes("multipart")
        );
        for (const contentType of multipartContentTypes) {
            const schemaId = [...this.group, this.method, "Request"].join("_");
            const convertedSchema = await this.convertRequestSchemaForMediaType({
                schemaId,
                contentType,
                errorCollector
            });
            if (convertedSchema == null) {
                continue;
            }

            if (convertedSchema.schema?.shape.type === "object") {
                const requestBody = HttpRequestBody.fileUpload({
                    docs: this.requestBody.description,
                    name: this.context.casingsGenerator.generateName(schemaId),
                    properties: convertedSchema.schema?.shape.properties.map((property) => {
                        return this.convertRequestBodyProperty({ property, contentType });
                    }),
                    v2Examples: {
                        userSpecifiedExamples: await this.convertRequestBodyExamples({
                            contentType,
                            errorCollector
                        }),
                        autogeneratedExamples: {}
                    }
                });
                return {
                    requestBody,
                    inlinedTypes: this.context.removeSchemaFromInlinedTypes({
                        id: schemaId,
                        inlinedTypes: convertedSchema.inlinedTypes
                    }),
                    examples: convertedSchema.examples
                };
            }
        }

        const urlEncodedContentTypes = Object.keys(this.requestBody.content).filter((type) =>
            type.includes("urlencoded")
        );
        for (const contentType of urlEncodedContentTypes) {
            const result = this.handleJsonOrFormContent({ contentType, errorCollector });
            if (result != null) {
                return result;
            }
        }

        return undefined;
    }

    private async convertRequestSchemaForMediaType({
        schemaId,
        contentType,
        errorCollector
    }: {
        schemaId: string;
        contentType: string;
        errorCollector: ErrorCollector;
    }): Promise<ConvertedRequestSchema | undefined> {
        const mediaTypeObject = this.requestBody.content[contentType];
        if (mediaTypeObject == null || mediaTypeObject.schema == null) {
            return undefined;
        }

        const schemaOrReferenceConverter = new Converters.SchemaConverters.SchemaOrReferenceConverter({
            context: this.context,
            breadcrumbs: [...this.breadcrumbs, "schema"],
            schemaOrReference: mediaTypeObject.schema,
            schemaIdOverride: schemaId
        });
        const convertedSchema = await schemaOrReferenceConverter.convert({ errorCollector });
        if (convertedSchema == null) {
            return undefined;
        }

        const examples =
            mediaTypeObject.examples != null
                ? Object.fromEntries(
                      await Promise.all(
                          Object.entries(mediaTypeObject.examples).map(async ([key, example]) => [
                              key,
                              this.context.isReferenceObject(example)
                                  ? await this.context.resolveReference<OpenAPIV3_1.ExampleObject>(example)
                                  : example
                          ])
                      )
                  )
                : undefined;

        return { ...convertedSchema, examples };
    }

    private async handleJsonOrFormContent({
        contentType,
        errorCollector
    }: {
        contentType: string;
        errorCollector: ErrorCollector;
    }): Promise<RequestBodyConverter.Output | undefined> {
        const schemaId = [...this.group, this.method, "Request"].join("_");
        const convertedSchema = await this.convertRequestSchemaForMediaType({
            schemaId,
            contentType,
            errorCollector
        });
        if (convertedSchema == null) {
            return undefined;
        }

        if (convertedSchema.schema?.shape.type === "object") {
            const requestBody = HttpRequestBody.inlinedRequestBody({
                contentType,
                docs: this.requestBody.description,
                name: this.context.casingsGenerator.generateName(schemaId),
                extendedProperties: convertedSchema.schema?.shape.extendedProperties,
                extends: convertedSchema.schema?.shape.extends,
                properties: convertedSchema.schema?.shape.properties,
                extraProperties: convertedSchema.schema?.shape.extraProperties,
                v2Examples: {
                    userSpecifiedExamples: await this.convertRequestBodyExamples({
                        contentType,
                        errorCollector
                    }),
                    autogeneratedExamples: {}
                }
            });

            return {
                requestBody,
                inlinedTypes: this.context.removeSchemaFromInlinedTypes({
                    id: schemaId,
                    inlinedTypes: convertedSchema.inlinedTypes
                })
            };
        } else {
            const requestBody = HttpRequestBody.reference({
                contentType,
                docs: this.requestBody.description,
                requestBodyType: convertedSchema.type
            });

            return {
                requestBody,
                inlinedTypes: convertedSchema.inlinedTypes ?? {}
            };
        }
    }

    private convertRequestBodyProperty({ property, contentType }: { property: ObjectProperty; contentType: string }) {
        if (this.context.isFile(property.valueType)) {
            return FileUploadRequestProperty.file(
                FileProperty.file({
                    key: property.name,
                    isOptional: false,
                    contentType,
                    docs: property.docs
                })
            );
        }
        if (this.context.isOptional(property.valueType) && this.context.isFile(property.valueType.container.optional)) {
            return FileUploadRequestProperty.file(
                FileProperty.file({
                    key: property.name,
                    isOptional: true,
                    contentType,
                    docs: property.docs
                })
            );
        }
        if (this.context.isList(property.valueType) && this.context.isFile(property.valueType.container.list)) {
            return FileUploadRequestProperty.file(
                FileProperty.fileArray({
                    key: property.name,
                    isOptional: false,
                    contentType,
                    docs: property.docs
                })
            );
        }
        if (
            this.context.isList(property.valueType) &&
            this.context.isOptional(property.valueType.container.list) &&
            this.context.isFile(property.valueType.container.list.container.optional)
        ) {
            return FileUploadRequestProperty.file(
                FileProperty.fileArray({
                    key: property.name,
                    isOptional: false,
                    contentType,
                    docs: property.docs
                })
            );
        }
        if (
            this.context.isOptional(property.valueType) &&
            this.context.isList(property.valueType.container.optional) &&
            this.context.isFile(property.valueType.container.optional.container.list)
        ) {
            return FileUploadRequestProperty.file(
                FileProperty.fileArray({
                    key: property.name,
                    isOptional: true,
                    contentType,
                    docs: property.docs
                })
            );
        }
        return FileUploadRequestProperty.bodyProperty({
            ...property,
            contentType,
            style: undefined,
            name: property.name
        });
    }

    private async convertRequestBodyExamples({
        contentType,
        errorCollector
    }: {
        contentType: string;
        errorCollector: ErrorCollector;
    }): Promise<Record<string, unknown>> {
        let userSpecifiedExamples: Record<string, unknown> = {};
        const requestBodyExample = this.requestBody.content[contentType]?.example;
        const requestBodyExamples = this.requestBody.content[contentType]?.examples;

        for (const [key, example] of Object.entries(requestBodyExamples ?? {})) {
            if (this.context.isReferenceObject(example)) {
                const resolved = await this.context.resolveReference(example);
                if (resolved.resolved) {
                    if (this.context.isExampleWithValue(resolved.value)) {
                        userSpecifiedExamples[key] = resolved.value.value;
                    }
                }
            } else if (example != null) {
                userSpecifiedExamples[key] = example;
            }
        }

        const exampleName = this.context.generateUniqueName({
            prefix: `${[...this.group, this.method].join("_")}_example`,
            existingNames: Object.keys(userSpecifiedExamples)
        });

        userSpecifiedExamples =
            requestBodyExample != null
                ? {
                      [exampleName]: requestBodyExample,
                      ...userSpecifiedExamples
                  }
                : userSpecifiedExamples;

        return userSpecifiedExamples;
    }
}

import { OpenAPIV3_1 } from "openapi-types";

import { ExampleEndpointCall, HttpEndpoint } from "@fern-api/ir-sdk";
import { constructHttpPath } from "@fern-api/ir-utils";
import { ErrorCollector } from "@fern-api/v2-importer-commons";

import { FernStreamingExtension } from "../../../extensions/x-fern-streaming";
import { OpenAPIConverterContext3_1 } from "../../OpenAPIConverterContext3_1";
import { ServersConverter } from "../../servers/ServersConverter";
import { AbstractOperationConverter } from "./AbstractOperationConverter";

export declare namespace OperationConverter {
    export interface Args extends AbstractOperationConverter.Args {
        idempotent: boolean | undefined;
        servers?: OpenAPIV3_1.ServerObject[];
    }

    export interface Output extends AbstractOperationConverter.Output {
        endpoint: HttpEndpoint;
        servers?: OpenAPIV3_1.ServerObject[];
    }
}

export class OperationConverter extends AbstractOperationConverter {
    private readonly idempotent: boolean | undefined;
    private readonly servers?: OpenAPIV3_1.ServerObject[];
    private readonly streamingExtensionConverter: FernStreamingExtension;

    constructor({ breadcrumbs, operation, method, path, idempotent, servers }: OperationConverter.Args) {
        super({ breadcrumbs, operation, method, path });
        this.idempotent = idempotent;
        this.servers = servers;
        this.streamingExtensionConverter = new FernStreamingExtension({
            breadcrumbs: this.breadcrumbs,
            operation: this.operation
        });
    }

    public async convert({
        context,
        errorCollector
    }: {
        context: OpenAPIConverterContext3_1;
        errorCollector: ErrorCollector;
    }): Promise<OperationConverter.Output | undefined> {
        const httpMethod = this.convertHttpMethod();
        if (httpMethod == null) {
            return undefined;
        }

        const { group, method } =
            this.computeGroupNameAndLocationFromExtensions({ context, errorCollector }) ??
            this.computeGroupNameFromTagAndOperationId({ context, errorCollector });

        const streamingExtension = this.streamingExtensionConverter.convert({ context, errorCollector });

        const { headers, pathParameters, queryParameters } = await this.convertParameters({
            context,
            errorCollector,
            breadcrumbs: [...this.breadcrumbs, "parameters"]
        });

        const convertedRequestBody = await this.convertRequestBody({
            context,
            errorCollector,
            breadcrumbs: [...this.breadcrumbs, "requestBody"],
            group,
            method
        });
        const requestBody = convertedRequestBody != null ? convertedRequestBody.value : undefined;

        const response = await this.convertResponseBody({
            context,
            errorCollector,
            breadcrumbs: [...this.breadcrumbs, "responses"],
            group,
            method,
            streamingExtension
        });

        const server = this.operation.servers?.[0] ?? this.servers?.[0] ?? context.spec.servers?.[0];

        const endpointId = [];
        if (context.namespace != null) {
            endpointId.push(context.namespace);
        }
        endpointId.push(...group ?? []);
        endpointId.push(method);

        return {
            group,
            endpoint: {
                id: endpointId.join("."),
                displayName: this.operation.summary,
                method: httpMethod,
                name: context.casingsGenerator.generateName(method),
                baseUrl:
                    server != null ? ServersConverter.getServerName({ server, context, errorCollector }) : undefined,
                path: constructHttpPath(this.path),
                pathParameters,
                queryParameters,
                headers,
                requestBody,
                sdkRequest: undefined,
                response: response?.value,
                errors: [],
                auth: this.operation.security != null || context.spec.security != null,
                availability: await context.getAvailability({
                    node: this.operation,
                    breadcrumbs: this.breadcrumbs,
                    errorCollector
                }),
                docs: this.operation.description,
                userSpecifiedExamples: [],
                autogeneratedExamples: [],
                idempotent: this.idempotent ?? false,
                basePath: undefined,
                fullPath: constructHttpPath(this.path),
                allPathParameters: pathParameters,
                pagination: undefined,
                transport: undefined
            },
            inlinedTypes: this.inlinedTypes,
            servers: this.operation.servers
        };
    }

    private convertExamples({
        requestExamples,
        responseExamples,
        context
    }: {
        requestExamples?: Record<string, OpenAPIV3_1.ExampleObject>;
        responseExamples?: Record<string, OpenAPIV3_1.ExampleObject>;
        context: OpenAPIConverterContext3_1;
    }): ExampleEndpointCall[] {
        return [];
    }
}

import { HttpResponse, V2WebhookExample, Webhook, WebhookPayload } from "@fern-api/ir-sdk";

import { AbstractOperationConverter } from "./AbstractOperationConverter";

export declare namespace WebhookConverter {
    export interface Output extends AbstractOperationConverter.Output {
        webhook: Webhook;
        audiences: string[];
    }
}

export class WebhookConverter extends AbstractOperationConverter {
    constructor({ context, breadcrumbs, operation, method, path }: AbstractOperationConverter.Args) {
        super({ context, breadcrumbs, operation, method, path });
    }

    public convert(): WebhookConverter.Output | undefined {
        if (this.operation.requestBody == null) {
            this.context.errorCollector.collect({
                message: "Skipping webhook because no request body present",
                path: this.breadcrumbs
            });
            return undefined;
        }

        const httpMethod = this.convertHttpMethod();
        if (httpMethod == null) {
            return undefined;
        }

        if (httpMethod !== "POST" && httpMethod !== "GET") {
            this.context.errorCollector.collect({
                message: "Skipping webhook because non-POST or GET method",
                path: this.breadcrumbs
            });
            return undefined;
        }

        const { group, method } =
            this.computeGroupNameAndLocationFromExtensions() ?? this.computeGroupNameFromTagAndOperationId();

        const payloadBreadcrumbs = [...this.breadcrumbs, "Payload"];
        const { headers, queryParameters } = this.convertParameters({
            breadcrumbs: payloadBreadcrumbs
        });

        const convertedRequestBody = this.convertRequestBody({
            breadcrumbs: payloadBreadcrumbs,
            group,
            method,
            streamingExtension: undefined,
            queryParameters
        });
        if (convertedRequestBody == null) {
            return undefined;
        }
        const requestBody = convertedRequestBody[0]?.requestBody;
        if (requestBody == null) {
            return undefined;
        }

        let payload: WebhookPayload;
        if (requestBody.type === "inlinedRequestBody") {
            payload = WebhookPayload.inlinedPayload({
                name: requestBody.name,
                extends: requestBody.extends,
                properties: requestBody.properties
            });
        } else if (requestBody.type === "reference") {
            payload = WebhookPayload.reference({
                payloadType: requestBody.requestBodyType,
                docs: requestBody.docs
            });
        } else {
            return undefined;
        }

        const responses = this.convertWebhookResponses();

        return {
            audiences:
                this.context.getAudiences({
                    operation: this.operation,
                    breadcrumbs: this.breadcrumbs
                }) ?? [],
            group,
            webhook: {
                id: `${group?.join(".") ?? ""}.${method}`,
                name: this.context.casingsGenerator.generateName(method),
                displayName: this.operation.summary,
                method: httpMethod,
                headers,
                payload,
                responses: responses.length > 0 ? responses : undefined,
                examples: [],
                availability: this.context.getAvailability({
                    node: this.operation,
                    breadcrumbs: this.breadcrumbs
                }),
                docs: this.operation.description,
                v2Examples: {
                    autogeneratedExamples: this.getWebhookV2ExamplesFromRequestBodyV2Examples(
                        requestBody.v2Examples?.autogeneratedExamples ?? {}
                    ),
                    userSpecifiedExamples: this.getWebhookV2ExamplesFromRequestBodyV2Examples(
                        requestBody.v2Examples?.userSpecifiedExamples ?? {}
                    )
                }
            },
            inlinedTypes: this.inlinedTypes
        };
    }

    private convertWebhookResponses(): HttpResponse[] {
        const responses: HttpResponse[] = [];

        if (this.operation.responses == null) {
            return responses;
        }

        for (const [statusCode, response] of Object.entries(this.operation.responses)) {
            // Check for wildcard status codes like 4XX or 5XX
            const isWildcard = /^\d[Xx]{2}$/.test(statusCode);
            let statusCodeNum: number;

            if (isWildcard) {
                // Convert wildcard to base value (e.g., "4XX" -> 400, "5XX" -> 500)
                // We know statusCode[0] exists because the regex matched
                statusCodeNum = parseInt(statusCode.charAt(0)) * 100;
            } else {
                statusCodeNum = parseInt(statusCode);
                if (isNaN(statusCodeNum)) {
                    continue;
                }
            }

            this.context.resolveMaybeReference({
                schemaOrReference: response,
                breadcrumbs: [...this.breadcrumbs, "responses", statusCode]
            });

            responses.push({
                statusCode: statusCodeNum,
                isWildcardStatusCode: isWildcard ? true : undefined,
                body: undefined
            });
        }

        return responses;
    }

    private getWebhookV2ExamplesFromRequestBodyV2Examples(
        requestBodyV2Examples: Record<string, unknown>
    ): Record<string, V2WebhookExample> {
        return Object.fromEntries(
            Object.entries(requestBodyV2Examples).map(([key, value]) => {
                return [
                    key,
                    {
                        name: key,
                        payload: value
                    }
                ];
            })
        );
    }
}

import { OpenAPIV3_1 } from "openapi-types";

import {
    ContainerType,
    HttpHeader,
    PathParameter,
    PrimitiveTypeV2,
    QueryParameter,
    TypeDeclaration,
    TypeId,
    TypeReference
} from "@fern-api/ir-sdk";

import { AbstractConverter, AbstractConverterContext, ErrorCollector } from "../..";
import { ExampleConverter } from "../ExampleConverter";

export declare namespace AbstractParameterConverter {
    export interface Args<TParameter extends OpenAPIV3_1.ParameterObject> extends AbstractConverter.Args {
        parameter: TParameter;
    }

    export interface BaseParameterOutput {
        inlinedTypes?: Record<TypeId, TypeDeclaration>;
    }

    export interface QueryParameterOutput extends BaseParameterOutput {
        type: "query";
        parameter: QueryParameter;
    }

    export interface HeaderParameterOutput extends BaseParameterOutput {
        type: "header";
        parameter: HttpHeader;
    }

    export interface PathParameterOutput extends BaseParameterOutput {
        type: "path";
        parameter: PathParameter;
    }

    export type Output = QueryParameterOutput | HeaderParameterOutput | PathParameterOutput;
}

export abstract class AbstractParameterConverter<
    TParameter extends OpenAPIV3_1.ParameterObject
> extends AbstractConverter<AbstractConverterContext<object>, AbstractParameterConverter.Output> {
    public static STRING = TypeReference.primitive({
        v1: "STRING",
        v2: PrimitiveTypeV2.string({
            default: undefined,
            validation: undefined
        })
    });

    public static OPTIONAL_STRING = TypeReference.container(ContainerType.optional(AbstractParameterConverter.STRING));

    protected readonly parameter: TParameter;

    constructor({ breadcrumbs, parameter }: AbstractParameterConverter.Args<TParameter>) {
        super({ breadcrumbs });
        this.parameter = parameter;
    }

    public abstract convert({
        context,
        errorCollector
    }: {
        context: AbstractConverterContext<object>;
        errorCollector: ErrorCollector;
    }): Promise<AbstractParameterConverter.Output | undefined>;

    protected async convertToOutput({
        typeReference,
        inlinedTypes,
        context,
        errorCollector
    }: {
        typeReference: TypeReference | undefined;
        inlinedTypes: Record<TypeId, TypeDeclaration> | undefined;
        context: AbstractConverterContext<object>;
        errorCollector: ErrorCollector;
    }): Promise<AbstractParameterConverter.Output | undefined> {
        const availability = await context.getAvailability({
            node: this.parameter,
            breadcrumbs: this.breadcrumbs,
            errorCollector
        });

        switch (this.parameter.in) {
            case "query":
                return {
                    type: "query",
                    parameter: {
                        name: context.casingsGenerator.generateNameAndWireValue({
                            name: this.parameter.name,
                            wireValue: this.parameter.name
                        }),
                        docs: this.parameter.description,
                        valueType: typeReference ?? AbstractParameterConverter.OPTIONAL_STRING,
                        allowMultiple: this.parameter.explode ?? false,
                        v2Examples: {
                            userSpecifiedExamples: await this.convertParameterExamples({ context, errorCollector }),
                            autogeneratedExamples: {}
                        },
                        availability
                    },
                    inlinedTypes
                };
            case "header":
                return {
                    type: "header",
                    parameter: {
                        name: context.casingsGenerator.generateNameAndWireValue({
                            name: this.parameter.name,
                            wireValue: this.parameter.name
                        }),
                        docs: this.parameter.description,
                        valueType: typeReference ?? AbstractParameterConverter.OPTIONAL_STRING,
                        env: undefined,
                        v2Examples: {
                            userSpecifiedExamples: await this.convertParameterExamples({ context, errorCollector }),
                            autogeneratedExamples: {}
                        },
                        availability
                    },
                    inlinedTypes
                };
            case "path":
                return {
                    type: "path",
                    parameter: {
                        name: context.casingsGenerator.generateName(this.parameter.name),
                        docs: this.parameter.description,
                        valueType: typeReference ?? AbstractParameterConverter.STRING,
                        location: "ENDPOINT",
                        variable: undefined,
                        v2Examples: {
                            userSpecifiedExamples: await this.convertParameterExamples({ context, errorCollector }),
                            autogeneratedExamples: {}
                        }
                    },
                    inlinedTypes
                };
            default:
                return undefined;
        }
    }

    protected async convertParameterExamples({
        context,
        errorCollector
    }: {
        context: AbstractConverterContext<object>;
        errorCollector: ErrorCollector;
    }): Promise<Record<string, unknown>> {
        let userSpecifiedExamples: Record<string, unknown> = {};
        const parameterExample = this.parameter.example;
        const parameterExamples = this.parameter.examples;

        for (const [key, example] of Object.entries(parameterExamples ?? {})) {
            const resolvedExample = await context.resolveValuedExample(example);
            if (resolvedExample != null) {
                if (this.parameter.schema != null) {
                    userSpecifiedExamples[key] = await this.generateOrValidateExample({
                        shouldCollectErrors: true,
                        schema: this.parameter.schema,
                        example: resolvedExample,
                        context,
                        errorCollector
                    });
                } else {
                    userSpecifiedExamples[key] = resolvedExample;
                }
            }
        }
        const parameterExampleName = context.generateUniqueName({
            prefix: `${this.parameter.name}_example`,
            existingNames: Object.keys(userSpecifiedExamples)
        });

        userSpecifiedExamples =
            parameterExample != null
                ? {
                      [parameterExampleName]: parameterExample,
                      ...userSpecifiedExamples
                  }
                : userSpecifiedExamples;
        return userSpecifiedExamples;
    }

    private async generateOrValidateExample({
        schema,
        shouldCollectErrors,
        example,
        context,
        errorCollector
    }: {
        schema: OpenAPIV3_1.SchemaObject | OpenAPIV3_1.ReferenceObject;
        shouldCollectErrors: boolean;
        example: unknown;
        context: AbstractConverterContext<object>;
        errorCollector: ErrorCollector;
    }): Promise<unknown> {
        const exampleConverter = new ExampleConverter({
            breadcrumbs: this.breadcrumbs,
            schema,
            example
        });
        const { validExample: convertedExample, errors } = await exampleConverter.convert({ context, errorCollector });
        if (shouldCollectErrors) {
            errors.forEach((error) => {
                errorCollector.collect({
                    message: error.message,
                    path: error.path
                });
            });
        }
        return convertedExample;
    }
}

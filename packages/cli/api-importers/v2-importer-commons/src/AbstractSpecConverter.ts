import { camelCase } from "lodash-es";

import { Audiences } from "@fern-api/configuration";
import { FernIr, IntermediateRepresentation, Package } from "@fern-api/ir-sdk";
import {
    IrGraph,
    constructHttpPath,
    injectAutogeneratedExamples,
    injectAutogeneratedV2Examples
} from "@fern-api/ir-utils";

import { AbstractConverter } from "./AbstractConverter";
import { AbstractConverterContext } from "./AbstractConverterContext";
import { FernIgnoreExtension } from "./extensions";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace AbstractSpecConverter {
    export interface Args<Context> extends AbstractConverter.Args<Context> {
        audiences: Audiences;
    }

    export type AbstractArgs = Args<AbstractConverterContext<object>>;
}

/**
 * Top level spec converter interface.
 *
 * @template Context The converter context
 * @template Output The converted output type
 */
export abstract class AbstractSpecConverter<
    Context extends AbstractConverterContext<object>,
    Output
> extends AbstractConverter<Context, Output> {
    protected ir: BaseIntermediateRepresentation;
    protected audiences: Audiences;
    protected irGraph: IrGraph;

    constructor({ breadcrumbs = [], context, audiences }: AbstractSpecConverter.Args<Context>) {
        super({ breadcrumbs, context });
        this.audiences = audiences;
        this.irGraph = new IrGraph(audiences);
        this.ir = {
            auth: {
                docs: undefined,
                requirement: FernIr.AuthSchemesRequirement.All,
                schemes: []
            },
            selfHosted: false,
            types: {},
            services: {},
            errors: {},
            webhookGroups: {},
            websocketChannels: undefined,
            headers: [],
            idempotencyHeaders: [],
            apiVersion: undefined,
            apiDisplayName: undefined,
            apiDocs: undefined,
            basePath: undefined,
            pathParameters: [],
            errorDiscriminationStrategy: FernIr.ErrorDiscriminationStrategy.statusCode(),
            variables: [],
            serviceTypeReferenceInfo: {
                sharedTypes: [],
                typesReferencedOnlyByService: {}
            },
            readmeConfig: undefined,
            sourceConfig: undefined,
            publishConfig: undefined,
            dynamic: undefined,
            environments: undefined,
            fdrApiDefinitionId: undefined,
            rootPackage: this.createPackage(),
            subpackages: {},
            sdkConfig: {
                hasFileDownloadEndpoints: false,
                hasPaginatedEndpoints: false,
                hasStreamingEndpoints: false,
                isAuthMandatory: true,
                platformHeaders: {
                    language: "",
                    sdkName: "",
                    sdkVersion: "",
                    userAgent: undefined
                }
            }
        };
    }

    protected finalizeIr(): IntermediateRepresentation {
        const ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            }
        };

        const filteredEndpoints = this.irGraph.getFilteredEndpoints();
        this.filterIrForAudiences(filteredEndpoints);

        return {
            ...ir,
            ...injectAutogeneratedExamples({ ir, exampleGeneration: this.context.exampleGenerationArgs }),
            ...injectAutogeneratedV2Examples({ ir, exampleGeneration: this.context.exampleGenerationArgs })
        };
    }

    protected addEndpointToIr({
        endpoint,
        audiences,
        endpointGroup,
        serviceName
    }: {
        endpoint: FernIr.HttpEndpoint;
        audiences: string[];
        endpointGroup?: string[];
        serviceName?: string;
    }): void {
        const group = this.context.getGroup({
            groupParts: endpointGroup,
            namespace: this.context.namespace
        });
        const pkg = this.getOrCreatePackage({ group: endpointGroup });

        const allParts = [...group].map((part) => this.context.casingsGenerator.generateName(part));
        const finalpart = allParts[allParts.length - 1];

        if (pkg.service == null) {
            pkg.service = serviceName ?? `service_${group.join(".")}`;
        }

        if (this.ir.services[pkg.service] == null) {
            this.ir.services[pkg.service] = this.createNewService({ allParts, finalpart });
        }
        this.ir.services[pkg.service]?.endpoints.push(endpoint);

        const service = this.ir.services[pkg.service];
        if (service != null) {
            this.irGraph.addEndpoint(service, endpoint);
            // TODO: This method should be "markEndpointsForAudience"
            this.irGraph.markEndpointForAudience(service.name, [endpoint], audiences);
        }
    }

    protected addWebsocketChannelToIr({
        websocketChannel,
        channelPath,
        group
    }: {
        websocketChannel: FernIr.WebSocketChannel;
        channelPath: string;
        group?: string[];
    }): void {
        const channelName = group ? group.join(".") : `channel_${camelCase(channelPath)}`;
        this.ir.websocketChannels = {
            ...this.ir.websocketChannels,
            [channelName]: websocketChannel
        };
        if (channelName !== "") {
            const channelPath = channelName.replace("channel_", "");
            const channelSubpackageName = channelName.replace("channel_", "subpackage_");
            if (this.ir.subpackages[channelSubpackageName] == null) {
                this.ir.subpackages[channelSubpackageName] = {
                    name: this.context.casingsGenerator.generateName(channelPath),
                    ...this.createPackage({ name: channelPath })
                };
            }
            this.ir.subpackages[channelSubpackageName].websocket = channelName;
            this.ir.rootPackage.subpackages.push(channelSubpackageName);
        } else {
            this.ir.rootPackage.websocket = "";
        }
    }

    protected addWebhookGroupsToIr({
        webhook,
        operationId,
        group
    }: {
        webhook: FernIr.Webhook;
        operationId: string;
        group?: string[];
    }): void {
        const groupName = group?.join(".") ?? operationId;
        const pkg = this.getOrCreatePackage({
            group
        });

        if (this.ir.webhookGroups[groupName] == null) {
            this.ir.webhookGroups[groupName] = [];
        }
        this.ir.webhookGroups[groupName].push(webhook);
        pkg.webhooks = groupName;
    }

    protected addAuthToIR(auth: FernIr.ApiAuth): void {
        this.ir.auth = auth;
    }

    protected addErrorsToIr(errors: Record<FernIr.ErrorId, FernIr.ErrorDeclaration>): void {
        this.ir.errors = errors;
        for (const error of Object.values(errors)) {
            this.irGraph.addError(error);
        }
    }

    protected addEnvironmentsToIr(environments: FernIr.EnvironmentsConfig | undefined): void {
        this.ir.environments = environments;
    }

    protected addTypeToRootPackage(typeId: FernIr.TypeId): void {
        this.ir.rootPackage.types.push(typeId);
    }

    protected addTypeToPackage(typeId: FernIr.TypeId, group?: string[]): void {
        const groupPackage = this.getOrCreatePackage({ group });
        groupPackage.types.push(typeId);
    }

    protected addConvertedTypeToIr({
        inlinedTypes,
        typeId,
        typeDeclaration
    }: {
        inlinedTypes: Record<FernIr.TypeId, FernIr.TypeDeclaration>;
        typeId: FernIr.TypeId;
        typeDeclaration: FernIr.TypeDeclaration;
    }): void {
        this.addTypesToIr({
            ...inlinedTypes,
            [typeId]: typeDeclaration
        });
    }

    protected addTypesToIr(types: Record<FernIr.TypeId, FernIr.TypeDeclaration>): void {
        for (const [typeId, type] of Object.entries(types)) {
            this.addTypeToIrGraph(typeId, type);
        }
    }

    protected addTypeToIrGraph(typeId: FernIr.TypeId, type: FernIr.TypeDeclaration): void {
        this.ir.types = {
            ...this.ir.types,
            [typeId]: type
        };
    }

    private filterIrForAudiences(filteredEndpoints: Set<FernIr.EndpointId>): void {
        for (const service of Object.values(this.ir.services)) {
            const updatedEndpoints: FernIr.HttpEndpoint[] = [];
            for (const endpoint of service.endpoints) {
                if (filteredEndpoints.has(endpoint.id)) {
                    updatedEndpoints.push(endpoint);
                }
            }
            service.endpoints = updatedEndpoints;
        }
    }

    protected updateEndpointsWithDefaultUrl(defaultUrl: string | undefined): void {
        if (defaultUrl == null) {
            return;
        }
        for (const service of Object.values(this.ir.services)) {
            for (const endpoint of service.endpoints) {
                if (endpoint.baseUrl == null) {
                    endpoint.baseUrl = defaultUrl;
                }
            }
        }
    }

    protected async resolveAllExternalRefs({ spec }: { spec: unknown }): Promise<unknown> {
        const queue = [spec];

        while (queue.length > 0) {
            const current = queue.shift();
            if (current == null) {
                continue;
            }

            if (Array.isArray(current)) {
                await this.resolveExternalRefsInArray(current, queue);
            } else if (typeof current === "object") {
                await this.resolveExternalRefsInObject(current as Record<string, unknown>, queue);
            }
        }
        return spec;
    }

    private async resolveExternalRefsInArray(arr: unknown[], queue: unknown[]): Promise<void> {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = await this.resolveReferenceChain(arr[i], queue);
        }
    }

    private async resolveExternalRefsInObject(obj: Record<string, unknown>, queue: unknown[]): Promise<void> {
        for (const [key, value] of Object.entries(obj)) {
            obj[key] = await this.resolveReferenceChain(value, queue);
        }
    }

    private async resolveReferenceChain(value: unknown, queue: unknown[]): Promise<unknown | null> {
        let resolvedRefVal = value;
        if (!this.context.isReferenceObject(resolvedRefVal)) {
            queue.push(resolvedRefVal);
            return value;
        }

        while (this.context.isReferenceObject(resolvedRefVal)) {
            const isExternalRef = this.context.isExternalReference(resolvedRefVal.$ref);
            const nextResolvedRef = await this.context.resolveMaybeExternalReference({ $ref: resolvedRefVal.$ref });
            if (nextResolvedRef.resolved) {
                resolvedRefVal = nextResolvedRef.value;
                if (isExternalRef) {
                    return resolvedRefVal;
                }
            } else {
                return value;
            }
        }
        return value;
    }

    protected removeXFernIgnores({
        document,
        breadcrumbs = []
    }: {
        document: unknown;
        breadcrumbs?: string[];
    }): unknown {
        if (Array.isArray(document)) {
            return document
                .filter((item, index) => {
                    const shouldIgnore = new FernIgnoreExtension({
                        breadcrumbs: [...breadcrumbs, String(index)],
                        operation: item,
                        context: this.context
                    }).convert();
                    return !shouldIgnore;
                })
                .map((item, index) =>
                    this.removeXFernIgnores({
                        document: item,
                        breadcrumbs: [...breadcrumbs, String(index)]
                    })
                );
        } else if (document != null && typeof document === "object") {
            return Object.fromEntries(
                Object.entries(document)
                    .filter(([key, value]) => {
                        const shouldIgnore = new FernIgnoreExtension({
                            breadcrumbs: [...breadcrumbs, key],
                            operation: value,
                            context: this.context
                        }).convert();
                        return !shouldIgnore;
                    })
                    .map(([key, value]) => [
                        key,
                        this.removeXFernIgnores({
                            document: value,
                            breadcrumbs: [...breadcrumbs, key]
                        })
                    ])
            );
        }
        return document;
    }

    protected createNewService({
        allParts,
        finalpart
    }: {
        allParts: FernIr.Name[];
        finalpart: FernIr.Name | undefined;
    }): FernIr.HttpService {
        return {
            name: {
                fernFilepath: {
                    allParts,
                    packagePath: allParts.slice(0, -1),
                    file: finalpart
                }
            },
            displayName: undefined,
            basePath: constructHttpPath(""),
            headers: [],
            pathParameters: [],
            availability: undefined,
            endpoints: [],
            transport: undefined,
            encoding: undefined
        };
    }

    /**
     * Creates a Package object with default values
     * @param args Optional object containing package name
     * @returns Package object with default values
     */
    public createPackage(args: { name?: string } = {}): Package {
        return {
            fernFilepath: this.context.createFernFilepath(args),
            service: undefined,
            types: [],
            errors: [],
            subpackages: [],
            docs: undefined,
            webhooks: undefined,
            websocket: undefined,
            hasEndpointsInTree: false,
            navigationConfig: undefined
        };
    }

    /**
     * Gets an existing package or creates a new one if it doesn't exist
     * @param packageName The name of the package to get or create
     * @param context The converter context
     * @returns The package object
     */
    protected getOrCreatePackage({ group }: { group?: string[] }): Package {
        const groupParts = [];
        if (this.context.namespace != null) {
            groupParts.push(this.context.namespace);
        }
        groupParts.push(...(group ?? []));

        if (groupParts.length == 0) {
            return this.ir.rootPackage;
        }

        let pkg = this.ir.rootPackage;
        for (let i = 0; i < groupParts.length; i++) {
            const name = camelCase(groupParts[i]);
            const camelCasedGroupParts = groupParts.slice(0, i + 1).map((part) => camelCase(part));
            const subpackageId = `subpackage_${camelCasedGroupParts.join(".")}`;
            if (this.ir.subpackages[subpackageId] == null) {
                this.ir.subpackages[subpackageId] = {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    name: this.context.casingsGenerator.generateName(name!),
                    ...this.createPackage({ name })
                };
            }
            const curr = this.ir.subpackages[subpackageId];
            if (!pkg.subpackages.includes(subpackageId)) {
                pkg.subpackages.push(subpackageId);
            }
            pkg = curr;
        }

        return pkg;
    }
}

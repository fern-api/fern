import { Audiences } from "@fern-api/configuration";
import { FernIr, IntermediateRepresentation, Package } from "@fern-api/ir-sdk";
import {
    constructHttpPath,
    IrGraph,
    injectAutogeneratedExamples,
    injectAutogeneratedV2Examples
} from "@fern-api/ir-utils";
import { camelCase } from "lodash-es";
import { OpenAPIV3_1 } from "openapi-types";

import { AbstractConverter } from "./AbstractConverter";
import { AbstractConverterContext } from "./AbstractConverterContext";
import { SchemaConverter } from "./converters/schema/SchemaConverter";
import { FernIgnoreExtension } from "./extensions";

export type BaseIntermediateRepresentation = Omit<IntermediateRepresentation, "apiName" | "constants">;

export declare namespace AbstractSpecConverter {
    export interface Args<Context> extends AbstractConverter.Args<Context> {
        audiences: Audiences;
    }

    export type AbstractArgs = Args<AbstractConverterContext<object>>;
}

/**
 * Top level spec converter interface.
 *
 * @template Context The converter context
 * @template Output The converted output type
 */
export abstract class AbstractSpecConverter<
    Context extends AbstractConverterContext<object>,
    Output
> extends AbstractConverter<Context, Output> {
    protected ir: BaseIntermediateRepresentation;
    protected audiences: Audiences;
    protected irGraph: IrGraph;

    constructor({ breadcrumbs = [], context, audiences }: AbstractSpecConverter.Args<Context>) {
        super({ breadcrumbs, context });
        this.audiences = audiences;
        this.irGraph = new IrGraph(audiences);
        this.ir = {
            auth: {
                docs: undefined,
                requirement: FernIr.AuthSchemesRequirement.All,
                schemes: []
            },
            selfHosted: false,
            types: {},
            services: {},
            errors: {},
            webhookGroups: {},
            websocketChannels: undefined,
            headers: [],
            idempotencyHeaders: [],
            apiVersion: undefined,
            apiDisplayName: undefined,
            apiDocs: undefined,
            basePath: undefined,
            pathParameters: [],
            errorDiscriminationStrategy: FernIr.ErrorDiscriminationStrategy.statusCode(),
            variables: [],
            serviceTypeReferenceInfo: {
                sharedTypes: [],
                typesReferencedOnlyByService: {}
            },
            readmeConfig: undefined,
            sourceConfig: undefined,
            publishConfig: undefined,
            dynamic: undefined,
            environments: undefined,
            fdrApiDefinitionId: undefined,
            rootPackage: this.createPackage(),
            subpackages: {},
            sdkConfig: {
                hasFileDownloadEndpoints: false,
                hasPaginatedEndpoints: false,
                hasStreamingEndpoints: false,
                isAuthMandatory: true,
                platformHeaders: {
                    language: "",
                    sdkName: "",
                    sdkVersion: "",
                    userAgent: undefined
                }
            },
            audiences: undefined,
            generationMetadata: undefined,
            apiPlayground: undefined
        };
    }

    protected removeXFernIgnores({
        document,
        breadcrumbs = []
    }: {
        document: unknown;
        breadcrumbs?: string[];
    }): unknown {
        if (Array.isArray(document)) {
            return document
                .filter((item, index) => {
                    const shouldIgnore = new FernIgnoreExtension({
                        breadcrumbs: [...breadcrumbs, String(index)],
                        operation: item,
                        context: this.context
                    }).convert();
                    return !shouldIgnore;
                })
                .map((item, index) =>
                    this.removeXFernIgnores({
                        document: item,
                        breadcrumbs: [...breadcrumbs, String(index)]
                    })
                );
        } else if (document != null && typeof document === "object") {
            return Object.fromEntries(
                Object.entries(document)
                    .filter(([key, value]) => {
                        const shouldIgnore = new FernIgnoreExtension({
                            breadcrumbs: [...breadcrumbs, key],
                            operation: value,
                            context: this.context
                        }).convert();
                        return !shouldIgnore;
                    })
                    .map(([key, value]) => [
                        key,
                        this.removeXFernIgnores({
                            document: value,
                            breadcrumbs: [...breadcrumbs, key]
                        })
                    ])
            );
        }
        return document;
    }

    protected finalizeIr(): IntermediateRepresentation {
        let ir = {
            ...this.ir,
            apiName: this.context.casingsGenerator.generateName(this.ir.apiDisplayName ?? ""),
            constants: {
                errorInstanceIdKey: this.context.casingsGenerator.generateNameAndWireValue({
                    wireValue: "errorInstanceId",
                    name: "errorInstanceId"
                })
            },
            audiences: this.audiences.type === "select" ? this.audiences.audiences : undefined
        };

        if (!this.irGraph.hasNoAudiences()) {
            ir = this.filterIrForAudiences(ir);
        }

        const exampleGeneration = this.context.exampleGenerationArgs;
        const irWithV2Examples = injectAutogeneratedV2Examples({ ir, exampleGeneration });

        if (this.context.generateV1Examples) {
            const irWithV1Examples = injectAutogeneratedExamples({ ir, exampleGeneration });
            return {
                ...ir,
                ...irWithV1Examples,
                ...irWithV2Examples
            };
        }

        return {
            ...ir,
            ...irWithV2Examples
        };
    }

    private filterIrForAudiences(ir: IntermediateRepresentation): IntermediateRepresentation {
        // TODO: Use IrGraph.build() in the long run to filter the IR
        const filteredEndpoints = this.irGraph.getFilteredEndpoints();
        const filteredChannels = this.irGraph.getFilteredChannels();
        const filteredWebhooks = this.irGraph.getFilteredWebhooks();

        for (const service of Object.values(ir.services)) {
            const updatedEndpoints: FernIr.HttpEndpoint[] = [];
            for (const endpoint of service.endpoints) {
                if (filteredEndpoints.has(endpoint.id)) {
                    updatedEndpoints.push(endpoint);
                }
            }
            service.endpoints = updatedEndpoints;
        }
        ir.websocketChannels = Object.fromEntries(
            Object.entries(ir.websocketChannels ?? {}).filter(([channelId]) => filteredChannels.has(channelId))
        );
        ir.webhookGroups = Object.fromEntries(
            Object.entries(ir.webhookGroups).filter(([webhookId]) => filteredWebhooks.has(webhookId))
        );
        return ir;
    }

    protected async resolveAllExternalRefs({ spec }: { spec: unknown }): Promise<unknown> {
        const queue = [spec];

        while (queue.length > 0) {
            const current = queue.shift();
            if (current == null) {
                continue;
            }

            if (Array.isArray(current)) {
                await this.resolveExternalRefsInArray(current, queue);
            } else if (typeof current === "object") {
                await this.resolveExternalRefsInObject(current as Record<string, unknown>, queue);
            }
        }
        return spec;
    }

    private async resolveExternalRefsInArray(arr: unknown[], queue: unknown[]): Promise<void> {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = await this.resolveReferenceChain(arr[i], queue);
        }
    }

    private async resolveExternalRefsInObject(obj: Record<string, unknown>, queue: unknown[]): Promise<void> {
        for (const [key, value] of Object.entries(obj)) {
            obj[key] = await this.resolveReferenceChain(value, queue);
        }
    }

    private async resolveReferenceChain(value: unknown, queue: unknown[]): Promise<unknown | null> {
        let resolvedRefVal = value;
        if (!this.context.isReferenceObject(resolvedRefVal)) {
            queue.push(resolvedRefVal);
            return value;
        }

        while (this.context.isReferenceObject(resolvedRefVal)) {
            const isExternalRef = this.context.isExternalReference(resolvedRefVal.$ref);
            const nextResolvedRef = await this.context.resolveMaybeExternalReference(resolvedRefVal);
            if (nextResolvedRef.resolved) {
                resolvedRefVal = nextResolvedRef.value;
                if (isExternalRef) {
                    return resolvedRefVal;
                }
            } else {
                return value;
            }
        }
        return value;
    }

    protected shouldAddServerToCollectedServers({
        server,
        currentServers,
        specType = "openapi"
    }: {
        server: OpenAPIV3_1.ServerObject;
        currentServers: OpenAPIV3_1.ServerObject[];
        specType?: "openapi" | "openrpc";
    }): boolean {
        if (specType === "openapi") {
            return !currentServers.some(
                (s) =>
                    s.url === server.url &&
                    "x-fern-server-name" in s &&
                    "x-fern-server-name" in server &&
                    s["x-fern-server-name"] === server["x-fern-server-name"]
            );
        } else {
            return !currentServers.some(
                (s) => s.url === server.url && "name" in s && "name" in server && s["name"] === server["name"]
            );
        }
    }

    protected addEndpointToIr({
        endpoint,
        audiences,
        endpointGroup,
        endpointGroupDisplayName,
        serviceName
    }: {
        endpoint: FernIr.HttpEndpoint;
        audiences: string[];
        endpointGroup?: string[];
        endpointGroupDisplayName?: string;
        serviceName?: string;
    }): void {
        const group = this.context.getGroup({
            groupParts: endpointGroup,
            namespace: this.context.namespace
        });
        const pkg = this.getOrCreatePackage({ group: endpointGroup });

        const allParts = [...group].map((part) => this.context.casingsGenerator.generateName(part));
        const finalpart = allParts[allParts.length - 1];

        if (pkg.service == null) {
            pkg.service = serviceName ?? `service_${group.map((part) => camelCase(part)).join("/")}`;
        }

        if (this.ir.services[pkg.service] == null) {
            this.ir.services[pkg.service] = this.createNewService({ allParts, finalpart, endpointGroupDisplayName });
        }
        this.ir.services[pkg.service]?.endpoints.push(endpoint);

        const service = this.ir.services[pkg.service];
        if (service != null) {
            this.irGraph.addEndpoint(service, endpoint);
            // TODO: This method should be "markEndpointsForAudience"
            this.irGraph.markEndpointForAudience(service.name, [endpoint], audiences);
        }
    }

    protected addWebhookToIr({
        webhook,
        operationId,
        audiences,
        group
    }: {
        webhook: FernIr.Webhook;
        operationId: string;
        audiences: string[];
        group?: string[];
    }): void {
        const groupName = group?.join(".") ?? operationId;
        const pkg = this.getOrCreatePackage({
            group
        });

        if (this.ir.webhookGroups[groupName] == null) {
            this.ir.webhookGroups[groupName] = [];
        }
        this.ir.webhookGroups[groupName].push(webhook);
        pkg.webhooks = groupName;
        const emptyFile = this.context.createFernFilepath();
        this.irGraph.addWebhook(emptyFile, webhook);
        if (audiences != null) {
            this.irGraph.markWebhookForAudiences(emptyFile, webhook, audiences);
        }
    }

    protected addWebsocketChannelToIr({
        websocketChannel,
        channelPath,
        audiences,
        websocketGroup
    }: {
        websocketChannel: FernIr.WebSocketChannel;
        channelPath: string;
        audiences: string[];
        websocketGroup?: string[];
    }): void {
        const channelNameOverride = camelCase(websocketGroup?.join("."));
        const defaultChannelName = camelCase(channelPath);
        const channelPrefix = this.context.namespace ? `${camelCase(this.context.namespace)}/` : "";
        const channelName = channelNameOverride
            ? `channel_${channelPrefix}${channelNameOverride}`
            : `channel_${channelPrefix}${defaultChannelName}`;
        const pkg = websocketGroup
            ? this.getOrCreatePackage({ group: websocketGroup })
            : this.getOrCreatePackage({ group: [defaultChannelName] });

        this.ir.websocketChannels = {
            ...this.ir.websocketChannels,
            [channelName]: websocketChannel
        };
        if (channelName !== "") {
            if (pkg.websocket == null) {
                pkg.websocket = channelName;
            }
        } else {
            this.ir.rootPackage.websocket = "";
        }
        const emptyFile = this.context.createFernFilepath();
        this.irGraph.addChannel(emptyFile, channelName, websocketChannel);
        if (audiences != null) {
            this.irGraph.markChannelForAudiences(emptyFile, channelName, audiences);
        }
    }

    protected addAuthToIR(auth: FernIr.ApiAuth): void {
        this.ir.auth = auth;
    }

    protected addErrorsToIr(errors: Record<FernIr.ErrorId, FernIr.ErrorDeclaration>): void {
        this.ir.errors = errors;
        for (const error of Object.values(errors)) {
            this.irGraph.addError(error);
        }
    }

    protected addGlobalHeadersToIr(globalHeaders: FernIr.HttpHeader[]): void {
        this.ir.headers = globalHeaders;
    }

    protected addEnvironmentsToIr({
        environmentConfig,
        audiences
    }: {
        environmentConfig: FernIr.EnvironmentsConfig | undefined;
        audiences?: Record<string, string[]>;
    }): void {
        this.ir.environments = environmentConfig;
        if (audiences == null) {
            return;
        }
        for (const [environmentId, environment] of Object.entries(environmentConfig ?? {})) {
            if (audiences[environmentId] != null) {
                this.irGraph.markEnvironmentForAudiences(environment, audiences[environmentId]);
            }
        }
    }

    protected addTypeToRootPackage(typeId: FernIr.TypeId): void {
        this.ir.rootPackage.types.push(typeId);
    }

    protected addSchemaOutputToIr(typeId: FernIr.TypeId, output: SchemaConverter.Output): void {
        /**
         * Adds a schema output to the IR, handling potential naming conflicts.
         *
         * When inlined types have the same ID as the main type, this method automatically
         * postfixes the main type ID with "Wrapper" to avoid conflicts. The main type
         * is added to the root package, and all types (main + inlined) are added to the IR.
         *
         * @param typeId - The identifier for the main type
         * @param output - The schema converter output containing the main type and any inlined types
         */
        const { convertedSchema, inlinedTypes } = output;

        const shouldPostfixId = Object.keys(inlinedTypes).some((inlineTypeId) => inlineTypeId === typeId);
        const safeTypeId = shouldPostfixId ? `${typeId}Wrapper` : typeId;

        this.addTypeToPackage(safeTypeId);
        this.addTypesToIr({
            ...inlinedTypes,
            [safeTypeId]: convertedSchema
        });
    }

    protected addTypeToPackage(typeId: FernIr.TypeId): void {
        const group = this.context.getGroup({
            groupParts: [],
            namespace: this.context.namespace
        });
        const groupPackage = this.getOrCreatePackage({ group });
        groupPackage.types.push(typeId);
    }

    protected addTypesToIr(types: Record<FernIr.TypeId, SchemaConverter.ConvertedSchema>): void {
        Object.assign(
            this.ir.types,
            Object.fromEntries(Object.entries(types).map(([id, type]) => [id, type.typeDeclaration]))
        );
        for (const convertedType of Object.values(types)) {
            this.irGraph.addType({
                declaredTypeName: convertedType.typeDeclaration.name,
                descendantTypeIds: convertedType.typeDeclaration.referencedTypes,
                descendantTypeIdsByAudience: {},
                propertiesByAudience: convertedType.propertiesByAudience,
                descendantFilepaths: new Set<FernIr.FernFilepath>()
            });
            this.irGraph.markTypeForAudiences(convertedType.typeDeclaration.name, convertedType.audiences);
        }
    }

    protected updateEndpointsWithDefaultUrl(defaultUrl: string | undefined): void {
        if (defaultUrl == null) {
            return;
        }
        for (const service of Object.values(this.ir.services)) {
            for (const endpoint of service.endpoints) {
                if (endpoint.baseUrl == null) {
                    endpoint.baseUrl = defaultUrl;
                }
            }
        }
    }

    protected createNewService({
        allParts,
        finalpart,
        endpointGroupDisplayName
    }: {
        allParts: FernIr.Name[];
        finalpart: FernIr.Name | undefined;
        endpointGroupDisplayName?: string;
    }): FernIr.HttpService {
        return {
            name: {
                fernFilepath: {
                    allParts,
                    packagePath: allParts.slice(0, -1),
                    file: finalpart
                }
            },
            displayName: endpointGroupDisplayName,
            basePath: constructHttpPath(""),
            headers: [],
            pathParameters: [],
            availability: undefined,
            endpoints: [],
            transport: undefined,
            encoding: undefined,
            audiences: undefined
        };
    }

    /**
     * Creates a Package object with default values
     * @param args Optional object containing package name
     * @returns Package object with default values
     */
    public createPackage(args: { name?: string } = {}): Package {
        return {
            fernFilepath: this.context.createFernFilepath(args),
            service: undefined,
            types: [],
            errors: [],
            subpackages: [],
            docs: undefined,
            webhooks: undefined,
            websocket: undefined,
            hasEndpointsInTree: false,
            navigationConfig: undefined
        };
    }

    /**
     * Gets an existing package or creates a new one if it doesn't exist
     * @param packageName The name of the package to get or create
     * @param context The converter context
     * @returns The package object
     */
    protected getOrCreatePackage({ group }: { group?: string[] }): Package {
        const groupParts = [];
        if (this.context.namespace != null) {
            groupParts.push(this.context.namespace);
        }
        groupParts.push(...(group ?? []).map((part) => camelCase(part)));

        if (groupParts.length == 0) {
            return this.ir.rootPackage;
        }

        let pkg = this.ir.rootPackage;
        for (let i = 0; i < groupParts.length; i++) {
            const name = groupParts[i] ?? "";
            const groupPartsSubset = groupParts.slice(0, i + 1);
            const subpackageId = `subpackage_${groupPartsSubset.join("/")}`;
            if (this.ir.subpackages[subpackageId] == null) {
                this.ir.subpackages[subpackageId] = {
                    name: this.context.casingsGenerator.generateName(name),
                    displayName: undefined,
                    ...this.createPackage({ name })
                };
            }
            const curr = this.ir.subpackages[subpackageId];
            if (!pkg.subpackages.includes(subpackageId)) {
                pkg.subpackages.push(subpackageId);
            }
            pkg = curr;
        }
        return pkg;
    }
}

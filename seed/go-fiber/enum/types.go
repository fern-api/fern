// Code generated by Fern. DO NOT EDIT.

package enum

import (
	json "encoding/json"
	fmt "fmt"
)

type Color string

const (
	ColorRed  Color = "red"
	ColorBlue Color = "blue"
)

func NewColorFromString(s string) (Color, error) {
	switch s {
	case "red":
		return ColorRed, nil
	case "blue":
		return ColorBlue, nil
	}
	var t Color
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Color) Ptr() *Color {
	return &c
}

type ColorOrOperand struct {
	Color   Color
	Operand Operand

	typ string
}

func (c *ColorOrOperand) GetColor() Color {
	if c == nil {
		return ""
	}
	return c.Color
}

func (c *ColorOrOperand) GetOperand() Operand {
	if c == nil {
		return ""
	}
	return c.Operand
}

func (c *ColorOrOperand) UnmarshalJSON(data []byte) error {
	var valueColor Color
	if err := json.Unmarshal(data, &valueColor); err == nil {
		c.typ = "Color"
		c.Color = valueColor
		return nil
	}
	var valueOperand Operand
	if err := json.Unmarshal(data, &valueOperand); err == nil {
		c.typ = "Operand"
		c.Operand = valueOperand
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ColorOrOperand) MarshalJSON() ([]byte, error) {
	if c.typ == "Color" || c.Color != "" {
		return json.Marshal(c.Color)
	}
	if c.typ == "Operand" || c.Operand != "" {
		return json.Marshal(c.Operand)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ColorOrOperandVisitor interface {
	VisitColor(Color) error
	VisitOperand(Operand) error
}

func (c *ColorOrOperand) Accept(visitor ColorOrOperandVisitor) error {
	if c.typ == "Color" || c.Color != "" {
		return visitor.VisitColor(c.Color)
	}
	if c.typ == "Operand" || c.Operand != "" {
		return visitor.VisitOperand(c.Operand)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type EnumWithCustom string

const (
	EnumWithCustomSafe   EnumWithCustom = "safe"
	EnumWithCustomCustom EnumWithCustom = "Custom"
)

func NewEnumWithCustomFromString(s string) (EnumWithCustom, error) {
	switch s {
	case "safe":
		return EnumWithCustomSafe, nil
	case "Custom":
		return EnumWithCustomCustom, nil
	}
	var t EnumWithCustom
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumWithCustom) Ptr() *EnumWithCustom {
	return &e
}

type EnumWithSpecialCharacters string

const (
	EnumWithSpecialCharactersBla EnumWithSpecialCharacters = "\\$bla"
	EnumWithSpecialCharactersYo  EnumWithSpecialCharacters = "\\$yo"
)

func NewEnumWithSpecialCharactersFromString(s string) (EnumWithSpecialCharacters, error) {
	switch s {
	case "\\$bla":
		return EnumWithSpecialCharactersBla, nil
	case "\\$yo":
		return EnumWithSpecialCharactersYo, nil
	}
	var t EnumWithSpecialCharacters
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumWithSpecialCharacters) Ptr() *EnumWithSpecialCharacters {
	return &e
}

// Tests enum name and value can be
// different.
type Operand string

const (
	OperandGreaterThan Operand = ">"
	OperandEqualTo     Operand = "="
	// The name and value should be similar
	// are similar for less than.
	OperandLessThan Operand = "less_than"
)

func NewOperandFromString(s string) (Operand, error) {
	switch s {
	case ">":
		return OperandGreaterThan, nil
	case "=":
		return OperandEqualTo, nil
	case "less_than":
		return OperandLessThan, nil
	}
	var t Operand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Operand) Ptr() *Operand {
	return &o
}

type SpecialEnum string

const (
	SpecialEnumA  SpecialEnum = ""
	SpecialEnumB  SpecialEnum = "Hello \\\\\"World\\\\\""
	SpecialEnumC  SpecialEnum = "Hello 'World'"
	SpecialEnumD  SpecialEnum = "Hello\\\\World"
	SpecialEnumE  SpecialEnum = "Hello\\nWorld"
	SpecialEnumF  SpecialEnum = "Hello\\rWorld"
	SpecialEnumH  SpecialEnum = "Hello\\tWorld"
	SpecialEnumI  SpecialEnum = "Hello\\fWorld"
	SpecialEnumJ  SpecialEnum = "Hello\\u0008World"
	SpecialEnumK  SpecialEnum = "Hello\\vWorld"
	SpecialEnumL  SpecialEnum = "Hello\\x00World"
	SpecialEnumM  SpecialEnum = "Hello\\u0007World"
	SpecialEnumN  SpecialEnum = "Hello\\u0001World"
	SpecialEnumO  SpecialEnum = "Hello\\u0002World"
	SpecialEnumP  SpecialEnum = "Hello\\u001FWorld"
	SpecialEnumQ  SpecialEnum = "Hello\\u007FWorld"
	SpecialEnumR  SpecialEnum = "Hello\\u009FWorld"
	SpecialEnumS  SpecialEnum = "Line 1\\n\\\"Quote\\\"\\tTab\\\\Backslash\\r\\nLine 2\\0Null"
	SpecialEnumT  SpecialEnum = "\\n\\r\\t\\x00\\u0008\\f\\v\\u0007"
	SpecialEnumU  SpecialEnum = "Hello ä¸–ç•Œ"
	SpecialEnumV  SpecialEnum = "cafÃ©"
	SpecialEnumW  SpecialEnum = "ðŸš€"
	SpecialEnumX  SpecialEnum = "\\\\n"
	SpecialEnumY  SpecialEnum = "\\\\"
	SpecialEnumZ  SpecialEnum = "{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"city\\\": \\\"New York\\\"}"
	SpecialEnumAa SpecialEnum = "SELECT * FROM users WHERE name = 'John O\\\\'Reilly'"
	SpecialEnumBb SpecialEnum = "C:\\\\Users\\\\John\\\\Documents\\\\file.txt"
	SpecialEnumCc SpecialEnum = "/usr/local/bin/app"
	SpecialEnumDd SpecialEnum = "\\\\d{3}-\\\\d{2}-\\\\d{4}"
	SpecialEnumEe SpecialEnum = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}"
	SpecialEnumFf SpecialEnum = "transcript[transcriptType=\\\"final\\\"]"
	SpecialEnumGg SpecialEnum = "transcript[transcriptType='final']"
)

func NewSpecialEnumFromString(s string) (SpecialEnum, error) {
	switch s {
	case "":
		return SpecialEnumA, nil
	case "Hello \\\"World\\\"":
		return SpecialEnumB, nil
	case "Hello 'World'":
		return SpecialEnumC, nil
	case "Hello\\\\World":
		return SpecialEnumD, nil
	case "Hello\\nWorld":
		return SpecialEnumE, nil
	case "Hello\\rWorld":
		return SpecialEnumF, nil
	case "Hello\\tWorld":
		return SpecialEnumH, nil
	case "Hello\\fWorld":
		return SpecialEnumI, nil
	case "Hello\\u0008World":
		return SpecialEnumJ, nil
	case "Hello\\vWorld":
		return SpecialEnumK, nil
	case "Hello\\x00World":
		return SpecialEnumL, nil
	case "Hello\\u0007World":
		return SpecialEnumM, nil
	case "Hello\\u0001World":
		return SpecialEnumN, nil
	case "Hello\\u0002World":
		return SpecialEnumO, nil
	case "Hello\\u001FWorld":
		return SpecialEnumP, nil
	case "Hello\\u007FWorld":
		return SpecialEnumQ, nil
	case "Hello\\u009FWorld":
		return SpecialEnumR, nil
	case "Line 1\\n\"Quote\"\\tTab\\\\Backslash\\r\\nLine 2\\0Null":
		return SpecialEnumS, nil
	case "\\n\\r\\t\\x00\\u0008\\f\\v\\u0007":
		return SpecialEnumT, nil
	case "Hello ä¸–ç•Œ":
		return SpecialEnumU, nil
	case "cafÃ©":
		return SpecialEnumV, nil
	case "ðŸš€":
		return SpecialEnumW, nil
	case "\\\\n":
		return SpecialEnumX, nil
	case "\\\\":
		return SpecialEnumY, nil
	case "{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}":
		return SpecialEnumZ, nil
	case "SELECT * FROM users WHERE name = 'John O\\\\'Reilly'":
		return SpecialEnumAa, nil
	case "C:\\\\Users\\\\John\\\\Documents\\\\file.txt":
		return SpecialEnumBb, nil
	case "/usr/local/bin/app":
		return SpecialEnumCc, nil
	case "\\\\d{3}-\\\\d{2}-\\\\d{4}":
		return SpecialEnumDd, nil
	case "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}":
		return SpecialEnumEe, nil
	case "transcript[transcriptType=\"final\"]":
		return SpecialEnumFf, nil
	case "transcript[transcriptType='final']":
		return SpecialEnumGg, nil
	}
	var t SpecialEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpecialEnum) Ptr() *SpecialEnum {
	return &s
}

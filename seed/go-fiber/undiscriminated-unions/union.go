// This file was auto-generated by Fern from our API Definition.

package undiscriminatedunions

import (
	json "encoding/json"
	fmt "fmt"
)

// Several different types are accepted.
type MyUnion struct {
	typeName        string
	String          string
	StringList      []string
	Integer         int
	IntegerList     []int
	IntegerListList [][]int
}

func NewMyUnionFromString(value string) *MyUnion {
	return &MyUnion{typeName: "string", String: value}
}

func NewMyUnionFromStringList(value []string) *MyUnion {
	return &MyUnion{typeName: "stringList", StringList: value}
}

func NewMyUnionFromInteger(value int) *MyUnion {
	return &MyUnion{typeName: "integer", Integer: value}
}

func NewMyUnionFromIntegerList(value []int) *MyUnion {
	return &MyUnion{typeName: "integerList", IntegerList: value}
}

func NewMyUnionFromIntegerListList(value [][]int) *MyUnion {
	return &MyUnion{typeName: "integerListList", IntegerListList: value}
}

func (m *MyUnion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		m.typeName = "stringList"
		m.StringList = valueStringList
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		m.typeName = "integer"
		m.Integer = valueInteger
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		m.typeName = "integerList"
		m.IntegerList = valueIntegerList
		return nil
	}
	var valueIntegerListList [][]int
	if err := json.Unmarshal(data, &valueIntegerListList); err == nil {
		m.typeName = "integerListList"
		m.IntegerListList = valueIntegerListList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MyUnion) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return json.Marshal(m.String)
	case "stringList":
		return json.Marshal(m.StringList)
	case "integer":
		return json.Marshal(m.Integer)
	case "integerList":
		return json.Marshal(m.IntegerList)
	case "integerListList":
		return json.Marshal(m.IntegerListList)
	}
}

type MyUnionVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
	VisitInteger(int) error
	VisitIntegerList([]int) error
	VisitIntegerListList([][]int) error
}

func (m *MyUnion) Accept(visitor MyUnionVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return visitor.VisitString(m.String)
	case "stringList":
		return visitor.VisitStringList(m.StringList)
	case "integer":
		return visitor.VisitInteger(m.Integer)
	case "integerList":
		return visitor.VisitIntegerList(m.IntegerList)
	case "integerListList":
		return visitor.VisitIntegerListList(m.IntegerListList)
	}
}

// This file was auto-generated by Fern from our API Definition.

package commons

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/examples/fern/internal"
)

type Data struct {
	Type   string
	String string
	Base64 []byte
}

func NewDataFromString(value string) *Data {
	return &Data{Type: "string", String: value}
}

func NewDataFromBase64(value []byte) *Data {
	return &Data{Type: "base64", Base64: value}
}

func (d *Data) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *Data) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *Data) GetBase64() []byte {
	if d == nil {
		return nil
	}
	return d.Base64
}

func (d *Data) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.String = valueUnmarshaler.String
	case "base64":
		var valueUnmarshaler struct {
			Base64 []byte `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.Base64 = valueUnmarshaler.Base64
	}
	return nil
}

func (d Data) MarshalJSON() ([]byte, error) {
	if err := d.validate(); err != nil {
		return nil, err
	}
	switch d.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: d.String,
		}
		return json.Marshal(marshaler)
	case "base64":
		var marshaler = struct {
			Type   string `json:"type"`
			Base64 []byte `json:"value"`
		}{
			Type:   "base64",
			Base64: d.Base64,
		}
		return json.Marshal(marshaler)
	}
}

type DataVisitor interface {
	VisitString(string) error
	VisitBase64([]byte) error
}

func (d *Data) Accept(visitor DataVisitor) error {
	switch d.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "string":
		return visitor.VisitString(d.String)
	case "base64":
		return visitor.VisitBase64(d.Base64)
	}
}

func (d *Data) validate() error {
	if d == nil {
		return fmt.Errorf("type %T is nil", d)
	}
	var fields []string
	if d.String != "" {
		fields = append(fields, "string")
	}
	if d.Base64 != nil {
		fields = append(fields, "base64")
	}
	if len(fields) == 0 {
		if d.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", d, d.Type)
		}
		return fmt.Errorf("type %T is empty", d)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", d, fields)
	}
	if d.Type != "" {
		field := fields[0]
		if d.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				d,
				d.Type,
				d,
			)
		}
	}
	return nil
}

type EventInfo struct {
	Type     string
	Metadata *Metadata
	Tag      Tag
}

func NewEventInfoFromMetadata(value *Metadata) *EventInfo {
	return &EventInfo{Type: "metadata", Metadata: value}
}

func NewEventInfoFromTag(value Tag) *EventInfo {
	return &EventInfo{Type: "tag", Tag: value}
}

func (e *EventInfo) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EventInfo) GetMetadata() *Metadata {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EventInfo) GetTag() Tag {
	if e == nil {
		return ""
	}
	return e.Tag
}

func (e *EventInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "metadata":
		value := new(Metadata)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Metadata = value
	case "tag":
		var valueUnmarshaler struct {
			Tag Tag `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Tag = valueUnmarshaler.Tag
	}
	return nil
}

func (e EventInfo) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "metadata":
		return internal.MarshalJSONWithExtraProperty(e.Metadata, "type", "metadata")
	case "tag":
		var marshaler = struct {
			Type string `json:"type"`
			Tag  Tag    `json:"value"`
		}{
			Type: "tag",
			Tag:  e.Tag,
		}
		return json.Marshal(marshaler)
	}
}

type EventInfoVisitor interface {
	VisitMetadata(*Metadata) error
	VisitTag(Tag) error
}

func (e *EventInfo) Accept(visitor EventInfoVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "metadata":
		return visitor.VisitMetadata(e.Metadata)
	case "tag":
		return visitor.VisitTag(e.Tag)
	}
}

func (e *EventInfo) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if e.Tag != "" {
		fields = append(fields, "tag")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type Metadata struct {
	Id         string            `json:"id" url:"id"`
	Data       map[string]string `json:"data,omitempty" url:"data,omitempty"`
	JsonString *string           `json:"jsonString,omitempty" url:"jsonString,omitempty"`

	extraProperties map[string]interface{}
}

func (m *Metadata) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *Metadata) GetData() map[string]string {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *Metadata) GetJsonString() *string {
	if m == nil {
		return nil
	}
	return m.JsonString
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *Metadata) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Tag = string

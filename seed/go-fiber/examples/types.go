// Code generated by Fern. DO NOT EDIT.

package examples

import (
	json "encoding/json"
	fmt "fmt"
	commons "github.com/examples/fern/commons"
	internal "github.com/examples/fern/internal"
	uuid "github.com/google/uuid"
	big "math/big"
	time "time"
)

type BasicType string

const (
	BasicTypePrimitive BasicType = "primitive"
	BasicTypeLiteral   BasicType = "literal"
)

func NewBasicTypeFromString(s string) (BasicType, error) {
	switch s {
	case "primitive":
		return BasicTypePrimitive, nil
	case "literal":
		return BasicTypeLiteral, nil
	}
	var t BasicType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BasicType) Ptr() *BasicType {
	return &b
}

type ComplexType string

const (
	ComplexTypeObject  ComplexType = "object"
	ComplexTypeUnion   ComplexType = "union"
	ComplexTypeUnknown ComplexType = "unknown"
)

func NewComplexTypeFromString(s string) (ComplexType, error) {
	switch s {
	case "object":
		return ComplexTypeObject, nil
	case "union":
		return ComplexTypeUnion, nil
	case "unknown":
		return ComplexTypeUnknown, nil
	}
	var t ComplexType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComplexType) Ptr() *ComplexType {
	return &c
}

var (
	identifierFieldType  = big.NewInt(1 << 0)
	identifierFieldValue = big.NewInt(1 << 1)
	identifierFieldLabel = big.NewInt(1 << 2)
)

type Identifier struct {
	Type  *Type  `json:"type" url:"type"`
	Value string `json:"value" url:"value"`
	Label string `json:"label" url:"label"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *Identifier) GetType() *Type {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *Identifier) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

func (i *Identifier) GetLabel() string {
	if i == nil {
		return ""
	}
	return i.Label
}

func (i *Identifier) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Identifier) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Identifier) SetType(type_ *Type) {
	i.Type = type_
	i.require(identifierFieldType)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Identifier) SetValue(value string) {
	i.Value = value
	i.require(identifierFieldValue)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Identifier) SetLabel(label string) {
	i.Label = label
	i.require(identifierFieldLabel)
}

func (i *Identifier) UnmarshalJSON(data []byte) error {
	type unmarshaler Identifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Identifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *Identifier) MarshalJSON() ([]byte, error) {
	type embed Identifier
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *Identifier) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Type struct {
	BasicType   BasicType
	ComplexType ComplexType

	typ string
}

func (t *Type) GetBasicType() BasicType {
	if t == nil {
		return ""
	}
	return t.BasicType
}

func (t *Type) GetComplexType() ComplexType {
	if t == nil {
		return ""
	}
	return t.ComplexType
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var valueBasicType BasicType
	if err := json.Unmarshal(data, &valueBasicType); err == nil {
		t.typ = "BasicType"
		t.BasicType = valueBasicType
		return nil
	}
	var valueComplexType ComplexType
	if err := json.Unmarshal(data, &valueComplexType); err == nil {
		t.typ = "ComplexType"
		t.ComplexType = valueComplexType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t Type) MarshalJSON() ([]byte, error) {
	if t.typ == "BasicType" || t.BasicType != "" {
		return json.Marshal(t.BasicType)
	}
	if t.typ == "ComplexType" || t.ComplexType != "" {
		return json.Marshal(t.ComplexType)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TypeVisitor interface {
	VisitBasicType(BasicType) error
	VisitComplexType(ComplexType) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	if t.typ == "BasicType" || t.BasicType != "" {
		return visitor.VisitBasicType(t.BasicType)
	}
	if t.typ == "ComplexType" || t.ComplexType != "" {
		return visitor.VisitComplexType(t.ComplexType)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

var (
	typeWithSingleCharPropertyEqualToTypeStartingLetterFieldT  = big.NewInt(1 << 0)
	typeWithSingleCharPropertyEqualToTypeStartingLetterFieldTy = big.NewInt(1 << 1)
)

type TypeWithSingleCharPropertyEqualToTypeStartingLetter struct {
	T  string `json:"t" url:"t"`
	Ty string `json:"ty" url:"ty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) GetT() string {
	if t == nil {
		return ""
	}
	return t.T
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) GetTy() string {
	if t == nil {
		return ""
	}
	return t.Ty
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetT sets the T field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (_SetT *TypeWithSingleCharPropertyEqualToTypeStartingLetter) SetT(t string) {
	_SetT.T = t
	_SetT.require(typeWithSingleCharPropertyEqualToTypeStartingLetterFieldT)
}

// SetTy sets the Ty field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (_SetT *TypeWithSingleCharPropertyEqualToTypeStartingLetter) SetTy(ty string) {
	_SetT.Ty = ty
	_SetT.require(typeWithSingleCharPropertyEqualToTypeStartingLetterFieldTy)
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) UnmarshalJSON(data []byte) error {
	type unmarshaler TypeWithSingleCharPropertyEqualToTypeStartingLetter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeWithSingleCharPropertyEqualToTypeStartingLetter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) MarshalJSON() ([]byte, error) {
	type embed TypeWithSingleCharPropertyEqualToTypeStartingLetter
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TypeWithSingleCharPropertyEqualToTypeStartingLetter) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	actorFieldName = big.NewInt(1 << 0)
	actorFieldId   = big.NewInt(1 << 1)
)

type Actor struct {
	Name string `json:"name" url:"name"`
	Id   string `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (a *Actor) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *Actor) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Actor) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Actor) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Actor) SetName(name string) {
	a.Name = name
	a.require(actorFieldName)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Actor) SetId(id string) {
	a.Id = id
	a.require(actorFieldId)
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	type unmarshaler Actor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *Actor) MarshalJSON() ([]byte, error) {
	type embed Actor
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Actor) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actressFieldName = big.NewInt(1 << 0)
	actressFieldId   = big.NewInt(1 << 1)
)

type Actress struct {
	Name string `json:"name" url:"name"`
	Id   string `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (a *Actress) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *Actress) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Actress) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Actress) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Actress) SetName(name string) {
	a.Name = name
	a.require(actressFieldName)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Actress) SetId(id string) {
	a.Id = id
	a.require(actressFieldId)
}

func (a *Actress) UnmarshalJSON(data []byte) error {
	type unmarshaler Actress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *Actress) MarshalJSON() ([]byte, error) {
	type embed Actress
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Actress) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	bigEntityFieldCastMember     = big.NewInt(1 << 0)
	bigEntityFieldExtendedMovie  = big.NewInt(1 << 1)
	bigEntityFieldEntity         = big.NewInt(1 << 2)
	bigEntityFieldMetadata       = big.NewInt(1 << 3)
	bigEntityFieldCommonMetadata = big.NewInt(1 << 4)
	bigEntityFieldEventInfo      = big.NewInt(1 << 5)
	bigEntityFieldData           = big.NewInt(1 << 6)
	bigEntityFieldMigration      = big.NewInt(1 << 7)
	bigEntityFieldException      = big.NewInt(1 << 8)
	bigEntityFieldTest           = big.NewInt(1 << 9)
	bigEntityFieldNode           = big.NewInt(1 << 10)
	bigEntityFieldDirectory      = big.NewInt(1 << 11)
	bigEntityFieldMoment         = big.NewInt(1 << 12)
)

type BigEntity struct {
	CastMember     *CastMember        `json:"castMember,omitempty" url:"castMember,omitempty"`
	ExtendedMovie  *ExtendedMovie     `json:"extendedMovie,omitempty" url:"extendedMovie,omitempty"`
	Entity         *Entity            `json:"entity,omitempty" url:"entity,omitempty"`
	Metadata       *Metadata          `json:"metadata,omitempty" url:"metadata,omitempty"`
	CommonMetadata *commons.Metadata  `json:"commonMetadata,omitempty" url:"commonMetadata,omitempty"`
	EventInfo      *commons.EventInfo `json:"eventInfo,omitempty" url:"eventInfo,omitempty"`
	Data           *commons.Data      `json:"data,omitempty" url:"data,omitempty"`
	Migration      *Migration         `json:"migration,omitempty" url:"migration,omitempty"`
	Exception      *Exception         `json:"exception,omitempty" url:"exception,omitempty"`
	Test           *Test              `json:"test,omitempty" url:"test,omitempty"`
	Node           *Node              `json:"node,omitempty" url:"node,omitempty"`
	Directory      *Directory         `json:"directory,omitempty" url:"directory,omitempty"`
	Moment         *Moment            `json:"moment,omitempty" url:"moment,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BigEntity) GetCastMember() *CastMember {
	if b == nil {
		return nil
	}
	return b.CastMember
}

func (b *BigEntity) GetExtendedMovie() *ExtendedMovie {
	if b == nil {
		return nil
	}
	return b.ExtendedMovie
}

func (b *BigEntity) GetEntity() *Entity {
	if b == nil {
		return nil
	}
	return b.Entity
}

func (b *BigEntity) GetMetadata() *Metadata {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BigEntity) GetCommonMetadata() *commons.Metadata {
	if b == nil {
		return nil
	}
	return b.CommonMetadata
}

func (b *BigEntity) GetEventInfo() *commons.EventInfo {
	if b == nil {
		return nil
	}
	return b.EventInfo
}

func (b *BigEntity) GetData() *commons.Data {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BigEntity) GetMigration() *Migration {
	if b == nil {
		return nil
	}
	return b.Migration
}

func (b *BigEntity) GetException() *Exception {
	if b == nil {
		return nil
	}
	return b.Exception
}

func (b *BigEntity) GetTest() *Test {
	if b == nil {
		return nil
	}
	return b.Test
}

func (b *BigEntity) GetNode() *Node {
	if b == nil {
		return nil
	}
	return b.Node
}

func (b *BigEntity) GetDirectory() *Directory {
	if b == nil {
		return nil
	}
	return b.Directory
}

func (b *BigEntity) GetMoment() *Moment {
	if b == nil {
		return nil
	}
	return b.Moment
}

func (b *BigEntity) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BigEntity) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetCastMember sets the CastMember field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetCastMember(castMember *CastMember) {
	b.CastMember = castMember
	b.require(bigEntityFieldCastMember)
}

// SetExtendedMovie sets the ExtendedMovie field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetExtendedMovie(extendedMovie *ExtendedMovie) {
	b.ExtendedMovie = extendedMovie
	b.require(bigEntityFieldExtendedMovie)
}

// SetEntity sets the Entity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetEntity(entity *Entity) {
	b.Entity = entity
	b.require(bigEntityFieldEntity)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetMetadata(metadata *Metadata) {
	b.Metadata = metadata
	b.require(bigEntityFieldMetadata)
}

// SetCommonMetadata sets the CommonMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetCommonMetadata(commonMetadata *commons.Metadata) {
	b.CommonMetadata = commonMetadata
	b.require(bigEntityFieldCommonMetadata)
}

// SetEventInfo sets the EventInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetEventInfo(eventInfo *commons.EventInfo) {
	b.EventInfo = eventInfo
	b.require(bigEntityFieldEventInfo)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetData(data *commons.Data) {
	b.Data = data
	b.require(bigEntityFieldData)
}

// SetMigration sets the Migration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetMigration(migration *Migration) {
	b.Migration = migration
	b.require(bigEntityFieldMigration)
}

// SetException sets the Exception field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetException(exception *Exception) {
	b.Exception = exception
	b.require(bigEntityFieldException)
}

// SetTest sets the Test field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetTest(test *Test) {
	b.Test = test
	b.require(bigEntityFieldTest)
}

// SetNode sets the Node field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetNode(node *Node) {
	b.Node = node
	b.require(bigEntityFieldNode)
}

// SetDirectory sets the Directory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetDirectory(directory *Directory) {
	b.Directory = directory
	b.require(bigEntityFieldDirectory)
}

// SetMoment sets the Moment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigEntity) SetMoment(moment *Moment) {
	b.Moment = moment
	b.require(bigEntityFieldMoment)
}

func (b *BigEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler BigEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BigEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BigEntity) MarshalJSON() ([]byte, error) {
	type embed BigEntity
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BigEntity) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CastMember struct {
	Actor       *Actor
	Actress     *Actress
	StuntDouble *StuntDouble

	typ string
}

func (c *CastMember) GetActor() *Actor {
	if c == nil {
		return nil
	}
	return c.Actor
}

func (c *CastMember) GetActress() *Actress {
	if c == nil {
		return nil
	}
	return c.Actress
}

func (c *CastMember) GetStuntDouble() *StuntDouble {
	if c == nil {
		return nil
	}
	return c.StuntDouble
}

func (c *CastMember) UnmarshalJSON(data []byte) error {
	valueActor := new(Actor)
	if err := json.Unmarshal(data, &valueActor); err == nil {
		c.typ = "Actor"
		c.Actor = valueActor
		return nil
	}
	valueActress := new(Actress)
	if err := json.Unmarshal(data, &valueActress); err == nil {
		c.typ = "Actress"
		c.Actress = valueActress
		return nil
	}
	valueStuntDouble := new(StuntDouble)
	if err := json.Unmarshal(data, &valueStuntDouble); err == nil {
		c.typ = "StuntDouble"
		c.StuntDouble = valueStuntDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CastMember) MarshalJSON() ([]byte, error) {
	if c.typ == "Actor" || c.Actor != nil {
		return json.Marshal(c.Actor)
	}
	if c.typ == "Actress" || c.Actress != nil {
		return json.Marshal(c.Actress)
	}
	if c.typ == "StuntDouble" || c.StuntDouble != nil {
		return json.Marshal(c.StuntDouble)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CastMemberVisitor interface {
	VisitActor(*Actor) error
	VisitActress(*Actress) error
	VisitStuntDouble(*StuntDouble) error
}

func (c *CastMember) Accept(visitor CastMemberVisitor) error {
	if c.typ == "Actor" || c.Actor != nil {
		return visitor.VisitActor(c.Actor)
	}
	if c.typ == "Actress" || c.Actress != nil {
		return visitor.VisitActress(c.Actress)
	}
	if c.typ == "StuntDouble" || c.StuntDouble != nil {
		return visitor.VisitStuntDouble(c.StuntDouble)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

var (
	cronJobFieldExpression = big.NewInt(1 << 0)
)

type CronJob struct {
	Expression string `json:"expression" url:"expression"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (c *CronJob) GetExpression() string {
	if c == nil {
		return ""
	}
	return c.Expression
}

func (c *CronJob) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CronJob) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetExpression sets the Expression field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CronJob) SetExpression(expression string) {
	c.Expression = expression
	c.require(cronJobFieldExpression)
}

func (c *CronJob) UnmarshalJSON(data []byte) error {
	type unmarshaler CronJob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CronJob(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CronJob) MarshalJSON() ([]byte, error) {
	type embed CronJob
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CronJob) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	directoryFieldName        = big.NewInt(1 << 0)
	directoryFieldFiles       = big.NewInt(1 << 1)
	directoryFieldDirectories = big.NewInt(1 << 2)
)

type Directory struct {
	Name        string       `json:"name" url:"name"`
	Files       []*File      `json:"files,omitempty" url:"files,omitempty"`
	Directories []*Directory `json:"directories,omitempty" url:"directories,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *Directory) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *Directory) GetFiles() []*File {
	if d == nil {
		return nil
	}
	return d.Files
}

func (d *Directory) GetDirectories() []*Directory {
	if d == nil {
		return nil
	}
	return d.Directories
}

func (d *Directory) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Directory) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Directory) SetName(name string) {
	d.Name = name
	d.require(directoryFieldName)
}

// SetFiles sets the Files field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Directory) SetFiles(files []*File) {
	d.Files = files
	d.require(directoryFieldFiles)
}

// SetDirectories sets the Directories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Directory) SetDirectories(directories []*Directory) {
	d.Directories = directories
	d.require(directoryFieldDirectories)
}

func (d *Directory) UnmarshalJSON(data []byte) error {
	type unmarshaler Directory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Directory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Directory) MarshalJSON() ([]byte, error) {
	type embed Directory
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Directory) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	entityFieldType = big.NewInt(1 << 0)
	entityFieldName = big.NewInt(1 << 1)
)

type Entity struct {
	Type *Type  `json:"type" url:"type"`
	Name string `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *Entity) GetType() *Type {
	if e == nil {
		return nil
	}
	return e.Type
}

func (e *Entity) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *Entity) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Entity) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Entity) SetType(type_ *Type) {
	e.Type = type_
	e.require(entityFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Entity) SetName(name string) {
	e.Name = name
	e.require(entityFieldName)
}

func (e *Entity) UnmarshalJSON(data []byte) error {
	type unmarshaler Entity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Entity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *Entity) MarshalJSON() ([]byte, error) {
	type embed Entity
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Entity) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Exception struct {
	Type    string
	Generic *ExceptionInfo
	Timeout interface{}
}

func (e *Exception) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *Exception) GetGeneric() *ExceptionInfo {
	if e == nil {
		return nil
	}
	return e.Generic
}

func (e *Exception) GetTimeout() interface{} {
	if e == nil {
		return nil
	}
	return e.Timeout
}

func (e *Exception) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "generic":
		value := new(ExceptionInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Generic = value
	case "timeout":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Timeout = value
	}
	return nil
}

func (e Exception) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Generic != nil {
		return internal.MarshalJSONWithExtraProperty(e.Generic, "type", "generic")
	}
	if e.Timeout != nil {
		var marshaler = struct {
			Type    string      `json:"type"`
			Timeout interface{} `json:"timeout,omitempty"`
		}{
			Type:    "timeout",
			Timeout: e.Timeout,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExceptionVisitor interface {
	VisitGeneric(*ExceptionInfo) error
	VisitTimeout(interface{}) error
}

func (e *Exception) Accept(visitor ExceptionVisitor) error {
	if e.Generic != nil {
		return visitor.VisitGeneric(e.Generic)
	}
	if e.Timeout != nil {
		return visitor.VisitTimeout(e.Timeout)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *Exception) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Generic != nil {
		fields = append(fields, "generic")
	}
	if e.Timeout != nil {
		fields = append(fields, "timeout")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exceptionInfoFieldExceptionType       = big.NewInt(1 << 0)
	exceptionInfoFieldExceptionMessage    = big.NewInt(1 << 1)
	exceptionInfoFieldExceptionStacktrace = big.NewInt(1 << 2)
)

type ExceptionInfo struct {
	ExceptionType       string `json:"exceptionType" url:"exceptionType"`
	ExceptionMessage    string `json:"exceptionMessage" url:"exceptionMessage"`
	ExceptionStacktrace string `json:"exceptionStacktrace" url:"exceptionStacktrace"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExceptionInfo) GetExceptionType() string {
	if e == nil {
		return ""
	}
	return e.ExceptionType
}

func (e *ExceptionInfo) GetExceptionMessage() string {
	if e == nil {
		return ""
	}
	return e.ExceptionMessage
}

func (e *ExceptionInfo) GetExceptionStacktrace() string {
	if e == nil {
		return ""
	}
	return e.ExceptionStacktrace
}

func (e *ExceptionInfo) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExceptionInfo) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetExceptionType sets the ExceptionType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExceptionInfo) SetExceptionType(exceptionType string) {
	e.ExceptionType = exceptionType
	e.require(exceptionInfoFieldExceptionType)
}

// SetExceptionMessage sets the ExceptionMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExceptionInfo) SetExceptionMessage(exceptionMessage string) {
	e.ExceptionMessage = exceptionMessage
	e.require(exceptionInfoFieldExceptionMessage)
}

// SetExceptionStacktrace sets the ExceptionStacktrace field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExceptionInfo) SetExceptionStacktrace(exceptionStacktrace string) {
	e.ExceptionStacktrace = exceptionStacktrace
	e.require(exceptionInfoFieldExceptionStacktrace)
}

func (e *ExceptionInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ExceptionInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExceptionInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExceptionInfo) MarshalJSON() ([]byte, error) {
	type embed ExceptionInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExceptionInfo) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	extendedMovieFieldId       = big.NewInt(1 << 0)
	extendedMovieFieldPrequel  = big.NewInt(1 << 1)
	extendedMovieFieldTitle    = big.NewInt(1 << 2)
	extendedMovieFieldFrom     = big.NewInt(1 << 3)
	extendedMovieFieldRating   = big.NewInt(1 << 4)
	extendedMovieFieldTag      = big.NewInt(1 << 5)
	extendedMovieFieldBook     = big.NewInt(1 << 6)
	extendedMovieFieldMetadata = big.NewInt(1 << 7)
	extendedMovieFieldRevenue  = big.NewInt(1 << 8)
	extendedMovieFieldCast     = big.NewInt(1 << 9)
)

type ExtendedMovie struct {
	Id      MovieId  `json:"id" url:"id"`
	Prequel *MovieId `json:"prequel,omitempty" url:"prequel,omitempty"`
	Title   string   `json:"title" url:"title"`
	From    string   `json:"from" url:"from"`
	// The rating scale is one to five stars
	Rating   float64                `json:"rating" url:"rating"`
	Tag      commons.Tag            `json:"tag" url:"tag"`
	Book     *string                `json:"book,omitempty" url:"book,omitempty"`
	Metadata map[string]interface{} `json:"metadata" url:"metadata"`
	Revenue  int64                  `json:"revenue" url:"revenue"`
	Cast     []string               `json:"cast" url:"cast"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
}

func (e *ExtendedMovie) GetId() MovieId {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ExtendedMovie) GetPrequel() *MovieId {
	if e == nil {
		return nil
	}
	return e.Prequel
}

func (e *ExtendedMovie) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ExtendedMovie) GetFrom() string {
	if e == nil {
		return ""
	}
	return e.From
}

func (e *ExtendedMovie) GetRating() float64 {
	if e == nil {
		return 0
	}
	return e.Rating
}

func (e *ExtendedMovie) GetTag() commons.Tag {
	if e == nil {
		return ""
	}
	return e.Tag
}

func (e *ExtendedMovie) GetBook() *string {
	if e == nil {
		return nil
	}
	return e.Book
}

func (e *ExtendedMovie) GetMetadata() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *ExtendedMovie) GetRevenue() int64 {
	if e == nil {
		return 0
	}
	return e.Revenue
}

func (e *ExtendedMovie) GetCast() []string {
	if e == nil {
		return nil
	}
	return e.Cast
}

func (e *ExtendedMovie) Type() string {
	return e.type_
}

func (e *ExtendedMovie) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExtendedMovie) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetId(id MovieId) {
	e.Id = id
	e.require(extendedMovieFieldId)
}

// SetPrequel sets the Prequel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetPrequel(prequel *MovieId) {
	e.Prequel = prequel
	e.require(extendedMovieFieldPrequel)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetTitle(title string) {
	e.Title = title
	e.require(extendedMovieFieldTitle)
}

// SetFrom sets the From field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetFrom(from string) {
	e.From = from
	e.require(extendedMovieFieldFrom)
}

// SetRating sets the Rating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetRating(rating float64) {
	e.Rating = rating
	e.require(extendedMovieFieldRating)
}

// SetTag sets the Tag field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetTag(tag commons.Tag) {
	e.Tag = tag
	e.require(extendedMovieFieldTag)
}

// SetBook sets the Book field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetBook(book *string) {
	e.Book = book
	e.require(extendedMovieFieldBook)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetMetadata(metadata map[string]interface{}) {
	e.Metadata = metadata
	e.require(extendedMovieFieldMetadata)
}

// SetRevenue sets the Revenue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetRevenue(revenue int64) {
	e.Revenue = revenue
	e.require(extendedMovieFieldRevenue)
}

// SetCast sets the Cast field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExtendedMovie) SetCast(cast []string) {
	e.Cast = cast
	e.require(extendedMovieFieldCast)
}

func (e *ExtendedMovie) UnmarshalJSON(data []byte) error {
	type embed ExtendedMovie
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExtendedMovie(unmarshaler.embed)
	if unmarshaler.Type != "movie" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "movie", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExtendedMovie) MarshalJSON() ([]byte, error) {
	type embed ExtendedMovie
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "movie",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExtendedMovie) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	fileFieldName     = big.NewInt(1 << 0)
	fileFieldContents = big.NewInt(1 << 1)
)

type File struct {
	Name     string `json:"name" url:"name"`
	Contents string `json:"contents" url:"contents"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (f *File) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *File) GetContents() string {
	if f == nil {
		return ""
	}
	return f.Contents
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetName(name string) {
	f.Name = name
	f.require(fileFieldName)
}

// SetContents sets the Contents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetContents(contents string) {
	f.Contents = contents
	f.require(fileFieldContents)
}

func (f *File) UnmarshalJSON(data []byte) error {
	type unmarshaler File
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = File(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *File) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Metadata struct {
	Type     string
	Extra    map[string]string
	Tags     []string
	Html     string
	Markdown string
}

func (m *Metadata) GetType() string {
	if m == nil {
		return ""
	}
	return m.Type
}

func (m *Metadata) GetExtra() map[string]string {
	if m == nil {
		return nil
	}
	return m.Extra
}

func (m *Metadata) GetTags() []string {
	if m == nil {
		return nil
	}
	return m.Tags
}

func (m *Metadata) GetHtml() string {
	if m == nil {
		return ""
	}
	return m.Html
}

func (m *Metadata) GetMarkdown() string {
	if m == nil {
		return ""
	}
	return m.Markdown
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type  string            `json:"type"`
		Extra map[string]string `json:"extra"`
		Tags  []string          `json:"tags"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	m.Type = unmarshaler.Type
	m.Extra = unmarshaler.Extra
	m.Tags = unmarshaler.Tags
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", m)
	}
	switch unmarshaler.Type {
	case "html":
		var valueUnmarshaler struct {
			Html string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		m.Html = valueUnmarshaler.Html
	case "markdown":
		var valueUnmarshaler struct {
			Markdown string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		m.Markdown = valueUnmarshaler.Markdown
	}
	return nil
}

func (m Metadata) MarshalJSON() ([]byte, error) {
	if err := m.validate(); err != nil {
		return nil, err
	}
	if m.Html != "" {
		var marshaler = struct {
			Type  string            `json:"type"`
			Extra map[string]string `json:"extra"`
			Tags  []string          `json:"tags"`
			Html  string            `json:"value"`
		}{
			Type:  "html",
			Extra: m.Extra,
			Tags:  m.Tags,
			Html:  m.Html,
		}
		return json.Marshal(marshaler)
	}
	if m.Markdown != "" {
		var marshaler = struct {
			Type     string            `json:"type"`
			Extra    map[string]string `json:"extra"`
			Tags     []string          `json:"tags"`
			Markdown string            `json:"value"`
		}{
			Type:     "markdown",
			Extra:    m.Extra,
			Tags:     m.Tags,
			Markdown: m.Markdown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", m)
}

type MetadataVisitor interface {
	VisitHtml(string) error
	VisitMarkdown(string) error
}

func (m *Metadata) Accept(visitor MetadataVisitor) error {
	if m.Html != "" {
		return visitor.VisitHtml(m.Html)
	}
	if m.Markdown != "" {
		return visitor.VisitMarkdown(m.Markdown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", m)
}

func (m *Metadata) validate() error {
	if m == nil {
		return fmt.Errorf("type %T is nil", m)
	}
	var fields []string
	if m.Html != "" {
		fields = append(fields, "html")
	}
	if m.Markdown != "" {
		fields = append(fields, "markdown")
	}
	if len(fields) == 0 {
		if m.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", m, m.Type)
		}
		return fmt.Errorf("type %T is empty", m)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", m, fields)
	}
	if m.Type != "" {
		field := fields[0]
		if m.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				m,
				m.Type,
				m,
			)
		}
	}
	return nil
}

var (
	migrationFieldName   = big.NewInt(1 << 0)
	migrationFieldStatus = big.NewInt(1 << 1)
)

type Migration struct {
	Name   string          `json:"name" url:"name"`
	Status MigrationStatus `json:"status" url:"status"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *Migration) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *Migration) GetStatus() MigrationStatus {
	if m == nil {
		return ""
	}
	return m.Status
}

func (m *Migration) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Migration) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Migration) SetName(name string) {
	m.Name = name
	m.require(migrationFieldName)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Migration) SetStatus(status MigrationStatus) {
	m.Status = status
	m.require(migrationFieldStatus)
}

func (m *Migration) UnmarshalJSON(data []byte) error {
	type unmarshaler Migration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Migration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *Migration) MarshalJSON() ([]byte, error) {
	type embed Migration
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Migration) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MigrationStatus string

const (
	// The migration is running.
	MigrationStatusRunning MigrationStatus = "RUNNING"
	// The migration failed.
	MigrationStatusFailed   MigrationStatus = "FAILED"
	MigrationStatusFinished MigrationStatus = "FINISHED"
)

func NewMigrationStatusFromString(s string) (MigrationStatus, error) {
	switch s {
	case "RUNNING":
		return MigrationStatusRunning, nil
	case "FAILED":
		return MigrationStatusFailed, nil
	case "FINISHED":
		return MigrationStatusFinished, nil
	}
	var t MigrationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MigrationStatus) Ptr() *MigrationStatus {
	return &m
}

var (
	momentFieldId       = big.NewInt(1 << 0)
	momentFieldDate     = big.NewInt(1 << 1)
	momentFieldDatetime = big.NewInt(1 << 2)
)

type Moment struct {
	Id       uuid.UUID `json:"id" url:"id"`
	Date     time.Time `json:"date" url:"date" format:"date"`
	Datetime time.Time `json:"datetime" url:"datetime"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *Moment) GetId() uuid.UUID {
	if m == nil {
		return uuid.Nil
	}
	return m.Id
}

func (m *Moment) GetDate() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Date
}

func (m *Moment) GetDatetime() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Datetime
}

func (m *Moment) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Moment) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Moment) SetId(id uuid.UUID) {
	m.Id = id
	m.require(momentFieldId)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Moment) SetDate(date time.Time) {
	m.Date = date
	m.require(momentFieldDate)
}

// SetDatetime sets the Datetime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Moment) SetDatetime(datetime time.Time) {
	m.Datetime = datetime
	m.require(momentFieldDatetime)
}

func (m *Moment) UnmarshalJSON(data []byte) error {
	type embed Moment
	var unmarshaler = struct {
		embed
		Date     *internal.Date     `json:"date"`
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Moment(unmarshaler.embed)
	m.Date = unmarshaler.Date.Time()
	m.Datetime = unmarshaler.Datetime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *Moment) MarshalJSON() ([]byte, error) {
	type embed Moment
	var marshaler = struct {
		embed
		Date     *internal.Date     `json:"date"`
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed:    embed(*m),
		Date:     internal.NewDate(m.Date),
		Datetime: internal.NewDateTime(m.Datetime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Moment) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	movieFieldId       = big.NewInt(1 << 0)
	movieFieldPrequel  = big.NewInt(1 << 1)
	movieFieldTitle    = big.NewInt(1 << 2)
	movieFieldFrom     = big.NewInt(1 << 3)
	movieFieldRating   = big.NewInt(1 << 4)
	movieFieldTag      = big.NewInt(1 << 5)
	movieFieldBook     = big.NewInt(1 << 6)
	movieFieldMetadata = big.NewInt(1 << 7)
	movieFieldRevenue  = big.NewInt(1 << 8)
)

type Movie struct {
	Id      MovieId  `json:"id" url:"id"`
	Prequel *MovieId `json:"prequel,omitempty" url:"prequel,omitempty"`
	Title   string   `json:"title" url:"title"`
	From    string   `json:"from" url:"from"`
	// The rating scale is one to five stars
	Rating   float64                `json:"rating" url:"rating"`
	Tag      commons.Tag            `json:"tag" url:"tag"`
	Book     *string                `json:"book,omitempty" url:"book,omitempty"`
	Metadata map[string]interface{} `json:"metadata" url:"metadata"`
	Revenue  int64                  `json:"revenue" url:"revenue"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
}

func (m *Movie) GetId() MovieId {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *Movie) GetPrequel() *MovieId {
	if m == nil {
		return nil
	}
	return m.Prequel
}

func (m *Movie) GetTitle() string {
	if m == nil {
		return ""
	}
	return m.Title
}

func (m *Movie) GetFrom() string {
	if m == nil {
		return ""
	}
	return m.From
}

func (m *Movie) GetRating() float64 {
	if m == nil {
		return 0
	}
	return m.Rating
}

func (m *Movie) GetTag() commons.Tag {
	if m == nil {
		return ""
	}
	return m.Tag
}

func (m *Movie) GetBook() *string {
	if m == nil {
		return nil
	}
	return m.Book
}

func (m *Movie) GetMetadata() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *Movie) GetRevenue() int64 {
	if m == nil {
		return 0
	}
	return m.Revenue
}

func (m *Movie) Type() string {
	return m.type_
}

func (m *Movie) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Movie) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetId(id MovieId) {
	m.Id = id
	m.require(movieFieldId)
}

// SetPrequel sets the Prequel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetPrequel(prequel *MovieId) {
	m.Prequel = prequel
	m.require(movieFieldPrequel)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetTitle(title string) {
	m.Title = title
	m.require(movieFieldTitle)
}

// SetFrom sets the From field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetFrom(from string) {
	m.From = from
	m.require(movieFieldFrom)
}

// SetRating sets the Rating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetRating(rating float64) {
	m.Rating = rating
	m.require(movieFieldRating)
}

// SetTag sets the Tag field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetTag(tag commons.Tag) {
	m.Tag = tag
	m.require(movieFieldTag)
}

// SetBook sets the Book field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetBook(book *string) {
	m.Book = book
	m.require(movieFieldBook)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetMetadata(metadata map[string]interface{}) {
	m.Metadata = metadata
	m.require(movieFieldMetadata)
}

// SetRevenue sets the Revenue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Movie) SetRevenue(revenue int64) {
	m.Revenue = revenue
	m.require(movieFieldRevenue)
}

func (m *Movie) UnmarshalJSON(data []byte) error {
	type embed Movie
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Movie(unmarshaler.embed)
	if unmarshaler.Type != "movie" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "movie", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *Movie) MarshalJSON() ([]byte, error) {
	type embed Movie
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "movie",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Movie) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MovieId = string

var (
	nodeFieldName  = big.NewInt(1 << 0)
	nodeFieldNodes = big.NewInt(1 << 1)
	nodeFieldTrees = big.NewInt(1 << 2)
)

type Node struct {
	Name  string  `json:"name" url:"name"`
	Nodes []*Node `json:"nodes,omitempty" url:"nodes,omitempty"`
	Trees []*Tree `json:"trees,omitempty" url:"trees,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *Node) GetName() string {
	if n == nil {
		return ""
	}
	return n.Name
}

func (n *Node) GetNodes() []*Node {
	if n == nil {
		return nil
	}
	return n.Nodes
}

func (n *Node) GetTrees() []*Tree {
	if n == nil {
		return nil
	}
	return n.Trees
}

func (n *Node) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Node) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Node) SetName(name string) {
	n.Name = name
	n.require(nodeFieldName)
}

// SetNodes sets the Nodes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Node) SetNodes(nodes []*Node) {
	n.Nodes = nodes
	n.require(nodeFieldNodes)
}

// SetTrees sets the Trees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Node) SetTrees(trees []*Tree) {
	n.Trees = trees
	n.require(nodeFieldTrees)
}

func (n *Node) UnmarshalJSON(data []byte) error {
	type unmarshaler Node
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Node(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *Node) MarshalJSON() ([]byte, error) {
	type embed Node
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *Node) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	refreshTokenRequestFieldTtl = big.NewInt(1 << 0)
)

type RefreshTokenRequest struct {
	Ttl int `json:"ttl" url:"ttl"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *RefreshTokenRequest) GetTtl() int {
	if r == nil {
		return 0
	}
	return r.Ttl
}

func (r *RefreshTokenRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefreshTokenRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetTtl sets the Ttl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefreshTokenRequest) SetTtl(ttl int) {
	r.Ttl = ttl
	r.require(refreshTokenRequestFieldTtl)
}

func (r *RefreshTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RefreshTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefreshTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RefreshTokenRequest) MarshalJSON() ([]byte, error) {
	type embed RefreshTokenRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefreshTokenRequest) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	requestFieldRequest = big.NewInt(1 << 0)
)

type Request struct {
	Request interface{} `json:"request" url:"request"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *Request) GetRequest() interface{} {
	if r == nil {
		return nil
	}
	return r.Request
}

func (r *Request) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Request) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Request) SetRequest(request interface{}) {
	r.Request = request
	r.require(requestFieldRequest)
}

func (r *Request) UnmarshalJSON(data []byte) error {
	type unmarshaler Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Request(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *Request) MarshalJSON() ([]byte, error) {
	type embed Request
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *Request) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFieldResponse    = big.NewInt(1 << 0)
	responseFieldIdentifiers = big.NewInt(1 << 1)
)

type Response struct {
	Response    interface{}   `json:"response" url:"response"`
	Identifiers []*Identifier `json:"identifiers" url:"identifiers"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *Response) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *Response) GetIdentifiers() []*Identifier {
	if r == nil {
		return nil
	}
	return r.Identifiers
}

func (r *Response) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Response) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Response) SetResponse(response interface{}) {
	r.Response = response
	r.require(responseFieldResponse)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Response) SetIdentifiers(identifiers []*Identifier) {
	r.Identifiers = identifiers
	r.require(responseFieldIdentifiers)
}

func (r *Response) UnmarshalJSON(data []byte) error {
	type unmarshaler Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *Response) MarshalJSON() ([]byte, error) {
	type embed Response
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *Response) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseTypeFieldType = big.NewInt(1 << 0)
)

type ResponseType struct {
	Type *Type `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *ResponseType) GetType() *Type {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *ResponseType) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseType) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseType) SetType(type_ *Type) {
	r.Type = type_
	r.require(responseTypeFieldType)
}

func (r *ResponseType) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResponseType) MarshalJSON() ([]byte, error) {
	type embed ResponseType
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseType) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	stuntDoubleFieldName             = big.NewInt(1 << 0)
	stuntDoubleFieldActorOrActressId = big.NewInt(1 << 1)
)

type StuntDouble struct {
	Name             string `json:"name" url:"name"`
	ActorOrActressId string `json:"actorOrActressId" url:"actorOrActressId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *StuntDouble) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *StuntDouble) GetActorOrActressId() string {
	if s == nil {
		return ""
	}
	return s.ActorOrActressId
}

func (s *StuntDouble) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StuntDouble) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StuntDouble) SetName(name string) {
	s.Name = name
	s.require(stuntDoubleFieldName)
}

// SetActorOrActressId sets the ActorOrActressId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StuntDouble) SetActorOrActressId(actorOrActressId string) {
	s.ActorOrActressId = actorOrActressId
	s.require(stuntDoubleFieldActorOrActressId)
}

func (s *StuntDouble) UnmarshalJSON(data []byte) error {
	type unmarshaler StuntDouble
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StuntDouble(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StuntDouble) MarshalJSON() ([]byte, error) {
	type embed StuntDouble
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StuntDouble) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Test struct {
	Type string
	And  bool
	Or   bool
}

func (t *Test) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Test) GetAnd() bool {
	if t == nil {
		return false
	}
	return t.And
}

func (t *Test) GetOr() bool {
	if t == nil {
		return false
	}
	return t.Or
}

func (t *Test) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "and":
		var valueUnmarshaler struct {
			And bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.And = valueUnmarshaler.And
	case "or":
		var valueUnmarshaler struct {
			Or bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Or = valueUnmarshaler.Or
	}
	return nil
}

func (t Test) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.And != false {
		var marshaler = struct {
			Type string `json:"type"`
			And  bool   `json:"value"`
		}{
			Type: "and",
			And:  t.And,
		}
		return json.Marshal(marshaler)
	}
	if t.Or != false {
		var marshaler = struct {
			Type string `json:"type"`
			Or   bool   `json:"value"`
		}{
			Type: "or",
			Or:   t.Or,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TestVisitor interface {
	VisitAnd(bool) error
	VisitOr(bool) error
}

func (t *Test) Accept(visitor TestVisitor) error {
	if t.And != false {
		return visitor.VisitAnd(t.And)
	}
	if t.Or != false {
		return visitor.VisitOr(t.Or)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Test) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.And != false {
		fields = append(fields, "and")
	}
	if t.Or != false {
		fields = append(fields, "or")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

var (
	treeFieldNodes = big.NewInt(1 << 0)
)

type Tree struct {
	Nodes []*Node `json:"nodes,omitempty" url:"nodes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (t *Tree) GetNodes() []*Node {
	if t == nil {
		return nil
	}
	return t.Nodes
}

func (t *Tree) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tree) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetNodes sets the Nodes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tree) SetNodes(nodes []*Node) {
	t.Nodes = nodes
	t.require(treeFieldNodes)
}

func (t *Tree) UnmarshalJSON(data []byte) error {
	type unmarshaler Tree
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tree(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *Tree) MarshalJSON() ([]byte, error) {
	type embed Tree
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tree) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

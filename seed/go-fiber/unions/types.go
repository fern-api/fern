// This file was auto-generated by Fern from our API Definition.

package unions

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/unions/fern/internal"
	time "time"
)

type Bar struct {
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (b *Bar) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *Bar) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bar) UnmarshalJSON(data []byte) error {
	type unmarshaler Bar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bar(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *Bar) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Foo struct {
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (f *Foo) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *Foo) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FooExtended struct {
	Name string `json:"name" url:"name"`
	Age  int    `json:"age" url:"age"`

	extraProperties map[string]interface{}
}

func (f *FooExtended) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FooExtended) GetAge() int {
	if f == nil {
		return 0
	}
	return f.Age
}

func (f *FooExtended) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FooExtended) UnmarshalJSON(data []byte) error {
	type unmarshaler FooExtended
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FooExtended(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FooExtended) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is a simple union.
type Union struct {
	Type string
	Foo  *Foo
	Bar  *Bar
}

func NewUnionFromFoo(value *Foo) *Union {
	return &Union{Type: "foo", Foo: value}
}

func NewUnionFromBar(value *Bar) *Union {
	return &Union{Type: "bar", Bar: value}
}

func (u *Union) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *Union) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *Union) GetBar() *Bar {
	if u == nil {
		return nil
	}
	return u.Bar
}

func (u *Union) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		var valueUnmarshaler struct {
			Foo *Foo `json:"foo,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Foo = valueUnmarshaler.Foo
	case "bar":
		var valueUnmarshaler struct {
			Bar *Bar `json:"bar,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Bar = valueUnmarshaler.Bar
	}
	return nil
}

func (u Union) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		var marshaler = struct {
			Type string `json:"type"`
			Foo  *Foo   `json:"foo,omitempty"`
		}{
			Type: "foo",
			Foo:  u.Foo,
		}
		return json.Marshal(marshaler)
	case "bar":
		var marshaler = struct {
			Type string `json:"type"`
			Bar  *Bar   `json:"bar,omitempty"`
		}{
			Type: "bar",
			Bar:  u.Bar,
		}
		return json.Marshal(marshaler)
	}
}

type UnionVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *Union) Accept(visitor UnionVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "bar":
		return visitor.VisitBar(u.Bar)
	}
}

func (u *Union) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Bar != nil {
		fields = append(fields, "bar")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithBaseProperties struct {
	Type    string
	Id      string
	Integer int
	String  string
	Foo     *Foo
}

func NewUnionWithBasePropertiesFromInteger(value int) *UnionWithBaseProperties {
	return &UnionWithBaseProperties{Type: "integer", Integer: value}
}

func NewUnionWithBasePropertiesFromString(value string) *UnionWithBaseProperties {
	return &UnionWithBaseProperties{Type: "string", String: value}
}

func NewUnionWithBasePropertiesFromFoo(value *Foo) *UnionWithBaseProperties {
	return &UnionWithBaseProperties{Type: "foo", Foo: value}
}

func (u *UnionWithBaseProperties) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithBaseProperties) GetId() string {
	if u == nil {
		return ""
	}
	return u.Id
}

func (u *UnionWithBaseProperties) GetInteger() int {
	if u == nil {
		return 0
	}
	return u.Integer
}

func (u *UnionWithBaseProperties) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionWithBaseProperties) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithBaseProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
		Id   string `json:"id"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	u.Id = unmarshaler.Id
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer = valueUnmarshaler.Integer
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String = valueUnmarshaler.String
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	}
	return nil
}

func (u UnionWithBaseProperties) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Id      string `json:"id"`
			Integer int    `json:"value"`
		}{
			Type:    "integer",
			Id:      u.Id,
			Integer: u.Integer,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			Id     string `json:"id"`
			String string `json:"value"`
		}{
			Type:   "string",
			Id:     u.Id,
			String: u.String,
		}
		return json.Marshal(marshaler)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
}

type UnionWithBasePropertiesVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
	VisitFoo(*Foo) error
}

func (u *UnionWithBaseProperties) Accept(visitor UnionWithBasePropertiesVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer":
		return visitor.VisitInteger(u.Integer)
	case "string":
		return visitor.VisitString(u.String)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	}
}

func (u *UnionWithBaseProperties) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Integer != 0 {
		fields = append(fields, "integer")
	}
	if u.String != "" {
		fields = append(fields, "string")
	}
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithDiscriminant struct {
	Type string
	// This is a Foo field.
	Foo *Foo
	Bar *Bar
}

func NewUnionWithDiscriminantFromFoo(value *Foo) *UnionWithDiscriminant {
	return &UnionWithDiscriminant{Type: "foo", Foo: value}
}

func NewUnionWithDiscriminantFromBar(value *Bar) *UnionWithDiscriminant {
	return &UnionWithDiscriminant{Type: "bar", Bar: value}
}

func (u *UnionWithDiscriminant) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithDiscriminant) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithDiscriminant) GetBar() *Bar {
	if u == nil {
		return nil
	}
	return u.Bar
}

func (u *UnionWithDiscriminant) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		var valueUnmarshaler struct {
			Foo *Foo `json:"foo,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Foo = valueUnmarshaler.Foo
	case "bar":
		var valueUnmarshaler struct {
			Bar *Bar `json:"bar,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Bar = valueUnmarshaler.Bar
	}
	return nil
}

func (u UnionWithDiscriminant) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		var marshaler = struct {
			Type string `json:"_type"`
			Foo  *Foo   `json:"foo,omitempty"`
		}{
			Type: "foo",
			Foo:  u.Foo,
		}
		return json.Marshal(marshaler)
	case "bar":
		var marshaler = struct {
			Type string `json:"_type"`
			Bar  *Bar   `json:"bar,omitempty"`
		}{
			Type: "bar",
			Bar:  u.Bar,
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithDiscriminantVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *UnionWithDiscriminant) Accept(visitor UnionWithDiscriminantVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "bar":
		return visitor.VisitBar(u.Bar)
	}
}

func (u *UnionWithDiscriminant) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Bar != nil {
		fields = append(fields, "bar")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithDuplicatePrimitive struct {
	Type     string
	Integer1 int
	Integer2 int
	String1  string
	String2  string
}

func NewUnionWithDuplicatePrimitiveFromInteger1(value int) *UnionWithDuplicatePrimitive {
	return &UnionWithDuplicatePrimitive{Type: "integer1", Integer1: value}
}

func NewUnionWithDuplicatePrimitiveFromInteger2(value int) *UnionWithDuplicatePrimitive {
	return &UnionWithDuplicatePrimitive{Type: "integer2", Integer2: value}
}

func NewUnionWithDuplicatePrimitiveFromString1(value string) *UnionWithDuplicatePrimitive {
	return &UnionWithDuplicatePrimitive{Type: "string1", String1: value}
}

func NewUnionWithDuplicatePrimitiveFromString2(value string) *UnionWithDuplicatePrimitive {
	return &UnionWithDuplicatePrimitive{Type: "string2", String2: value}
}

func (u *UnionWithDuplicatePrimitive) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithDuplicatePrimitive) GetInteger1() int {
	if u == nil {
		return 0
	}
	return u.Integer1
}

func (u *UnionWithDuplicatePrimitive) GetInteger2() int {
	if u == nil {
		return 0
	}
	return u.Integer2
}

func (u *UnionWithDuplicatePrimitive) GetString1() string {
	if u == nil {
		return ""
	}
	return u.String1
}

func (u *UnionWithDuplicatePrimitive) GetString2() string {
	if u == nil {
		return ""
	}
	return u.String2
}

func (u *UnionWithDuplicatePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "integer1":
		var valueUnmarshaler struct {
			Integer1 int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer1 = valueUnmarshaler.Integer1
	case "integer2":
		var valueUnmarshaler struct {
			Integer2 int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer2 = valueUnmarshaler.Integer2
	case "string1":
		var valueUnmarshaler struct {
			String1 string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String1 = valueUnmarshaler.String1
	case "string2":
		var valueUnmarshaler struct {
			String2 string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String2 = valueUnmarshaler.String2
	}
	return nil
}

func (u UnionWithDuplicatePrimitive) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer1":
		var marshaler = struct {
			Type     string `json:"type"`
			Integer1 int    `json:"value"`
		}{
			Type:     "integer1",
			Integer1: u.Integer1,
		}
		return json.Marshal(marshaler)
	case "integer2":
		var marshaler = struct {
			Type     string `json:"type"`
			Integer2 int    `json:"value"`
		}{
			Type:     "integer2",
			Integer2: u.Integer2,
		}
		return json.Marshal(marshaler)
	case "string1":
		var marshaler = struct {
			Type    string `json:"type"`
			String1 string `json:"value"`
		}{
			Type:    "string1",
			String1: u.String1,
		}
		return json.Marshal(marshaler)
	case "string2":
		var marshaler = struct {
			Type    string `json:"type"`
			String2 string `json:"value"`
		}{
			Type:    "string2",
			String2: u.String2,
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithDuplicatePrimitiveVisitor interface {
	VisitInteger1(int) error
	VisitInteger2(int) error
	VisitString1(string) error
	VisitString2(string) error
}

func (u *UnionWithDuplicatePrimitive) Accept(visitor UnionWithDuplicatePrimitiveVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer1":
		return visitor.VisitInteger1(u.Integer1)
	case "integer2":
		return visitor.VisitInteger2(u.Integer2)
	case "string1":
		return visitor.VisitString1(u.String1)
	case "string2":
		return visitor.VisitString2(u.String2)
	}
}

func (u *UnionWithDuplicatePrimitive) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Integer1 != 0 {
		fields = append(fields, "integer1")
	}
	if u.Integer2 != 0 {
		fields = append(fields, "integer2")
	}
	if u.String1 != "" {
		fields = append(fields, "string1")
	}
	if u.String2 != "" {
		fields = append(fields, "string2")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithDuplicateTypes struct {
	Type string
	Foo1 *Foo
	Foo2 *Foo
}

func NewUnionWithDuplicateTypesFromFoo1(value *Foo) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{Type: "foo1", Foo1: value}
}

func NewUnionWithDuplicateTypesFromFoo2(value *Foo) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{Type: "foo2", Foo2: value}
}

func (u *UnionWithDuplicateTypes) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithDuplicateTypes) GetFoo1() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo1
}

func (u *UnionWithDuplicateTypes) GetFoo2() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo2
}

func (u *UnionWithDuplicateTypes) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo1":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo1 = value
	case "foo2":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo2 = value
	}
	return nil
}

func (u UnionWithDuplicateTypes) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo1":
		return internal.MarshalJSONWithExtraProperty(u.Foo1, "type", "foo1")
	case "foo2":
		return internal.MarshalJSONWithExtraProperty(u.Foo2, "type", "foo2")
	}
}

type UnionWithDuplicateTypesVisitor interface {
	VisitFoo1(*Foo) error
	VisitFoo2(*Foo) error
}

func (u *UnionWithDuplicateTypes) Accept(visitor UnionWithDuplicateTypesVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo1":
		return visitor.VisitFoo1(u.Foo1)
	case "foo2":
		return visitor.VisitFoo2(u.Foo2)
	}
}

func (u *UnionWithDuplicateTypes) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo1 != nil {
		fields = append(fields, "foo1")
	}
	if u.Foo2 != nil {
		fields = append(fields, "foo2")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithLiteral struct {
	Type string
	fern string
	base string
}

func NewUnionWithLiteralWithFern() *UnionWithLiteral {
	return &UnionWithLiteral{Type: "fern", fern: "fern"}
}

func (u *UnionWithLiteral) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithLiteral) Base() string {
	if u == nil {
		return ""
	}
	return u.base
}

func (u *UnionWithLiteral) Fern() string {
	if u == nil {
		return ""
	}
	return u.fern
}

func (u *UnionWithLiteral) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
		Base string `json:"base,omitempty"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Base != "base" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "base", unmarshaler.Base)
	}
	u.base = unmarshaler.Base
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "fern":
		var valueUnmarshaler struct {
			Fern string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		if valueUnmarshaler.Fern != "fern" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "fern", valueUnmarshaler.Fern)
		}
		u.fern = valueUnmarshaler.Fern
	}
	return nil
}

func (u UnionWithLiteral) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "fern":
		var marshaler = struct {
			Type string `json:"type"`
			Base string `json:"base"`
			Fern string `json:"value,omitempty"`
		}{
			Type: "fern",
			Base: "base",
			Fern: "fern",
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithLiteralVisitor interface {
	VisitFern(string) error
}

func (u *UnionWithLiteral) Accept(visitor UnionWithLiteralVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "fern":
		return visitor.VisitFern(u.fern)
	}
}

func (u *UnionWithLiteral) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.fern != "" {
		fields = append(fields, "fern")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithMultipleNoProperties struct {
	Type   string
	Foo    *Foo
	Empty1 interface{}
	Empty2 interface{}
}

func NewUnionWithMultipleNoPropertiesFromFoo(value *Foo) *UnionWithMultipleNoProperties {
	return &UnionWithMultipleNoProperties{Type: "foo", Foo: value}
}

func NewUnionWithMultipleNoPropertiesFromEmpty1(value interface{}) *UnionWithMultipleNoProperties {
	return &UnionWithMultipleNoProperties{Type: "empty1", Empty1: value}
}

func NewUnionWithMultipleNoPropertiesFromEmpty2(value interface{}) *UnionWithMultipleNoProperties {
	return &UnionWithMultipleNoProperties{Type: "empty2", Empty2: value}
}

func (u *UnionWithMultipleNoProperties) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithMultipleNoProperties) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithMultipleNoProperties) GetEmpty1() interface{} {
	if u == nil {
		return nil
	}
	return u.Empty1
}

func (u *UnionWithMultipleNoProperties) GetEmpty2() interface{} {
	if u == nil {
		return nil
	}
	return u.Empty2
}

func (u *UnionWithMultipleNoProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "empty1":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Empty1 = value
	case "empty2":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Empty2 = value
	}
	return nil
}

func (u UnionWithMultipleNoProperties) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	case "empty1":
		var marshaler = struct {
			Type   string      `json:"type"`
			Empty1 interface{} `json:"empty1,omitempty"`
		}{
			Type:   "empty1",
			Empty1: u.Empty1,
		}
		return json.Marshal(marshaler)
	case "empty2":
		var marshaler = struct {
			Type   string      `json:"type"`
			Empty2 interface{} `json:"empty2,omitempty"`
		}{
			Type:   "empty2",
			Empty2: u.Empty2,
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithMultipleNoPropertiesVisitor interface {
	VisitFoo(*Foo) error
	VisitEmpty1(interface{}) error
	VisitEmpty2(interface{}) error
}

func (u *UnionWithMultipleNoProperties) Accept(visitor UnionWithMultipleNoPropertiesVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "empty1":
		return visitor.VisitEmpty1(u.Empty1)
	case "empty2":
		return visitor.VisitEmpty2(u.Empty2)
	}
}

func (u *UnionWithMultipleNoProperties) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Empty1 != nil {
		fields = append(fields, "empty1")
	}
	if u.Empty2 != nil {
		fields = append(fields, "empty2")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithNoProperties struct {
	Type  string
	Foo   *Foo
	Empty interface{}
}

func NewUnionWithNoPropertiesFromFoo(value *Foo) *UnionWithNoProperties {
	return &UnionWithNoProperties{Type: "foo", Foo: value}
}

func NewUnionWithNoPropertiesFromEmpty(value interface{}) *UnionWithNoProperties {
	return &UnionWithNoProperties{Type: "empty", Empty: value}
}

func (u *UnionWithNoProperties) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithNoProperties) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithNoProperties) GetEmpty() interface{} {
	if u == nil {
		return nil
	}
	return u.Empty
}

func (u *UnionWithNoProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "empty":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Empty = value
	}
	return nil
}

func (u UnionWithNoProperties) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	case "empty":
		var marshaler = struct {
			Type  string      `json:"type"`
			Empty interface{} `json:"empty,omitempty"`
		}{
			Type:  "empty",
			Empty: u.Empty,
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithNoPropertiesVisitor interface {
	VisitFoo(*Foo) error
	VisitEmpty(interface{}) error
}

func (u *UnionWithNoProperties) Accept(visitor UnionWithNoPropertiesVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "empty":
		return visitor.VisitEmpty(u.Empty)
	}
}

func (u *UnionWithNoProperties) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Empty != nil {
		fields = append(fields, "empty")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithOptionalTime struct {
	Type     string
	Date     *time.Time
	Datetime *time.Time
}

func NewUnionWithOptionalTimeFromDate(value *time.Time) *UnionWithOptionalTime {
	return &UnionWithOptionalTime{Type: "date", Date: value}
}

func NewUnionWithOptionalTimeFromDatetime(value *time.Time) *UnionWithOptionalTime {
	return &UnionWithOptionalTime{Type: "datetime", Datetime: value}
}

func (u *UnionWithOptionalTime) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithOptionalTime) GetDate() *time.Time {
	if u == nil {
		return nil
	}
	return u.Date
}

func (u *UnionWithOptionalTime) GetDatetime() *time.Time {
	if u == nil {
		return nil
	}
	return u.Datetime
}

func (u *UnionWithOptionalTime) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "date":
		var valueUnmarshaler struct {
			Date *internal.Date `json:"value,omitempty" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Date = valueUnmarshaler.Date.TimePtr()
	case "datetime":
		var valueUnmarshaler struct {
			Datetime *internal.DateTime `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Datetime = valueUnmarshaler.Datetime.TimePtr()
	}
	return nil
}

func (u UnionWithOptionalTime) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "date":
		var marshaler = struct {
			Type string         `json:"type"`
			Date *internal.Date `json:"value,omitempty" format:"date"`
		}{
			Type: "date",
			Date: internal.NewOptionalDate(u.Date),
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string             `json:"type"`
			Datetime *internal.DateTime `json:"value,omitempty"`
		}{
			Type:     "datetime",
			Datetime: internal.NewOptionalDateTime(u.Datetime),
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithOptionalTimeVisitor interface {
	VisitDate(*time.Time) error
	VisitDatetime(*time.Time) error
}

func (u *UnionWithOptionalTime) Accept(visitor UnionWithOptionalTimeVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "date":
		return visitor.VisitDate(u.Date)
	case "datetime":
		return visitor.VisitDatetime(u.Datetime)
	}
}

func (u *UnionWithOptionalTime) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Date != nil {
		fields = append(fields, "date")
	}
	if u.Datetime != nil {
		fields = append(fields, "datetime")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithPrimitive struct {
	Type    string
	Integer int
	String  string
}

func NewUnionWithPrimitiveFromInteger(value int) *UnionWithPrimitive {
	return &UnionWithPrimitive{Type: "integer", Integer: value}
}

func NewUnionWithPrimitiveFromString(value string) *UnionWithPrimitive {
	return &UnionWithPrimitive{Type: "string", String: value}
}

func (u *UnionWithPrimitive) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithPrimitive) GetInteger() int {
	if u == nil {
		return 0
	}
	return u.Integer
}

func (u *UnionWithPrimitive) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionWithPrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer = valueUnmarshaler.Integer
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String = valueUnmarshaler.String
	}
	return nil
}

func (u UnionWithPrimitive) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"value"`
		}{
			Type:    "integer",
			Integer: u.Integer,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: u.String,
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithPrimitiveVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (u *UnionWithPrimitive) Accept(visitor UnionWithPrimitiveVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "integer":
		return visitor.VisitInteger(u.Integer)
	case "string":
		return visitor.VisitString(u.String)
	}
}

func (u *UnionWithPrimitive) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Integer != 0 {
		fields = append(fields, "integer")
	}
	if u.String != "" {
		fields = append(fields, "string")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithSingleElement struct {
	Type string
	Foo  *Foo
}

func NewUnionWithSingleElementFromFoo(value *Foo) *UnionWithSingleElement {
	return &UnionWithSingleElement{Type: "foo", Foo: value}
}

func (u *UnionWithSingleElement) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithSingleElement) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithSingleElement) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	}
	return nil
}

func (u UnionWithSingleElement) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
}

type UnionWithSingleElementVisitor interface {
	VisitFoo(*Foo) error
}

func (u *UnionWithSingleElement) Accept(visitor UnionWithSingleElementVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	}
}

func (u *UnionWithSingleElement) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithSubTypes struct {
	Type        string
	Foo         *Foo
	FooExtended *FooExtended
}

func NewUnionWithSubTypesFromFoo(value *Foo) *UnionWithSubTypes {
	return &UnionWithSubTypes{Type: "foo", Foo: value}
}

func NewUnionWithSubTypesFromFooExtended(value *FooExtended) *UnionWithSubTypes {
	return &UnionWithSubTypes{Type: "fooExtended", FooExtended: value}
}

func (u *UnionWithSubTypes) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithSubTypes) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithSubTypes) GetFooExtended() *FooExtended {
	if u == nil {
		return nil
	}
	return u.FooExtended
}

func (u *UnionWithSubTypes) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "fooExtended":
		value := new(FooExtended)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.FooExtended = value
	}
	return nil
}

func (u UnionWithSubTypes) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	case "fooExtended":
		return internal.MarshalJSONWithExtraProperty(u.FooExtended, "type", "fooExtended")
	}
}

type UnionWithSubTypesVisitor interface {
	VisitFoo(*Foo) error
	VisitFooExtended(*FooExtended) error
}

func (u *UnionWithSubTypes) Accept(visitor UnionWithSubTypesVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "fooExtended":
		return visitor.VisitFooExtended(u.FooExtended)
	}
}

func (u *UnionWithSubTypes) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.FooExtended != nil {
		fields = append(fields, "fooExtended")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithTime struct {
	Type     string
	Value    int
	Date     time.Time
	Datetime time.Time
}

func NewUnionWithTimeFromValue(value int) *UnionWithTime {
	return &UnionWithTime{Type: "value", Value: value}
}

func NewUnionWithTimeFromDate(value time.Time) *UnionWithTime {
	return &UnionWithTime{Type: "date", Date: value}
}

func NewUnionWithTimeFromDatetime(value time.Time) *UnionWithTime {
	return &UnionWithTime{Type: "datetime", Datetime: value}
}

func (u *UnionWithTime) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithTime) GetValue() int {
	if u == nil {
		return 0
	}
	return u.Value
}

func (u *UnionWithTime) GetDate() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.Date
}

func (u *UnionWithTime) GetDatetime() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.Datetime
}

func (u *UnionWithTime) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "value":
		var valueUnmarshaler struct {
			Value int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Value = valueUnmarshaler.Value
	case "date":
		var valueUnmarshaler struct {
			Date *internal.Date `json:"value" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Date = valueUnmarshaler.Date.Time()
	case "datetime":
		var valueUnmarshaler struct {
			Datetime *internal.DateTime `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Datetime = valueUnmarshaler.Datetime.Time()
	}
	return nil
}

func (u UnionWithTime) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "value":
		var marshaler = struct {
			Type  string `json:"type"`
			Value int    `json:"value"`
		}{
			Type:  "value",
			Value: u.Value,
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string         `json:"type"`
			Date *internal.Date `json:"value" format:"date"`
		}{
			Type: "date",
			Date: internal.NewDate(u.Date),
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string             `json:"type"`
			Datetime *internal.DateTime `json:"value"`
		}{
			Type:     "datetime",
			Datetime: internal.NewDateTime(u.Datetime),
		}
		return json.Marshal(marshaler)
	}
}

type UnionWithTimeVisitor interface {
	VisitValue(int) error
	VisitDate(time.Time) error
	VisitDatetime(time.Time) error
}

func (u *UnionWithTime) Accept(visitor UnionWithTimeVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "value":
		return visitor.VisitValue(u.Value)
	case "date":
		return visitor.VisitDate(u.Date)
	case "datetime":
		return visitor.VisitDatetime(u.Datetime)
	}
}

func (u *UnionWithTime) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Value != 0 {
		fields = append(fields, "value")
	}
	if !u.Date.IsZero() {
		fields = append(fields, "date")
	}
	if !u.Datetime.IsZero() {
		fields = append(fields, "datetime")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UnionWithoutKey struct {
	Type string
	Foo  *Foo
	// This is a bar field.
	Bar *Bar
}

func NewUnionWithoutKeyFromFoo(value *Foo) *UnionWithoutKey {
	return &UnionWithoutKey{Type: "foo", Foo: value}
}

func NewUnionWithoutKeyFromBar(value *Bar) *UnionWithoutKey {
	return &UnionWithoutKey{Type: "bar", Bar: value}
}

func (u *UnionWithoutKey) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnionWithoutKey) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UnionWithoutKey) GetBar() *Bar {
	if u == nil {
		return nil
	}
	return u.Bar
}

func (u *UnionWithoutKey) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "bar":
		value := new(Bar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Bar = value
	}
	return nil
}

func (u UnionWithoutKey) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	case "bar":
		return internal.MarshalJSONWithExtraProperty(u.Bar, "type", "bar")
	}
}

type UnionWithoutKeyVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *UnionWithoutKey) Accept(visitor UnionWithoutKeyVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "bar":
		return visitor.VisitBar(u.Bar)
	}
}

func (u *UnionWithoutKey) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Bar != nil {
		fields = append(fields, "bar")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

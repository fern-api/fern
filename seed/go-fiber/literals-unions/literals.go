// Code generated by Fern. DO NOT EDIT.

package literalsunions

import (
	json "encoding/json"
	fmt "fmt"
)

// A string literal.
type LiteralString = string

// An undiscriminated union over a literal.
type UnionOverLiteral struct {
	String        string
	LiteralString LiteralString

	typ string
}

func NewUnionOverLiteralWithLiteralString() *UnionOverLiteral {
	return &UnionOverLiteral{typ: "LiteralString", LiteralString: "literally"}
}

func (u *UnionOverLiteral) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionOverLiteral) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	var valueLiteralString LiteralString
	if err := json.Unmarshal(data, &valueLiteralString); err == nil {
		u.typ = "LiteralString"
		u.LiteralString = valueLiteralString
		if u.LiteralString != "literally" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "literally", valueLiteralString)
		}
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnionOverLiteral) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "LiteralString" || u.LiteralString != "" {
		return json.Marshal("literally")
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UnionOverLiteralVisitor interface {
	VisitString(string) error
	VisitLiteralString(LiteralString) error
}

func (u *UnionOverLiteral) Accept(visitor UnionOverLiteralVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "LiteralString" || u.LiteralString != "" {
		return visitor.VisitLiteralString(u.LiteralString)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

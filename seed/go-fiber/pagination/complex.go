// Code generated by Fern. DO NOT EDIT.

package pagination

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/pagination/fern/internal"
	big "math/big"
)

var (
	conversationFieldFoo = big.NewInt(1 << 0)
)

type Conversation struct {
	Foo string `json:"foo" url:"foo"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (c *Conversation) GetFoo() string {
	if c == nil {
		return ""
	}
	return c.Foo
}

func (c *Conversation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Conversation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetFoo sets the Foo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Conversation) SetFoo(foo string) {
	c.Foo = foo
	c.require(conversationFieldFoo)
}

func (c *Conversation) UnmarshalJSON(data []byte) error {
	type unmarshaler Conversation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Conversation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *Conversation) MarshalJSON() ([]byte, error) {
	type embed Conversation
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Conversation) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	cursorPagesFieldNext       = big.NewInt(1 << 0)
	cursorPagesFieldPage       = big.NewInt(1 << 1)
	cursorPagesFieldPerPage    = big.NewInt(1 << 2)
	cursorPagesFieldTotalPages = big.NewInt(1 << 3)
)

type CursorPages struct {
	Next       *StartingAfterPaging `json:"next,omitempty" url:"next,omitempty"`
	Page       *int                 `json:"page,omitempty" url:"page,omitempty"`
	PerPage    *int                 `json:"per_page,omitempty" url:"per_page,omitempty"`
	TotalPages *int                 `json:"total_pages,omitempty" url:"total_pages,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
}

func (c *CursorPages) GetNext() *StartingAfterPaging {
	if c == nil {
		return nil
	}
	return c.Next
}

func (c *CursorPages) GetPage() *int {
	if c == nil {
		return nil
	}
	return c.Page
}

func (c *CursorPages) GetPerPage() *int {
	if c == nil {
		return nil
	}
	return c.PerPage
}

func (c *CursorPages) GetTotalPages() *int {
	if c == nil {
		return nil
	}
	return c.TotalPages
}

func (c *CursorPages) Type() string {
	return c.type_
}

func (c *CursorPages) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CursorPages) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CursorPages) SetNext(next *StartingAfterPaging) {
	c.Next = next
	c.require(cursorPagesFieldNext)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CursorPages) SetPage(page *int) {
	c.Page = page
	c.require(cursorPagesFieldPage)
}

// SetPerPage sets the PerPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CursorPages) SetPerPage(perPage *int) {
	c.PerPage = perPage
	c.require(cursorPagesFieldPerPage)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CursorPages) SetTotalPages(totalPages *int) {
	c.TotalPages = totalPages
	c.require(cursorPagesFieldTotalPages)
}

func (c *CursorPages) UnmarshalJSON(data []byte) error {
	type embed CursorPages
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CursorPages(unmarshaler.embed)
	if unmarshaler.Type != "pages" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "pages", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CursorPages) MarshalJSON() ([]byte, error) {
	type embed CursorPages
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "pages",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CursorPages) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	multipleFilterSearchRequestFieldOperator = big.NewInt(1 << 0)
	multipleFilterSearchRequestFieldValue    = big.NewInt(1 << 1)
)

type MultipleFilterSearchRequest struct {
	Operator *MultipleFilterSearchRequestOperator `json:"operator,omitempty" url:"operator,omitempty"`
	Value    *MultipleFilterSearchRequestValue    `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MultipleFilterSearchRequest) GetOperator() *MultipleFilterSearchRequestOperator {
	if m == nil {
		return nil
	}
	return m.Operator
}

func (m *MultipleFilterSearchRequest) GetValue() *MultipleFilterSearchRequestValue {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MultipleFilterSearchRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleFilterSearchRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleFilterSearchRequest) SetOperator(operator *MultipleFilterSearchRequestOperator) {
	m.Operator = operator
	m.require(multipleFilterSearchRequestFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleFilterSearchRequest) SetValue(value *MultipleFilterSearchRequestValue) {
	m.Value = value
	m.require(multipleFilterSearchRequestFieldValue)
}

func (m *MultipleFilterSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleFilterSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleFilterSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleFilterSearchRequest) MarshalJSON() ([]byte, error) {
	type embed MultipleFilterSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultipleFilterSearchRequest) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleFilterSearchRequestOperator string

const (
	MultipleFilterSearchRequestOperatorAnd MultipleFilterSearchRequestOperator = "AND"
	MultipleFilterSearchRequestOperatorOr  MultipleFilterSearchRequestOperator = "OR"
)

func NewMultipleFilterSearchRequestOperatorFromString(s string) (MultipleFilterSearchRequestOperator, error) {
	switch s {
	case "AND":
		return MultipleFilterSearchRequestOperatorAnd, nil
	case "OR":
		return MultipleFilterSearchRequestOperatorOr, nil
	}
	var t MultipleFilterSearchRequestOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MultipleFilterSearchRequestOperator) Ptr() *MultipleFilterSearchRequestOperator {
	return &m
}

type MultipleFilterSearchRequestValue struct {
	MultipleFilterSearchRequestList []*MultipleFilterSearchRequest
	SingleFilterSearchRequestList   []*SingleFilterSearchRequest

	typ string
}

func (m *MultipleFilterSearchRequestValue) GetMultipleFilterSearchRequestList() []*MultipleFilterSearchRequest {
	if m == nil {
		return nil
	}
	return m.MultipleFilterSearchRequestList
}

func (m *MultipleFilterSearchRequestValue) GetSingleFilterSearchRequestList() []*SingleFilterSearchRequest {
	if m == nil {
		return nil
	}
	return m.SingleFilterSearchRequestList
}

func (m *MultipleFilterSearchRequestValue) UnmarshalJSON(data []byte) error {
	var valueMultipleFilterSearchRequestList []*MultipleFilterSearchRequest
	if err := json.Unmarshal(data, &valueMultipleFilterSearchRequestList); err == nil {
		m.typ = "MultipleFilterSearchRequestList"
		m.MultipleFilterSearchRequestList = valueMultipleFilterSearchRequestList
		return nil
	}
	var valueSingleFilterSearchRequestList []*SingleFilterSearchRequest
	if err := json.Unmarshal(data, &valueSingleFilterSearchRequestList); err == nil {
		m.typ = "SingleFilterSearchRequestList"
		m.SingleFilterSearchRequestList = valueSingleFilterSearchRequestList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipleFilterSearchRequestValue) MarshalJSON() ([]byte, error) {
	if m.typ == "MultipleFilterSearchRequestList" || m.MultipleFilterSearchRequestList != nil {
		return json.Marshal(m.MultipleFilterSearchRequestList)
	}
	if m.typ == "SingleFilterSearchRequestList" || m.SingleFilterSearchRequestList != nil {
		return json.Marshal(m.SingleFilterSearchRequestList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MultipleFilterSearchRequestValueVisitor interface {
	VisitMultipleFilterSearchRequestList([]*MultipleFilterSearchRequest) error
	VisitSingleFilterSearchRequestList([]*SingleFilterSearchRequest) error
}

func (m *MultipleFilterSearchRequestValue) Accept(visitor MultipleFilterSearchRequestValueVisitor) error {
	if m.typ == "MultipleFilterSearchRequestList" || m.MultipleFilterSearchRequestList != nil {
		return visitor.VisitMultipleFilterSearchRequestList(m.MultipleFilterSearchRequestList)
	}
	if m.typ == "SingleFilterSearchRequestList" || m.SingleFilterSearchRequestList != nil {
		return visitor.VisitSingleFilterSearchRequestList(m.SingleFilterSearchRequestList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

var (
	paginatedConversationResponseFieldConversations = big.NewInt(1 << 0)
	paginatedConversationResponseFieldPages         = big.NewInt(1 << 1)
	paginatedConversationResponseFieldTotalCount    = big.NewInt(1 << 2)
)

type PaginatedConversationResponse struct {
	Conversations []*Conversation `json:"conversations" url:"conversations"`
	Pages         *CursorPages    `json:"pages,omitempty" url:"pages,omitempty"`
	TotalCount    int             `json:"total_count" url:"total_count"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
}

func (p *PaginatedConversationResponse) GetConversations() []*Conversation {
	if p == nil {
		return nil
	}
	return p.Conversations
}

func (p *PaginatedConversationResponse) GetPages() *CursorPages {
	if p == nil {
		return nil
	}
	return p.Pages
}

func (p *PaginatedConversationResponse) GetTotalCount() int {
	if p == nil {
		return 0
	}
	return p.TotalCount
}

func (p *PaginatedConversationResponse) Type() string {
	return p.type_
}

func (p *PaginatedConversationResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedConversationResponse) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetConversations sets the Conversations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedConversationResponse) SetConversations(conversations []*Conversation) {
	p.Conversations = conversations
	p.require(paginatedConversationResponseFieldConversations)
}

// SetPages sets the Pages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedConversationResponse) SetPages(pages *CursorPages) {
	p.Pages = pages
	p.require(paginatedConversationResponseFieldPages)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedConversationResponse) SetTotalCount(totalCount int) {
	p.TotalCount = totalCount
	p.require(paginatedConversationResponseFieldTotalCount)
}

func (p *PaginatedConversationResponse) UnmarshalJSON(data []byte) error {
	type embed PaginatedConversationResponse
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaginatedConversationResponse(unmarshaler.embed)
	if unmarshaler.Type != "conversation.list" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "conversation.list", unmarshaler.Type)
	}
	p.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PaginatedConversationResponse) MarshalJSON() ([]byte, error) {
	type embed PaginatedConversationResponse
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "conversation.list",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedConversationResponse) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	searchRequestFieldPagination = big.NewInt(1 << 0)
	searchRequestFieldQuery      = big.NewInt(1 << 1)
)

type SearchRequest struct {
	Pagination *StartingAfterPaging `json:"pagination,omitempty" url:"pagination,omitempty"`
	Query      *SearchRequestQuery  `json:"query" url:"query"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SearchRequest) GetPagination() *StartingAfterPaging {
	if s == nil {
		return nil
	}
	return s.Pagination
}

func (s *SearchRequest) GetQuery() *SearchRequestQuery {
	if s == nil {
		return nil
	}
	return s.Query
}

func (s *SearchRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPagination sets the Pagination field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchRequest) SetPagination(pagination *StartingAfterPaging) {
	s.Pagination = pagination
	s.require(searchRequestFieldPagination)
}

// SetQuery sets the Query field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchRequest) SetQuery(query *SearchRequestQuery) {
	s.Query = query
	s.require(searchRequestFieldQuery)
}

func (s *SearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SearchRequest) MarshalJSON() ([]byte, error) {
	type embed SearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchRequest) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchRequestQuery struct {
	SingleFilterSearchRequest   *SingleFilterSearchRequest
	MultipleFilterSearchRequest *MultipleFilterSearchRequest

	typ string
}

func (s *SearchRequestQuery) GetSingleFilterSearchRequest() *SingleFilterSearchRequest {
	if s == nil {
		return nil
	}
	return s.SingleFilterSearchRequest
}

func (s *SearchRequestQuery) GetMultipleFilterSearchRequest() *MultipleFilterSearchRequest {
	if s == nil {
		return nil
	}
	return s.MultipleFilterSearchRequest
}

func (s *SearchRequestQuery) UnmarshalJSON(data []byte) error {
	valueSingleFilterSearchRequest := new(SingleFilterSearchRequest)
	if err := json.Unmarshal(data, &valueSingleFilterSearchRequest); err == nil {
		s.typ = "SingleFilterSearchRequest"
		s.SingleFilterSearchRequest = valueSingleFilterSearchRequest
		return nil
	}
	valueMultipleFilterSearchRequest := new(MultipleFilterSearchRequest)
	if err := json.Unmarshal(data, &valueMultipleFilterSearchRequest); err == nil {
		s.typ = "MultipleFilterSearchRequest"
		s.MultipleFilterSearchRequest = valueMultipleFilterSearchRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestQuery) MarshalJSON() ([]byte, error) {
	if s.typ == "SingleFilterSearchRequest" || s.SingleFilterSearchRequest != nil {
		return json.Marshal(s.SingleFilterSearchRequest)
	}
	if s.typ == "MultipleFilterSearchRequest" || s.MultipleFilterSearchRequest != nil {
		return json.Marshal(s.MultipleFilterSearchRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestQueryVisitor interface {
	VisitSingleFilterSearchRequest(*SingleFilterSearchRequest) error
	VisitMultipleFilterSearchRequest(*MultipleFilterSearchRequest) error
}

func (s *SearchRequestQuery) Accept(visitor SearchRequestQueryVisitor) error {
	if s.typ == "SingleFilterSearchRequest" || s.SingleFilterSearchRequest != nil {
		return visitor.VisitSingleFilterSearchRequest(s.SingleFilterSearchRequest)
	}
	if s.typ == "MultipleFilterSearchRequest" || s.MultipleFilterSearchRequest != nil {
		return visitor.VisitMultipleFilterSearchRequest(s.MultipleFilterSearchRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

var (
	singleFilterSearchRequestFieldField    = big.NewInt(1 << 0)
	singleFilterSearchRequestFieldOperator = big.NewInt(1 << 1)
	singleFilterSearchRequestFieldValue    = big.NewInt(1 << 2)
)

type SingleFilterSearchRequest struct {
	Field    *string                            `json:"field,omitempty" url:"field,omitempty"`
	Operator *SingleFilterSearchRequestOperator `json:"operator,omitempty" url:"operator,omitempty"`
	Value    *string                            `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleFilterSearchRequest) GetField() *string {
	if s == nil {
		return nil
	}
	return s.Field
}

func (s *SingleFilterSearchRequest) GetOperator() *SingleFilterSearchRequestOperator {
	if s == nil {
		return nil
	}
	return s.Operator
}

func (s *SingleFilterSearchRequest) GetValue() *string {
	if s == nil {
		return nil
	}
	return s.Value
}

func (s *SingleFilterSearchRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleFilterSearchRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterSearchRequest) SetField(field *string) {
	s.Field = field
	s.require(singleFilterSearchRequestFieldField)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterSearchRequest) SetOperator(operator *SingleFilterSearchRequestOperator) {
	s.Operator = operator
	s.require(singleFilterSearchRequestFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleFilterSearchRequest) SetValue(value *string) {
	s.Value = value
	s.require(singleFilterSearchRequestFieldValue)
}

func (s *SingleFilterSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleFilterSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleFilterSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleFilterSearchRequest) MarshalJSON() ([]byte, error) {
	type embed SingleFilterSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleFilterSearchRequest) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleFilterSearchRequestOperator string

const (
	SingleFilterSearchRequestOperatorEquals         SingleFilterSearchRequestOperator = "="
	SingleFilterSearchRequestOperatorNotEquals      SingleFilterSearchRequestOperator = "!="
	SingleFilterSearchRequestOperatorIn             SingleFilterSearchRequestOperator = "IN"
	SingleFilterSearchRequestOperatorNotIn          SingleFilterSearchRequestOperator = "NIN"
	SingleFilterSearchRequestOperatorLessThan       SingleFilterSearchRequestOperator = "<"
	SingleFilterSearchRequestOperatorGreaterThan    SingleFilterSearchRequestOperator = ">"
	SingleFilterSearchRequestOperatorContains       SingleFilterSearchRequestOperator = "~"
	SingleFilterSearchRequestOperatorDoesNotContain SingleFilterSearchRequestOperator = "!~"
	SingleFilterSearchRequestOperatorStartsWith     SingleFilterSearchRequestOperator = "^"
	SingleFilterSearchRequestOperatorEndsWith       SingleFilterSearchRequestOperator = "$"
)

func NewSingleFilterSearchRequestOperatorFromString(s string) (SingleFilterSearchRequestOperator, error) {
	switch s {
	case "=":
		return SingleFilterSearchRequestOperatorEquals, nil
	case "!=":
		return SingleFilterSearchRequestOperatorNotEquals, nil
	case "IN":
		return SingleFilterSearchRequestOperatorIn, nil
	case "NIN":
		return SingleFilterSearchRequestOperatorNotIn, nil
	case "<":
		return SingleFilterSearchRequestOperatorLessThan, nil
	case ">":
		return SingleFilterSearchRequestOperatorGreaterThan, nil
	case "~":
		return SingleFilterSearchRequestOperatorContains, nil
	case "!~":
		return SingleFilterSearchRequestOperatorDoesNotContain, nil
	case "^":
		return SingleFilterSearchRequestOperatorStartsWith, nil
	case "$":
		return SingleFilterSearchRequestOperatorEndsWith, nil
	}
	var t SingleFilterSearchRequestOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleFilterSearchRequestOperator) Ptr() *SingleFilterSearchRequestOperator {
	return &s
}

var (
	startingAfterPagingFieldPerPage       = big.NewInt(1 << 0)
	startingAfterPagingFieldStartingAfter = big.NewInt(1 << 1)
)

type StartingAfterPaging struct {
	PerPage       int     `json:"per_page" url:"per_page"`
	StartingAfter *string `json:"starting_after,omitempty" url:"starting_after,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *StartingAfterPaging) GetPerPage() int {
	if s == nil {
		return 0
	}
	return s.PerPage
}

func (s *StartingAfterPaging) GetStartingAfter() *string {
	if s == nil {
		return nil
	}
	return s.StartingAfter
}

func (s *StartingAfterPaging) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartingAfterPaging) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPerPage sets the PerPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StartingAfterPaging) SetPerPage(perPage int) {
	s.PerPage = perPage
	s.require(startingAfterPagingFieldPerPage)
}

// SetStartingAfter sets the StartingAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StartingAfterPaging) SetStartingAfter(startingAfter *string) {
	s.StartingAfter = startingAfter
	s.require(startingAfterPagingFieldStartingAfter)
}

func (s *StartingAfterPaging) UnmarshalJSON(data []byte) error {
	type unmarshaler StartingAfterPaging
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartingAfterPaging(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StartingAfterPaging) MarshalJSON() ([]byte, error) {
	type embed StartingAfterPaging
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StartingAfterPaging) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Code generated by Fern. DO NOT EDIT.

package pagination

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	internal "github.com/pagination/fern/internal"
	big "math/big"
)

type ListUsernamesRequest struct {
	// The cursor used for pagination in order to fetch
	// the next page of results.
	StartingAfter *string `query:"starting_after"`
}

type ListUsernamesWithOptionalResponseRequest struct {
	// The cursor used for pagination in order to fetch
	// the next page of results.
	StartingAfter *string `query:"starting_after"`
}

type ListUsersBodyCursorPaginationRequest struct {
	// The object that contains the cursor used for pagination
	// in order to fetch the next page of results.
	Pagination *WithCursor `json:"pagination,omitempty" url:"-"`
}

type ListUsersBodyOffsetPaginationRequest struct {
	// The object that contains the offset used for pagination
	// in order to fetch the next page of results.
	Pagination *WithPage `json:"pagination,omitempty" url:"-"`
}

type ListUsersCursorPaginationRequest struct {
	// Defaults to first page
	Page *int `query:"page"`
	// Defaults to per page
	PerPage *int   `query:"per_page"`
	Order   *Order `query:"order"`
	// The cursor used for pagination in order to fetch
	// the next page of results.
	StartingAfter *string `query:"starting_after"`
}

type ListUsersDoubleOffsetPaginationRequest struct {
	// Defaults to first page
	Page *float64 `query:"page"`
	// Defaults to per page
	PerPage *float64 `query:"per_page"`
	Order   *Order   `query:"order"`
	// The cursor used for pagination in order to fetch
	// the next page of results.
	StartingAfter *string `query:"starting_after"`
}

type ListUsersExtendedRequest struct {
	Cursor *uuid.UUID `query:"cursor"`
}

type ListUsersExtendedRequestForOptionalData struct {
	Cursor *uuid.UUID `query:"cursor"`
}

type ListWithGlobalConfigRequest struct {
	Offset *int `query:"offset"`
}

type ListUsersMixedTypeCursorPaginationRequest struct {
	Cursor *string `query:"cursor"`
}

type ListUsersOffsetPaginationRequest struct {
	// Defaults to first page
	Page *int `query:"page"`
	// Defaults to per page
	PerPage *int   `query:"per_page"`
	Order   *Order `query:"order"`
	// The cursor used for pagination in order to fetch
	// the next page of results.
	StartingAfter *string `query:"starting_after"`
}

type ListWithOffsetPaginationHasNextPageRequest struct {
	// Defaults to first page
	Page *int `query:"page"`
	// The maximum number of elements to return.
	// This is also used as the step size in this
	// paginated endpoint.
	Limit *int   `query:"limit"`
	Order *Order `query:"order"`
}

type ListUsersOffsetStepPaginationRequest struct {
	// Defaults to first page
	Page *int `query:"page"`
	// The maximum number of elements to return.
	// This is also used as the step size in this
	// paginated endpoint.
	Limit *int   `query:"limit"`
	Order *Order `query:"order"`
}

type ListUsersOptionalDataRequest struct {
	// Defaults to first page
	Page *int `query:"page"`
}

var (
	listUsersExtendedOptionalListResponseFieldData       = big.NewInt(1 << 0)
	listUsersExtendedOptionalListResponseFieldNext       = big.NewInt(1 << 1)
	listUsersExtendedOptionalListResponseFieldTotalCount = big.NewInt(1 << 2)
)

type ListUsersExtendedOptionalListResponse struct {
	Data *UserOptionalListContainer `json:"data" url:"data"`
	Next *uuid.UUID                 `json:"next,omitempty" url:"next,omitempty"`
	// The totall number of /users
	TotalCount int `json:"total_count" url:"total_count"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *ListUsersExtendedOptionalListResponse) GetData() *UserOptionalListContainer {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListUsersExtendedOptionalListResponse) GetNext() *uuid.UUID {
	if l == nil {
		return nil
	}
	return l.Next
}

func (l *ListUsersExtendedOptionalListResponse) GetTotalCount() int {
	if l == nil {
		return 0
	}
	return l.TotalCount
}

func (l *ListUsersExtendedOptionalListResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUsersExtendedOptionalListResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedOptionalListResponse) SetData(data *UserOptionalListContainer) {
	l.Data = data
	l.require(listUsersExtendedOptionalListResponseFieldData)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedOptionalListResponse) SetNext(next *uuid.UUID) {
	l.Next = next
	l.require(listUsersExtendedOptionalListResponseFieldNext)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedOptionalListResponse) SetTotalCount(totalCount int) {
	l.TotalCount = totalCount
	l.require(listUsersExtendedOptionalListResponseFieldTotalCount)
}

func (l *ListUsersExtendedOptionalListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUsersExtendedOptionalListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUsersExtendedOptionalListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *ListUsersExtendedOptionalListResponse) MarshalJSON() ([]byte, error) {
	type embed ListUsersExtendedOptionalListResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListUsersExtendedOptionalListResponse) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	listUsersExtendedResponseFieldData       = big.NewInt(1 << 0)
	listUsersExtendedResponseFieldNext       = big.NewInt(1 << 1)
	listUsersExtendedResponseFieldTotalCount = big.NewInt(1 << 2)
)

type ListUsersExtendedResponse struct {
	Data *UserListContainer `json:"data" url:"data"`
	Next *uuid.UUID         `json:"next,omitempty" url:"next,omitempty"`
	// The totall number of /users
	TotalCount int `json:"total_count" url:"total_count"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *ListUsersExtendedResponse) GetData() *UserListContainer {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListUsersExtendedResponse) GetNext() *uuid.UUID {
	if l == nil {
		return nil
	}
	return l.Next
}

func (l *ListUsersExtendedResponse) GetTotalCount() int {
	if l == nil {
		return 0
	}
	return l.TotalCount
}

func (l *ListUsersExtendedResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUsersExtendedResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedResponse) SetData(data *UserListContainer) {
	l.Data = data
	l.require(listUsersExtendedResponseFieldData)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedResponse) SetNext(next *uuid.UUID) {
	l.Next = next
	l.require(listUsersExtendedResponseFieldNext)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersExtendedResponse) SetTotalCount(totalCount int) {
	l.TotalCount = totalCount
	l.require(listUsersExtendedResponseFieldTotalCount)
}

func (l *ListUsersExtendedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUsersExtendedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUsersExtendedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *ListUsersExtendedResponse) MarshalJSON() ([]byte, error) {
	type embed ListUsersExtendedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListUsersExtendedResponse) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	listUsersMixedTypePaginationResponseFieldNext = big.NewInt(1 << 0)
	listUsersMixedTypePaginationResponseFieldData = big.NewInt(1 << 1)
)

type ListUsersMixedTypePaginationResponse struct {
	Next string  `json:"next" url:"next"`
	Data []*User `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *ListUsersMixedTypePaginationResponse) GetNext() string {
	if l == nil {
		return ""
	}
	return l.Next
}

func (l *ListUsersMixedTypePaginationResponse) GetData() []*User {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListUsersMixedTypePaginationResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUsersMixedTypePaginationResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersMixedTypePaginationResponse) SetNext(next string) {
	l.Next = next
	l.require(listUsersMixedTypePaginationResponseFieldNext)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersMixedTypePaginationResponse) SetData(data []*User) {
	l.Data = data
	l.require(listUsersMixedTypePaginationResponseFieldData)
}

func (l *ListUsersMixedTypePaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUsersMixedTypePaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUsersMixedTypePaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *ListUsersMixedTypePaginationResponse) MarshalJSON() ([]byte, error) {
	type embed ListUsersMixedTypePaginationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListUsersMixedTypePaginationResponse) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	listUsersOptionalDataPaginationResponseFieldHasNextPage = big.NewInt(1 << 0)
	listUsersOptionalDataPaginationResponseFieldPage        = big.NewInt(1 << 1)
	listUsersOptionalDataPaginationResponseFieldTotalCount  = big.NewInt(1 << 2)
	listUsersOptionalDataPaginationResponseFieldData        = big.NewInt(1 << 3)
)

type ListUsersOptionalDataPaginationResponse struct {
	HasNextPage *bool `json:"hasNextPage,omitempty" url:"hasNextPage,omitempty"`
	Page        *Page `json:"page,omitempty" url:"page,omitempty"`
	// The totall number of /users
	TotalCount int     `json:"total_count" url:"total_count"`
	Data       []*User `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *ListUsersOptionalDataPaginationResponse) GetHasNextPage() *bool {
	if l == nil {
		return nil
	}
	return l.HasNextPage
}

func (l *ListUsersOptionalDataPaginationResponse) GetPage() *Page {
	if l == nil {
		return nil
	}
	return l.Page
}

func (l *ListUsersOptionalDataPaginationResponse) GetTotalCount() int {
	if l == nil {
		return 0
	}
	return l.TotalCount
}

func (l *ListUsersOptionalDataPaginationResponse) GetData() []*User {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListUsersOptionalDataPaginationResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUsersOptionalDataPaginationResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetHasNextPage sets the HasNextPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersOptionalDataPaginationResponse) SetHasNextPage(hasNextPage *bool) {
	l.HasNextPage = hasNextPage
	l.require(listUsersOptionalDataPaginationResponseFieldHasNextPage)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersOptionalDataPaginationResponse) SetPage(page *Page) {
	l.Page = page
	l.require(listUsersOptionalDataPaginationResponseFieldPage)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersOptionalDataPaginationResponse) SetTotalCount(totalCount int) {
	l.TotalCount = totalCount
	l.require(listUsersOptionalDataPaginationResponseFieldTotalCount)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersOptionalDataPaginationResponse) SetData(data []*User) {
	l.Data = data
	l.require(listUsersOptionalDataPaginationResponseFieldData)
}

func (l *ListUsersOptionalDataPaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUsersOptionalDataPaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUsersOptionalDataPaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *ListUsersOptionalDataPaginationResponse) MarshalJSON() ([]byte, error) {
	type embed ListUsersOptionalDataPaginationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListUsersOptionalDataPaginationResponse) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	listUsersPaginationResponseFieldHasNextPage = big.NewInt(1 << 0)
	listUsersPaginationResponseFieldPage        = big.NewInt(1 << 1)
	listUsersPaginationResponseFieldTotalCount  = big.NewInt(1 << 2)
	listUsersPaginationResponseFieldData        = big.NewInt(1 << 3)
)

type ListUsersPaginationResponse struct {
	HasNextPage *bool `json:"hasNextPage,omitempty" url:"hasNextPage,omitempty"`
	Page        *Page `json:"page,omitempty" url:"page,omitempty"`
	// The totall number of /users
	TotalCount int     `json:"total_count" url:"total_count"`
	Data       []*User `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *ListUsersPaginationResponse) GetHasNextPage() *bool {
	if l == nil {
		return nil
	}
	return l.HasNextPage
}

func (l *ListUsersPaginationResponse) GetPage() *Page {
	if l == nil {
		return nil
	}
	return l.Page
}

func (l *ListUsersPaginationResponse) GetTotalCount() int {
	if l == nil {
		return 0
	}
	return l.TotalCount
}

func (l *ListUsersPaginationResponse) GetData() []*User {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListUsersPaginationResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUsersPaginationResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetHasNextPage sets the HasNextPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersPaginationResponse) SetHasNextPage(hasNextPage *bool) {
	l.HasNextPage = hasNextPage
	l.require(listUsersPaginationResponseFieldHasNextPage)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersPaginationResponse) SetPage(page *Page) {
	l.Page = page
	l.require(listUsersPaginationResponseFieldPage)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersPaginationResponse) SetTotalCount(totalCount int) {
	l.TotalCount = totalCount
	l.require(listUsersPaginationResponseFieldTotalCount)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListUsersPaginationResponse) SetData(data []*User) {
	l.Data = data
	l.require(listUsersPaginationResponseFieldData)
}

func (l *ListUsersPaginationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUsersPaginationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUsersPaginationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *ListUsersPaginationResponse) MarshalJSON() ([]byte, error) {
	type embed ListUsersPaginationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListUsersPaginationResponse) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	nextPageFieldPage          = big.NewInt(1 << 0)
	nextPageFieldStartingAfter = big.NewInt(1 << 1)
)

type NextPage struct {
	Page          int    `json:"page" url:"page"`
	StartingAfter string `json:"starting_after" url:"starting_after"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NextPage) GetPage() int {
	if n == nil {
		return 0
	}
	return n.Page
}

func (n *NextPage) GetStartingAfter() string {
	if n == nil {
		return ""
	}
	return n.StartingAfter
}

func (n *NextPage) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NextPage) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NextPage) SetPage(page int) {
	n.Page = page
	n.require(nextPageFieldPage)
}

// SetStartingAfter sets the StartingAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NextPage) SetStartingAfter(startingAfter string) {
	n.StartingAfter = startingAfter
	n.require(nextPageFieldStartingAfter)
}

func (n *NextPage) UnmarshalJSON(data []byte) error {
	type unmarshaler NextPage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NextPage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NextPage) MarshalJSON() ([]byte, error) {
	type embed NextPage
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NextPage) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Order string

const (
	OrderAsc  Order = "asc"
	OrderDesc Order = "desc"
)

func NewOrderFromString(s string) (Order, error) {
	switch s {
	case "asc":
		return OrderAsc, nil
	case "desc":
		return OrderDesc, nil
	}
	var t Order
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Order) Ptr() *Order {
	return &o
}

var (
	pageFieldPage      = big.NewInt(1 << 0)
	pageFieldNext      = big.NewInt(1 << 1)
	pageFieldPerPage   = big.NewInt(1 << 2)
	pageFieldTotalPage = big.NewInt(1 << 3)
)

type Page struct {
	// The current page
	Page      int       `json:"page" url:"page"`
	Next      *NextPage `json:"next,omitempty" url:"next,omitempty"`
	PerPage   int       `json:"per_page" url:"per_page"`
	TotalPage int       `json:"total_page" url:"total_page"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *Page) GetPage() int {
	if p == nil {
		return 0
	}
	return p.Page
}

func (p *Page) GetNext() *NextPage {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *Page) GetPerPage() int {
	if p == nil {
		return 0
	}
	return p.PerPage
}

func (p *Page) GetTotalPage() int {
	if p == nil {
		return 0
	}
	return p.TotalPage
}

func (p *Page) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Page) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetPage(page int) {
	p.Page = page
	p.require(pageFieldPage)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetNext(next *NextPage) {
	p.Next = next
	p.require(pageFieldNext)
}

// SetPerPage sets the PerPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetPerPage(perPage int) {
	p.PerPage = perPage
	p.require(pageFieldPerPage)
}

// SetTotalPage sets the TotalPage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetTotalPage(totalPage int) {
	p.TotalPage = totalPage
	p.require(pageFieldTotalPage)
}

func (p *Page) UnmarshalJSON(data []byte) error {
	type unmarshaler Page
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Page(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *Page) MarshalJSON() ([]byte, error) {
	type embed Page
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Page) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	userFieldName = big.NewInt(1 << 0)
	userFieldId   = big.NewInt(1 << 1)
)

type User struct {
	Name string `json:"name" url:"name"`
	Id   int    `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *User) GetName() string {
	if u == nil {
		return ""
	}
	return u.Name
}

func (u *User) GetId() int {
	if u == nil {
		return 0
	}
	return u.Id
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetName(name string) {
	u.Name = name
	u.require(userFieldName)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetId(id int) {
	u.Id = id
	u.require(userFieldId)
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *User) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userListContainerFieldUsers = big.NewInt(1 << 0)
)

type UserListContainer struct {
	Users []*User `json:"users" url:"users"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UserListContainer) GetUsers() []*User {
	if u == nil {
		return nil
	}
	return u.Users
}

func (u *UserListContainer) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserListContainer) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetUsers sets the Users field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserListContainer) SetUsers(users []*User) {
	u.Users = users
	u.require(userListContainerFieldUsers)
}

func (u *UserListContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler UserListContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserListContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserListContainer) MarshalJSON() ([]byte, error) {
	type embed UserListContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserListContainer) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userOptionalListContainerFieldUsers = big.NewInt(1 << 0)
)

type UserOptionalListContainer struct {
	Users []*User `json:"users,omitempty" url:"users,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UserOptionalListContainer) GetUsers() []*User {
	if u == nil {
		return nil
	}
	return u.Users
}

func (u *UserOptionalListContainer) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserOptionalListContainer) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetUsers sets the Users field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserOptionalListContainer) SetUsers(users []*User) {
	u.Users = users
	u.require(userOptionalListContainerFieldUsers)
}

func (u *UserOptionalListContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler UserOptionalListContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserOptionalListContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserOptionalListContainer) MarshalJSON() ([]byte, error) {
	type embed UserOptionalListContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserOptionalListContainer) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userOptionalListPageFieldData = big.NewInt(1 << 0)
	userOptionalListPageFieldNext = big.NewInt(1 << 1)
)

type UserOptionalListPage struct {
	Data *UserOptionalListContainer `json:"data" url:"data"`
	Next *uuid.UUID                 `json:"next,omitempty" url:"next,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UserOptionalListPage) GetData() *UserOptionalListContainer {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UserOptionalListPage) GetNext() *uuid.UUID {
	if u == nil {
		return nil
	}
	return u.Next
}

func (u *UserOptionalListPage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserOptionalListPage) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserOptionalListPage) SetData(data *UserOptionalListContainer) {
	u.Data = data
	u.require(userOptionalListPageFieldData)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserOptionalListPage) SetNext(next *uuid.UUID) {
	u.Next = next
	u.require(userOptionalListPageFieldNext)
}

func (u *UserOptionalListPage) UnmarshalJSON(data []byte) error {
	type unmarshaler UserOptionalListPage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserOptionalListPage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserOptionalListPage) MarshalJSON() ([]byte, error) {
	type embed UserOptionalListPage
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserOptionalListPage) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userPageFieldData = big.NewInt(1 << 0)
	userPageFieldNext = big.NewInt(1 << 1)
)

type UserPage struct {
	Data *UserListContainer `json:"data" url:"data"`
	Next *uuid.UUID         `json:"next,omitempty" url:"next,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UserPage) GetData() *UserListContainer {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UserPage) GetNext() *uuid.UUID {
	if u == nil {
		return nil
	}
	return u.Next
}

func (u *UserPage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserPage) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserPage) SetData(data *UserListContainer) {
	u.Data = data
	u.require(userPageFieldData)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserPage) SetNext(next *uuid.UUID) {
	u.Next = next
	u.require(userPageFieldNext)
}

func (u *UserPage) UnmarshalJSON(data []byte) error {
	type unmarshaler UserPage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserPage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserPage) MarshalJSON() ([]byte, error) {
	type embed UserPage
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserPage) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	usernameContainerFieldResults = big.NewInt(1 << 0)
)

type UsernameContainer struct {
	Results []string `json:"results" url:"results"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UsernameContainer) GetResults() []string {
	if u == nil {
		return nil
	}
	return u.Results
}

func (u *UsernameContainer) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsernameContainer) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UsernameContainer) SetResults(results []string) {
	u.Results = results
	u.require(usernameContainerFieldResults)
}

func (u *UsernameContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler UsernameContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsernameContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UsernameContainer) MarshalJSON() ([]byte, error) {
	type embed UsernameContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UsernameContainer) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	withCursorFieldCursor = big.NewInt(1 << 0)
)

type WithCursor struct {
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithCursor) GetCursor() *string {
	if w == nil {
		return nil
	}
	return w.Cursor
}

func (w *WithCursor) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithCursor) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithCursor) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(withCursorFieldCursor)
}

func (w *WithCursor) UnmarshalJSON(data []byte) error {
	type unmarshaler WithCursor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithCursor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithCursor) MarshalJSON() ([]byte, error) {
	type embed WithCursor
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithCursor) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

var (
	withPageFieldPage = big.NewInt(1 << 0)
)

type WithPage struct {
	Page *int `json:"page,omitempty" url:"page,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithPage) GetPage() *int {
	if w == nil {
		return nil
	}
	return w.Page
}

func (w *WithPage) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithPage) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithPage) SetPage(page *int) {
	w.Page = page
	w.require(withPageFieldPage)
}

func (w *WithPage) UnmarshalJSON(data []byte) error {
	type unmarshaler WithPage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithPage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithPage) MarshalJSON() ([]byte, error) {
	type embed WithPage
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithPage) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

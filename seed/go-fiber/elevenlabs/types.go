// This file was auto-generated by Fern from our API Definition.

package elevenlabs

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/elevenlabs/fern/core"
)

type Accent string

const (
	AccentBritish    Accent = "british"
	AccentAmerican   Accent = "american"
	AccentAfrican    Accent = "african"
	AccentAustralian Accent = "australian"
	AccentIndian     Accent = "indian"
)

func NewAccentFromString(s string) (Accent, error) {
	switch s {
	case "british":
		return AccentBritish, nil
	case "american":
		return AccentAmerican, nil
	case "african":
		return AccentAfrican, nil
	case "australian":
		return AccentAustralian, nil
	case "indian":
		return AccentIndian, nil
	}
	var t Accent
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Accent) Ptr() *Accent {
	return &a
}

type AudioNativeGetEmbedCodeResponseModel = interface{}

type AudioOutput struct {
	// A generated partial audio chunk, encoded using the selected output_format, by default this
	// is MP3 encoded as a base64 string.
	Audio *string `json:"audio,omitempty" url:"audio,omitempty"`
	// Indicates if the generation is complete. If set to `True`, `audio` will be null.
	IsFinal             *bool                `json:"isFinal,omitempty" url:"isFinal,omitempty"`
	NormalizedAlignment *NormalizedAlignment `json:"normalizedAlignment,omitempty" url:"normalizedAlignment,omitempty"`

	extraProperties map[string]interface{}
}

func (a *AudioOutput) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AudioOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler AudioOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudioOutput(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	return nil
}

func (a *AudioOutput) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Category string

const (
	CategoryGenerated    Category = "generated"
	CategoryProfessional Category = "professional"
	CategoryHighQuality  Category = "high_quality"
)

func NewCategoryFromString(s string) (Category, error) {
	switch s {
	case "generated":
		return CategoryGenerated, nil
	case "professional":
		return CategoryProfessional, nil
	case "high_quality":
		return CategoryHighQuality, nil
	}
	var t Category
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Category) Ptr() *Category {
	return &c
}

type ChapterSnapshotResponse struct {
	ChapterSnapshotId string `json:"chapter_snapshot_id" url:"chapter_snapshot_id"`
	ProjectId         string `json:"project_id" url:"project_id"`
	ChapterId         string `json:"chapter_id" url:"chapter_id"`
	CreatedAtUnix     int    `json:"created_at_unix" url:"created_at_unix"`
	Name              string `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (c *ChapterSnapshotResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChapterSnapshotResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChapterSnapshotResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChapterSnapshotResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	return nil
}

func (c *ChapterSnapshotResponse) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChapterState string

const (
	ChapterStateDefault    ChapterState = "default"
	ChapterStateConverting ChapterState = "converting"
)

func NewChapterStateFromString(s string) (ChapterState, error) {
	switch s {
	case "default":
		return ChapterStateDefault, nil
	case "converting":
		return ChapterStateConverting, nil
	}
	var t ChapterState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChapterState) Ptr() *ChapterState {
	return &c
}

type ChapterStatisticsResponse struct {
	CharactersUnconverted int `json:"characters_unconverted" url:"characters_unconverted"`
	CharactersConverted   int `json:"characters_converted" url:"characters_converted"`
	ParagraphsConverted   int `json:"paragraphs_converted" url:"paragraphs_converted"`
	ParagraphsUnconverted int `json:"paragraphs_unconverted" url:"paragraphs_unconverted"`

	extraProperties map[string]interface{}
}

func (c *ChapterStatisticsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChapterStatisticsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChapterStatisticsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChapterStatisticsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	return nil
}

func (c *ChapterStatisticsResponse) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloseConnection struct {
	// End the stream with an empty string
	text string

	extraProperties map[string]interface{}
}

func (c *CloseConnection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloseConnection) Text() string {
	return c.text
}

func (c *CloseConnection) UnmarshalJSON(data []byte) error {
	type embed CloseConnection
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CloseConnection(unmarshaler.embed)
	c.text = ""

	extraProperties, err := core.ExtractExtraProperties(data, *c, "text")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	return nil
}

func (c *CloseConnection) MarshalJSON() ([]byte, error) {
	type embed CloseConnection
	var marshaler = struct {
		embed
		Text string `json:"text"`
	}{
		embed: embed(*c),
		Text:  "",
	}
	return json.Marshal(marshaler)
}

func (c *CloseConnection) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Currency string

const (
	CurrencyUsd Currency = "usd"
	CurrencyEur Currency = "eur"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "usd":
		return CurrencyUsd, nil
	case "eur":
		return CurrencyEur, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

type ExtendedSubscriptionResponseModelBillingPeriod string

const (
	ExtendedSubscriptionResponseModelBillingPeriodMonthlyPeriod ExtendedSubscriptionResponseModelBillingPeriod = "monthly_period"
	ExtendedSubscriptionResponseModelBillingPeriodAnnualPeriod  ExtendedSubscriptionResponseModelBillingPeriod = "annual_period"
)

func NewExtendedSubscriptionResponseModelBillingPeriodFromString(s string) (ExtendedSubscriptionResponseModelBillingPeriod, error) {
	switch s {
	case "monthly_period":
		return ExtendedSubscriptionResponseModelBillingPeriodMonthlyPeriod, nil
	case "annual_period":
		return ExtendedSubscriptionResponseModelBillingPeriodAnnualPeriod, nil
	}
	var t ExtendedSubscriptionResponseModelBillingPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExtendedSubscriptionResponseModelBillingPeriod) Ptr() *ExtendedSubscriptionResponseModelBillingPeriod {
	return &e
}

type FeedbackItem struct {
	ThumbsUp        bool    `json:"thumbs_up" url:"thumbs_up"`
	Feedback        string  `json:"feedback" url:"feedback"`
	Emotions        bool    `json:"emotions" url:"emotions"`
	InaccurateClone bool    `json:"inaccurate_clone" url:"inaccurate_clone"`
	Glitches        bool    `json:"glitches" url:"glitches"`
	AudioQuality    bool    `json:"audio_quality" url:"audio_quality"`
	Other           bool    `json:"other" url:"other"`
	ReviewStatus    *string `json:"review_status,omitempty" url:"review_status,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FeedbackItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	return nil
}

func (f *FeedbackItem) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FineTuningResponse struct {
	IsAllowedToFineTune         *bool                          `json:"is_allowed_to_fine_tune,omitempty" url:"is_allowed_to_fine_tune,omitempty"`
	FinetuningState             *FinetuningState               `json:"finetuning_state,omitempty" url:"finetuning_state,omitempty"`
	VerificationFailures        []string                       `json:"verification_failures,omitempty" url:"verification_failures,omitempty"`
	VerificationAttemptsCount   *int                           `json:"verification_attempts_count,omitempty" url:"verification_attempts_count,omitempty"`
	ManualVerificationRequested *bool                          `json:"manual_verification_requested,omitempty" url:"manual_verification_requested,omitempty"`
	Language                    *string                        `json:"language,omitempty" url:"language,omitempty"`
	FinetuningProgress          map[string]float64             `json:"finetuning_progress,omitempty" url:"finetuning_progress,omitempty"`
	Message                     *string                        `json:"message,omitempty" url:"message,omitempty"`
	DatasetDurationSeconds      *float64                       `json:"dataset_duration_seconds,omitempty" url:"dataset_duration_seconds,omitempty"`
	VerificationAttempts        []*VerificationAttemptResponse `json:"verification_attempts,omitempty" url:"verification_attempts,omitempty"`
	SliceIds                    []string                       `json:"slice_ids,omitempty" url:"slice_ids,omitempty"`
	ManualVerification          *ManualVerificationResponse    `json:"manual_verification,omitempty" url:"manual_verification,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FineTuningResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FineTuningResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FineTuningResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FineTuningResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	return nil
}

func (f *FineTuningResponse) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinetuningState string

const (
	FinetuningStateNotStarted FinetuningState = "not_started"
	FinetuningStateQueued     FinetuningState = "queued"
	FinetuningStateFineTuning FinetuningState = "fine_tuning"
	FinetuningStateFineTuned  FinetuningState = "fine_tuned"
	FinetuningStateFailed     FinetuningState = "failed"
	FinetuningStateDelayed    FinetuningState = "delayed"
)

func NewFinetuningStateFromString(s string) (FinetuningState, error) {
	switch s {
	case "not_started":
		return FinetuningStateNotStarted, nil
	case "queued":
		return FinetuningStateQueued, nil
	case "fine_tuning":
		return FinetuningStateFineTuning, nil
	case "fine_tuned":
		return FinetuningStateFineTuned, nil
	case "failed":
		return FinetuningStateFailed, nil
	case "delayed":
		return FinetuningStateDelayed, nil
	}
	var t FinetuningState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinetuningState) Ptr() *FinetuningState {
	return &f
}

type GenerationConfig struct {
	// This is an advanced setting that most users shouldn't need to use. It relates to our
	// generation schedule explained [here](https://elevenlabs.io/docs/api-reference/websockets#understanding-how-our-websockets-buffer-text).
	//
	// Determines the minimum amount of text that needs to be sent and present in our
	// buffer before audio starts being generated. This is to maximise the amount of context available to
	// the model to improve audio quality, whilst balancing latency of the returned audio chunks.
	//
	// The default value is: [120, 160, 250, 290].
	//
	// This means that the first chunk of audio will not be generated until you send text that
	// totals at least 120 characters long. The next chunk of audio will only be generated once a
	// further 160 characters have been sent. The third audio chunk will be generated after the
	// next 250 characters. Then the fourth, and beyond, will be generated in sets of at least 290 characters.
	//
	// Customize this array to suit your needs. If you want to generate audio more frequently
	// to optimise latency, you can reduce the values in the array. Note that setting the values
	// too low may result in lower quality audio. Please test and adjust as needed.
	//
	// Each item should be in the range 50-500.
	ChunkLengthSchedule []float64 `json:"chunk_length_schedule,omitempty" url:"chunk_length_schedule,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GenerationConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerationConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GenerationConfig) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	return nil
}

func (h *HttpValidationError) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type History = interface{}

type HistoryItem struct {
	State         interface{} `json:"state,omitempty" url:"state,omitempty"`
	VoiceCategory interface{} `json:"voice_category,omitempty" url:"voice_category,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HistoryItem) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HistoryItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HistoryItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HistoryItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	return nil
}

func (h *HistoryItem) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InitializeConnection struct {
	// The initial text that must be sent is a blank space.
	VoiceSettings *RealtimeVoiceSettings `json:"voice_settings,omitempty" url:"voice_settings,omitempty"`
	// This property should only be provided in the first message you send.
	GenerationConfig *GenerationConfig `json:"generation_config,omitempty" url:"generation_config,omitempty"`
	// Your ElevenLabs API key. This is a required parameter that should be provided in the first message you send.
	// You can find your API key in the [API Keys section](https://elevenlabs.io/docs/api-reference/websockets#api-keys).
	XiApiKey string `json:"xi-api-key" url:"xi-api-key"`
	text     string

	extraProperties map[string]interface{}
}

func (i *InitializeConnection) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InitializeConnection) Text() string {
	return i.text
}

func (i *InitializeConnection) UnmarshalJSON(data []byte) error {
	type embed InitializeConnection
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InitializeConnection(unmarshaler.embed)
	i.text = " "

	extraProperties, err := core.ExtractExtraProperties(data, *i, "text")
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	return nil
}

func (i *InitializeConnection) MarshalJSON() ([]byte, error) {
	type embed InitializeConnection
	var marshaler = struct {
		embed
		Text string `json:"text"`
	}{
		embed: embed(*i),
		Text:  " ",
	}
	return json.Marshal(marshaler)
}

func (i *InitializeConnection) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Invoice struct {
	AmountDueCents         int `json:"amount_due_cents" url:"amount_due_cents"`
	NextPaymentAttemptUnix int `json:"next_payment_attempt_unix" url:"next_payment_attempt_unix"`

	extraProperties map[string]interface{}
}

func (i *Invoice) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Invoice) UnmarshalJSON(data []byte) error {
	type unmarshaler Invoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Invoice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	return nil
}

func (i *Invoice) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LanguageResponse struct {
	LanguageId string `json:"language_id" url:"language_id"`
	Name       string `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (l *LanguageResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LanguageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LanguageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LanguageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	return nil
}

func (l *LanguageResponse) String() string {
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LibraryVoiceResponse struct {
	PublicOwnerId         string  `json:"public_owner_id" url:"public_owner_id"`
	VoiceId               string  `json:"voice_id" url:"voice_id"`
	DateUnix              int     `json:"date_unix" url:"date_unix"`
	Name                  string  `json:"name" url:"name"`
	Accent                string  `json:"accent" url:"accent"`
	Gender                string  `json:"gender" url:"gender"`
	Age                   string  `json:"age" url:"age"`
	Descriptive           string  `json:"descriptive" url:"descriptive"`
	UseCase               string  `json:"use_case" url:"use_case"`
	Category              string  `json:"category" url:"category"`
	Language              string  `json:"language" url:"language"`
	Description           string  `json:"description" url:"description"`
	PreviewUrl            string  `json:"preview_url" url:"preview_url"`
	UsageCharacterCount1Y int     `json:"usage_character_count_1y" url:"usage_character_count_1y"`
	UsageCharacterCount7D int     `json:"usage_character_count_7d" url:"usage_character_count_7d"`
	ClonedByCount         int     `json:"cloned_by_count" url:"cloned_by_count"`
	Rate                  float64 `json:"rate" url:"rate"`
	FreeUsersAllowed      bool    `json:"free_users_allowed" url:"free_users_allowed"`
	LiveModerationEnabled bool    `json:"live_moderation_enabled" url:"live_moderation_enabled"`
	Featured              bool    `json:"featured" url:"featured"`
	NoticePeriod          *int    `json:"notice_period,omitempty" url:"notice_period,omitempty"`
	InstagramUsername     *string `json:"instagram_username,omitempty" url:"instagram_username,omitempty"`
	TwitterUsername       *string `json:"twitter_username,omitempty" url:"twitter_username,omitempty"`
	YoutubeUsername       *string `json:"youtube_username,omitempty" url:"youtube_username,omitempty"`
	TiktokUsername        *string `json:"tiktok_username,omitempty" url:"tiktok_username,omitempty"`

	extraProperties map[string]interface{}
}

func (l *LibraryVoiceResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LibraryVoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LibraryVoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LibraryVoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	return nil
}

func (l *LibraryVoiceResponse) String() string {
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ManualVerificationFileResponse struct {
	FileId         string `json:"file_id" url:"file_id"`
	FileName       string `json:"file_name" url:"file_name"`
	MimeType       string `json:"mime_type" url:"mime_type"`
	SizeBytes      int    `json:"size_bytes" url:"size_bytes"`
	UploadDateUnix int    `json:"upload_date_unix" url:"upload_date_unix"`

	extraProperties map[string]interface{}
}

func (m *ManualVerificationFileResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ManualVerificationFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ManualVerificationFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ManualVerificationFileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *ManualVerificationFileResponse) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ManualVerificationResponse struct {
	ExtraText       string                            `json:"extra_text" url:"extra_text"`
	RequestTimeUnix int                               `json:"request_time_unix" url:"request_time_unix"`
	Files           []*ManualVerificationFileResponse `json:"files,omitempty" url:"files,omitempty"`

	extraProperties map[string]interface{}
}

func (m *ManualVerificationResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ManualVerificationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ManualVerificationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ManualVerificationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *ManualVerificationResponse) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Alignment information for the generated audio given the input normalized text sequence.
type NormalizedAlignment struct {
	// A list of starting times (in milliseconds) for each character in the normalized text as it
	// corresponds to the audio. For instance, the character 'H' starts at time 0 ms in the audio.
	// Note these times are relative to the returned chunk from the model, and not the
	// full audio response.
	CharStartTimesMs []int `json:"char_start_times_ms,omitempty" url:"char_start_times_ms,omitempty"`
	// A list of durations (in milliseconds) for each character in the normalized text as it
	// corresponds to the audio. For instance, the character 'H' lasts for 3 ms in the audio.
	// Note these times are relative to the returned chunk from the model, and not the
	// full audio response.
	CharsDurationsMs []int `json:"chars_durations_ms,omitempty" url:"chars_durations_ms,omitempty"`
	// A list of characters in the normalized text sequence. For instance, the first character is 'H'.
	// Note that this list may contain spaces, punctuation, and other special characters.
	// The length of this list should be the same as the lengths of `char_start_times_ms` and `chars_durations_ms`.
	Chars []string `json:"chars,omitempty" url:"chars,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NormalizedAlignment) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NormalizedAlignment) UnmarshalJSON(data []byte) error {
	type unmarshaler NormalizedAlignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NormalizedAlignment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NormalizedAlignment) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OptimizeStreamingLatency string

const (
	// Default mode (no latency optimizations)
	OptimizeStreamingLatencyZero OptimizeStreamingLatency = "0"
	// Normal latency optimizations (about 50% of possible latency improvement of option 3)
	OptimizeStreamingLatencyOne OptimizeStreamingLatency = "1"
	// Strong latency optimizations (about 75% of possible latency improvement of option 3)
	OptimizeStreamingLatencyTwo OptimizeStreamingLatency = "2"
	// Max latency optimizations
	OptimizeStreamingLatencyThree OptimizeStreamingLatency = "3"
	// Max latency optimizations, but also with text normalizer turned off for even more latency savings (best latency, but can mispronounce eg numbers and dates).
	OptimizeStreamingLatencyFour OptimizeStreamingLatency = "4"
)

func NewOptimizeStreamingLatencyFromString(s string) (OptimizeStreamingLatency, error) {
	switch s {
	case "0":
		return OptimizeStreamingLatencyZero, nil
	case "1":
		return OptimizeStreamingLatencyOne, nil
	case "2":
		return OptimizeStreamingLatencyTwo, nil
	case "3":
		return OptimizeStreamingLatencyThree, nil
	case "4":
		return OptimizeStreamingLatencyFour, nil
	}
	var t OptimizeStreamingLatency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OptimizeStreamingLatency) Ptr() *OptimizeStreamingLatency {
	return &o
}

type OutputFormat string

const (
	// Output format, mp3 with 22.05kHz sample rate at 32kbps
	OutputFormatMp32205032 OutputFormat = "mp3_22050_32"
	// Output format, mp3 with 44.1kHz sample rate at 32kbps
	OutputFormatMp34410032 OutputFormat = "mp3_44100_32"
	// Output format, mp3 with 44.1kHz sample rate at 64kbps
	OutputFormatMp34410064 OutputFormat = "mp3_44100_64"
	// Output format, mp3 with 44.1kHz sample rate at 96kbps
	OutputFormatMp34410096 OutputFormat = "mp3_44100_96"
	// Default output format, mp3 with 44.1kHz sample rate at 128kbps
	OutputFormatMp344100128 OutputFormat = "mp3_44100_128"
	// Output format, mp3 with 44.1kHz sample rate at 192kbps.
	OutputFormatMp344100192 OutputFormat = "mp3_44100_192"
	// PCM format (S16LE) with 16kHz sample rate.
	OutputFormatPcm16000 OutputFormat = "pcm_16000"
	// PCM format (S16LE) with 22.05kHz sample rate.
	OutputFormatPcm22050 OutputFormat = "pcm_22050"
	// PCM format (S16LE) with 24kHz sample rate.
	OutputFormatPcm24000 OutputFormat = "pcm_24000"
	// PCM format (S16LE) with 44.1kHz sample rate. Requires you to be subscribed to Independent Publisher tier or above.
	OutputFormatPcm44100 OutputFormat = "pcm_44100"
	// Î¼-law format (sometimes written mu-law, often approximated as u-law) with 8kHz sample rate. Note that this format is commonly used for Twilio audio inputs.
	OutputFormatUlaw8000 OutputFormat = "ulaw_8000"
)

func NewOutputFormatFromString(s string) (OutputFormat, error) {
	switch s {
	case "mp3_22050_32":
		return OutputFormatMp32205032, nil
	case "mp3_44100_32":
		return OutputFormatMp34410032, nil
	case "mp3_44100_64":
		return OutputFormatMp34410064, nil
	case "mp3_44100_96":
		return OutputFormatMp34410096, nil
	case "mp3_44100_128":
		return OutputFormatMp344100128, nil
	case "mp3_44100_192":
		return OutputFormatMp344100192, nil
	case "pcm_16000":
		return OutputFormatPcm16000, nil
	case "pcm_22050":
		return OutputFormatPcm22050, nil
	case "pcm_24000":
		return OutputFormatPcm24000, nil
	case "pcm_44100":
		return OutputFormatPcm44100, nil
	case "ulaw_8000":
		return OutputFormatUlaw8000, nil
	}
	var t OutputFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OutputFormat) Ptr() *OutputFormat {
	return &o
}

type ProjectResponse struct {
	ProjectId               string       `json:"project_id" url:"project_id"`
	Name                    string       `json:"name" url:"name"`
	CreateDateUnix          int          `json:"create_date_unix" url:"create_date_unix"`
	DefaultTitleVoiceId     string       `json:"default_title_voice_id" url:"default_title_voice_id"`
	DefaultParagraphVoiceId string       `json:"default_paragraph_voice_id" url:"default_paragraph_voice_id"`
	DefaultModelId          string       `json:"default_model_id" url:"default_model_id"`
	LastConversionDateUnix  int          `json:"last_conversion_date_unix" url:"last_conversion_date_unix"`
	CanBeDownloaded         bool         `json:"can_be_downloaded" url:"can_be_downloaded"`
	Title                   string       `json:"title" url:"title"`
	Author                  string       `json:"author" url:"author"`
	IsbnNumber              string       `json:"isbn_number" url:"isbn_number"`
	VolumeNormalization     bool         `json:"volume_normalization" url:"volume_normalization"`
	State                   ProjectState `json:"state" url:"state"`

	extraProperties map[string]interface{}
}

func (p *ProjectResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *ProjectResponse) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectSnapshotResponse struct {
	ProjectSnapshotId string `json:"project_snapshot_id" url:"project_snapshot_id"`
	ProjectId         string `json:"project_id" url:"project_id"`
	CreatedAtUnix     int    `json:"created_at_unix" url:"created_at_unix"`
	Name              string `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (p *ProjectSnapshotResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectSnapshotResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectSnapshotResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectSnapshotResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *ProjectSnapshotResponse) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectState string

const (
	ProjectStateDefault    ProjectState = "default"
	ProjectStateConverting ProjectState = "converting"
)

func NewProjectStateFromString(s string) (ProjectState, error) {
	switch s {
	case "default":
		return ProjectStateDefault, nil
	case "converting":
		return ProjectStateConverting, nil
	}
	var t ProjectState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProjectState) Ptr() *ProjectState {
	return &p
}

type PronunciationDictionaryAliasRuleRequestModel struct {
	StringToReplace string `json:"string_to_replace" url:"string_to_replace"`
	Alias           string `json:"alias" url:"alias"`

	extraProperties map[string]interface{}
}

func (p *PronunciationDictionaryAliasRuleRequestModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PronunciationDictionaryAliasRuleRequestModel) UnmarshalJSON(data []byte) error {
	type unmarshaler PronunciationDictionaryAliasRuleRequestModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PronunciationDictionaryAliasRuleRequestModel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PronunciationDictionaryAliasRuleRequestModel) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PronunciationDictionaryPhonemeRuleRequestModel struct {
	StringToReplace string `json:"string_to_replace" url:"string_to_replace"`
	Phoneme         string `json:"phoneme" url:"phoneme"`
	Alphabet        string `json:"alphabet" url:"alphabet"`

	extraProperties map[string]interface{}
}

func (p *PronunciationDictionaryPhonemeRuleRequestModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PronunciationDictionaryPhonemeRuleRequestModel) UnmarshalJSON(data []byte) error {
	type unmarshaler PronunciationDictionaryPhonemeRuleRequestModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PronunciationDictionaryPhonemeRuleRequestModel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PronunciationDictionaryPhonemeRuleRequestModel) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PronunciationDictionaryVersionLocator struct {
	PronunciationDictionaryId string `json:"pronunciation_dictionary_id" url:"pronunciation_dictionary_id"`
	VersionId                 string `json:"version_id" url:"version_id"`

	extraProperties map[string]interface{}
}

func (p *PronunciationDictionaryVersionLocator) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PronunciationDictionaryVersionLocator) UnmarshalJSON(data []byte) error {
	type unmarshaler PronunciationDictionaryVersionLocator
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PronunciationDictionaryVersionLocator(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PronunciationDictionaryVersionLocator) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RealtimeVoiceSettings struct {
	// Defines the stability for voice settings.
	Stability float64 `json:"stability" url:"stability"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost float64 `json:"similarity_boost" url:"similarity_boost"`
	// Defines the style for voice settings. This parameter is available on V2+ models.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings. This parameter is available on V2+ models.
	UseSpeakerBoost *bool `json:"use_speaker_boost,omitempty" url:"use_speaker_boost,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RealtimeVoiceSettings) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RealtimeVoiceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler RealtimeVoiceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RealtimeVoiceSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *RealtimeVoiceSettings) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordingResponse struct {
	RecordingId    string `json:"recording_id" url:"recording_id"`
	MimeType       string `json:"mime_type" url:"mime_type"`
	SizeBytes      int    `json:"size_bytes" url:"size_bytes"`
	UploadDateUnix int    `json:"upload_date_unix" url:"upload_date_unix"`
	Transcription  string `json:"transcription" url:"transcription"`

	extraProperties map[string]interface{}
}

func (r *RecordingResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *RecordingResponse) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SendText struct {
	Text string `json:"text" url:"text"`
	// This is an advanced setting that most users shouldn't need to use. It relates to our generation schedule
	// explained [here](#understanding-how-our-websockets-buffer-text).
	//
	// Use this to attempt to immediately trigger the generation of audio, overriding the `chunk_length_schedule`.
	// Unlike flush, `try_trigger_generation` will only generate audio if our
	// buffer contains more than a minimum
	// threshold of characters, this is to ensure a higher quality response from our model.
	//
	// Note that overriding the chunk schedule to generate small amounts of
	// text may result in lower quality audio, therefore, only use this parameter if you
	// really need text to be processed immediately. We generally recommend keeping the default value of
	// `false` and adjusting the `chunk_length_schedule` in the `generation_config` instead.
	TryTriggerGeneration *bool `json:"try_trigger_generation,omitempty" url:"try_trigger_generation,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SendText) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SendText) UnmarshalJSON(data []byte) error {
	type unmarshaler SendText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SendText) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Source string

const (
	SourceTts Source = "TTS"
	SourceSts Source = "STS"
)

func NewSourceFromString(s string) (Source, error) {
	switch s {
	case "TTS":
		return SourceTts, nil
	case "STS":
		return SourceSts, nil
	}
	var t Source
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Source) Ptr() *Source {
	return &s
}

type SpeechHistoryItemResponseModelVoiceCategory string

const (
	SpeechHistoryItemResponseModelVoiceCategoryPremade      SpeechHistoryItemResponseModelVoiceCategory = "premade"
	SpeechHistoryItemResponseModelVoiceCategoryCloned       SpeechHistoryItemResponseModelVoiceCategory = "cloned"
	SpeechHistoryItemResponseModelVoiceCategoryGenerated    SpeechHistoryItemResponseModelVoiceCategory = "generated"
	SpeechHistoryItemResponseModelVoiceCategoryProfessional SpeechHistoryItemResponseModelVoiceCategory = "professional"
)

func NewSpeechHistoryItemResponseModelVoiceCategoryFromString(s string) (SpeechHistoryItemResponseModelVoiceCategory, error) {
	switch s {
	case "premade":
		return SpeechHistoryItemResponseModelVoiceCategoryPremade, nil
	case "cloned":
		return SpeechHistoryItemResponseModelVoiceCategoryCloned, nil
	case "generated":
		return SpeechHistoryItemResponseModelVoiceCategoryGenerated, nil
	case "professional":
		return SpeechHistoryItemResponseModelVoiceCategoryProfessional, nil
	}
	var t SpeechHistoryItemResponseModelVoiceCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpeechHistoryItemResponseModelVoiceCategory) Ptr() *SpeechHistoryItemResponseModelVoiceCategory {
	return &s
}

type SsoProviderDbModel struct {
	ProviderType SsoProviderDbModelProviderType `json:"provider_type" url:"provider_type"`
	ProviderId   string                         `json:"provider_id" url:"provider_id"`
	Domains      []string                       `json:"domains,omitempty" url:"domains,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SsoProviderDbModel) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SsoProviderDbModel) UnmarshalJSON(data []byte) error {
	type unmarshaler SsoProviderDbModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SsoProviderDbModel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SsoProviderDbModel) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SsoProviderDbModelProviderType string

const (
	SsoProviderDbModelProviderTypeSaml SsoProviderDbModelProviderType = "saml"
	SsoProviderDbModelProviderTypeOidc SsoProviderDbModelProviderType = "oidc"
)

func NewSsoProviderDbModelProviderTypeFromString(s string) (SsoProviderDbModelProviderType, error) {
	switch s {
	case "saml":
		return SsoProviderDbModelProviderTypeSaml, nil
	case "oidc":
		return SsoProviderDbModelProviderTypeOidc, nil
	}
	var t SsoProviderDbModelProviderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SsoProviderDbModelProviderType) Ptr() *SsoProviderDbModelProviderType {
	return &s
}

type SubscriptionResponse struct {
	Tier                           string                                 `json:"tier" url:"tier"`
	CharacterCount                 int                                    `json:"character_count" url:"character_count"`
	CharacterLimit                 int                                    `json:"character_limit" url:"character_limit"`
	CanExtendCharacterLimit        bool                                   `json:"can_extend_character_limit" url:"can_extend_character_limit"`
	AllowedToExtendCharacterLimit  bool                                   `json:"allowed_to_extend_character_limit" url:"allowed_to_extend_character_limit"`
	NextCharacterCountResetUnix    int                                    `json:"next_character_count_reset_unix" url:"next_character_count_reset_unix"`
	VoiceLimit                     int                                    `json:"voice_limit" url:"voice_limit"`
	MaxVoiceAddEdits               int                                    `json:"max_voice_add_edits" url:"max_voice_add_edits"`
	VoiceAddEditCounter            int                                    `json:"voice_add_edit_counter" url:"voice_add_edit_counter"`
	ProfessionalVoiceLimit         int                                    `json:"professional_voice_limit" url:"professional_voice_limit"`
	CanExtendVoiceLimit            bool                                   `json:"can_extend_voice_limit" url:"can_extend_voice_limit"`
	CanUseInstantVoiceCloning      bool                                   `json:"can_use_instant_voice_cloning" url:"can_use_instant_voice_cloning"`
	CanUseProfessionalVoiceCloning bool                                   `json:"can_use_professional_voice_cloning" url:"can_use_professional_voice_cloning"`
	Currency                       Currency                               `json:"currency" url:"currency"`
	Status                         SubscriptionStatus                     `json:"status" url:"status"`
	BillingPeriod                  SubscriptionResponseModelBillingPeriod `json:"billing_period" url:"billing_period"`

	extraProperties map[string]interface{}
}

func (s *SubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SubscriptionResponse) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionResponseModelBillingPeriod string

const (
	SubscriptionResponseModelBillingPeriodMonthlyPeriod SubscriptionResponseModelBillingPeriod = "monthly_period"
	SubscriptionResponseModelBillingPeriodAnnualPeriod  SubscriptionResponseModelBillingPeriod = "annual_period"
)

func NewSubscriptionResponseModelBillingPeriodFromString(s string) (SubscriptionResponseModelBillingPeriod, error) {
	switch s {
	case "monthly_period":
		return SubscriptionResponseModelBillingPeriodMonthlyPeriod, nil
	case "annual_period":
		return SubscriptionResponseModelBillingPeriodAnnualPeriod, nil
	}
	var t SubscriptionResponseModelBillingPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionResponseModelBillingPeriod) Ptr() *SubscriptionResponseModelBillingPeriod {
	return &s
}

type SubscriptionStatus string

const (
	SubscriptionStatusTrialing          SubscriptionStatus = "trialing"
	SubscriptionStatusActive            SubscriptionStatus = "active"
	SubscriptionStatusIncomplete        SubscriptionStatus = "incomplete"
	SubscriptionStatusIncompleteExpired SubscriptionStatus = "incomplete_expired"
	SubscriptionStatusPastDue           SubscriptionStatus = "past_due"
	SubscriptionStatusCanceled          SubscriptionStatus = "canceled"
	SubscriptionStatusUnpaid            SubscriptionStatus = "unpaid"
	SubscriptionStatusFree              SubscriptionStatus = "free"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "trialing":
		return SubscriptionStatusTrialing, nil
	case "active":
		return SubscriptionStatusActive, nil
	case "incomplete":
		return SubscriptionStatusIncomplete, nil
	case "incomplete_expired":
		return SubscriptionStatusIncompleteExpired, nil
	case "past_due":
		return SubscriptionStatusPastDue, nil
	case "canceled":
		return SubscriptionStatusCanceled, nil
	case "unpaid":
		return SubscriptionStatusUnpaid, nil
	case "free":
		return SubscriptionStatusFree, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	extraProperties map[string]interface{}
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *ValidationError) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.String != "" {
		return json.Marshal(v.String)
	}
	if v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VerificationAttemptResponse struct {
	Text                string             `json:"text" url:"text"`
	DateUnix            int                `json:"date_unix" url:"date_unix"`
	Accepted            bool               `json:"accepted" url:"accepted"`
	Similarity          float64            `json:"similarity" url:"similarity"`
	LevenshteinDistance float64            `json:"levenshtein_distance" url:"levenshtein_distance"`
	Recording           *RecordingResponse `json:"recording,omitempty" url:"recording,omitempty"`

	extraProperties map[string]interface{}
}

func (v *VerificationAttemptResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VerificationAttemptResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationAttemptResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationAttemptResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VerificationAttemptResponse) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type Voice struct {
	VoiceId                 string                           `json:"voice_id" url:"voice_id"`
	Name                    *string                          `json:"name,omitempty" url:"name,omitempty"`
	Samples                 []*VoiceSample                   `json:"samples,omitempty" url:"samples,omitempty"`
	Category                *string                          `json:"category,omitempty" url:"category,omitempty"`
	FineTuning              *FineTuningResponse              `json:"fine_tuning,omitempty" url:"fine_tuning,omitempty"`
	Labels                  map[string]string                `json:"labels,omitempty" url:"labels,omitempty"`
	Description             *string                          `json:"description,omitempty" url:"description,omitempty"`
	PreviewUrl              *string                          `json:"preview_url,omitempty" url:"preview_url,omitempty"`
	AvailableForTiers       []string                         `json:"available_for_tiers,omitempty" url:"available_for_tiers,omitempty"`
	Settings                *VoiceSettings                   `json:"settings,omitempty" url:"settings,omitempty"`
	Sharing                 *VoiceSharingResponse            `json:"sharing,omitempty" url:"sharing,omitempty"`
	HighQualityBaseModelIds []string                         `json:"high_quality_base_model_ids,omitempty" url:"high_quality_base_model_ids,omitempty"`
	SafetyControl           *VoiceResponseModelSafetyControl `json:"safety_control,omitempty" url:"safety_control,omitempty"`
	VoiceVerification       *VoiceVerificationResponse       `json:"voice_verification,omitempty" url:"voice_verification,omitempty"`
	OwnerId                 *string                          `json:"owner_id,omitempty" url:"owner_id,omitempty"`
	PermissionOnResource    *string                          `json:"permission_on_resource,omitempty" url:"permission_on_resource,omitempty"`

	extraProperties map[string]interface{}
}

func (v *Voice) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Voice) UnmarshalJSON(data []byte) error {
	type unmarshaler Voice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Voice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *Voice) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceGenerationParameterOptionResponse struct {
	Name string `json:"name" url:"name"`
	Code string `json:"code" url:"code"`

	extraProperties map[string]interface{}
}

func (v *VoiceGenerationParameterOptionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceGenerationParameterOptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceGenerationParameterOptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceGenerationParameterOptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceGenerationParameterOptionResponse) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceResponseModelSafetyControl string

const (
	VoiceResponseModelSafetyControlNone                 VoiceResponseModelSafetyControl = "NONE"
	VoiceResponseModelSafetyControlBan                  VoiceResponseModelSafetyControl = "BAN"
	VoiceResponseModelSafetyControlCaptcha              VoiceResponseModelSafetyControl = "CAPTCHA"
	VoiceResponseModelSafetyControlCaptchaAndModeration VoiceResponseModelSafetyControl = "CAPTCHA_AND_MODERATION"
)

func NewVoiceResponseModelSafetyControlFromString(s string) (VoiceResponseModelSafetyControl, error) {
	switch s {
	case "NONE":
		return VoiceResponseModelSafetyControlNone, nil
	case "BAN":
		return VoiceResponseModelSafetyControlBan, nil
	case "CAPTCHA":
		return VoiceResponseModelSafetyControlCaptcha, nil
	case "CAPTCHA_AND_MODERATION":
		return VoiceResponseModelSafetyControlCaptchaAndModeration, nil
	}
	var t VoiceResponseModelSafetyControl
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceResponseModelSafetyControl) Ptr() *VoiceResponseModelSafetyControl {
	return &v
}

type VoiceSample struct {
	SampleId  *string `json:"sample_id,omitempty" url:"sample_id,omitempty"`
	FileName  *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	MimeType  *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	SizeBytes *int    `json:"size_bytes,omitempty" url:"size_bytes,omitempty"`
	Hash      *string `json:"hash,omitempty" url:"hash,omitempty"`

	extraProperties map[string]interface{}
}

func (v *VoiceSample) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceSample) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceSample) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceSettings struct {
	Stability       *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	SimilarityBoost *float64 `json:"similarity_boost,omitempty" url:"similarity_boost,omitempty"`
	Style           *float64 `json:"style,omitempty" url:"style,omitempty"`
	UseSpeakerBoost *bool    `json:"use_speaker_boost,omitempty" url:"use_speaker_boost,omitempty"`

	extraProperties map[string]interface{}
}

func (v *VoiceSettings) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceSettings) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceSharingResponse struct {
	Status                  *VoiceSharingState `json:"status,omitempty" url:"status,omitempty"`
	HistoryItemSampleId     *string            `json:"history_item_sample_id,omitempty" url:"history_item_sample_id,omitempty"`
	DateUnix                *int               `json:"date_unix,omitempty" url:"date_unix,omitempty"`
	WhitelistedEmails       []string           `json:"whitelisted_emails,omitempty" url:"whitelisted_emails,omitempty"`
	PublicOwnerId           *string            `json:"public_owner_id,omitempty" url:"public_owner_id,omitempty"`
	OriginalVoiceId         *string            `json:"original_voice_id,omitempty" url:"original_voice_id,omitempty"`
	FinancialRewardsEnabled *bool              `json:"financial_rewards_enabled,omitempty" url:"financial_rewards_enabled,omitempty"`
	FreeUsersAllowed        *bool              `json:"free_users_allowed,omitempty" url:"free_users_allowed,omitempty"`
	LiveModerationEnabled   *bool              `json:"live_moderation_enabled,omitempty" url:"live_moderation_enabled,omitempty"`
	Rate                    *float64           `json:"rate,omitempty" url:"rate,omitempty"`
	NoticePeriod            *int               `json:"notice_period,omitempty" url:"notice_period,omitempty"`
	DisableAtUnix           *int               `json:"disable_at_unix,omitempty" url:"disable_at_unix,omitempty"`
	VoiceMixingAllowed      *bool              `json:"voice_mixing_allowed,omitempty" url:"voice_mixing_allowed,omitempty"`
	Featured                *bool              `json:"featured,omitempty" url:"featured,omitempty"`
	Category                *Category          `json:"category,omitempty" url:"category,omitempty"`
	ReaderAppEnabled        *bool              `json:"reader_app_enabled,omitempty" url:"reader_app_enabled,omitempty"`
	BanReason               *string            `json:"ban_reason,omitempty" url:"ban_reason,omitempty"`
	LikedByCount            *int               `json:"liked_by_count,omitempty" url:"liked_by_count,omitempty"`
	ClonedByCount           *int               `json:"cloned_by_count,omitempty" url:"cloned_by_count,omitempty"`
	Name                    *string            `json:"name,omitempty" url:"name,omitempty"`
	Description             *string            `json:"description,omitempty" url:"description,omitempty"`
	Labels                  map[string]string  `json:"labels,omitempty" url:"labels,omitempty"`
	ReviewStatus            *ReviewStatus      `json:"review_status,omitempty" url:"review_status,omitempty"`
	ReviewMessage           *string            `json:"review_message,omitempty" url:"review_message,omitempty"`
	EnabledInLibrary        *bool              `json:"enabled_in_library,omitempty" url:"enabled_in_library,omitempty"`
	InstagramUsername       *string            `json:"instagram_username,omitempty" url:"instagram_username,omitempty"`
	TwitterUsername         *string            `json:"twitter_username,omitempty" url:"twitter_username,omitempty"`
	YoutubeUsername         *string            `json:"youtube_username,omitempty" url:"youtube_username,omitempty"`
	TiktokUsername          *string            `json:"tiktok_username,omitempty" url:"tiktok_username,omitempty"`

	extraProperties map[string]interface{}
}

func (v *VoiceSharingResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceSharingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceSharingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceSharingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceSharingResponse) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceVerificationResponse struct {
	RequiresVerification      bool                           `json:"requires_verification" url:"requires_verification"`
	IsVerified                bool                           `json:"is_verified" url:"is_verified"`
	VerificationFailures      []string                       `json:"verification_failures,omitempty" url:"verification_failures,omitempty"`
	VerificationAttemptsCount int                            `json:"verification_attempts_count" url:"verification_attempts_count"`
	Language                  *string                        `json:"language,omitempty" url:"language,omitempty"`
	VerificationAttempts      []*VerificationAttemptResponse `json:"verification_attempts,omitempty" url:"verification_attempts,omitempty"`

	extraProperties map[string]interface{}
}

func (v *VoiceVerificationResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceVerificationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceVerificationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceVerificationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceVerificationResponse) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ReviewStatus string

const (
	ReviewStatusNotRequested       ReviewStatus = "not_requested"
	ReviewStatusPending            ReviewStatus = "pending"
	ReviewStatusDeclined           ReviewStatus = "declined"
	ReviewStatusAllowed            ReviewStatus = "allowed"
	ReviewStatusAllowedWithChanges ReviewStatus = "allowed_with_changes"
)

func NewReviewStatusFromString(s string) (ReviewStatus, error) {
	switch s {
	case "not_requested":
		return ReviewStatusNotRequested, nil
	case "pending":
		return ReviewStatusPending, nil
	case "declined":
		return ReviewStatusDeclined, nil
	case "allowed":
		return ReviewStatusAllowed, nil
	case "allowed_with_changes":
		return ReviewStatusAllowedWithChanges, nil
	}
	var t ReviewStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReviewStatus) Ptr() *ReviewStatus {
	return &r
}

type VoiceSharingState string

const (
	VoiceSharingStateEnabled        VoiceSharingState = "enabled"
	VoiceSharingStateDisabled       VoiceSharingState = "disabled"
	VoiceSharingStateCopied         VoiceSharingState = "copied"
	VoiceSharingStateCopiedDisabled VoiceSharingState = "copied_disabled"
)

func NewVoiceSharingStateFromString(s string) (VoiceSharingState, error) {
	switch s {
	case "enabled":
		return VoiceSharingStateEnabled, nil
	case "disabled":
		return VoiceSharingStateDisabled, nil
	case "copied":
		return VoiceSharingStateCopied, nil
	case "copied_disabled":
		return VoiceSharingStateCopiedDisabled, nil
	}
	var t VoiceSharingState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceSharingState) Ptr() *VoiceSharingState {
	return &v
}

// Send messages to the WebSocket
type SendMessage struct {
	InitializeConnection *InitializeConnection
	SendText             *SendText
	CloseConnection      *CloseConnection
}

func NewSendMessageFromInitializeConnection(value *InitializeConnection) *SendMessage {
	return &SendMessage{InitializeConnection: value}
}

func NewSendMessageFromSendText(value *SendText) *SendMessage {
	return &SendMessage{SendText: value}
}

func NewSendMessageFromCloseConnection(value *CloseConnection) *SendMessage {
	return &SendMessage{CloseConnection: value}
}

func (s *SendMessage) UnmarshalJSON(data []byte) error {
	valueInitializeConnection := new(InitializeConnection)
	if err := json.Unmarshal(data, &valueInitializeConnection); err == nil {
		s.InitializeConnection = valueInitializeConnection
		return nil
	}
	valueSendText := new(SendText)
	if err := json.Unmarshal(data, &valueSendText); err == nil {
		s.SendText = valueSendText
		return nil
	}
	valueCloseConnection := new(CloseConnection)
	if err := json.Unmarshal(data, &valueCloseConnection); err == nil {
		s.CloseConnection = valueCloseConnection
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SendMessage) MarshalJSON() ([]byte, error) {
	if s.InitializeConnection != nil {
		return json.Marshal(s.InitializeConnection)
	}
	if s.SendText != nil {
		return json.Marshal(s.SendText)
	}
	if s.CloseConnection != nil {
		return json.Marshal(s.CloseConnection)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SendMessageVisitor interface {
	VisitInitializeConnection(*InitializeConnection) error
	VisitSendText(*SendText) error
	VisitCloseConnection(*CloseConnection) error
}

func (s *SendMessage) Accept(visitor SendMessageVisitor) error {
	if s.InitializeConnection != nil {
		return visitor.VisitInitializeConnection(s.InitializeConnection)
	}
	if s.SendText != nil {
		return visitor.VisitSendText(s.SendText)
	}
	if s.CloseConnection != nil {
		return visitor.VisitCloseConnection(s.CloseConnection)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations
from ....core.pydantic_utilities import IS_PYDANTIC_V2
from ....core.pydantic_utilities import UniversalRootModel
import typing
import typing_extensions
import pydantic
from ....core.pydantic_utilities import UniversalBaseModel
from ....core.pydantic_utilities import update_forward_refs

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def integer_1(self, value: int) -> UnionWithDuplicatePrimitive:
        if IS_PYDANTIC_V2:
            return UnionWithDuplicatePrimitive(
                root=_UnionWithDuplicatePrimitive.Integer1(type="integer1", value=value)
            )  # type: ignore
        else:
            return UnionWithDuplicatePrimitive(
                __root__=_UnionWithDuplicatePrimitive.Integer1(
                    type="integer1", value=value
                )
            )  # type: ignore

    def integer_2(self, value: int) -> UnionWithDuplicatePrimitive:
        if IS_PYDANTIC_V2:
            return UnionWithDuplicatePrimitive(
                root=_UnionWithDuplicatePrimitive.Integer2(type="integer2", value=value)
            )  # type: ignore
        else:
            return UnionWithDuplicatePrimitive(
                __root__=_UnionWithDuplicatePrimitive.Integer2(
                    type="integer2", value=value
                )
            )  # type: ignore

    def string_1(self, value: str) -> UnionWithDuplicatePrimitive:
        if IS_PYDANTIC_V2:
            return UnionWithDuplicatePrimitive(
                root=_UnionWithDuplicatePrimitive.String1(type="string1", value=value)
            )  # type: ignore
        else:
            return UnionWithDuplicatePrimitive(
                __root__=_UnionWithDuplicatePrimitive.String1(
                    type="string1", value=value
                )
            )  # type: ignore

    def string_2(self, value: str) -> UnionWithDuplicatePrimitive:
        if IS_PYDANTIC_V2:
            return UnionWithDuplicatePrimitive(
                root=_UnionWithDuplicatePrimitive.String2(type="string2", value=value)
            )  # type: ignore
        else:
            return UnionWithDuplicatePrimitive(
                __root__=_UnionWithDuplicatePrimitive.String2(
                    type="string2", value=value
                )
            )  # type: ignore


class UnionWithDuplicatePrimitive(UniversalRootModel):
    """
    Examples
    --------
    from seed.unions.resources.types import UnionWithDuplicatePrimitive_Integer1

    UnionWithDuplicatePrimitive_Integer1(value=9)
    """

    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _UnionWithDuplicatePrimitive.Integer1,
                _UnionWithDuplicatePrimitive.Integer2,
                _UnionWithDuplicatePrimitive.String1,
                _UnionWithDuplicatePrimitive.String2,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _UnionWithDuplicatePrimitive.Integer1,
            _UnionWithDuplicatePrimitive.Integer2,
            _UnionWithDuplicatePrimitive.String1,
            _UnionWithDuplicatePrimitive.String2,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _UnionWithDuplicatePrimitive.Integer1,
                _UnionWithDuplicatePrimitive.Integer2,
                _UnionWithDuplicatePrimitive.String1,
                _UnionWithDuplicatePrimitive.String2,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _UnionWithDuplicatePrimitive.Integer1,
            _UnionWithDuplicatePrimitive.Integer2,
            _UnionWithDuplicatePrimitive.String1,
            _UnionWithDuplicatePrimitive.String2,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        integer_1: typing.Callable[[int], T_Result],
        integer_2: typing.Callable[[int], T_Result],
        string_1: typing.Callable[[str], T_Result],
        string_2: typing.Callable[[str], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "integer1":
            return integer_1(unioned_value.value)
        if unioned_value.type == "integer2":
            return integer_2(unioned_value.value)
        if unioned_value.type == "string1":
            return string_1(unioned_value.value)
        if unioned_value.type == "string2":
            return string_2(unioned_value.value)


class _UnionWithDuplicatePrimitive:
    class Integer1(UniversalBaseModel):
        type: typing.Literal["integer1"] = "integer1"
        value: int

    class Integer2(UniversalBaseModel):
        type: typing.Literal["integer2"] = "integer2"
        value: int

    class String1(UniversalBaseModel):
        type: typing.Literal["string1"] = "string1"
        value: str

    class String2(UniversalBaseModel):
        type: typing.Literal["string2"] = "string2"
        value: str


update_forward_refs(UnionWithDuplicatePrimitive)

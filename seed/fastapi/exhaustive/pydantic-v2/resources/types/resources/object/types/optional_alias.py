# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
from ......core.pydantic_utilities import universal_root_validator


class OptionalAlias(pydantic.RootModel):
    root: typing.Optional[str]

    def get_as_str(self) -> typing.Optional[str]:
        return self.root

    @staticmethod
    def from_str(value: typing.Optional[str]) -> OptionalAlias:
        return OptionalAlias(root=value)

    class Validators:
        """
        Use this class to add validators to the Pydantic model.

            @OptionalAlias.Validators.validate
            def validate(value: typing.Optional[str]) -> typing.Optional[str]:
                ...
        """

        _validators: typing.ClassVar[typing.List[typing.Callable[[typing.Optional[str]], typing.Optional[str]]]] = []

        @classmethod
        def validate(cls, validator: typing.Callable[[typing.Optional[str]], typing.Optional[str]]) -> None:
            cls._validators.append(validator)

    @universal_root_validator(pre=False)
    def _validate(cls, values: typing.Any) -> typing.Any:
        print(f"DEBUG _validate called! values={values}, type={type(values)}")
        value = values.root
        print(f"DEBUG extracted value={value}")
        for validator in OptionalAlias.Validators._validators:
            print(f"DEBUG calling validator={validator}")
            value = validator(value)
            print(f"DEBUG after validator, value={value}")
        result = cls.model_construct(root=value)
        print(f"DEBUG returning result={result}")
        return result

    model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2

# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ....core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def positive_int(self, value: int) -> UnionWithSameNumberTypes:
        if IS_PYDANTIC_V2:
            return UnionWithSameNumberTypes(root=_UnionWithSameNumberTypes.PositiveInt(type="positiveInt", value=value))  # type: ignore
        else:
            return UnionWithSameNumberTypes(
                __root__=_UnionWithSameNumberTypes.PositiveInt(type="positiveInt", value=value)
            )  # type: ignore

    def negative_int(self, value: int) -> UnionWithSameNumberTypes:
        if IS_PYDANTIC_V2:
            return UnionWithSameNumberTypes(root=_UnionWithSameNumberTypes.NegativeInt(type="negativeInt", value=value))  # type: ignore
        else:
            return UnionWithSameNumberTypes(
                __root__=_UnionWithSameNumberTypes.NegativeInt(type="negativeInt", value=value)
            )  # type: ignore

    def any_number(self, value: float) -> UnionWithSameNumberTypes:
        if IS_PYDANTIC_V2:
            return UnionWithSameNumberTypes(root=_UnionWithSameNumberTypes.AnyNumber(type="anyNumber", value=value))  # type: ignore
        else:
            return UnionWithSameNumberTypes(__root__=_UnionWithSameNumberTypes.AnyNumber(type="anyNumber", value=value))  # type: ignore


class UnionWithSameNumberTypes(UniversalRootModel):
    """
    Examples
    --------
    from seed.unions.resources.types import UnionWithSameNumberTypes_PositiveInt

    UnionWithSameNumberTypes_PositiveInt(value=100)
    """

    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _UnionWithSameNumberTypes.PositiveInt,
                _UnionWithSameNumberTypes.NegativeInt,
                _UnionWithSameNumberTypes.AnyNumber,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _UnionWithSameNumberTypes.PositiveInt,
            _UnionWithSameNumberTypes.NegativeInt,
            _UnionWithSameNumberTypes.AnyNumber,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _UnionWithSameNumberTypes.PositiveInt,
                _UnionWithSameNumberTypes.NegativeInt,
                _UnionWithSameNumberTypes.AnyNumber,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _UnionWithSameNumberTypes.PositiveInt,
            _UnionWithSameNumberTypes.NegativeInt,
            _UnionWithSameNumberTypes.AnyNumber,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        positive_int: typing.Callable[[int], T_Result],
        negative_int: typing.Callable[[int], T_Result],
        any_number: typing.Callable[[float], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "positiveInt":
            return positive_int(unioned_value.value)
        if unioned_value.type == "negativeInt":
            return negative_int(unioned_value.value)
        if unioned_value.type == "anyNumber":
            return any_number(unioned_value.value)


class _UnionWithSameNumberTypes:
    class PositiveInt(UniversalBaseModel):
        type: typing.Literal["positiveInt"] = "positiveInt"
        value: int

    class NegativeInt(UniversalBaseModel):
        type: typing.Literal["negativeInt"] = "negativeInt"
        value: int

    class AnyNumber(UniversalBaseModel):
        type: typing.Literal["anyNumber"] = "anyNumber"
        value: float


update_forward_refs(UnionWithSameNumberTypes)

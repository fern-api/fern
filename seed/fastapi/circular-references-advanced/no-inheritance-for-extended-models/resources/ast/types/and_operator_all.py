# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ....core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs

T_Result = typing.TypeVar("T_Result")
T_Result = typing.TypeVar("T_Result")
T_Result = typing.TypeVar("T_Result")
T_Result = typing.TypeVar("T_Result")
T_Result = typing.TypeVar("T_Result")
T_Result = typing.TypeVar("T_Result")


class AndOperator(UniversalBaseModel):
    """
    Deep circular reference pattern mimicking elevenlabs AST operators
    """

    children: typing.List["resources_ast_types_and_operator_child_AndOperatorChild"]

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="forbid")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.forbid


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_and_operator_child_AndOperatorChild:
        if IS_PYDANTIC_V2:
            return AndOperatorChild(
                root=_AndOperatorChild.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return AndOperatorChild(
                __root__=_AndOperatorChild.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_and_operator_child_AndOperatorChild:
        if IS_PYDANTIC_V2:
            return AndOperatorChild(
                root=_AndOperatorChild.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return AndOperatorChild(
                __root__=_AndOperatorChild.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_and_operator_child_AndOperatorChild:
        if IS_PYDANTIC_V2:
            return AndOperatorChild(
                root=_AndOperatorChild.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return AndOperatorChild(
                __root__=_AndOperatorChild.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_and_operator_child_AndOperatorChild:
        if IS_PYDANTIC_V2:
            return AndOperatorChild(
                root=_AndOperatorChild.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return AndOperatorChild(
                __root__=_AndOperatorChild.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def boolean_literal(self, value: bool) -> resources_ast_types_and_operator_child_AndOperatorChild:
        if IS_PYDANTIC_V2:
            return AndOperatorChild(root=_AndOperatorChild.BooleanLiteral(type="boolean_literal", value=value))  # type: ignore
        else:
            return AndOperatorChild(__root__=_AndOperatorChild.BooleanLiteral(type="boolean_literal", value=value))  # type: ignore


class AndOperatorChild(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _AndOperatorChild.AndOperator,
                _AndOperatorChild.OrOperator,
                _AndOperatorChild.EqOperator,
                _AndOperatorChild.GtOperator,
                _AndOperatorChild.BooleanLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _AndOperatorChild.AndOperator,
            _AndOperatorChild.OrOperator,
            _AndOperatorChild.EqOperator,
            _AndOperatorChild.GtOperator,
            _AndOperatorChild.BooleanLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _AndOperatorChild.AndOperator,
                _AndOperatorChild.OrOperator,
                _AndOperatorChild.EqOperator,
                _AndOperatorChild.GtOperator,
                _AndOperatorChild.BooleanLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _AndOperatorChild.AndOperator,
            _AndOperatorChild.OrOperator,
            _AndOperatorChild.EqOperator,
            _AndOperatorChild.GtOperator,
            _AndOperatorChild.BooleanLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        boolean_literal: typing.Callable[[bool], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "boolean_literal":
            return boolean_literal(unioned_value.value)


class _AndOperatorChild:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class BooleanLiteral(UniversalBaseModel):
        type: typing.Literal["boolean_literal"] = "boolean_literal"
        value: bool


class EqualsOperator(UniversalBaseModel):
    left: "resources_ast_types_equals_operator_left_EqualsOperatorLeft"
    right: "resources_ast_types_equals_operator_right_EqualsOperatorRight"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="forbid")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.forbid


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_equals_operator_left_EqualsOperatorLeft:
        if IS_PYDANTIC_V2:
            return EqualsOperatorLeft(
                root=_EqualsOperatorLeft.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return EqualsOperatorLeft(
                __root__=_EqualsOperatorLeft.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_equals_operator_left_EqualsOperatorLeft:
        if IS_PYDANTIC_V2:
            return EqualsOperatorLeft(
                root=_EqualsOperatorLeft.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return EqualsOperatorLeft(
                __root__=_EqualsOperatorLeft.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_equals_operator_left_EqualsOperatorLeft:
        if IS_PYDANTIC_V2:
            return EqualsOperatorLeft(
                root=_EqualsOperatorLeft.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return EqualsOperatorLeft(
                __root__=_EqualsOperatorLeft.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_equals_operator_left_EqualsOperatorLeft:
        if IS_PYDANTIC_V2:
            return EqualsOperatorLeft(
                root=_EqualsOperatorLeft.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return EqualsOperatorLeft(
                __root__=_EqualsOperatorLeft.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def string_literal(self, value: str) -> resources_ast_types_equals_operator_left_EqualsOperatorLeft:
        if IS_PYDANTIC_V2:
            return EqualsOperatorLeft(root=_EqualsOperatorLeft.StringLiteral(type="string_literal", value=value))  # type: ignore
        else:
            return EqualsOperatorLeft(__root__=_EqualsOperatorLeft.StringLiteral(type="string_literal", value=value))  # type: ignore


class EqualsOperatorLeft(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _EqualsOperatorLeft.AndOperator,
                _EqualsOperatorLeft.OrOperator,
                _EqualsOperatorLeft.EqOperator,
                _EqualsOperatorLeft.GtOperator,
                _EqualsOperatorLeft.StringLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _EqualsOperatorLeft.AndOperator,
            _EqualsOperatorLeft.OrOperator,
            _EqualsOperatorLeft.EqOperator,
            _EqualsOperatorLeft.GtOperator,
            _EqualsOperatorLeft.StringLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _EqualsOperatorLeft.AndOperator,
                _EqualsOperatorLeft.OrOperator,
                _EqualsOperatorLeft.EqOperator,
                _EqualsOperatorLeft.GtOperator,
                _EqualsOperatorLeft.StringLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _EqualsOperatorLeft.AndOperator,
            _EqualsOperatorLeft.OrOperator,
            _EqualsOperatorLeft.EqOperator,
            _EqualsOperatorLeft.GtOperator,
            _EqualsOperatorLeft.StringLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        string_literal: typing.Callable[[str], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "string_literal":
            return string_literal(unioned_value.value)


class _EqualsOperatorLeft:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class StringLiteral(UniversalBaseModel):
        type: typing.Literal["string_literal"] = "string_literal"
        value: str


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_equals_operator_right_EqualsOperatorRight:
        if IS_PYDANTIC_V2:
            return EqualsOperatorRight(
                root=_EqualsOperatorRight.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return EqualsOperatorRight(
                __root__=_EqualsOperatorRight.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_equals_operator_right_EqualsOperatorRight:
        if IS_PYDANTIC_V2:
            return EqualsOperatorRight(
                root=_EqualsOperatorRight.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return EqualsOperatorRight(
                __root__=_EqualsOperatorRight.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_equals_operator_right_EqualsOperatorRight:
        if IS_PYDANTIC_V2:
            return EqualsOperatorRight(
                root=_EqualsOperatorRight.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return EqualsOperatorRight(
                __root__=_EqualsOperatorRight.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_equals_operator_right_EqualsOperatorRight:
        if IS_PYDANTIC_V2:
            return EqualsOperatorRight(
                root=_EqualsOperatorRight.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return EqualsOperatorRight(
                __root__=_EqualsOperatorRight.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def string_literal(self, value: str) -> resources_ast_types_equals_operator_right_EqualsOperatorRight:
        if IS_PYDANTIC_V2:
            return EqualsOperatorRight(root=_EqualsOperatorRight.StringLiteral(type="string_literal", value=value))  # type: ignore
        else:
            return EqualsOperatorRight(__root__=_EqualsOperatorRight.StringLiteral(type="string_literal", value=value))  # type: ignore


class EqualsOperatorRight(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _EqualsOperatorRight.AndOperator,
                _EqualsOperatorRight.OrOperator,
                _EqualsOperatorRight.EqOperator,
                _EqualsOperatorRight.GtOperator,
                _EqualsOperatorRight.StringLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _EqualsOperatorRight.AndOperator,
            _EqualsOperatorRight.OrOperator,
            _EqualsOperatorRight.EqOperator,
            _EqualsOperatorRight.GtOperator,
            _EqualsOperatorRight.StringLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _EqualsOperatorRight.AndOperator,
                _EqualsOperatorRight.OrOperator,
                _EqualsOperatorRight.EqOperator,
                _EqualsOperatorRight.GtOperator,
                _EqualsOperatorRight.StringLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _EqualsOperatorRight.AndOperator,
            _EqualsOperatorRight.OrOperator,
            _EqualsOperatorRight.EqOperator,
            _EqualsOperatorRight.GtOperator,
            _EqualsOperatorRight.StringLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        string_literal: typing.Callable[[str], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "string_literal":
            return string_literal(unioned_value.value)


class _EqualsOperatorRight:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class StringLiteral(UniversalBaseModel):
        type: typing.Literal["string_literal"] = "string_literal"
        value: str


class GreaterThanOperator(UniversalBaseModel):
    left: "resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft"
    right: "resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="forbid")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.forbid


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorLeft(
                root=_GreaterThanOperatorLeft.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorLeft(
                __root__=_GreaterThanOperatorLeft.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorLeft(
                root=_GreaterThanOperatorLeft.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorLeft(
                __root__=_GreaterThanOperatorLeft.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorLeft(
                root=_GreaterThanOperatorLeft.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorLeft(
                __root__=_GreaterThanOperatorLeft.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorLeft(
                root=_GreaterThanOperatorLeft.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorLeft(
                __root__=_GreaterThanOperatorLeft.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def number_literal(self, value: float) -> resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorLeft(
                root=_GreaterThanOperatorLeft.NumberLiteral(type="number_literal", value=value)
            )  # type: ignore
        else:
            return GreaterThanOperatorLeft(
                __root__=_GreaterThanOperatorLeft.NumberLiteral(type="number_literal", value=value)
            )  # type: ignore


class GreaterThanOperatorLeft(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _GreaterThanOperatorLeft.AndOperator,
                _GreaterThanOperatorLeft.OrOperator,
                _GreaterThanOperatorLeft.EqOperator,
                _GreaterThanOperatorLeft.GtOperator,
                _GreaterThanOperatorLeft.NumberLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _GreaterThanOperatorLeft.AndOperator,
            _GreaterThanOperatorLeft.OrOperator,
            _GreaterThanOperatorLeft.EqOperator,
            _GreaterThanOperatorLeft.GtOperator,
            _GreaterThanOperatorLeft.NumberLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _GreaterThanOperatorLeft.AndOperator,
                _GreaterThanOperatorLeft.OrOperator,
                _GreaterThanOperatorLeft.EqOperator,
                _GreaterThanOperatorLeft.GtOperator,
                _GreaterThanOperatorLeft.NumberLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _GreaterThanOperatorLeft.AndOperator,
            _GreaterThanOperatorLeft.OrOperator,
            _GreaterThanOperatorLeft.EqOperator,
            _GreaterThanOperatorLeft.GtOperator,
            _GreaterThanOperatorLeft.NumberLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        number_literal: typing.Callable[[float], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "number_literal":
            return number_literal(unioned_value.value)


class _GreaterThanOperatorLeft:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class NumberLiteral(UniversalBaseModel):
        type: typing.Literal["number_literal"] = "number_literal"
        value: float


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorRight(
                root=_GreaterThanOperatorRight.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorRight(
                __root__=_GreaterThanOperatorRight.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorRight(
                root=_GreaterThanOperatorRight.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorRight(
                __root__=_GreaterThanOperatorRight.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorRight(
                root=_GreaterThanOperatorRight.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorRight(
                __root__=_GreaterThanOperatorRight.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorRight(
                root=_GreaterThanOperatorRight.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return GreaterThanOperatorRight(
                __root__=_GreaterThanOperatorRight.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def number_literal(self, value: float) -> resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight:
        if IS_PYDANTIC_V2:
            return GreaterThanOperatorRight(
                root=_GreaterThanOperatorRight.NumberLiteral(type="number_literal", value=value)
            )  # type: ignore
        else:
            return GreaterThanOperatorRight(
                __root__=_GreaterThanOperatorRight.NumberLiteral(type="number_literal", value=value)
            )  # type: ignore


class GreaterThanOperatorRight(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _GreaterThanOperatorRight.AndOperator,
                _GreaterThanOperatorRight.OrOperator,
                _GreaterThanOperatorRight.EqOperator,
                _GreaterThanOperatorRight.GtOperator,
                _GreaterThanOperatorRight.NumberLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _GreaterThanOperatorRight.AndOperator,
            _GreaterThanOperatorRight.OrOperator,
            _GreaterThanOperatorRight.EqOperator,
            _GreaterThanOperatorRight.GtOperator,
            _GreaterThanOperatorRight.NumberLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _GreaterThanOperatorRight.AndOperator,
                _GreaterThanOperatorRight.OrOperator,
                _GreaterThanOperatorRight.EqOperator,
                _GreaterThanOperatorRight.GtOperator,
                _GreaterThanOperatorRight.NumberLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _GreaterThanOperatorRight.AndOperator,
            _GreaterThanOperatorRight.OrOperator,
            _GreaterThanOperatorRight.EqOperator,
            _GreaterThanOperatorRight.GtOperator,
            _GreaterThanOperatorRight.NumberLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        number_literal: typing.Callable[[float], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "number_literal":
            return number_literal(unioned_value.value)


class _GreaterThanOperatorRight:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class NumberLiteral(UniversalBaseModel):
        type: typing.Literal["number_literal"] = "number_literal"
        value: float


class OrOperator(UniversalBaseModel):
    children: typing.List["resources_ast_types_or_operator_child_OrOperatorChild"]

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="forbid")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.forbid


class _Factory:
    def and_operator(
        self, value: resources_ast_types_and_operator_AndOperator
    ) -> resources_ast_types_or_operator_child_OrOperatorChild:
        if IS_PYDANTIC_V2:
            return OrOperatorChild(
                root=_OrOperatorChild.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore
        else:
            return OrOperatorChild(
                __root__=_OrOperatorChild.AndOperator(**value.dict(exclude_unset=True), type="and_operator")
            )  # type: ignore

    def or_operator(
        self, value: resources_ast_types_or_operator_OrOperator
    ) -> resources_ast_types_or_operator_child_OrOperatorChild:
        if IS_PYDANTIC_V2:
            return OrOperatorChild(
                root=_OrOperatorChild.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore
        else:
            return OrOperatorChild(
                __root__=_OrOperatorChild.OrOperator(**value.dict(exclude_unset=True), type="or_operator")
            )  # type: ignore

    def eq_operator(
        self, value: resources_ast_types_equals_operator_EqualsOperator
    ) -> resources_ast_types_or_operator_child_OrOperatorChild:
        if IS_PYDANTIC_V2:
            return OrOperatorChild(
                root=_OrOperatorChild.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore
        else:
            return OrOperatorChild(
                __root__=_OrOperatorChild.EqOperator(**value.dict(exclude_unset=True), type="eq_operator")
            )  # type: ignore

    def gt_operator(
        self, value: resources_ast_types_greater_than_operator_GreaterThanOperator
    ) -> resources_ast_types_or_operator_child_OrOperatorChild:
        if IS_PYDANTIC_V2:
            return OrOperatorChild(
                root=_OrOperatorChild.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore
        else:
            return OrOperatorChild(
                __root__=_OrOperatorChild.GtOperator(**value.dict(exclude_unset=True), type="gt_operator")
            )  # type: ignore

    def boolean_literal(self, value: bool) -> resources_ast_types_or_operator_child_OrOperatorChild:
        if IS_PYDANTIC_V2:
            return OrOperatorChild(root=_OrOperatorChild.BooleanLiteral(type="boolean_literal", value=value))  # type: ignore
        else:
            return OrOperatorChild(__root__=_OrOperatorChild.BooleanLiteral(type="boolean_literal", value=value))  # type: ignore


class OrOperatorChild(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _OrOperatorChild.AndOperator,
                _OrOperatorChild.OrOperator,
                _OrOperatorChild.EqOperator,
                _OrOperatorChild.GtOperator,
                _OrOperatorChild.BooleanLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _OrOperatorChild.AndOperator,
            _OrOperatorChild.OrOperator,
            _OrOperatorChild.EqOperator,
            _OrOperatorChild.GtOperator,
            _OrOperatorChild.BooleanLiteral,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _OrOperatorChild.AndOperator,
                _OrOperatorChild.OrOperator,
                _OrOperatorChild.EqOperator,
                _OrOperatorChild.GtOperator,
                _OrOperatorChild.BooleanLiteral,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _OrOperatorChild.AndOperator,
            _OrOperatorChild.OrOperator,
            _OrOperatorChild.EqOperator,
            _OrOperatorChild.GtOperator,
            _OrOperatorChild.BooleanLiteral,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        and_operator: typing.Callable[["resources_ast_types_and_operator_AndOperator"], T_Result],
        or_operator: typing.Callable[["resources_ast_types_or_operator_OrOperator"], T_Result],
        eq_operator: typing.Callable[["resources_ast_types_equals_operator_EqualsOperator"], T_Result],
        gt_operator: typing.Callable[["resources_ast_types_greater_than_operator_GreaterThanOperator"], T_Result],
        boolean_literal: typing.Callable[[bool], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "and_operator":
            return and_operator(
                resources_ast_types_and_operator_AndOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "or_operator":
            return or_operator(
                resources_ast_types_or_operator_OrOperator(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "eq_operator":
            return eq_operator(
                resources_ast_types_equals_operator_EqualsOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "gt_operator":
            return gt_operator(
                resources_ast_types_greater_than_operator_GreaterThanOperator(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "boolean_literal":
            return boolean_literal(unioned_value.value)


from .and_operator_child import AndOperatorChild as resources_ast_types_and_operator_child_AndOperatorChild  # noqa: E402, F401, I001
from .and_operator import AndOperator as resources_ast_types_and_operator_AndOperator  # noqa: E402, F401, I001
from .or_operator import OrOperator as resources_ast_types_or_operator_OrOperator  # noqa: E402, F401, I001
from .equals_operator import EqualsOperator as resources_ast_types_equals_operator_EqualsOperator  # noqa: E402, F401, I001
from .greater_than_operator import GreaterThanOperator as resources_ast_types_greater_than_operator_GreaterThanOperator  # noqa: E402, F401, I001
from .equals_operator_left import EqualsOperatorLeft as resources_ast_types_equals_operator_left_EqualsOperatorLeft  # noqa: E402, F401, I001
from .equals_operator_right import EqualsOperatorRight as resources_ast_types_equals_operator_right_EqualsOperatorRight  # noqa: E402, F401, I001
from .greater_than_operator_left import (
    GreaterThanOperatorLeft as resources_ast_types_greater_than_operator_left_GreaterThanOperatorLeft,
)  # noqa: E402, F401, I001
from .greater_than_operator_right import (
    GreaterThanOperatorRight as resources_ast_types_greater_than_operator_right_GreaterThanOperatorRight,
)  # noqa: E402, F401, I001
from .or_operator_child import OrOperatorChild as resources_ast_types_or_operator_child_OrOperatorChild  # noqa: E402, F401, I001


class _OrOperatorChild:
    class AndOperator(resources_ast_types_and_operator_AndOperator):
        type: typing.Literal["and_operator"] = "and_operator"

    class OrOperator(resources_ast_types_or_operator_OrOperator):
        type: typing.Literal["or_operator"] = "or_operator"

    class EqOperator(resources_ast_types_equals_operator_EqualsOperator):
        type: typing.Literal["eq_operator"] = "eq_operator"

    class GtOperator(resources_ast_types_greater_than_operator_GreaterThanOperator):
        type: typing.Literal["gt_operator"] = "gt_operator"

    class BooleanLiteral(UniversalBaseModel):
        type: typing.Literal["boolean_literal"] = "boolean_literal"
        value: bool


update_forward_refs(_AndOperatorChild.AndOperator)
update_forward_refs(_AndOperatorChild.OrOperator)
update_forward_refs(_AndOperatorChild.EqOperator)
update_forward_refs(_AndOperatorChild.GtOperator)
update_forward_refs(_EqualsOperatorLeft.AndOperator)
update_forward_refs(_EqualsOperatorLeft.OrOperator)
update_forward_refs(_EqualsOperatorLeft.EqOperator)
update_forward_refs(_EqualsOperatorLeft.GtOperator)
update_forward_refs(_EqualsOperatorRight.AndOperator)
update_forward_refs(_EqualsOperatorRight.OrOperator)
update_forward_refs(_EqualsOperatorRight.EqOperator)
update_forward_refs(_EqualsOperatorRight.GtOperator)
update_forward_refs(_GreaterThanOperatorLeft.AndOperator)
update_forward_refs(_GreaterThanOperatorLeft.OrOperator)
update_forward_refs(_GreaterThanOperatorLeft.EqOperator)
update_forward_refs(_GreaterThanOperatorLeft.GtOperator)
update_forward_refs(_GreaterThanOperatorRight.AndOperator)
update_forward_refs(_GreaterThanOperatorRight.OrOperator)
update_forward_refs(_GreaterThanOperatorRight.EqOperator)
update_forward_refs(_GreaterThanOperatorRight.GtOperator)
update_forward_refs(_OrOperatorChild.AndOperator)
update_forward_refs(_OrOperatorChild.OrOperator)
update_forward_refs(_OrOperatorChild.EqOperator)
update_forward_refs(_OrOperatorChild.GtOperator)

# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import datetime as dt
import typing

import typing_extensions

from ...core.datetime_utils import serialize_datetime
from .object_value import ObjectValue as ast_types_object_value_ObjectValue
from .primitive_value import PrimitiveValue as ast_types_primitive_value_PrimitiveValue

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def primitive_value(self, value: ast_types_primitive_value_PrimitiveValue) -> FieldValue:
        return FieldValue(__root__=_FieldValue.PrimitiveValue(type="primitive_value", value=value))

    def object_value(self, value: ast_types_object_value_ObjectValue) -> FieldValue:
        return FieldValue(__root__=_FieldValue.ObjectValue(**value.dict(exclude_unset=True), type="object_value"))

    def container_value(self, value: ast_types_container_value_ContainerValue) -> FieldValue:
        return FieldValue(__root__=_FieldValue.ContainerValue(type="container_value", value=value))


class FieldValue(pydantic.BaseModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    def get_as_union(
        self,
    ) -> typing.Union[_FieldValue.PrimitiveValue, _FieldValue.ObjectValue, _FieldValue.ContainerValue]:
        return self.__root__

    def visit(
        self,
        primitive_value: typing.Callable[[ast_types_primitive_value_PrimitiveValue], T_Result],
        object_value: typing.Callable[[ast_types_object_value_ObjectValue], T_Result],
        container_value: typing.Callable[[ast_types_container_value_ContainerValue], T_Result],
    ) -> T_Result:
        if self.__root__.type == "primitive_value":
            return primitive_value(self.__root__.value)
        if self.__root__.type == "object_value":
            return object_value(
                ast_types_object_value_ObjectValue(**self.__root__.dict(exclude_unset=True, exclude={"type"}))
            )
        if self.__root__.type == "container_value":
            return container_value(self.__root__.value)

    __root__: typing_extensions.Annotated[
        typing.Union[_FieldValue.PrimitiveValue, _FieldValue.ObjectValue, _FieldValue.ContainerValue],
        pydantic.Field(discriminator="type"),
    ]

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        extra = pydantic.Extra.forbid
        json_encoders = {dt.datetime: serialize_datetime}


from .container_value import ContainerValue as ast_types_container_value_ContainerValue  # noqa: E402


class _FieldValue:
    class PrimitiveValue(pydantic.BaseModel):
        type: typing_extensions.Literal["primitive_value"]
        value: ast_types_primitive_value_PrimitiveValue

    class ObjectValue(ast_types_object_value_ObjectValue):
        type: typing_extensions.Literal["object_value"]

        class Config:
            allow_population_by_field_name = True

    class ContainerValue(pydantic.BaseModel):
        type: typing_extensions.Literal["container_value"]
        value: ast_types_container_value_ContainerValue


_FieldValue.ContainerValue.update_forward_refs(
    ContainerValue=ast_types_container_value_ContainerValue, FieldValue=FieldValue
)
FieldValue.update_forward_refs()

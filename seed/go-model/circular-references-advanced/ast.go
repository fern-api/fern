// Code generated by Fern. DO NOT EDIT.

package api

import (
	fmt "fmt"
)

type Animal struct {
	Cat *Cat
	Dog *Dog
}

type Fruit struct {
	Acai *Acai
	Fig  *Fig
}

type Node struct {
	BranchNode *BranchNode
	LeafNode   *LeafNode
}

type Cat struct {
	Fruit *Fruit `json:"fruit" url:"fruit"`
}

type Dog struct {
	Fruit *Fruit `json:"fruit" url:"fruit"`
}

type Acai struct {
	Animal *Animal `json:"animal" url:"animal"`
}

type Fig struct {
	Animal *Animal `json:"animal" url:"animal"`
}

type Berry struct {
	Animal *Animal `json:"animal" url:"animal"`
}

type BranchNode struct {
	Children []*Node `json:"children" url:"children"`
}

type LeafNode struct{}

type NodesWrapper struct {
	Nodes [][]*Node `json:"nodes" url:"nodes"`
}

type ContainerValue struct {
	Type     string
	List     []*FieldValue
	Optional *FieldValue
}

type PrimitiveValue string

const (
	PrimitiveValueString = "STRING"
	PrimitiveValueNumber = "NUMBER"
)

func NewPrimitiveValueFromString(s string) (PrimitiveValue, error) {
	switch s {
	case "STRING":
		return PrimitiveValueString, nil
	case "NUMBER":
		return PrimitiveValueNumber, nil
	}
	var t PrimitiveValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveValue) Ptr() *PrimitiveValue {
	return &p
}

type ObjectValue struct{}

type FieldName = string

type FieldValue struct {
	Type           string
	PrimitiveValue *PrimitiveValue
	ObjectValue    ObjectValue
	ContainerValue *ContainerValue
}

// This type allows us to test a circular reference with a union type (see FieldValue).
type ObjectFieldValue struct {
	Name  FieldName   `json:"name" url:"name"`
	Value *FieldValue `json:"value" url:"value"`
}

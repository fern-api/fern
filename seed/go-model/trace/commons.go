// Code generated by Fern. DO NOT EDIT.

package trace

import (
    fmt "fmt"
)


type UserId = string

type ProblemId = string

type NodeId = string

type VariableType struct {
    Type string
    IntegerType any
    DoubleType any
    BooleanType any
    StringType any
    CharType any
    ListType ListType
    MapType MapType
    BinaryTreeType any
    SinglyLinkedListType any
    DoublyLinkedListType any
}


type ListType struct {
    ValueType *VariableType `json:"valueType" url:"valueType"`
    // Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false.
    IsFixedLength *bool `json:"isFixedLength,omitempty" url:"isFixedLength,omitempty"`
}


type MapType struct {
    KeyType *VariableType `json:"keyType" url:"keyType"`
    ValueType *VariableType `json:"valueType" url:"valueType"`
}


type VariableValue struct {
    Type string
    IntegerValue int
    BooleanValue bool
    DoubleValue float64
    StringValue string
    CharValue string
    MapValue MapValue
    ListValue []*VariableValue
    BinaryTreeValue BinaryTreeValue
    SinglyLinkedListValue SinglyLinkedListValue
    DoublyLinkedListValue DoublyLinkedListValue
    NullValue any
}


type DebugVariableValue struct {
    Type string
    IntegerValue int
    BooleanValue bool
    DoubleValue float64
    StringValue string
    CharValue string
    MapValue DebugMapValue
    ListValue []*DebugVariableValue
    BinaryTreeNodeValue BinaryTreeNodeAndTreeValue
    SinglyLinkedListNodeValue SinglyLinkedListNodeAndListValue
    DoublyLinkedListNodeValue DoublyLinkedListNodeAndListValue
    UndefinedValue any
    NullValue any
    GenericValue GenericValue
}


type GenericValue struct {
    StringifiedType *string `json:"stringifiedType,omitempty" url:"stringifiedType,omitempty"`
    StringifiedValue string `json:"stringifiedValue" url:"stringifiedValue"`
}


type MapValue struct {
    KeyValuePairs []*KeyValuePair `json:"keyValuePairs" url:"keyValuePairs"`
}


type KeyValuePair struct {
    Key *VariableValue `json:"key" url:"key"`
    Value *VariableValue `json:"value" url:"value"`
}


type BinaryTreeValue struct {
    Root *NodeId `json:"root,omitempty" url:"root,omitempty"`
    Nodes map[NodeId]*BinaryTreeNodeValue `json:"nodes" url:"nodes"`
}


type BinaryTreeNodeValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    Val float64 `json:"val" url:"val"`
    Right *NodeId `json:"right,omitempty" url:"right,omitempty"`
    Left *NodeId `json:"left,omitempty" url:"left,omitempty"`
}


type BinaryTreeNodeAndTreeValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    FullTree *BinaryTreeValue `json:"fullTree" url:"fullTree"`
}


type SinglyLinkedListValue struct {
    Head *NodeId `json:"head,omitempty" url:"head,omitempty"`
    Nodes map[NodeId]*SinglyLinkedListNodeValue `json:"nodes" url:"nodes"`
}


type SinglyLinkedListNodeValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    Val float64 `json:"val" url:"val"`
    Next *NodeId `json:"next,omitempty" url:"next,omitempty"`
}


type SinglyLinkedListNodeAndListValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    FullList *SinglyLinkedListValue `json:"fullList" url:"fullList"`
}


type DoublyLinkedListValue struct {
    Head *NodeId `json:"head,omitempty" url:"head,omitempty"`
    Nodes map[NodeId]*DoublyLinkedListNodeValue `json:"nodes" url:"nodes"`
}


type DoublyLinkedListNodeValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    Val float64 `json:"val" url:"val"`
    Next *NodeId `json:"next,omitempty" url:"next,omitempty"`
    Prev *NodeId `json:"prev,omitempty" url:"prev,omitempty"`
}


type DoublyLinkedListNodeAndListValue struct {
    NodeId NodeId `json:"nodeId" url:"nodeId"`
    FullList *DoublyLinkedListValue `json:"fullList" url:"fullList"`
}


type DebugMapValue struct {
    KeyValuePairs []*DebugKeyValuePairs `json:"keyValuePairs" url:"keyValuePairs"`
}


type DebugKeyValuePairs struct {
    Key *DebugVariableValue `json:"key" url:"key"`
    Value *DebugVariableValue `json:"value" url:"value"`
}


type TestCase struct {
    Id string `json:"id" url:"id"`
    Params []*VariableValue `json:"params" url:"params"`
}


type TestCaseWithExpectedResult struct {
    TestCase *TestCase `json:"testCase" url:"testCase"`
    ExpectedResult *VariableValue `json:"expectedResult" url:"expectedResult"`
}


type FileInfo struct {
    Filename string `json:"filename" url:"filename"`
    Contents string `json:"contents" url:"contents"`
}


type Language string

const (
    LanguageJava = "JAVA"
    LanguageJavascript = "JAVASCRIPT"
    LanguagePython = "PYTHON"
)
func NewLanguageFromString(s string) (Language, error){
    switch s{
        case "JAVA":
            return LanguageJava, nil
        case "JAVASCRIPT":
            return LanguageJavascript, nil
        case "PYTHON":
            return LanguagePython, nil
    }
    var t Language
    return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Language) Ptr() *Language{
    return &l
}


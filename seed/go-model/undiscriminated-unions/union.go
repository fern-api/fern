// Code generated by Fern. DO NOT EDIT.

package undiscriminatedunions

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/undiscriminated-unions/fern/internal"
)

type Request struct {
	Union *MetadataUnion `json:"union,omitempty" url:"union,omitempty"`

	extraProperties map[string]any
	rawJSON         json.RawMessage
}

func (r *Request) GetUnion() *MetadataUnion {
	if r == nil {
		return nil
	}
	return r.Union
}

func (r *Request) GetExtraProperties() map[string]any {
	if r == nil {
		return nil
	}
	return r.extraProperties
}

func (r *Request) UnmarshalJSON(
	data []byte,
) error {
	type unmarshaler Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Request(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Request) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type TypeWithOptionalUnion struct {
	MyUnion *MyUnion `json:"myUnion,omitempty" url:"myUnion,omitempty"`

	extraProperties map[string]any
	rawJSON         json.RawMessage
}

func (t *TypeWithOptionalUnion) GetMyUnion() *MyUnion {
	if t == nil {
		return nil
	}
	return t.MyUnion
}

func (t *TypeWithOptionalUnion) GetExtraProperties() map[string]any {
	if t == nil {
		return nil
	}
	return t.extraProperties
}

func (t *TypeWithOptionalUnion) UnmarshalJSON(
	data []byte,
) error {
	type unmarshaler TypeWithOptionalUnion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeWithOptionalUnion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypeWithOptionalUnion) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Several different types are accepted.
type MyUnion struct {
	String          string
	StringList      []string
	Integer         int
	IntegerList     []int
	IntegerListList [][]int
	StringSet       []string
}

// Nested layer 2.
type NestedUnionL2 struct {
	Boolean    bool
	StringSet  []string
	StringList []string
}

// Nested layer 1.
type NestedUnionL1 struct {
	Integer       int
	StringSet     []string
	StringList    []string
	NestedUnionL2 *NestedUnionL2
}

// Nested union root.
type NestedUnionRoot struct {
	String        string
	StringList    []string
	NestedUnionL1 *NestedUnionL1
}

// Duplicate types.
type UnionWithDuplicateTypes struct {
	String     string
	StringList []string
	Integer    int
	StringSet  []string
}

type MetadataUnion struct {
	OptionalMetadata OptionalMetadata
	NamedMetadata    *NamedMetadata
}

type NamedMetadata struct {
	Name  string         `json:"name" url:"name"`
	Value map[string]any `json:"value" url:"value"`

	extraProperties map[string]any
	rawJSON         json.RawMessage
}

func (n *NamedMetadata) GetName() string {
	if n == nil {
		return ""
	}
	return n.Name
}

func (n *NamedMetadata) GetValue() map[string]any {
	if n == nil {
		return nil
	}
	return n.Value
}

func (n *NamedMetadata) GetExtraProperties() map[string]any {
	if n == nil {
		return nil
	}
	return n.extraProperties
}

func (n *NamedMetadata) UnmarshalJSON(
	data []byte,
) error {
	type unmarshaler NamedMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamedMetadata) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OptionalMetadata = map[string]any

// Undiscriminated unions can act as a map key
// as long as all of their values are valid keys
// (i.e. do they have a valid string representation).
type Metadata = map[*Key]string

type Key struct {
	KeyType *KeyType

	defaultStringLiteral string
}

type KeyType string

const (
	KeyTypeName  = "name"
	KeyTypeValue = "value"
)

func NewKeyTypeFromString(s string) (KeyType, error) {
	switch s {
	case "name":
		return KeyTypeName, nil
	case "value":
		return KeyTypeValue, nil
	}
	var t KeyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KeyType) Ptr() *KeyType {
	return &k
}

// Multiple string types that all resolve to String in Java.
// This tests the fix for duplicate method signatures.
type UnionWithIdenticalStrings struct {
	String string
}

// Mix of primitives where some resolve to the same Java type.
type UnionWithIdenticalPrimitives struct {
	Integer int
	Double  float64
	String  string
}

// Tests that nested properties with camelCase wire names are properly
// converted from snake_case Ruby keys when passed as Hash values.
type PaymentMethodUnion struct {
	TokenizeCard *TokenizeCard
	ConvertToken *ConvertToken
}

type TokenizeCard struct {
	Method     string `json:"method" url:"method"`
	CardNumber string `json:"cardNumber" url:"cardNumber"`

	extraProperties map[string]any
	rawJSON         json.RawMessage
}

func (t *TokenizeCard) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TokenizeCard) GetCardNumber() string {
	if t == nil {
		return ""
	}
	return t.CardNumber
}

func (t *TokenizeCard) GetExtraProperties() map[string]any {
	if t == nil {
		return nil
	}
	return t.extraProperties
}

func (t *TokenizeCard) UnmarshalJSON(
	data []byte,
) error {
	type unmarshaler TokenizeCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeCard(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeCard) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ConvertToken struct {
	Method  string `json:"method" url:"method"`
	TokenId string `json:"tokenId" url:"tokenId"`

	extraProperties map[string]any
	rawJSON         json.RawMessage
}

func (c *ConvertToken) GetMethod() string {
	if c == nil {
		return ""
	}
	return c.Method
}

func (c *ConvertToken) GetTokenId() string {
	if c == nil {
		return ""
	}
	return c.TokenId
}

func (c *ConvertToken) GetExtraProperties() map[string]any {
	if c == nil {
		return nil
	}
	return c.extraProperties
}

func (c *ConvertToken) UnmarshalJSON(
	data []byte,
) error {
	type unmarshaler ConvertToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConvertToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConvertToken) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

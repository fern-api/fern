// Code generated by Fern. DO NOT EDIT.

package pagination

import (
	fmt "fmt"
)

type SearchRequestQuery struct {
	SingleFilterSearchRequest   *SingleFilterSearchRequest
	MultipleFilterSearchRequest *MultipleFilterSearchRequest
}

type MultipleFilterSearchRequest struct {
	Operator *MultipleFilterSearchRequestOperator `json:"operator,omitempty" url:"operator,omitempty"`
	Value    *MultipleFilterSearchRequestValue    `json:"value,omitempty" url:"value,omitempty"`
}

type MultipleFilterSearchRequestOperator string

const (
	MultipleFilterSearchRequestOperatorAnd = "AND"
	MultipleFilterSearchRequestOperatorOr  = "OR"
)

func NewMultipleFilterSearchRequestOperatorFromString(s string) (MultipleFilterSearchRequestOperator, error) {
	switch s {
	case "AND":
		return MultipleFilterSearchRequestOperatorAnd, nil
	case "OR":
		return MultipleFilterSearchRequestOperatorOr, nil
	}
	var t MultipleFilterSearchRequestOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MultipleFilterSearchRequestOperator) Ptr() *MultipleFilterSearchRequestOperator {
	return &m
}

type MultipleFilterSearchRequestValue struct {
	MultipleFilterSearchRequestList []*MultipleFilterSearchRequest
	SingleFilterSearchRequestList   []*SingleFilterSearchRequest
}

type SingleFilterSearchRequest struct {
	Field    *string                            `json:"field,omitempty" url:"field,omitempty"`
	Operator *SingleFilterSearchRequestOperator `json:"operator,omitempty" url:"operator,omitempty"`
	Value    *string                            `json:"value,omitempty" url:"value,omitempty"`
}

type SingleFilterSearchRequestOperator string

const (
	SingleFilterSearchRequestOperatorEquals         = "="
	SingleFilterSearchRequestOperatorNotEquals      = "!="
	SingleFilterSearchRequestOperatorIn             = "IN"
	SingleFilterSearchRequestOperatorNotIn          = "NIN"
	SingleFilterSearchRequestOperatorLessThan       = "<"
	SingleFilterSearchRequestOperatorGreaterThan    = ">"
	SingleFilterSearchRequestOperatorContains       = "~"
	SingleFilterSearchRequestOperatorDoesNotContain = "!~"
	SingleFilterSearchRequestOperatorStartsWith     = "^"
	SingleFilterSearchRequestOperatorEndsWith       = "$"
)

func NewSingleFilterSearchRequestOperatorFromString(s string) (SingleFilterSearchRequestOperator, error) {
	switch s {
	case "=":
		return SingleFilterSearchRequestOperatorEquals, nil
	case "!=":
		return SingleFilterSearchRequestOperatorNotEquals, nil
	case "IN":
		return SingleFilterSearchRequestOperatorIn, nil
	case "NIN":
		return SingleFilterSearchRequestOperatorNotIn, nil
	case "<":
		return SingleFilterSearchRequestOperatorLessThan, nil
	case ">":
		return SingleFilterSearchRequestOperatorGreaterThan, nil
	case "~":
		return SingleFilterSearchRequestOperatorContains, nil
	case "!~":
		return SingleFilterSearchRequestOperatorDoesNotContain, nil
	case "^":
		return SingleFilterSearchRequestOperatorStartsWith, nil
	case "$":
		return SingleFilterSearchRequestOperatorEndsWith, nil
	}
	var t SingleFilterSearchRequestOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleFilterSearchRequestOperator) Ptr() *SingleFilterSearchRequestOperator {
	return &s
}

type SearchRequest struct {
	Pagination *StartingAfterPaging `json:"pagination,omitempty" url:"pagination,omitempty"`
	Query      *SearchRequestQuery  `json:"query" url:"query"`
}

type PaginatedConversationResponse struct {
	Conversations []*Conversation `json:"conversations" url:"conversations"`
	Pages         *CursorPages    `json:"pages,omitempty" url:"pages,omitempty"`
	TotalCount    int             `json:"total_count" url:"total_count"`

	type_ string
}

type CursorPages struct {
	Next       *StartingAfterPaging `json:"next,omitempty" url:"next,omitempty"`
	Page       *int                 `json:"page,omitempty" url:"page,omitempty"`
	PerPage    *int                 `json:"per_page,omitempty" url:"per_page,omitempty"`
	TotalPages *int                 `json:"total_pages,omitempty" url:"total_pages,omitempty"`

	type_ string
}

type StartingAfterPaging struct {
	PerPage       int     `json:"per_page" url:"per_page"`
	StartingAfter *string `json:"starting_after,omitempty" url:"starting_after,omitempty"`
}

type Conversation struct {
	Foo string `json:"foo" url:"foo"`
}

// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import type { BearerAuthProvider } from "./BearerAuthProvider.js";
import type { HeaderAuthProvider } from "./HeaderAuthProvider.js";
import type { OAuthAuthProvider } from "./OAuthAuthProvider.js";

export namespace RoutingAuthProvider {
    type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;

    export type AuthOptions = Partial<
        UnionToIntersection<
            BearerAuthProvider.AuthOptions | HeaderAuthProvider.AuthOptions | OAuthAuthProvider.AuthOptions
        >
    >;
}

export class RoutingAuthProvider implements core.AuthProvider {
    private readonly authProviders: Map<string, core.AuthProvider>;

    constructor(authProviders: Map<string, core.AuthProvider>) {
        this.authProviders = authProviders;
    }

    public async getAuthRequest(arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
        const security = arg?.endpointMetadata?.security;

        // If no security requirements specified, endpoint is anonymous - return empty auth request
        if (security == null || security.length === 0) {
            return { headers: {} };
        }

        // First, verify that at least one security requirement can be satisfied by available providers
        const canSatisfyAnyRequirement = security.some((securityRequirement) => {
            const schemeKeys = Object.keys(securityRequirement);
            return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
        });

        if (!canSatisfyAnyRequirement) {
            const requiredSchemes = security.map((req) => Object.keys(req).join(" AND ")).join(" OR ");
            throw new Error(
                "No authentication credentials provided that satisfy the endpoint's security requirements. " +
                    "Required: " +
                    requiredSchemes +
                    ". Please provide the necessary authentication credentials.",
            );
        }

        // Get the first security requirement that can be satisfied (OR relationship)
        const satisfiableRequirement = security.find((securityRequirement) => {
            const schemeKeys = Object.keys(securityRequirement);
            return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
        });

        if (satisfiableRequirement == null) {
            // This should not happen since we already verified above, but handle it gracefully
            const requiredSchemes = security.map((req) => Object.keys(req).join(" AND ")).join(" OR ");
            throw new Error(
                "No authentication credentials provided that satisfy the endpoint's security requirements. " +
                    "Required: " +
                    requiredSchemes +
                    ". Please provide the necessary authentication credentials.",
            );
        }

        // Get auth for all schemes in the satisfiable requirement (AND relationship)
        const combinedHeaders: Record<string, string> = {};
        for (const schemeKey of Object.keys(satisfiableRequirement)) {
            const provider = this.authProviders.get(schemeKey);
            if (provider == null) {
                throw new Error(`Auth provider not found for scheme: ${schemeKey}`);
            }
            const authRequest = await provider.getAuthRequest(arg);
            Object.assign(combinedHeaders, authRequest.headers);
        }

        return { headers: combinedHeaders };
    }
}

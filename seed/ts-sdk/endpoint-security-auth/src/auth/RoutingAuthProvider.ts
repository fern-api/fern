// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import type { BearerAuthProvider } from "./BearerAuthProvider.js";
import type { HeaderAuthProvider } from "./HeaderAuthProvider.js";
import type { OAuthAuthProvider } from "./OAuthAuthProvider.js";

export namespace RoutingAuthProvider {
    type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;

    type AtLeastOneOf<T extends any[]> = {
        [K in keyof T]: T[K] & Partial<UnionToIntersection<Exclude<T[number], T[K]>>>;
    }[number];

    export type AuthOptions = AtLeastOneOf<
        [BearerAuthProvider.AuthOptions, HeaderAuthProvider.AuthOptions, OAuthAuthProvider.AuthOptions]
    >;
}

export class RoutingAuthProvider implements core.AuthProvider {
    private readonly authProviders: Map<string, core.AuthProvider>;

    constructor(authProviders: Map<string, core.AuthProvider>) {
        this.authProviders = authProviders;
    }

    public async getAuthRequest(arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
        const security = arg?.endpointMetadata?.security;

        // If no security requirements specified, try all providers in order
        if (security == null || security.length === 0) {
            for (const provider of this.authProviders.values()) {
                try {
                    const authRequest = await provider.getAuthRequest(arg);
                    if (authRequest.headers.Authorization != null || Object.keys(authRequest.headers).length > 0) {
                        return authRequest;
                    }
                } catch (_e) {
                    // Continue to next auth provider
                }
            }
            return { headers: {} };
        }

        // Try each security requirement collection (OR relationship)
        for (const securityRequirement of security) {
            const schemeKeys = Object.keys(securityRequirement);
            let allSchemesSucceeded = true;
            const combinedHeaders: Record<string, string> = {};

            // Try all schemes in this requirement (AND relationship)
            for (const schemeKey of schemeKeys) {
                const provider = this.authProviders.get(schemeKey);
                if (provider == null) {
                    allSchemesSucceeded = false;
                    break;
                }

                try {
                    const authRequest = await provider.getAuthRequest(arg);
                    if (authRequest.headers.Authorization == null && Object.keys(authRequest.headers).length === 0) {
                        allSchemesSucceeded = false;
                        break;
                    }
                    Object.assign(combinedHeaders, authRequest.headers);
                } catch (_e) {
                    allSchemesSucceeded = false;
                    break;
                }
            }

            if (allSchemesSucceeded && Object.keys(combinedHeaders).length > 0) {
                return { headers: combinedHeaders };
            }
        }

        // No security requirement could be satisfied
        return { headers: {} };
    }
}

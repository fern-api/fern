// This file was auto-generated by Fern from our API Definition.

import type { NormalizedClientOptions } from "../BaseClient.js";
import { BearerAuthProvider } from "./BearerAuthProvider.js";
import { HeaderAuthProvider } from "./HeaderAuthProvider.js";
import { OAuthAuthProvider } from "./OAuthAuthProvider.js";
import { BasicAuthProvider } from "./BasicAuthProvider.js";
import { InferredAuthProvider } from "./InferredAuthProvider.js";
import * as core from "../core/index.js";

type AuthScheme = string;
type AuthConfigErrorMessage = string;

export class RoutingAuthProvider implements core.AuthProvider {
    private readonly authProviders: Map<AuthScheme, core.AuthProvider>;
    private readonly authConfigErrorMessages: Map<AuthScheme, AuthConfigErrorMessage>;

    constructor(authProviders: [AuthScheme, core.AuthProvider, AuthConfigErrorMessage][]) {
        this.authProviders = new Map(authProviders.map(([scheme, provider]) => [scheme, provider]));
        this.authConfigErrorMessages = new Map(authProviders.map(([scheme, , errorMessage]) => [scheme, errorMessage]));
    }

    private getAuthConfigErrorMessage(schemeKey: string): string {

                return (
                    this.authConfigErrorMessages.get(schemeKey) ??
                    `Please provide the required authentication credentials for ${schemeKey} when initializing the client`
                );
    }

    public async getAuthRequest({ endpointMetadata }: {
            endpointMetadata?: core.EndpointMetadata;
        } = {}): Promise<core.AuthRequest> {

                const security = endpointMetadata?.security;

                // If no security requirements specified, endpoint is anonymous - return empty auth request
                if (security == null || security.length === 0) {
                    return { headers: {} };
                }

                // First, verify that at least one security requirement can be satisfied by available providers
                const canSatisfyAnyRequirement = security.some((securityRequirement) => {
                    const schemeKeys = Object.keys(securityRequirement);
                    return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
                });

                if (!canSatisfyAnyRequirement) {
                    // Build user-friendly error message showing which auth options are missing
                    const missingAuthHints = security.map((req) => {
                        const schemeKeys = Object.keys(req);
                        const missingSchemes = schemeKeys.filter((key) => !this.authProviders.has(key));
                        return missingSchemes.map((key) => this.getAuthConfigErrorMessage(key)).join(" AND ");
                    }).join(" OR ");
                    throw new Error(
                        "No authentication credentials provided that satisfy the endpoint's security requirements. " +
                        missingAuthHints
                    );
                }

                // Get the first security requirement that can be satisfied (OR relationship)
                const satisfiableRequirement = security.find((securityRequirement) => {
                    const schemeKeys = Object.keys(securityRequirement);
                    return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
                })!;

                // Get auth for all schemes in the satisfiable requirement (AND relationship)
                const combinedHeaders: Record<string, string> = {};
                for (const schemeKey of Object.keys(satisfiableRequirement)) {
                    const provider = this.authProviders.get(schemeKey);
                    if (provider == null) {
                        throw new Error(`Internal error: auth provider not found for scheme: ${schemeKey}`);
                    }
                    const authRequest = await provider.getAuthRequest({ endpointMetadata });
                    Object.assign(combinedHeaders, authRequest.headers);
                }

                return { headers: combinedHeaders };
    }
}

export namespace RoutingAuthProvider {
    type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
    
    export type AuthOptions<TAuthProviders extends readonly any[]> = Partial<UnionToIntersection<TAuthProviders[number]>>;
    export type Options<TOptions extends readonly any[]> = Partial<UnionToIntersection<TOptions[number]>>;
    
    type InstantiatableAuthProviderWithScheme = {
        canCreate: (opts: NormalizedClientOptions) => boolean;
        createInstance: (opts: NormalizedClientOptions) => core.AuthProvider;
        AUTH_SCHEME: string;
        AUTH_CONFIG_ERROR_MESSAGE: string;
    };
    

    export function createInstance(options: NormalizedClientOptions, authProviderClasses: InstantiatableAuthProviderWithScheme[]): core.AuthProvider {

                const authProviders: [AuthScheme, core.AuthProvider, AuthConfigErrorMessage][] = authProviderClasses
                    .filter((providerClass) => providerClass.canCreate(options))
                    .map((providerClass) => [
                        providerClass.AUTH_SCHEME,
                        providerClass.createInstance(options),
                        providerClass.AUTH_CONFIG_ERROR_MESSAGE,
                    ]);

                return new RoutingAuthProvider(authProviders);
    }
}

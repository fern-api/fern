// This file was auto-generated by Fern from our API Definition.

import type * as core from "../core/index.js";
import { BearerAuthProvider } from "./BearerAuthProvider.js";
import { HeaderAuthProvider } from "./HeaderAuthProvider.js";
import { OAuthAuthProvider } from "./OAuthAuthProvider.js";

export namespace RoutingAuthProvider {
    type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;

    export type AuthOptions = Partial<
        UnionToIntersection<
            BearerAuthProvider.AuthOptions | HeaderAuthProvider.AuthOptions | { oAuth?: OAuthAuthProvider.AuthOptions }
        >
    >;
}

export class RoutingAuthProvider implements core.AuthProvider {
    private readonly authProviders: Map<string, core.AuthProvider>;

    constructor(authProviders: Map<string, core.AuthProvider>) {
        this.authProviders = authProviders;
    }

    private static getAuthConfigErrorMessage(schemeKey: string): string {
        switch (schemeKey) {
            case "Bearer":
                return BearerAuthProvider.getAuthConfigErrorMessage();
            case "ApiKey":
                return HeaderAuthProvider.getAuthConfigErrorMessage();
            case "OAuth":
                return OAuthAuthProvider.getAuthConfigErrorMessage();
            default:
                return `Please provide the required authentication credentials for ${schemeKey} when initializing the client`;
        }
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        const security = endpointMetadata?.security;

        // If no security requirements specified, endpoint is anonymous - return empty auth request
        if (security == null || security.length === 0) {
            return { headers: {} };
        }

        // First, verify that at least one security requirement can be satisfied by available providers
        const canSatisfyAnyRequirement = security.some((securityRequirement) => {
            const schemeKeys = Object.keys(securityRequirement);
            return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
        });

        if (!canSatisfyAnyRequirement) {
            // Build user-friendly error message showing which auth options are missing
            const missingAuthHints = security
                .map((req) => {
                    const schemeKeys = Object.keys(req);
                    const missingSchemes = schemeKeys.filter((key) => !this.authProviders.has(key));
                    return missingSchemes
                        .map((key) => RoutingAuthProvider.getAuthConfigErrorMessage(key))
                        .join(" AND ");
                })
                .join(" OR ");
            throw new Error(
                "No authentication credentials provided that satisfy the endpoint's security requirements. " +
                    missingAuthHints,
            );
        }

        // Get the first security requirement that can be satisfied (OR relationship)
        const satisfiableRequirement = security.find((securityRequirement) => {
            const schemeKeys = Object.keys(securityRequirement);
            return schemeKeys.every((schemeKey) => this.authProviders.has(schemeKey));
        })!;

        // Get auth for all schemes in the satisfiable requirement (AND relationship)
        const combinedHeaders: Record<string, string> = {};
        for (const schemeKey of Object.keys(satisfiableRequirement)) {
            const provider = this.authProviders.get(schemeKey);
            if (provider == null) {
                throw new Error(`Internal error: auth provider not found for scheme: ${schemeKey}`);
            }
            const authRequest = await provider.getAuthRequest({ endpointMetadata });
            Object.assign(combinedHeaders, authRequest.headers);
        }

        return { headers: combinedHeaders };
    }
}

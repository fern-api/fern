/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { setupServer } from "msw/node";
import { SeedExhaustiveClient } from "../../../src/Client";
import { requestBuilder as httpHandlerBuilder } from "../../msw/requestBuilder";

const baseUrl = "http://localhost:9999";
const client = new SeedExhaustiveClient({
    environment: baseUrl,
    token: "test",
});

describe("Container", () => {
    const server = setupServer();

    beforeEach(() => {
        server.resetHandlers();
    });

    afterEach(() => {
        server.close();
    });

    test("getAndReturnListOfPrimitives", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/list-of-primitives")
                .header("Content-Type", "application/json")
                .requestJsonBody(["string", "string"])
                .respondWithJsonBody(["string", "string"]),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnListOfPrimitives(["string", "string"]);
        expect(response).toEqual(["string", "string"]);
    });

    test("getAndReturnListOfObjects", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/list-of-objects")
                .header("Content-Type", "application/json")
                .requestJsonBody([
                    {
                        string: "string",
                    },
                    {
                        string: "string",
                    },
                ])
                .respondWithJsonBody([
                    {
                        string: "string",
                    },
                    {
                        string: "string",
                    },
                ]),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnListOfObjects([
            {
                string: "string",
            },
            {
                string: "string",
            },
        ]);
        expect(response).toEqual([{ string: "string" }, { string: "string" }]);
    });

    test("getAndReturnSetOfPrimitives", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/set-of-primitives")
                .header("Content-Type", "application/json")
                .requestJsonBody(["string"])
                .respondWithJsonBody(["string"]),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnSetOfPrimitives(["string"]);
        expect(response).toEqual(["string"]);
    });

    test("getAndReturnSetOfObjects", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/set-of-objects")
                .header("Content-Type", "application/json")
                .requestJsonBody([
                    {
                        string: "string",
                    },
                ])
                .respondWithJsonBody([
                    {
                        string: "string",
                    },
                ]),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnSetOfObjects([
            {
                string: "string",
            },
        ]);
        expect(response).toEqual([{ string: "string" }]);
    });

    test("getAndReturnMapPrimToPrim", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/map-prim-to-prim")
                .header("Content-Type", "application/json")
                .requestJsonBody({
                    string: "string",
                })
                .respondWithJsonBody({
                    string: "string",
                }),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnMapPrimToPrim({
            string: "string",
        });
        expect(response).toEqual({ string: "string" });
    });

    test("getAndReturnMapOfPrimToObject", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/map-prim-to-object")
                .header("Content-Type", "application/json")
                .requestJsonBody({
                    string: {
                        string: "string",
                    },
                })
                .respondWithJsonBody({
                    string: {
                        string: "string",
                    },
                }),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnMapOfPrimToObject({
            string: {
                string: "string",
            },
        });
        expect(response).toEqual({ string: { string: "string" } });
    });

    test("getAndReturnOptional", async () => {
        server.use(
            httpHandlerBuilder({ once: true })
                .baseUrl(baseUrl)
                .post("/container/opt-objects")
                .header("Content-Type", "application/json")
                .requestJsonBody({
                    string: "string",
                })
                .respondWithJsonBody({
                    string: "string",
                }),
        );
        server.listen({ onUnhandledRequest: "error" });

        const response = await client.endpoints.container.getAndReturnOptional({
            string: "string",
        });
        expect(response).toEqual({ string: "string" });
    });
});

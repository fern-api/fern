// This file was auto-generated by Fern from our API Definition.

import {
    type QueryClient,
    type UseMutationOptions,
    type UseMutationResult,
    type UseQueryOptions,
    type UseQueryResult,
    type UseSuspenseQueryOptions,
    type UseSuspenseQueryResult,
    useMutation,
    useQuery,
    useSuspenseQuery,
} from "@tanstack/react-query";
import { useContext } from "react";
import { SdkClientContext } from "./index.js";

export function useEndpointsParamsGetWithPath(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithPath must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithpath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPath();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithPathSuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithPathSuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithpath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPath();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithPath(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithpath"],
        ...filters,
    });
}

export function invalidateAllEndpointsParams(queryClient: QueryClient): Promise<void> {
    return queryClient.invalidateQueries({
        predicate: (query) => {
            const key = query.queryKey[0];
            return typeof key === "string" && key.startsWith("endpointsparams");
        },
    });
}

export async function prefetchEndpointsParamsGetWithPath(client: any, queryClient: QueryClient): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithpath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPath();
        },
    });
}

export function useEndpointsParamsGetWithInlinePath(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithInlinePath must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithinlinepath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePath();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithInlinePathSuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithInlinePathSuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithinlinepath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePath();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithInlinePath(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithinlinepath"],
        ...filters,
    });
}

export async function prefetchEndpointsParamsGetWithInlinePath(client: any, queryClient: QueryClient): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithinlinepath"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePath();
        },
    });
}

export function useEndpointsParamsGetWithQuery(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithQuery must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithQuery();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithQuerySuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithQuerySuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithQuery();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithQuery(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithquery"],
        ...filters,
    });
}

export async function prefetchEndpointsParamsGetWithQuery(client: any, queryClient: QueryClient): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithQuery();
        },
    });
}

export function useEndpointsParamsGetWithAllowMultipleQuery(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithAllowMultipleQuery must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithallowmultiplequery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithAllowMultipleQuery();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithAllowMultipleQuerySuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithAllowMultipleQuerySuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithallowmultiplequery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithAllowMultipleQuery();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithAllowMultipleQuery(
    queryClient: QueryClient,
    filters?: any,
): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithallowmultiplequery"],
        ...filters,
    });
}

export async function prefetchEndpointsParamsGetWithAllowMultipleQuery(
    client: any,
    queryClient: QueryClient,
): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithallowmultiplequery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithAllowMultipleQuery();
        },
    });
}

export function useEndpointsParamsGetWithPathAndQuery(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithPathAndQuery must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithpathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPathAndQuery();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithPathAndQuerySuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithPathAndQuerySuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithpathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPathAndQuery();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithPathAndQuery(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithpathandquery"],
        ...filters,
    });
}

export async function prefetchEndpointsParamsGetWithPathAndQuery(client: any, queryClient: QueryClient): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithpathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithPathAndQuery();
        },
    });
}

export function useEndpointsParamsGetWithInlinePathAndQuery(
    options?: UseQueryOptions<unknown, Error, unknown, string[]>,
): UseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithInlinePathAndQuery must be used within a provider");
    }

    return useQuery({
        queryKey: ["endpointsparams.getwithinlinepathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePathAndQuery();
        },
        ...options,
    });
}

export function useEndpointsParamsGetWithInlinePathAndQuerySuspense(
    options?: UseSuspenseQueryOptions<unknown, Error, unknown, string[]>,
): UseSuspenseQueryResult<unknown, Error> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsGetWithInlinePathAndQuerySuspense must be used within a provider");
    }

    return useSuspenseQuery({
        queryKey: ["endpointsparams.getwithinlinepathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePathAndQuery();
        },
        ...options,
    });
}

export function invalidateEndpointsParamsGetWithInlinePathAndQuery(
    queryClient: QueryClient,
    filters?: any,
): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.getwithinlinepathandquery"],
        ...filters,
    });
}

export async function prefetchEndpointsParamsGetWithInlinePathAndQuery(
    client: any,
    queryClient: QueryClient,
): Promise<void> {
    await queryClient.prefetchQuery({
        queryKey: ["endpointsparams.getwithinlinepathandquery"],
        queryFn: async () => {
            return await client.endpoints.params.getWithInlinePathAndQuery();
        },
    });
}

export function useEndpointsParamsModifyWithPathMutation(
    options?: UseMutationOptions<unknown, Error, any, unknown>,
): UseMutationResult<unknown, Error, any, unknown> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsModifyWithPathMutation must be used within a provider");
    }

    return useMutation({
        mutationFn: async (variables) => {
            return await client.endpoints.params.modifyWithPath(variables);
        },
        ...options,
    });
}

export function invalidateEndpointsParamsModifyWithPath(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.modifywithpath"],
        ...filters,
    });
}

export function useEndpointsParamsModifyWithInlinePathMutation(
    options?: UseMutationOptions<unknown, Error, any, unknown>,
): UseMutationResult<unknown, Error, any, unknown> {
    const client = useContext(SdkClientContext);
    if (!client) {
        throw new Error("useEndpointsParamsModifyWithInlinePathMutation must be used within a provider");
    }

    return useMutation({
        mutationFn: async (variables) => {
            return await client.endpoints.params.modifyWithInlinePath(variables);
        },
        ...options,
    });
}

export function invalidateEndpointsParamsModifyWithInlinePath(queryClient: QueryClient, filters?: any): Promise<void> {
    return queryClient.invalidateQueries({
        queryKey: ["endpointsparams.modifywithinlinepath"],
        ...filters,
    });
}

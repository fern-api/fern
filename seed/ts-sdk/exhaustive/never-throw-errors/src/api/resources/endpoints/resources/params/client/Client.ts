// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { normalizeClientOptions } from "../../../../../../BaseClient.js";
import * as core from "../../../../../../core/index.js";
import * as SeedExhaustive from "../../../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";

export declare namespace ParamsClient {
    export interface Options extends BaseClientOptions {
    }

    export interface RequestOptions extends BaseRequestOptions {
    }
}

export class ParamsClient {
    protected readonly _options: ParamsClient.Options;

    constructor(options: ParamsClient.Options) {

        this._options = normalizeClientOptions(options);
    }

    /**
     * GET with path param
     *
     * @param {string} param
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithPath("param")
     */
    public getWithPath(param: string, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<string, SeedExhaustive.endpoints.params.getWithPath.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithPath(param, requestOptions));
    }

    private async __getWithPath(param: string, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<string, SeedExhaustive.endpoints.params.getWithPath.Error>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path/${core.url.encodePathParam(param)}`),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: _response.body as string,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithPath.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * GET with path param
     *
     * @param {SeedExhaustive.endpoints.GetWithInlinePath} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithInlinePath({
     *         param: "param"
     *     })
     */
    public getWithInlinePath(request: SeedExhaustive.endpoints.GetWithInlinePath, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<string, SeedExhaustive.endpoints.params.getWithInlinePath.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithInlinePath(request, requestOptions));
    }

    private async __getWithInlinePath(request: SeedExhaustive.endpoints.GetWithInlinePath, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<string, SeedExhaustive.endpoints.params.getWithInlinePath.Error>>> {
        const { param } = request;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path/${core.url.encodePathParam(param)}`),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: _response.body as string,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithInlinePath.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * GET with query param
     *
     * @param {SeedExhaustive.endpoints.GetWithQuery} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithQuery({
     *         query: "query",
     *         number: 1
     *     })
     */
    public getWithQuery(request: SeedExhaustive.endpoints.GetWithQuery, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithQuery.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithQuery(request, requestOptions));
    }

    private async __getWithQuery(request: SeedExhaustive.endpoints.GetWithQuery, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithQuery.Error>>> {
        const { query, "number": number_ } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["query"] = query;
        _queryParams["number"] = number_.toString();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), "/params"),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithQuery.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * GET with multiple of same query param
     *
     * @param {SeedExhaustive.endpoints.GetWithMultipleQuery} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithAllowMultipleQuery({
     *         query: "query",
     *         number: 1
     *     })
     */
    public getWithAllowMultipleQuery(request: SeedExhaustive.endpoints.GetWithMultipleQuery, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithAllowMultipleQuery.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithAllowMultipleQuery(request, requestOptions));
    }

    private async __getWithAllowMultipleQuery(request: SeedExhaustive.endpoints.GetWithMultipleQuery, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithAllowMultipleQuery.Error>>> {
        const { query, "number": number_ } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (Array.isArray(query)) {
            _queryParams["query"] = query.map(item => item);
        }
        else {
            _queryParams["query"] = query;
        }

        if (Array.isArray(number_)) {
            _queryParams["number"] = number_.map(item => item.toString());
        }
        else {
            _queryParams["number"] = number_.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), "/params"),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithAllowMultipleQuery.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * GET with path and query params
     *
     * @param {string} param
     * @param {SeedExhaustive.endpoints.GetWithPathAndQuery} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithPathAndQuery("param", {
     *         query: "query"
     *     })
     */
    public getWithPathAndQuery(param: string, request: SeedExhaustive.endpoints.GetWithPathAndQuery, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithPathAndQuery.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithPathAndQuery(param, request, requestOptions));
    }

    private async __getWithPathAndQuery(param: string, request: SeedExhaustive.endpoints.GetWithPathAndQuery, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithPathAndQuery.Error>>> {
        const { query } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["query"] = query;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path-query/${core.url.encodePathParam(param)}`),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithPathAndQuery.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * GET with path and query params
     *
     * @param {SeedExhaustive.endpoints.GetWithInlinePathAndQuery} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.getWithInlinePathAndQuery({
     *         param: "param",
     *         query: "query"
     *     })
     */
    public getWithInlinePathAndQuery(request: SeedExhaustive.endpoints.GetWithInlinePathAndQuery, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithInlinePathAndQuery.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__getWithInlinePathAndQuery(request, requestOptions));
    }

    private async __getWithInlinePathAndQuery(request: SeedExhaustive.endpoints.GetWithInlinePathAndQuery, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<void, SeedExhaustive.endpoints.params.getWithInlinePathAndQuery.Error>>> {
        const { param, query } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["query"] = query;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path-query/${core.url.encodePathParam(param)}`),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: undefined,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.getWithInlinePathAndQuery.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * PUT to update with path param
     *
     * @param {string} param
     * @param {string} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.modifyWithPath("param", "string")
     */
    public modifyWithPath(param: string, request: string, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<string, SeedExhaustive.endpoints.params.modifyWithPath.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__modifyWithPath(param, request, requestOptions));
    }

    private async __modifyWithPath(param: string, request: string, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<string, SeedExhaustive.endpoints.params.modifyWithPath.Error>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path/${core.url.encodePathParam(param)}`),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: _response.body as string,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.modifyWithPath.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    /**
     * PUT to update with path param
     *
     * @param {SeedExhaustive.endpoints.ModifyResourceAtInlinedPath} request
     * @param {ParamsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.endpoints.params.modifyWithInlinePath({
     *         param: "param",
     *         body: "string"
     *     })
     */
    public modifyWithInlinePath(request: SeedExhaustive.endpoints.ModifyResourceAtInlinedPath, requestOptions?: ParamsClient.RequestOptions): core.HttpResponsePromise<core.APIResponse<string, SeedExhaustive.endpoints.params.modifyWithInlinePath.Error>> {
        return core.HttpResponsePromise.fromPromise(this.__modifyWithInlinePath(request, requestOptions));
    }

    private async __modifyWithInlinePath(request: SeedExhaustive.endpoints.ModifyResourceAtInlinedPath, requestOptions?: ParamsClient.RequestOptions): Promise<core.WithRawResponse<core.APIResponse<string, SeedExhaustive.endpoints.params.modifyWithInlinePath.Error>>> {
        const { param, body: _body } = request;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, mergeOnlyDefinedHeaders({ "Authorization": await this._getAuthorizationHeader() }), requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(await core.Supplier.get(this._options.baseUrl) ?? await core.Supplier.get(this._options.environment), `/params/path/${core.url.encodePathParam(param)}`),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging
        });
        if (_response.ok) {
            return { data: {
                    ok: true,
                    body: _response.body as string,
                    headers: _response.headers,
                    rawResponse: _response.rawResponse
                }, rawResponse: _response.rawResponse };
        }

        return { data: {
                ok: false,
                error: SeedExhaustive.endpoints.params.modifyWithInlinePath.Error._unknown(_response.error),
                rawResponse: _response.rawResponse
            }, rawResponse: _response.rawResponse };
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}

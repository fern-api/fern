// This file was auto-generated by Fern from our API Definition.

import { AuthClient } from "../api/resources/auth/client/Client.js";
import type { BaseClientOptions } from "../BaseClient.js";
import * as core from "../core/index.js";
import * as errors from "../errors/index.js";

const WRAPPER_PROPERTY = "inferredAuth" as const;
const BUFFER_IN_MINUTES = 2 as const;

function throwRequiredAuthParamErrorMessage(paramName: string): never {
    throw new errors.SeedAnyAuthError({
        message: `Please provide ${paramName} when initializing the client`,
    });
}

export class InferredAuthProvider implements core.AuthProvider {
    private readonly client: AuthClient;
    private readonly options: InferredAuthProvider.Options;
    private expiresAt: Date | undefined;
    private authRequestPromise: Promise<core.AuthRequest> | undefined;

    constructor(options: InferredAuthProvider.Options) {
        this.options = options;
        this.client = new AuthClient(options);
    }

    public static canCreate(options: Partial<InferredAuthProvider.Options>): boolean {
        return options?.[WRAPPER_PROPERTY]?.clientId != null && options?.[WRAPPER_PROPERTY]?.clientSecret != null;
    }

    private async getCachedAuthRequest(): Promise<core.AuthRequest> {
        if (this.expiresAt && this.expiresAt <= new Date()) {
            // If the token has expired, reset the auth request promise
            this.authRequestPromise = undefined;
        }

        if (!this.authRequestPromise) {
            this.authRequestPromise = this.getAuthRequestFromTokenEndpoint();
        }

        return this.authRequestPromise;
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        try {
            const authRequest = await this.getCachedAuthRequest();
            return authRequest;
        } catch (e) {
            this.authRequestPromise = undefined;
            this.expiresAt = undefined;
            throw e;
        }
    }

    private async getAuthRequestFromTokenEndpoint(): Promise<core.AuthRequest> {
        const clientId = await core.Supplier.get(this.options[WRAPPER_PROPERTY]?.clientId);
        if (clientId == null) {
            throwRequiredAuthParamErrorMessage(`${WRAPPER_PROPERTY}.clientId`);
        }

        const clientSecret = await core.Supplier.get(this.options[WRAPPER_PROPERTY]?.clientSecret);
        if (clientSecret == null) {
            throwRequiredAuthParamErrorMessage(`${WRAPPER_PROPERTY}.clientSecret`);
        }

        const response = await this.client.getToken({
            client_id: clientId,
            client_secret: clientSecret,
        });
        this.expiresAt = getExpiresAt(response.expires_in);
        return {
            headers: {
                Authorization: `Bearer ${response.access_token}`,
            },
        };
    }
}

function getExpiresAt(expiresInSeconds: number): Date {
    return new Date(Date.now() + expiresInSeconds * 1000 - BUFFER_IN_MINUTES * 60 * 1000);
}

export namespace InferredAuthProvider {
    export const AUTH_SCHEME = "InferredAuth" as const;
    export const AUTH_CONFIG_ERROR_MESSAGE: string =
        "Please provide clientId and clientSecret when initializing the client" as const;
    export type AuthOptions = {
        [WRAPPER_PROPERTY]: {
            clientId: core.Supplier<string> | undefined;
            clientSecret: core.Supplier<string> | undefined;
        };
    };
    export type Options = BaseClientOptions;

    export function createInstance(options: Options): core.AuthProvider {
        return new InferredAuthProvider(options);
    }
}

// This file was auto-generated by Fern from our API Definition.

import { AuthClient } from "../api/resources/auth/client/Client.js";
import type { BaseClientOptions } from "../BaseClient.js";
import * as core from "../core/index.js";
import * as errors from "../errors/index.js";

const WRAPPER_PROPERTY = "oauth" as const;
const CLIENT_ID_PARAM = "clientId" as const;
const CLIENT_SECRET_PARAM = "clientSecret" as const;
const TOKEN_PARAM = "token" as const;
const ENV_CLIENT_ID = "MY_CLIENT_ID" as const;
const ENV_CLIENT_SECRET = "MY_CLIENT_SECRET" as const;
const CLIENT_ID_REQUIRED_ERROR_MESSAGE =
    `${CLIENT_ID_PARAM} is required; either pass it as an argument or set the ${ENV_CLIENT_ID} environment variable` as const;
const CLIENT_SECRET_REQUIRED_ERROR_MESSAGE =
    `${CLIENT_SECRET_PARAM} is required; either pass it as an argument or set the ${ENV_CLIENT_SECRET} environment variable` as const;
const TOKEN_PARAM_REQUIRED_ERROR_MESSAGE = `${TOKEN_PARAM} is required. Please provide it in options.` as const;
const BUFFER_IN_MINUTES = 2 as const;

export class OAuthAuthProvider implements core.AuthProvider {
    private readonly options: BaseClientOptions & OAuthAuthProvider.ClientCredentials;
    private readonly authClient: AuthClient;
    private accessToken: string | undefined;
    private expiresAt: Date;
    private refreshPromise: Promise<string> | undefined;

    constructor(options: OAuthAuthProvider.Options & OAuthAuthProvider.ClientCredentials) {
        this.options = options;
        this.authClient = new AuthClient(options);
        this.expiresAt = new Date();
    }

    public static canCreate(options?: Partial<OAuthAuthProvider.ClientCredentials & BaseClientOptions>): boolean {
        return (
            (options?.[WRAPPER_PROPERTY]?.[CLIENT_ID_PARAM] != null || process.env?.[ENV_CLIENT_ID] != null) &&
            (options?.[WRAPPER_PROPERTY]?.[CLIENT_SECRET_PARAM] != null || process.env?.[ENV_CLIENT_SECRET] != null)
        );
    }

    private async clientIdSupplier({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<string> {
        const supplier = this.options[WRAPPER_PROPERTY]?.[CLIENT_ID_PARAM];
        if (supplier != null) {
            return core.EndpointSupplier.get(supplier, { endpointMetadata });
        }
        const envClientId = process.env?.[ENV_CLIENT_ID];
        if (envClientId != null) {
            return envClientId;
        }
        throw new errors.SeedAnyAuthError({
            message: CLIENT_ID_REQUIRED_ERROR_MESSAGE,
        });
    }

    private async clientSecretSupplier({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<string> {
        const supplier = this.options[WRAPPER_PROPERTY]?.[CLIENT_SECRET_PARAM];
        if (supplier != null) {
            return core.EndpointSupplier.get(supplier, { endpointMetadata });
        }
        const envClientSecret = process.env?.[ENV_CLIENT_SECRET];
        if (envClientSecret != null) {
            return envClientSecret;
        }
        throw new errors.SeedAnyAuthError({
            message: CLIENT_SECRET_REQUIRED_ERROR_MESSAGE,
        });
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        const token = await this.getToken({ endpointMetadata });

        return {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        };
    }

    private async getToken({ endpointMetadata }: { endpointMetadata?: core.EndpointMetadata } = {}): Promise<string> {
        if (this.accessToken && this.expiresAt > new Date()) {
            return this.accessToken;
        }
        // If a refresh is already in progress, return the existing promise
        if (this.refreshPromise != null) {
            return this.refreshPromise;
        }
        return this.refresh({ endpointMetadata });
    }

    private async refresh({ endpointMetadata }: { endpointMetadata?: core.EndpointMetadata } = {}): Promise<string> {
        this.refreshPromise = (async () => {
            try {
                const clientId = await this.clientIdSupplier({ endpointMetadata });
                const clientSecret = await this.clientSecretSupplier({ endpointMetadata });
                const tokenResponse = await this.authClient.getToken({
                    client_id: clientId,
                    client_secret: clientSecret,
                });

                this.accessToken = tokenResponse.access_token;
                this.expiresAt = this.getExpiresAt(tokenResponse.expires_in, BUFFER_IN_MINUTES);
                return this.accessToken;
            } finally {
                this.refreshPromise = undefined;
            }
        })();
        return this.refreshPromise;
    }

    private getExpiresAt(expiresInSeconds: number, bufferInMinutes: number): Date {
        const now = new Date();
        return new Date(now.getTime() + expiresInSeconds * 1000 - bufferInMinutes * 60 * 1000);
    }
}

export class OAuthTokenOverrideAuthProvider implements core.AuthProvider {
    private readonly options: OAuthAuthProvider.TokenOverride;

    constructor(options: OAuthAuthProvider.TokenOverride) {
        this.options = options;
    }

    public static canCreate(
        options?: Partial<OAuthAuthProvider.TokenOverride & BaseClientOptions>,
    ): options is OAuthAuthProvider.TokenOverride {
        return options?.[WRAPPER_PROPERTY]?.[TOKEN_PARAM] != null;
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        const token = this.options[WRAPPER_PROPERTY]?.[TOKEN_PARAM];
        if (token == null) {
            throw new errors.SeedAnyAuthError({
                message: TOKEN_PARAM_REQUIRED_ERROR_MESSAGE,
            });
        }
        return {
            headers: {
                Authorization: `Bearer ${await core.EndpointSupplier.get(token, { endpointMetadata })}`,
            },
        };
    }
}

export namespace OAuthAuthProvider {
    export const AUTH_SCHEME = "OAuth" as const;
    export const AUTH_CONFIG_ERROR_MESSAGE: string =
        `Insufficient options to create OAuthAuthProvider. Please provide either '${CLIENT_ID_PARAM}' or '${ENV_CLIENT_ID}' env var and '${CLIENT_SECRET_PARAM}' or '${ENV_CLIENT_SECRET}' env var, or ${TOKEN_PARAM}.` as const;

    export interface ClientCredentials {
        [WRAPPER_PROPERTY]?: {
            [CLIENT_ID_PARAM]?: core.Supplier<string> | undefined;
            [CLIENT_SECRET_PARAM]?: core.Supplier<string> | undefined;
        };
    }

    export interface TokenOverride {
        [WRAPPER_PROPERTY]?: { [TOKEN_PARAM]?: core.Supplier<string> };
    }

    export type AuthOptions = ClientCredentials | TokenOverride;
    export type Options = BaseClientOptions & AuthOptions;

    export function createInstance(options: Options): core.AuthProvider {
        if (OAuthTokenOverrideAuthProvider.canCreate(options)) {
            return new OAuthTokenOverrideAuthProvider(options);
        } else if (OAuthAuthProvider.canCreate(options)) {
            return new OAuthAuthProvider(options);
        }
        throw new errors.SeedAnyAuthError({
            message: AUTH_CONFIG_ERROR_MESSAGE,
        });
    }
}

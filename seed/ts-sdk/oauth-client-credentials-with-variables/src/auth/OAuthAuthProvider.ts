// This file was auto-generated by Fern from our API Definition.

import { AuthClient } from "../api/resources/auth/client/Client.js";
import type { BaseClientOptions } from "../BaseClient.js";
import * as core from "../core/index.js";
import * as errors from "../errors/index.js";

const CLIENT_ID_PARAM = "clientId" as const;
const CLIENT_SECRET_PARAM = "clientSecret" as const;
const TOKEN_PARAM = "token" as const;
const CLIENT_ID_REQUIRED_ERROR_MESSAGE = `${CLIENT_ID_PARAM} is required` as const;
const CLIENT_SECRET_REQUIRED_ERROR_MESSAGE = `${CLIENT_SECRET_PARAM} is required` as const;
const TOKEN_PARAM_REQUIRED_ERROR_MESSAGE = `${TOKEN_PARAM} is required. Please provide it in options.` as const;
const BUFFER_IN_MINUTES = 2 as const;

export class OAuthAuthProvider implements core.AuthProvider {
    private readonly options: BaseClientOptions & OAuthAuthProvider.ClientCredentials;
    private readonly authClient: AuthClient;
    private accessToken: string | undefined;
    private expiresAt: Date;
    private refreshPromise: Promise<string> | undefined;

    constructor(options: OAuthAuthProvider.Options & OAuthAuthProvider.ClientCredentials) {
        this.options = options;
        this.authClient = new AuthClient(options);
        this.expiresAt = new Date();
    }

    public static canCreate(options?: Partial<OAuthAuthProvider.ClientCredentials & BaseClientOptions>): boolean {
        return options?.[CLIENT_ID_PARAM] != null && options?.[CLIENT_SECRET_PARAM] != null;
    }

    private async clientIdSupplier({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<string> {
        const supplier = this.options[CLIENT_ID_PARAM];
        if (supplier == null) {
            throw new errors.SeedOauthClientCredentialsWithVariablesError({
                message: CLIENT_ID_REQUIRED_ERROR_MESSAGE,
            });
        }
        return core.EndpointSupplier.get(supplier, { endpointMetadata });
    }

    private async clientSecretSupplier({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<string> {
        const supplier = this.options[CLIENT_SECRET_PARAM];
        if (supplier == null) {
            throw new errors.SeedOauthClientCredentialsWithVariablesError({
                message: CLIENT_SECRET_REQUIRED_ERROR_MESSAGE,
            });
        }
        return core.EndpointSupplier.get(supplier, { endpointMetadata });
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        const token = await this.getToken({ endpointMetadata });

        return {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        };
    }

    private async getToken({ endpointMetadata }: { endpointMetadata?: core.EndpointMetadata } = {}): Promise<string> {
        if (this.accessToken && this.expiresAt > new Date()) {
            return this.accessToken;
        }
        // If a refresh is already in progress, return the existing promise
        if (this.refreshPromise != null) {
            return this.refreshPromise;
        }
        return this.refresh({ endpointMetadata });
    }

    private async refresh({ endpointMetadata }: { endpointMetadata?: core.EndpointMetadata } = {}): Promise<string> {
        this.refreshPromise = (async () => {
            try {
                const clientId = await this.clientIdSupplier({ endpointMetadata });
                const clientSecret = await this.clientSecretSupplier({ endpointMetadata });
                const tokenResponse = await this.authClient.getTokenWithClientCredentials({
                    client_id: clientId,
                    client_secret: clientSecret,
                });

                this.accessToken = tokenResponse.access_token;
                this.expiresAt = this.getExpiresAt(tokenResponse.expires_in, BUFFER_IN_MINUTES);
                return this.accessToken;
            } finally {
                this.refreshPromise = undefined;
            }
        })();
        return this.refreshPromise;
    }

    private getExpiresAt(expiresInSeconds: number, bufferInMinutes: number): Date {
        const now = new Date();
        return new Date(now.getTime() + expiresInSeconds * 1000 - bufferInMinutes * 60 * 1000);
    }
}

export class OAuthTokenOverrideAuthProvider implements core.AuthProvider {
    private readonly options: OAuthAuthProvider.TokenOverride;

    constructor(options: OAuthAuthProvider.TokenOverride) {
        this.options = options;
    }

    public static canCreate(
        options?: Partial<OAuthAuthProvider.TokenOverride & BaseClientOptions>,
    ): options is OAuthAuthProvider.TokenOverride {
        return options?.[TOKEN_PARAM] != null;
    }

    public async getAuthRequest({
        endpointMetadata,
    }: {
        endpointMetadata?: core.EndpointMetadata;
    } = {}): Promise<core.AuthRequest> {
        const token = this.options[TOKEN_PARAM];
        if (token == null) {
            throw new errors.SeedOauthClientCredentialsWithVariablesError({
                message: TOKEN_PARAM_REQUIRED_ERROR_MESSAGE,
            });
        }
        return {
            headers: {
                Authorization: `Bearer ${await core.EndpointSupplier.get(token, { endpointMetadata })}`,
            },
        };
    }
}

export namespace OAuthAuthProvider {
    export const AUTH_SCHEME = "OAuthScheme" as const;
    export const AUTH_CONFIG_ERROR_MESSAGE: string =
        `Insufficient options to create OAuthAuthProvider. Please provide '${CLIENT_ID_PARAM}' and '${CLIENT_SECRET_PARAM}', or ${TOKEN_PARAM}.` as const;
    export type ClientCredentials = {
        [CLIENT_ID_PARAM]?: core.Supplier<string>;
        [CLIENT_SECRET_PARAM]?: core.Supplier<string>;
    };
    export type TokenOverride = {
        [TOKEN_PARAM]?: core.Supplier<string>;
    };
    export type AuthOptions = ClientCredentials | TokenOverride;
    export type Options = BaseClientOptions & AuthOptions;

    export function createInstance(options: Options): core.AuthProvider {
        if (OAuthTokenOverrideAuthProvider.canCreate(options)) {
            return new OAuthTokenOverrideAuthProvider(options);
        } else if (OAuthAuthProvider.canCreate(options)) {
            return new OAuthAuthProvider(options);
        }
        throw new errors.SeedOauthClientCredentialsWithVariablesError({
            message: AUTH_CONFIG_ERROR_MESSAGE,
        });
    }
}

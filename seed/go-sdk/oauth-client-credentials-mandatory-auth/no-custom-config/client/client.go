// Code generated by Fern. DO NOT EDIT.

package client

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	auth "github.com/oauth-client-credentials-mandatory-auth/fern/auth"
	core "github.com/oauth-client-credentials-mandatory-auth/fern/core"
	internal "github.com/oauth-client-credentials-mandatory-auth/fern/internal"
	client "github.com/oauth-client-credentials-mandatory-auth/fern/nested/client"
	option "github.com/oauth-client-credentials-mandatory-auth/fern/option"
	simple "github.com/oauth-client-credentials-mandatory-auth/fern/simple"
	http "net/http"
)

type Client struct {
	Auth   *auth.Client
	Nested *client.Client
	Simple *simple.Client

	options            *core.RequestOptions
	oauthTokenProvider *core.OAuthTokenProvider
	baseURL            string
	caller             *internal.Caller
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	tokenFetcher := func(ctx context.Context) (*core.OAuthTokenResponse, error) {
		requestBody := map[string]interface{}{
			"client_id":     options.ClientID,
			"client_secret": options.ClientSecret,
			"grant_type":    "client_credentials",
		}

		jsonBody, err := json.Marshal(requestBody)
		if err != nil {
			return nil, err
		}

		url := options.BaseURL + "//token"

		req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(jsonBody))
		if err != nil {
			return nil, err
		}
		req.Header.Set("Content-Type", "application/json")

		httpClient := options.HTTPClient
		if httpClient == nil {
			httpClient = http.DefaultClient
		}
		resp, err := httpClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return nil, core.NewAPIError(resp.StatusCode, resp.Header, nil)
		}

		var rawResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&rawResponse); err != nil {
			return nil, err
		}

		tokenResp := &core.OAuthTokenResponse{}
		if accessToken, ok := rawResponse["access_token"].(string); ok {
			tokenResp.AccessToken = accessToken
		}
		if expiresIn, ok := rawResponse["expires_in"].(float64); ok {
			tokenResp.ExpiresIn = int(expiresIn)
		}
		return tokenResp, nil
	}

	oauthTokenProvider := core.NewOAuthTokenProvider(tokenFetcher)
	options.OAuthTokenProvider = oauthTokenProvider

	return &Client{
		Auth:               auth.NewClient(options),
		Nested:             client.NewClient(options),
		Simple:             simple.NewClient(options),
		oauthTokenProvider: oauthTokenProvider,
		options:            options,
		baseURL:            options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
	}
}

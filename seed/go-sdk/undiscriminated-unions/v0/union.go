// Code generated by Fern. DO NOT EDIT.

package undiscriminatedunions

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/undiscriminated-unions/fern/internal"
	big "math/big"
)

var (
	paymentRequestFieldPaymentMethod = big.NewInt(1 << 0)
)

type PaymentRequest struct {
	PaymentMethod *PaymentMethodUnion `json:"paymentMethod,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PaymentRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetPaymentMethod(paymentMethod *PaymentMethodUnion) {
	p.PaymentMethod = paymentMethod
	p.require(paymentRequestFieldPaymentMethod)
}

var (
	convertTokenFieldMethod  = big.NewInt(1 << 0)
	convertTokenFieldTokenId = big.NewInt(1 << 1)
)

type ConvertToken struct {
	Method  string `json:"method" url:"method"`
	TokenId string `json:"tokenId" url:"tokenId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConvertToken) GetMethod() string {
	if c == nil {
		return ""
	}
	return c.Method
}

func (c *ConvertToken) GetTokenId() string {
	if c == nil {
		return ""
	}
	return c.TokenId
}

func (c *ConvertToken) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConvertToken) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConvertToken) SetMethod(method string) {
	c.Method = method
	c.require(convertTokenFieldMethod)
}

// SetTokenId sets the TokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConvertToken) SetTokenId(tokenId string) {
	c.TokenId = tokenId
	c.require(convertTokenFieldTokenId)
}

func (c *ConvertToken) UnmarshalJSON(data []byte) error {
	type unmarshaler ConvertToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConvertToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConvertToken) MarshalJSON() ([]byte, error) {
	type embed ConvertToken
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConvertToken) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Key struct {
	KeyType              KeyType
	DefaultStringLiteral string

	typ string
}

func NewKeyFromKeyType(value KeyType) *Key {
	return &Key{typ: "KeyType", KeyType: value}
}

func NewKeyWithDefaultStringLiteral() *Key {
	return &Key{typ: "DefaultStringLiteral", DefaultStringLiteral: "default"}
}

func (k *Key) GetKeyType() KeyType {
	if k == nil {
		return ""
	}
	return k.KeyType
}

func (k *Key) UnmarshalJSON(data []byte) error {
	var valueKeyType KeyType
	if err := json.Unmarshal(data, &valueKeyType); err == nil {
		k.typ = "KeyType"
		k.KeyType = valueKeyType
		return nil
	}
	var valueDefaultStringLiteral string
	if err := json.Unmarshal(data, &valueDefaultStringLiteral); err == nil {
		k.typ = "DefaultStringLiteral"
		k.DefaultStringLiteral = valueDefaultStringLiteral
		if k.DefaultStringLiteral != "default" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", k, "default", valueDefaultStringLiteral)
		}
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k Key) MarshalJSON() ([]byte, error) {
	if k.typ == "KeyType" || k.KeyType != "" {
		return json.Marshal(k.KeyType)
	}
	if k.typ == "DefaultStringLiteral" || k.DefaultStringLiteral != "" {
		return json.Marshal("default")
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KeyVisitor interface {
	VisitKeyType(KeyType) error
	VisitDefaultStringLiteral(string) error
}

func (k *Key) Accept(visitor KeyVisitor) error {
	if k.typ == "KeyType" || k.KeyType != "" {
		return visitor.VisitKeyType(k.KeyType)
	}
	if k.typ == "DefaultStringLiteral" || k.DefaultStringLiteral != "" {
		return visitor.VisitDefaultStringLiteral(k.DefaultStringLiteral)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KeyType string

const (
	KeyTypeName  KeyType = "name"
	KeyTypeValue KeyType = "value"
)

func NewKeyTypeFromString(s string) (KeyType, error) {
	switch s {
	case "name":
		return KeyTypeName, nil
	case "value":
		return KeyTypeValue, nil
	}
	var t KeyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KeyType) Ptr() *KeyType {
	return &k
}

// Undiscriminated unions can act as a map key
// as long as all of their values are valid keys
// (i.e. do they have a valid string representation).
type Metadata = map[*Key]string

type MetadataUnion struct {
	OptionalMetadata OptionalMetadata
	NamedMetadata    *NamedMetadata

	typ string
}

func NewMetadataUnionFromOptionalMetadata(value OptionalMetadata) *MetadataUnion {
	return &MetadataUnion{typ: "OptionalMetadata", OptionalMetadata: value}
}

func NewMetadataUnionFromNamedMetadata(value *NamedMetadata) *MetadataUnion {
	return &MetadataUnion{typ: "NamedMetadata", NamedMetadata: value}
}

func (m *MetadataUnion) GetOptionalMetadata() OptionalMetadata {
	if m == nil {
		return nil
	}
	return m.OptionalMetadata
}

func (m *MetadataUnion) GetNamedMetadata() *NamedMetadata {
	if m == nil {
		return nil
	}
	return m.NamedMetadata
}

func (m *MetadataUnion) UnmarshalJSON(data []byte) error {
	var valueOptionalMetadata OptionalMetadata
	if err := json.Unmarshal(data, &valueOptionalMetadata); err == nil {
		m.typ = "OptionalMetadata"
		m.OptionalMetadata = valueOptionalMetadata
		return nil
	}
	valueNamedMetadata := new(NamedMetadata)
	if err := json.Unmarshal(data, &valueNamedMetadata); err == nil {
		m.typ = "NamedMetadata"
		m.NamedMetadata = valueNamedMetadata
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MetadataUnion) MarshalJSON() ([]byte, error) {
	if m.typ == "OptionalMetadata" || m.OptionalMetadata != nil {
		return json.Marshal(m.OptionalMetadata)
	}
	if m.typ == "NamedMetadata" || m.NamedMetadata != nil {
		return json.Marshal(m.NamedMetadata)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MetadataUnionVisitor interface {
	VisitOptionalMetadata(OptionalMetadata) error
	VisitNamedMetadata(*NamedMetadata) error
}

func (m *MetadataUnion) Accept(visitor MetadataUnionVisitor) error {
	if m.typ == "OptionalMetadata" || m.OptionalMetadata != nil {
		return visitor.VisitOptionalMetadata(m.OptionalMetadata)
	}
	if m.typ == "NamedMetadata" || m.NamedMetadata != nil {
		return visitor.VisitNamedMetadata(m.NamedMetadata)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

// Several different types are accepted.
type MyUnion struct {
	String          string
	StringList      []string
	Integer         int
	IntegerList     []int
	IntegerListList [][]int
	StringSet       []string

	typ string
}

func NewMyUnionFromString(value string) *MyUnion {
	return &MyUnion{typ: "String", String: value}
}

func NewMyUnionFromStringList(value []string) *MyUnion {
	return &MyUnion{typ: "StringList", StringList: value}
}

func NewMyUnionFromInteger(value int) *MyUnion {
	return &MyUnion{typ: "Integer", Integer: value}
}

func NewMyUnionFromIntegerList(value []int) *MyUnion {
	return &MyUnion{typ: "IntegerList", IntegerList: value}
}

func NewMyUnionFromIntegerListList(value [][]int) *MyUnion {
	return &MyUnion{typ: "IntegerListList", IntegerListList: value}
}

func NewMyUnionFromStringSet(value []string) *MyUnion {
	return &MyUnion{typ: "StringSet", StringSet: value}
}

func (m *MyUnion) GetString() string {
	if m == nil {
		return ""
	}
	return m.String
}

func (m *MyUnion) GetStringList() []string {
	if m == nil {
		return nil
	}
	return m.StringList
}

func (m *MyUnion) GetInteger() int {
	if m == nil {
		return 0
	}
	return m.Integer
}

func (m *MyUnion) GetIntegerList() []int {
	if m == nil {
		return nil
	}
	return m.IntegerList
}

func (m *MyUnion) GetIntegerListList() [][]int {
	if m == nil {
		return nil
	}
	return m.IntegerListList
}

func (m *MyUnion) GetStringSet() []string {
	if m == nil {
		return nil
	}
	return m.StringSet
}

func (m *MyUnion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typ = "String"
		m.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		m.typ = "StringList"
		m.StringList = valueStringList
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		m.typ = "Integer"
		m.Integer = valueInteger
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		m.typ = "IntegerList"
		m.IntegerList = valueIntegerList
		return nil
	}
	var valueIntegerListList [][]int
	if err := json.Unmarshal(data, &valueIntegerListList); err == nil {
		m.typ = "IntegerListList"
		m.IntegerListList = valueIntegerListList
		return nil
	}
	var valueStringSet []string
	if err := json.Unmarshal(data, &valueStringSet); err == nil {
		m.typ = "StringSet"
		m.StringSet = valueStringSet
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MyUnion) MarshalJSON() ([]byte, error) {
	if m.typ == "String" || m.String != "" {
		return json.Marshal(m.String)
	}
	if m.typ == "StringList" || m.StringList != nil {
		return json.Marshal(m.StringList)
	}
	if m.typ == "Integer" || m.Integer != 0 {
		return json.Marshal(m.Integer)
	}
	if m.typ == "IntegerList" || m.IntegerList != nil {
		return json.Marshal(m.IntegerList)
	}
	if m.typ == "IntegerListList" || m.IntegerListList != nil {
		return json.Marshal(m.IntegerListList)
	}
	if m.typ == "StringSet" || m.StringSet != nil {
		return json.Marshal(m.StringSet)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MyUnionVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
	VisitInteger(int) error
	VisitIntegerList([]int) error
	VisitIntegerListList([][]int) error
	VisitStringSet([]string) error
}

func (m *MyUnion) Accept(visitor MyUnionVisitor) error {
	if m.typ == "String" || m.String != "" {
		return visitor.VisitString(m.String)
	}
	if m.typ == "StringList" || m.StringList != nil {
		return visitor.VisitStringList(m.StringList)
	}
	if m.typ == "Integer" || m.Integer != 0 {
		return visitor.VisitInteger(m.Integer)
	}
	if m.typ == "IntegerList" || m.IntegerList != nil {
		return visitor.VisitIntegerList(m.IntegerList)
	}
	if m.typ == "IntegerListList" || m.IntegerListList != nil {
		return visitor.VisitIntegerListList(m.IntegerListList)
	}
	if m.typ == "StringSet" || m.StringSet != nil {
		return visitor.VisitStringSet(m.StringSet)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

var (
	namedMetadataFieldName  = big.NewInt(1 << 0)
	namedMetadataFieldValue = big.NewInt(1 << 1)
)

type NamedMetadata struct {
	Name  string                 `json:"name" url:"name"`
	Value map[string]interface{} `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NamedMetadata) GetName() string {
	if n == nil {
		return ""
	}
	return n.Name
}

func (n *NamedMetadata) GetValue() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Value
}

func (n *NamedMetadata) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedMetadata) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedMetadata) SetName(name string) {
	n.Name = name
	n.require(namedMetadataFieldName)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedMetadata) SetValue(value map[string]interface{}) {
	n.Value = value
	n.require(namedMetadataFieldValue)
}

func (n *NamedMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamedMetadata) MarshalJSON() ([]byte, error) {
	type embed NamedMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NamedMetadata) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Nested layer 1.
type NestedUnionL1 struct {
	Integer       int
	StringSet     []string
	StringList    []string
	NestedUnionL2 *NestedUnionL2

	typ string
}

func NewNestedUnionL1FromInteger(value int) *NestedUnionL1 {
	return &NestedUnionL1{typ: "Integer", Integer: value}
}

func NewNestedUnionL1FromStringSet(value []string) *NestedUnionL1 {
	return &NestedUnionL1{typ: "StringSet", StringSet: value}
}

func NewNestedUnionL1FromStringList(value []string) *NestedUnionL1 {
	return &NestedUnionL1{typ: "StringList", StringList: value}
}

func NewNestedUnionL1FromNestedUnionL2(value *NestedUnionL2) *NestedUnionL1 {
	return &NestedUnionL1{typ: "NestedUnionL2", NestedUnionL2: value}
}

func (n *NestedUnionL1) GetInteger() int {
	if n == nil {
		return 0
	}
	return n.Integer
}

func (n *NestedUnionL1) GetStringSet() []string {
	if n == nil {
		return nil
	}
	return n.StringSet
}

func (n *NestedUnionL1) GetStringList() []string {
	if n == nil {
		return nil
	}
	return n.StringList
}

func (n *NestedUnionL1) GetNestedUnionL2() *NestedUnionL2 {
	if n == nil {
		return nil
	}
	return n.NestedUnionL2
}

func (n *NestedUnionL1) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		n.typ = "Integer"
		n.Integer = valueInteger
		return nil
	}
	var valueStringSet []string
	if err := json.Unmarshal(data, &valueStringSet); err == nil {
		n.typ = "StringSet"
		n.StringSet = valueStringSet
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		n.typ = "StringList"
		n.StringList = valueStringList
		return nil
	}
	valueNestedUnionL2 := new(NestedUnionL2)
	if err := json.Unmarshal(data, &valueNestedUnionL2); err == nil {
		n.typ = "NestedUnionL2"
		n.NestedUnionL2 = valueNestedUnionL2
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NestedUnionL1) MarshalJSON() ([]byte, error) {
	if n.typ == "Integer" || n.Integer != 0 {
		return json.Marshal(n.Integer)
	}
	if n.typ == "StringSet" || n.StringSet != nil {
		return json.Marshal(n.StringSet)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return json.Marshal(n.StringList)
	}
	if n.typ == "NestedUnionL2" || n.NestedUnionL2 != nil {
		return json.Marshal(n.NestedUnionL2)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NestedUnionL1Visitor interface {
	VisitInteger(int) error
	VisitStringSet([]string) error
	VisitStringList([]string) error
	VisitNestedUnionL2(*NestedUnionL2) error
}

func (n *NestedUnionL1) Accept(visitor NestedUnionL1Visitor) error {
	if n.typ == "Integer" || n.Integer != 0 {
		return visitor.VisitInteger(n.Integer)
	}
	if n.typ == "StringSet" || n.StringSet != nil {
		return visitor.VisitStringSet(n.StringSet)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return visitor.VisitStringList(n.StringList)
	}
	if n.typ == "NestedUnionL2" || n.NestedUnionL2 != nil {
		return visitor.VisitNestedUnionL2(n.NestedUnionL2)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", n)
}

// Nested layer 2.
type NestedUnionL2 struct {
	Boolean    bool
	StringSet  []string
	StringList []string

	typ string
}

func NewNestedUnionL2FromBoolean(value bool) *NestedUnionL2 {
	return &NestedUnionL2{typ: "Boolean", Boolean: value}
}

func NewNestedUnionL2FromStringSet(value []string) *NestedUnionL2 {
	return &NestedUnionL2{typ: "StringSet", StringSet: value}
}

func NewNestedUnionL2FromStringList(value []string) *NestedUnionL2 {
	return &NestedUnionL2{typ: "StringList", StringList: value}
}

func (n *NestedUnionL2) GetBoolean() bool {
	if n == nil {
		return false
	}
	return n.Boolean
}

func (n *NestedUnionL2) GetStringSet() []string {
	if n == nil {
		return nil
	}
	return n.StringSet
}

func (n *NestedUnionL2) GetStringList() []string {
	if n == nil {
		return nil
	}
	return n.StringList
}

func (n *NestedUnionL2) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		n.typ = "Boolean"
		n.Boolean = valueBoolean
		return nil
	}
	var valueStringSet []string
	if err := json.Unmarshal(data, &valueStringSet); err == nil {
		n.typ = "StringSet"
		n.StringSet = valueStringSet
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		n.typ = "StringList"
		n.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NestedUnionL2) MarshalJSON() ([]byte, error) {
	if n.typ == "Boolean" || n.Boolean != false {
		return json.Marshal(n.Boolean)
	}
	if n.typ == "StringSet" || n.StringSet != nil {
		return json.Marshal(n.StringSet)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return json.Marshal(n.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NestedUnionL2Visitor interface {
	VisitBoolean(bool) error
	VisitStringSet([]string) error
	VisitStringList([]string) error
}

func (n *NestedUnionL2) Accept(visitor NestedUnionL2Visitor) error {
	if n.typ == "Boolean" || n.Boolean != false {
		return visitor.VisitBoolean(n.Boolean)
	}
	if n.typ == "StringSet" || n.StringSet != nil {
		return visitor.VisitStringSet(n.StringSet)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return visitor.VisitStringList(n.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", n)
}

// Nested union root.
type NestedUnionRoot struct {
	String        string
	StringList    []string
	NestedUnionL1 *NestedUnionL1

	typ string
}

func NewNestedUnionRootFromString(value string) *NestedUnionRoot {
	return &NestedUnionRoot{typ: "String", String: value}
}

func NewNestedUnionRootFromStringList(value []string) *NestedUnionRoot {
	return &NestedUnionRoot{typ: "StringList", StringList: value}
}

func NewNestedUnionRootFromNestedUnionL1(value *NestedUnionL1) *NestedUnionRoot {
	return &NestedUnionRoot{typ: "NestedUnionL1", NestedUnionL1: value}
}

func (n *NestedUnionRoot) GetString() string {
	if n == nil {
		return ""
	}
	return n.String
}

func (n *NestedUnionRoot) GetStringList() []string {
	if n == nil {
		return nil
	}
	return n.StringList
}

func (n *NestedUnionRoot) GetNestedUnionL1() *NestedUnionL1 {
	if n == nil {
		return nil
	}
	return n.NestedUnionL1
}

func (n *NestedUnionRoot) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typ = "String"
		n.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		n.typ = "StringList"
		n.StringList = valueStringList
		return nil
	}
	valueNestedUnionL1 := new(NestedUnionL1)
	if err := json.Unmarshal(data, &valueNestedUnionL1); err == nil {
		n.typ = "NestedUnionL1"
		n.NestedUnionL1 = valueNestedUnionL1
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NestedUnionRoot) MarshalJSON() ([]byte, error) {
	if n.typ == "String" || n.String != "" {
		return json.Marshal(n.String)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return json.Marshal(n.StringList)
	}
	if n.typ == "NestedUnionL1" || n.NestedUnionL1 != nil {
		return json.Marshal(n.NestedUnionL1)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NestedUnionRootVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
	VisitNestedUnionL1(*NestedUnionL1) error
}

func (n *NestedUnionRoot) Accept(visitor NestedUnionRootVisitor) error {
	if n.typ == "String" || n.String != "" {
		return visitor.VisitString(n.String)
	}
	if n.typ == "StringList" || n.StringList != nil {
		return visitor.VisitStringList(n.StringList)
	}
	if n.typ == "NestedUnionL1" || n.NestedUnionL1 != nil {
		return visitor.VisitNestedUnionL1(n.NestedUnionL1)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", n)
}

type OptionalMetadata = map[string]interface{}

// Tests that nested properties with camelCase wire names are properly
// converted from snake_case Ruby keys when passed as Hash values.
type PaymentMethodUnion struct {
	TokenizeCard *TokenizeCard
	ConvertToken *ConvertToken

	typ string
}

func NewPaymentMethodUnionFromTokenizeCard(value *TokenizeCard) *PaymentMethodUnion {
	return &PaymentMethodUnion{typ: "TokenizeCard", TokenizeCard: value}
}

func NewPaymentMethodUnionFromConvertToken(value *ConvertToken) *PaymentMethodUnion {
	return &PaymentMethodUnion{typ: "ConvertToken", ConvertToken: value}
}

func (p *PaymentMethodUnion) GetTokenizeCard() *TokenizeCard {
	if p == nil {
		return nil
	}
	return p.TokenizeCard
}

func (p *PaymentMethodUnion) GetConvertToken() *ConvertToken {
	if p == nil {
		return nil
	}
	return p.ConvertToken
}

func (p *PaymentMethodUnion) UnmarshalJSON(data []byte) error {
	valueTokenizeCard := new(TokenizeCard)
	if err := json.Unmarshal(data, &valueTokenizeCard); err == nil {
		p.typ = "TokenizeCard"
		p.TokenizeCard = valueTokenizeCard
		return nil
	}
	valueConvertToken := new(ConvertToken)
	if err := json.Unmarshal(data, &valueConvertToken); err == nil {
		p.typ = "ConvertToken"
		p.ConvertToken = valueConvertToken
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentMethodUnion) MarshalJSON() ([]byte, error) {
	if p.typ == "TokenizeCard" || p.TokenizeCard != nil {
		return json.Marshal(p.TokenizeCard)
	}
	if p.typ == "ConvertToken" || p.ConvertToken != nil {
		return json.Marshal(p.ConvertToken)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentMethodUnionVisitor interface {
	VisitTokenizeCard(*TokenizeCard) error
	VisitConvertToken(*ConvertToken) error
}

func (p *PaymentMethodUnion) Accept(visitor PaymentMethodUnionVisitor) error {
	if p.typ == "TokenizeCard" || p.TokenizeCard != nil {
		return visitor.VisitTokenizeCard(p.TokenizeCard)
	}
	if p.typ == "ConvertToken" || p.ConvertToken != nil {
		return visitor.VisitConvertToken(p.ConvertToken)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

var (
	requestFieldUnion = big.NewInt(1 << 0)
)

type Request struct {
	Union *MetadataUnion `json:"union,omitempty" url:"union,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Request) GetUnion() *MetadataUnion {
	if r == nil {
		return nil
	}
	return r.Union
}

func (r *Request) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Request) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetUnion sets the Union field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Request) SetUnion(union *MetadataUnion) {
	r.Union = union
	r.require(requestFieldUnion)
}

func (r *Request) UnmarshalJSON(data []byte) error {
	type unmarshaler Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Request(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Request) MarshalJSON() ([]byte, error) {
	type embed Request
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *Request) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	tokenizeCardFieldMethod     = big.NewInt(1 << 0)
	tokenizeCardFieldCardNumber = big.NewInt(1 << 1)
)

type TokenizeCard struct {
	Method     string `json:"method" url:"method"`
	CardNumber string `json:"cardNumber" url:"cardNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizeCard) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TokenizeCard) GetCardNumber() string {
	if t == nil {
		return ""
	}
	return t.CardNumber
}

func (t *TokenizeCard) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeCard) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TokenizeCard) SetMethod(method string) {
	t.Method = method
	t.require(tokenizeCardFieldMethod)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TokenizeCard) SetCardNumber(cardNumber string) {
	t.CardNumber = cardNumber
	t.require(tokenizeCardFieldCardNumber)
}

func (t *TokenizeCard) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeCard(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeCard) MarshalJSON() ([]byte, error) {
	type embed TokenizeCard
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TokenizeCard) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	typeWithOptionalUnionFieldMyUnion = big.NewInt(1 << 0)
)

type TypeWithOptionalUnion struct {
	MyUnion *MyUnion `json:"myUnion,omitempty" url:"myUnion,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TypeWithOptionalUnion) GetMyUnion() *MyUnion {
	if t == nil {
		return nil
	}
	return t.MyUnion
}

func (t *TypeWithOptionalUnion) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypeWithOptionalUnion) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMyUnion sets the MyUnion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeWithOptionalUnion) SetMyUnion(myUnion *MyUnion) {
	t.MyUnion = myUnion
	t.require(typeWithOptionalUnionFieldMyUnion)
}

func (t *TypeWithOptionalUnion) UnmarshalJSON(data []byte) error {
	type unmarshaler TypeWithOptionalUnion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeWithOptionalUnion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypeWithOptionalUnion) MarshalJSON() ([]byte, error) {
	type embed TypeWithOptionalUnion
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TypeWithOptionalUnion) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Duplicate types.
type UnionWithDuplicateTypes struct {
	String     string
	StringList []string
	Integer    int
	StringSet  []string

	typ string
}

func NewUnionWithDuplicateTypesFromString(value string) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{typ: "String", String: value}
}

func NewUnionWithDuplicateTypesFromStringList(value []string) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{typ: "StringList", StringList: value}
}

func NewUnionWithDuplicateTypesFromInteger(value int) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{typ: "Integer", Integer: value}
}

func NewUnionWithDuplicateTypesFromStringSet(value []string) *UnionWithDuplicateTypes {
	return &UnionWithDuplicateTypes{typ: "StringSet", StringSet: value}
}

func (u *UnionWithDuplicateTypes) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionWithDuplicateTypes) GetStringList() []string {
	if u == nil {
		return nil
	}
	return u.StringList
}

func (u *UnionWithDuplicateTypes) GetInteger() int {
	if u == nil {
		return 0
	}
	return u.Integer
}

func (u *UnionWithDuplicateTypes) GetStringSet() []string {
	if u == nil {
		return nil
	}
	return u.StringSet
}

func (u *UnionWithDuplicateTypes) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		u.typ = "StringList"
		u.StringList = valueStringList
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		u.typ = "Integer"
		u.Integer = valueInteger
		return nil
	}
	var valueStringSet []string
	if err := json.Unmarshal(data, &valueStringSet); err == nil {
		u.typ = "StringSet"
		u.StringSet = valueStringSet
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnionWithDuplicateTypes) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "StringList" || u.StringList != nil {
		return json.Marshal(u.StringList)
	}
	if u.typ == "Integer" || u.Integer != 0 {
		return json.Marshal(u.Integer)
	}
	if u.typ == "StringSet" || u.StringSet != nil {
		return json.Marshal(u.StringSet)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UnionWithDuplicateTypesVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
	VisitInteger(int) error
	VisitStringSet([]string) error
}

func (u *UnionWithDuplicateTypes) Accept(visitor UnionWithDuplicateTypesVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "StringList" || u.StringList != nil {
		return visitor.VisitStringList(u.StringList)
	}
	if u.typ == "Integer" || u.Integer != 0 {
		return visitor.VisitInteger(u.Integer)
	}
	if u.typ == "StringSet" || u.StringSet != nil {
		return visitor.VisitStringSet(u.StringSet)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// Mix of primitives where some resolve to the same Java type.
type UnionWithIdenticalPrimitives struct {
	Integer int
	Double  float64
	String  string

	typ string
}

func NewUnionWithIdenticalPrimitivesFromInteger(value int) *UnionWithIdenticalPrimitives {
	return &UnionWithIdenticalPrimitives{typ: "Integer", Integer: value}
}

func NewUnionWithIdenticalPrimitivesFromDouble(value float64) *UnionWithIdenticalPrimitives {
	return &UnionWithIdenticalPrimitives{typ: "Double", Double: value}
}

func NewUnionWithIdenticalPrimitivesFromString(value string) *UnionWithIdenticalPrimitives {
	return &UnionWithIdenticalPrimitives{typ: "String", String: value}
}

func (u *UnionWithIdenticalPrimitives) GetInteger() int {
	if u == nil {
		return 0
	}
	return u.Integer
}

func (u *UnionWithIdenticalPrimitives) GetDouble() float64 {
	if u == nil {
		return 0
	}
	return u.Double
}

func (u *UnionWithIdenticalPrimitives) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionWithIdenticalPrimitives) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		u.typ = "Integer"
		u.Integer = valueInteger
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		u.typ = "Double"
		u.Double = valueDouble
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnionWithIdenticalPrimitives) MarshalJSON() ([]byte, error) {
	if u.typ == "Integer" || u.Integer != 0 {
		return json.Marshal(u.Integer)
	}
	if u.typ == "Double" || u.Double != 0 {
		return json.Marshal(u.Double)
	}
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UnionWithIdenticalPrimitivesVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
	VisitString(string) error
}

func (u *UnionWithIdenticalPrimitives) Accept(visitor UnionWithIdenticalPrimitivesVisitor) error {
	if u.typ == "Integer" || u.Integer != 0 {
		return visitor.VisitInteger(u.Integer)
	}
	if u.typ == "Double" || u.Double != 0 {
		return visitor.VisitDouble(u.Double)
	}
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// Multiple string types that all resolve to String in Java.
// This tests the fix for duplicate method signatures.
type UnionWithIdenticalStrings struct {
	String string

	typ string
}

func NewUnionWithIdenticalStringsFromString(value string) *UnionWithIdenticalStrings {
	return &UnionWithIdenticalStrings{typ: "String", String: value}
}

func (u *UnionWithIdenticalStrings) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UnionWithIdenticalStrings) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnionWithIdenticalStrings) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UnionWithIdenticalStringsVisitor interface {
	VisitString(string) error
}

func (u *UnionWithIdenticalStrings) Accept(visitor UnionWithIdenticalStringsVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

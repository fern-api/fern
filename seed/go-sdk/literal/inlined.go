// Code generated by Fern. DO NOT EDIT.


package literal
import (
fmt "fmt"
strings "strings"
assert "github.com/stretchr/testify/assert"
require "github.com/stretchr/testify/require"
option "github.com/literal/fern/option"
io "io"
os "os"
strconv "strconv"
testing "testing"
time "time"
uuid "github.com/google/uuid"
context "context"
json "encoding/json"
errors "errors"
multipart "mime/multipart"
http "net/http"
core "github.com/literal/fern/core"
internal "github.com/literal/fern/internal"
bytes "bytes"
base64 "encoding/base64"
url "net/url"
big "math/big"
)
var (
	sendLiteralsInlinedRequestFieldContext = big.NewInt(1 << 0)
	sendLiteralsInlinedRequestFieldQuery = big.NewInt(1 << 1)
	sendLiteralsInlinedRequestFieldTemperature = big.NewInt(1 << 2)
	sendLiteralsInlinedRequestFieldAliasedContext = big.NewInt(1 << 3)
	sendLiteralsInlinedRequestFieldMaybeContext = big.NewInt(1 << 4)
	sendLiteralsInlinedRequestFieldObjectWithLiteral = big.NewInt(1 << 5)
)

type SendLiteralsInlinedRequest struct {
Context *string`json:"context,omitempty" url:"-"`
Query string`json:"query" url:"-"`
Temperature *float64`json:"temperature,omitempty" url:"-"`
AliasedContext SomeAliasedLiteral`json:"aliasedContext" url:"-"`
MaybeContext *SomeAliasedLiteral`json:"maybeContext,omitempty" url:"-"`
ObjectWithLiteral *ATopLevelLiteral`json:"objectWithLiteral" url:"-"`
prompt string
stream bool

// Private bitmask of fields set to an explicit value and therefore not to be omitted
explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SendLiteralsInlinedRequest) Prompt()string{
return s.prompt
}

func (s *SendLiteralsInlinedRequest) Stream()bool{
return s.stream
}

func (s *SendLiteralsInlinedRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetContext(context *string) {
	s.Context = context
	s.require(sendLiteralsInlinedRequestFieldContext)
}

// SetQuery sets the Query field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetQuery(query string) {
	s.Query = query
	s.require(sendLiteralsInlinedRequestFieldQuery)
}

// SetTemperature sets the Temperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetTemperature(temperature *float64) {
	s.Temperature = temperature
	s.require(sendLiteralsInlinedRequestFieldTemperature)
}

// SetAliasedContext sets the AliasedContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetAliasedContext(aliasedContext SomeAliasedLiteral) {
	s.AliasedContext = aliasedContext
	s.require(sendLiteralsInlinedRequestFieldAliasedContext)
}

// SetMaybeContext sets the MaybeContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetMaybeContext(maybeContext *SomeAliasedLiteral) {
	s.MaybeContext = maybeContext
	s.require(sendLiteralsInlinedRequestFieldMaybeContext)
}

// SetObjectWithLiteral sets the ObjectWithLiteral field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SendLiteralsInlinedRequest) SetObjectWithLiteral(objectWithLiteral *ATopLevelLiteral) {
	s.ObjectWithLiteral = objectWithLiteral
	s.require(sendLiteralsInlinedRequestFieldObjectWithLiteral)
}

func (s *SendLiteralsInlinedRequest) UnmarshalJSON(data []byte) error {
type unmarshaler SendLiteralsInlinedRequest
var body unmarshaler
if err := json.Unmarshal(data, &body); err != nil {
return err
}
*s = SendLiteralsInlinedRequest(body)
s.prompt = "You are a helpful assistant"
s.stream = false
return nil
}

func (s *SendLiteralsInlinedRequest) MarshalJSON() ([]byte, error) {
type embed SendLiteralsInlinedRequest
var marshaler = struct{
embed
Prompt string `json:"prompt"`
Stream bool `json:"stream"`
}{
embed: embed(*s),
Prompt: "You are a helpful assistant",
Stream: false,
}
explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
return json.Marshal(explicitMarshaler)
}

type ANestedLiteral struct {

// Private bitmask of fields set to an explicit value and therefore not to be omitted
explicitFields *big.Int `json:"-" url:"-"`
myLiteral string

extraProperties map[string]interface{}
rawJSON json.RawMessage
}

func (a *ANestedLiteral) MyLiteral()string{
return a.myLiteral
}

func (a *ANestedLiteral) GetExtraProperties() map[string]interface{} {
return a.extraProperties
}

func (a *ANestedLiteral) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

func (a *ANestedLiteral) UnmarshalJSON(data []byte) error {
type embed ANestedLiteral
var unmarshaler = struct{
embed
MyLiteral string `json:"myLiteral"`
}{
embed: embed(*a),
}
if err := json.Unmarshal(data, &unmarshaler); err != nil {
return err
}
*a = ANestedLiteral(unmarshaler.embed)
if unmarshaler.MyLiteral!= "How super cool" {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "How super cool", unmarshaler.MyLiteral)
}
a.myLiteral = unmarshaler.MyLiteral
extraProperties, err := internal.ExtractExtraProperties(data, *a, "myLiteral", )
if err != nil {
return err
}
a.extraProperties = extraProperties
a.rawJSON = json.RawMessage(data)
return nil
}

func (a *ANestedLiteral) MarshalJSON() ([]byte, error) {
type embed ANestedLiteral
var marshaler = struct{
embed
MyLiteral string `json:"myLiteral"`
}{
embed: embed(*a),
MyLiteral: "How super cool",
}
explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
return json.Marshal(explicitMarshaler)
}

func (a *ANestedLiteral) String() string {
if len(a.rawJSON) > 0 {
if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
return value
}
}
if value, err := internal.StringifyJSON(a); err == nil {
return value
}
return fmt.Sprintf("%#v", a)
}

var (
	aTopLevelLiteralFieldNestedLiteral = big.NewInt(1 << 0)
)

type ATopLevelLiteral struct {
NestedLiteral *ANestedLiteral`json:"nestedLiteral" url:"nestedLiteral"`

// Private bitmask of fields set to an explicit value and therefore not to be omitted
explicitFields *big.Int `json:"-" url:"-"`

extraProperties map[string]interface{}
rawJSON json.RawMessage
}

func (a *ATopLevelLiteral) GetNestedLiteral()*ANestedLiteral {
if a == nil {
return nil
}
return a.NestedLiteral
}

func (a *ATopLevelLiteral) GetExtraProperties() map[string]interface{} {
return a.extraProperties
}

func (a *ATopLevelLiteral) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetNestedLiteral sets the NestedLiteral field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ATopLevelLiteral) SetNestedLiteral(nestedLiteral *ANestedLiteral) {
	a.NestedLiteral = nestedLiteral
	a.require(aTopLevelLiteralFieldNestedLiteral)
}

func (a *ATopLevelLiteral) UnmarshalJSON(data []byte) error {
type unmarshaler ATopLevelLiteral
var value unmarshaler
if err := json.Unmarshal(data, &value); err != nil {
return err
}
*a = ATopLevelLiteral(value)
extraProperties, err := internal.ExtractExtraProperties(data, *a)
if err != nil {
return err
}
a.extraProperties = extraProperties
a.rawJSON = json.RawMessage(data)
return nil
}

func (a *ATopLevelLiteral) MarshalJSON() ([]byte, error) {
type embed ATopLevelLiteral
var marshaler = struct{
embed
}{
embed: embed(*a),
}
explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
return json.Marshal(explicitMarshaler)
}

func (a *ATopLevelLiteral) String() string {
if len(a.rawJSON) > 0 {
if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
return value
}
}
if value, err := internal.StringifyJSON(a); err == nil {
return value
}
return fmt.Sprintf("%#v", a)
}

type DiscriminatedLiteral struct {
Type string
CustomName string
defaultName string
George bool
literalGeorge bool
}

func NewDiscriminatedLiteralWithDefaultName() *DiscriminatedLiteral{
return &DiscriminatedLiteral{Type: "defaultName", defaultName: "Bob"}
}

func NewDiscriminatedLiteralWithLiteralGeorge() *DiscriminatedLiteral{
return &DiscriminatedLiteral{Type: "literalGeorge", literalGeorge: true}
}

func (d *DiscriminatedLiteral) GetType()string {
if d == nil {
return ""
}
return d.Type
}

func (d *DiscriminatedLiteral) GetCustomName()string {
if d == nil {
return ""
}
return d.CustomName
}

func (d *DiscriminatedLiteral) GetGeorge()bool {
if d == nil {
return false
}
return d.George
}

func (d *DiscriminatedLiteral) DefaultName()string{
if d == nil {
return ""
}
return d.defaultName
}

func (d *DiscriminatedLiteral) LiteralGeorge()bool{
if d == nil {
return false
}
return d.literalGeorge
}

func (d *DiscriminatedLiteral) UnmarshalJSON(data []byte) error {
var unmarshaler struct {
Type string `json:"type"`
}
if err := json.Unmarshal(data, &unmarshaler); err != nil {
return err
}
d.Type = unmarshaler.Type
if unmarshaler.Type == "" {
return fmt.Errorf("%T did not include discriminant type", d)
}
switch unmarshaler.Type {
case "customName":
var valueUnmarshaler struct {
CustomName string`json:"value"`
}
if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
return err
}
d.CustomName = valueUnmarshaler.CustomName
case "defaultName":
var valueUnmarshaler struct {
DefaultName string`json:"value"`
}
if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
return err
}
if valueUnmarshaler.DefaultName!= "Bob" {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "Bob", valueUnmarshaler.DefaultName)
}
d.defaultName = valueUnmarshaler.DefaultName
case "george":
var valueUnmarshaler struct {
George bool`json:"value"`
}
if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
return err
}
d.George = valueUnmarshaler.George
case "literalGeorge":
var valueUnmarshaler struct {
LiteralGeorge bool`json:"value"`
}
if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
return err
}
if valueUnmarshaler.LiteralGeorge!= true {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, true, valueUnmarshaler.LiteralGeorge)
}
d.literalGeorge = valueUnmarshaler.LiteralGeorge
}
return nil
}

func (d DiscriminatedLiteral) MarshalJSON() ([]byte, error) {
if err := d.validate(); err != nil {
return nil, err
}
if d.CustomName != "" {
var marshaler = struct {
Type string `json:"type"`
CustomName string`json:"value"`
}{
Type: "customName",
CustomName: d.CustomName,
}
return json.Marshal(marshaler)
}
if d.defaultName != "" {
var marshaler = struct {
Type string `json:"type"`
DefaultName string`json:"value"`
}{
Type: "defaultName",
DefaultName: "Bob",
}
return json.Marshal(marshaler)
}
if d.George != false {
var marshaler = struct {
Type string `json:"type"`
George bool`json:"value"`
}{
Type: "george",
George: d.George,
}
return json.Marshal(marshaler)
}
if d.literalGeorge != false {
var marshaler = struct {
Type string `json:"type"`
LiteralGeorge bool`json:"value"`
}{
Type: "literalGeorge",
LiteralGeorge: true,
}
return json.Marshal(marshaler)
}
return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DiscriminatedLiteralVisitor interface {
VisitCustomName(string) error
VisitDefaultName(string) error
VisitGeorge(bool) error
VisitLiteralGeorge(bool) error
}

func (d *DiscriminatedLiteral) Accept(visitor DiscriminatedLiteralVisitor) error {
if d.CustomName != "" {
return visitor.VisitCustomName(d.CustomName)
}
if d.defaultName != "" {
return visitor.VisitDefaultName(d.defaultName)
}
if d.George != false {
return visitor.VisitGeorge(d.George)
}
if d.literalGeorge != false {
return visitor.VisitLiteralGeorge(d.literalGeorge)
}
return fmt.Errorf("type %T does not define a non-empty union type", d)
}

func (d *DiscriminatedLiteral) validate() error {
if d == nil {
return fmt.Errorf("type %T is nil", d)
}
var fields []string
if d.CustomName != "" {
fields = append(fields, "customName")
}
if d.defaultName != "" {
fields = append(fields, "defaultName")
}
if d.George != false {
fields = append(fields, "george")
}
if d.literalGeorge != false {
fields = append(fields, "literalGeorge")
}
if len(fields) == 0 {
if d.Type != "" {
return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", d, d.Type)
}
return fmt.Errorf("type %T is empty", d)
}
if len(fields) > 1 {
return fmt.Errorf("type %T defines values for %s, but only one value is allowed", d, fields)
}
if d.Type != "" {
field := fields[0]
if d.Type != field {
return fmt.Errorf(
"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
d, 
d.Type, 
d, 
)
}
}
return nil
}

type SomeAliasedLiteral = string

type UndiscriminatedLiteral struct {
String string
EndingStringLiteral string
10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral string
TrueLiteral bool
FalseLiteral bool
Boolean bool

typ string
}

func NewUndiscriminatedLiteralWithEndingStringLiteral() *UndiscriminatedLiteral{
return &UndiscriminatedLiteral{ typ: "EndingStringLiteral", EndingStringLiteral: "$ending"}
}

func NewUndiscriminatedLiteralWith10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral() *UndiscriminatedLiteral{
return &UndiscriminatedLiteral{ typ: "10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral", 10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral: "10 non-alphanumeric string literals you're going to love & why (number 8 will surprise you)"}
}

func NewUndiscriminatedLiteralWithTrueLiteral() *UndiscriminatedLiteral{
return &UndiscriminatedLiteral{ typ: "TrueLiteral", TrueLiteral: true}
}

func NewUndiscriminatedLiteralWithFalseLiteral() *UndiscriminatedLiteral{
return &UndiscriminatedLiteral{ typ: "FalseLiteral", FalseLiteral: false}
}

func (u *UndiscriminatedLiteral) GetString()string {
if u == nil {
return ""
}
return u.String
}

func (u *UndiscriminatedLiteral) GetBoolean()bool {
if u == nil {
return false
}
return u.Boolean
}

func (u *UndiscriminatedLiteral) UnmarshalJSON(data []byte) error {
var valueString string
if err := json.Unmarshal(data, &valueString); err == nil {
u.typ = "String"
u.String = valueString
return nil
}
var valueEndingStringLiteral string
if err := json.Unmarshal(data, &valueEndingStringLiteral); err == nil {
u.typ = "EndingStringLiteral"
u.EndingStringLiteral = valueEndingStringLiteral
if u.EndingStringLiteral != "$ending" {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "$ending", valueEndingStringLiteral)
}
return nil
}
var value10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral string
if err := json.Unmarshal(data, &value10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral); err == nil {
u.typ = "10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral"
u.10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral = value10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral
if u.10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral != "10 non-alphanumeric string literals you're going to love & why (number 8 will surprise you)" {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "10 non-alphanumeric string literals you're going to love & why (number 8 will surprise you)", value10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral)
}
return nil
}
var valueTrueLiteral bool
if err := json.Unmarshal(data, &valueTrueLiteral); err == nil {
u.typ = "TrueLiteral"
u.TrueLiteral = valueTrueLiteral
if u.TrueLiteral != true {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, true, valueTrueLiteral)
}
return nil
}
var valueFalseLiteral bool
if err := json.Unmarshal(data, &valueFalseLiteral); err == nil {
u.typ = "FalseLiteral"
u.FalseLiteral = valueFalseLiteral
if u.FalseLiteral != false {
return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, false, valueFalseLiteral)
}
return nil
}
var valueBoolean bool
if err := json.Unmarshal(data, &valueBoolean); err == nil {
u.typ = "Boolean"
u.Boolean = valueBoolean
return nil
}
return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UndiscriminatedLiteral) MarshalJSON() ([]byte, error) {
if u.typ == "String" || u.String != "" {
return json.Marshal(u.String)
}
if u.typ == "EndingStringLiteral" || u.EndingStringLiteral != "" {
return json.Marshal("$ending")
}
if u.typ == "10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral" || u.10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral != "" {
return json.Marshal("10 non-alphanumeric string literals you're going to love & why (number 8 will surprise you)")
}
if u.typ == "TrueLiteral" || u.TrueLiteral != false {
return json.Marshal(true)
}
if u.typ == "FalseLiteral" || u.FalseLiteral != false {
return json.Marshal(false)
}
if u.typ == "Boolean" || u.Boolean != false {
return json.Marshal(u.Boolean)
}
return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UndiscriminatedLiteralVisitor interface {
VisitString(string) error
VisitEndingStringLiteral(string) error
Visit10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral(string) error
VisitTrueLiteral(bool) error
VisitFalseLiteral(bool) error
VisitBoolean(bool) error
}

func (u *UndiscriminatedLiteral) Accept(visitor UndiscriminatedLiteralVisitor) error {
if u.typ == "String" || u.String != "" {
return visitor.VisitString(u.String)
}
if u.typ == "EndingStringLiteral" || u.EndingStringLiteral != "" {
return visitor.VisitEndingStringLiteral(u.EndingStringLiteral)
}
if u.typ == "10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral" || u.10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral != "" {
return visitor.Visit10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral(u.10nonalphanumericstringliteralsyouregoingtolovewhynumber8willsurpriseyouStringLiteral)
}
if u.typ == "TrueLiteral" || u.TrueLiteral != false {
return visitor.VisitTrueLiteral(u.TrueLiteral)
}
if u.typ == "FalseLiteral" || u.FalseLiteral != false {
return visitor.VisitFalseLiteral(u.FalseLiteral)
}
if u.typ == "Boolean" || u.Boolean != false {
return visitor.VisitBoolean(u.Boolean)
}
return fmt.Errorf("type %T does not include a non-empty union type", u)
}


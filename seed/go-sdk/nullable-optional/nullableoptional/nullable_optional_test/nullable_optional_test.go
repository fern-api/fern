// Code generated by Fern. DO NOT EDIT.

package nullable_optional_test

import (
	context "context"
	fmt "fmt"
	fern "github.com/nullable-optional/fern"
	client "github.com/nullable-optional/fern/client"
	option "github.com/nullable-optional/fern/option"
	require "github.com/stretchr/testify/require"
	gowiremock "github.com/wiremock/go-wiremock"
	wiremocktestcontainersgo "github.com/wiremock/wiremock-testcontainers-go"
	http "net/http"
	os "os"
	testing "testing"
)

// TestMain sets up shared test fixtures for all tests in this package// Global test fixtures
var (
	WireMockContainer *wiremocktestcontainersgo.WireMockContainer
	WireMockBaseURL   string
	WireMockClient    *gowiremock.Client
)

// TestMain sets up shared test fixtures for all tests in this package
func TestMain(m *testing.M) {
	// Setup shared WireMock container
	ctx := context.Background()
	container, err := wiremocktestcontainersgo.RunContainerAndStopOnCleanup(
		ctx,
		&testing.T{},
		wiremocktestcontainersgo.WithImage("docker.io/wiremock/wiremock:3.9.1"),
	)
	if err != nil {
		fmt.Printf("Failed to start WireMock container: %v\n", err)
		os.Exit(1)
	}

	// Store global references
	WireMockContainer = container
	WireMockClient = container.Client

	// Get the base URL
	baseURL, err := container.Endpoint(ctx, "")
	if err != nil {
		fmt.Printf("Failed to get WireMock container endpoint: %v\n", err)
		os.Exit(1)
	}
	WireMockBaseURL = "http://" + baseURL

	// Run all tests
	code := m.Run()

	// Cleanup
	if WireMockContainer != nil {
		WireMockContainer.Terminate(ctx)
	}

	// Exit with the same code as the tests
	os.Exit(code)
}

func TestNullableOptionalGetUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/users/{userId}")).WithPathParam(
		"userId",
		gowiremock.Matching("userId"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.NullableOptional.GetUser(
		context.TODO(),
		"userId",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalCreateUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/api/users")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.CreateUserRequest{
		Username: "username",
		Email: fern.String(
			"email",
		),
		Phone: fern.String(
			"phone",
		),
		Address: &fern.Address{
			Street: "street",
			City: fern.String(
				"city",
			),
			State: fern.String(
				"state",
			),
			ZipCode: "zipCode",
			Country: fern.String(
				"country",
			),
			BuildingId: fern.String(
				"buildingId",
			),
			TenantId: fern.String(
				"tenantId",
			),
		},
	}
	_, invocationErr := client.NullableOptional.CreateUser(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalUpdateUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Patch(gowiremock.URLPathTemplate("/api/users/{userId}")).WithPathParam(
		"userId",
		gowiremock.Matching("userId"),
	).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.UpdateUserRequest{
		Username: fern.String(
			"username",
		),
		Email: fern.String(
			"email",
		),
		Phone: fern.String(
			"phone",
		),
		Address: &fern.Address{
			Street: "street",
			City: fern.String(
				"city",
			),
			State: fern.String(
				"state",
			),
			ZipCode: "zipCode",
			Country: fern.String(
				"country",
			),
			BuildingId: fern.String(
				"buildingId",
			),
			TenantId: fern.String(
				"tenantId",
			),
		},
	}
	_, invocationErr := client.NullableOptional.UpdateUser(
		context.TODO(),
		"userId",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalListUsersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/users")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			[]interface{}{map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.ListUsersRequest{
		Limit: fern.Int(
			1,
		),
		Offset: fern.Int(
			1,
		),
		IncludeDeleted: fern.Bool(
			true,
		),
		SortBy: fern.String(
			"sortBy",
		),
	}
	_, invocationErr := client.NullableOptional.ListUsers(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalSearchUsersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/users/search")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			[]interface{}{map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.SearchUsersRequest{
		Query: "query",
		Department: fern.String(
			"department",
		),
		Role: fern.String(
			"role",
		),
		IsActive: fern.Bool(
			true,
		),
	}
	_, invocationErr := client.NullableOptional.SearchUsers(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalCreateComplexProfileWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/api/profiles/complex")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "nullableRole": "ADMIN", "optionalRole": "ADMIN", "optionalNullableRole": "ADMIN", "nullableStatus": "active", "optionalStatus": "active", "optionalNullableStatus": "active", "nullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "nullableSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "optionalSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableArray": []interface{}{"nullableArray", "nullableArray"}, "optionalArray": []interface{}{"optionalArray", "optionalArray"}, "optionalNullableArray": []interface{}{"optionalNullableArray", "optionalNullableArray"}, "nullableListOfNullables": []interface{}{"nullableListOfNullables", "nullableListOfNullables"}, "nullableMapOfNullables": map[string]interface{}{"nullableMapOfNullables": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableListOfUnions": []interface{}{map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}}, "optionalMapOfEnums": map[string]interface{}{"optionalMapOfEnums": "ADMIN"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.ComplexProfile{
		Id:                     "id",
		NullableRole:           fern.UserRoleAdmin.Ptr(),
		OptionalRole:           fern.UserRoleAdmin.Ptr(),
		OptionalNullableRole:   fern.UserRoleAdmin.Ptr(),
		NullableStatus:         fern.UserStatusActive.Ptr(),
		OptionalStatus:         fern.UserStatusActive.Ptr(),
		OptionalNullableStatus: fern.UserStatusActive.Ptr(),
		NullableNotification: &fern.NotificationMethod{
			Email: &fern.EmailNotification{
				EmailAddress: "emailAddress",
				Subject:      "subject",
				HtmlContent: fern.String(
					"htmlContent",
				),
			},
		},
		OptionalNotification: &fern.NotificationMethod{
			Email: &fern.EmailNotification{
				EmailAddress: "emailAddress",
				Subject:      "subject",
				HtmlContent: fern.String(
					"htmlContent",
				),
			},
		},
		OptionalNullableNotification: &fern.NotificationMethod{
			Email: &fern.EmailNotification{
				EmailAddress: "emailAddress",
				Subject:      "subject",
				HtmlContent: fern.String(
					"htmlContent",
				),
			},
		},
		NullableSearchResult: &fern.SearchResult{
			User: &fern.UserResponse{
				Id:       "id",
				Username: "username",
				Email: fern.String(
					"email",
				),
				Phone: fern.String(
					"phone",
				),
				CreatedAt: fern.MustParseDateTime(
					"2024-01-15T09:30:00Z",
				),
				UpdatedAt: fern.Time(
					fern.MustParseDateTime(
						"2024-01-15T09:30:00Z",
					),
				),
				Address: &fern.Address{
					Street: "street",
					City: fern.String(
						"city",
					),
					State: fern.String(
						"state",
					),
					ZipCode: "zipCode",
					Country: fern.String(
						"country",
					),
					BuildingId: fern.String(
						"buildingId",
					),
					TenantId: fern.String(
						"tenantId",
					),
				},
			},
		},
		OptionalSearchResult: &fern.SearchResult{
			User: &fern.UserResponse{
				Id:       "id",
				Username: "username",
				Email: fern.String(
					"email",
				),
				Phone: fern.String(
					"phone",
				),
				CreatedAt: fern.MustParseDateTime(
					"2024-01-15T09:30:00Z",
				),
				UpdatedAt: fern.Time(
					fern.MustParseDateTime(
						"2024-01-15T09:30:00Z",
					),
				),
				Address: &fern.Address{
					Street: "street",
					City: fern.String(
						"city",
					),
					State: fern.String(
						"state",
					),
					ZipCode: "zipCode",
					Country: fern.String(
						"country",
					),
					BuildingId: fern.String(
						"buildingId",
					),
					TenantId: fern.String(
						"tenantId",
					),
				},
			},
		},
		NullableArray: []string{
			"nullableArray",
			"nullableArray",
		},
		OptionalArray: []string{
			"optionalArray",
			"optionalArray",
		},
		OptionalNullableArray: []string{
			"optionalNullableArray",
			"optionalNullableArray",
		},
		NullableListOfNullables: []*string{
			fern.String(
				"nullableListOfNullables",
			),
			fern.String(
				"nullableListOfNullables",
			),
		},
		NullableMapOfNullables: map[string]*fern.Address{
			"nullableMapOfNullables": &fern.Address{
				Street: "street",
				City: fern.String(
					"city",
				),
				State: fern.String(
					"state",
				),
				ZipCode: "zipCode",
				Country: fern.String(
					"country",
				),
				BuildingId: fern.String(
					"buildingId",
				),
				TenantId: fern.String(
					"tenantId",
				),
			},
		},
		NullableListOfUnions: []*fern.NotificationMethod{
			&fern.NotificationMethod{
				Email: &fern.EmailNotification{
					EmailAddress: "emailAddress",
					Subject:      "subject",
					HtmlContent: fern.String(
						"htmlContent",
					),
				},
			},
			&fern.NotificationMethod{
				Email: &fern.EmailNotification{
					EmailAddress: "emailAddress",
					Subject:      "subject",
					HtmlContent: fern.String(
						"htmlContent",
					),
				},
			},
		},
		OptionalMapOfEnums: map[string]fern.UserRole{
			"optionalMapOfEnums": fern.UserRoleAdmin,
		},
	}
	_, invocationErr := client.NullableOptional.CreateComplexProfile(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalGetComplexProfileWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/profiles/complex/{profileId}")).WithPathParam(
		"profileId",
		gowiremock.Matching("profileId"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "nullableRole": "ADMIN", "optionalRole": "ADMIN", "optionalNullableRole": "ADMIN", "nullableStatus": "active", "optionalStatus": "active", "optionalNullableStatus": "active", "nullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "nullableSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "optionalSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableArray": []interface{}{"nullableArray", "nullableArray"}, "optionalArray": []interface{}{"optionalArray", "optionalArray"}, "optionalNullableArray": []interface{}{"optionalNullableArray", "optionalNullableArray"}, "nullableListOfNullables": []interface{}{"nullableListOfNullables", "nullableListOfNullables"}, "nullableMapOfNullables": map[string]interface{}{"nullableMapOfNullables": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableListOfUnions": []interface{}{map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}}, "optionalMapOfEnums": map[string]interface{}{"optionalMapOfEnums": "ADMIN"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.NullableOptional.GetComplexProfile(
		context.TODO(),
		"profileId",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalUpdateComplexProfileWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Patch(gowiremock.URLPathTemplate("/api/profiles/complex/{profileId}")).WithPathParam(
		"profileId",
		gowiremock.Matching("profileId"),
	).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": [],
                    "properties": {
                        
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"id": "id", "nullableRole": "ADMIN", "optionalRole": "ADMIN", "optionalNullableRole": "ADMIN", "nullableStatus": "active", "optionalStatus": "active", "optionalNullableStatus": "active", "nullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalNullableNotification": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "nullableSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "optionalSearchResult": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableArray": []interface{}{"nullableArray", "nullableArray"}, "optionalArray": []interface{}{"optionalArray", "optionalArray"}, "optionalNullableArray": []interface{}{"optionalNullableArray", "optionalNullableArray"}, "nullableListOfNullables": []interface{}{"nullableListOfNullables", "nullableListOfNullables"}, "nullableMapOfNullables": map[string]interface{}{"nullableMapOfNullables": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableListOfUnions": []interface{}{map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}}, "optionalMapOfEnums": map[string]interface{}{"optionalMapOfEnums": "ADMIN"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.UpdateComplexProfileRequest{
		NullableRole:   fern.UserRoleAdmin.Ptr(),
		NullableStatus: fern.UserStatusActive.Ptr(),
		NullableNotification: &fern.NotificationMethod{
			Email: &fern.EmailNotification{
				EmailAddress: "emailAddress",
				Subject:      "subject",
				HtmlContent: fern.String(
					"htmlContent",
				),
			},
		},
		NullableSearchResult: &fern.SearchResult{
			User: &fern.UserResponse{
				Id:       "id",
				Username: "username",
				Email: fern.String(
					"email",
				),
				Phone: fern.String(
					"phone",
				),
				CreatedAt: fern.MustParseDateTime(
					"2024-01-15T09:30:00Z",
				),
				UpdatedAt: fern.Time(
					fern.MustParseDateTime(
						"2024-01-15T09:30:00Z",
					),
				),
				Address: &fern.Address{
					Street: "street",
					City: fern.String(
						"city",
					),
					State: fern.String(
						"state",
					),
					ZipCode: "zipCode",
					Country: fern.String(
						"country",
					),
					BuildingId: fern.String(
						"buildingId",
					),
					TenantId: fern.String(
						"tenantId",
					),
				},
			},
		},
		NullableArray: []string{
			"nullableArray",
			"nullableArray",
		},
	}
	_, invocationErr := client.NullableOptional.UpdateComplexProfile(
		context.TODO(),
		"profileId",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalTestDeserializationWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/api/test/deserialization")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"echo": map[string]interface{}{"requiredString": "requiredString", "nullableString": "nullableString", "optionalString": "optionalString", "optionalNullableString": "optionalNullableString", "nullableEnum": "ADMIN", "optionalEnum": "active", "nullableUnion": map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"}, "optionalUnion": map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, "nullableList": []interface{}{"nullableList", "nullableList"}, "nullableMap": map[string]interface{}{"nullableMap": 1}, "nullableObject": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}, "optionalObject": map[string]interface{}{"id": "id", "name": "name", "domain": "domain", "employeeCount": 1}}, "processedAt": "2024-01-15T09:30:00Z", "nullCount": 1, "presentFieldsCount": 1},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.DeserializationTestRequest{
		RequiredString: "requiredString",
		NullableString: fern.String(
			"nullableString",
		),
		OptionalString: fern.String(
			"optionalString",
		),
		OptionalNullableString: fern.String(
			"optionalNullableString",
		),
		NullableEnum: fern.UserRoleAdmin.Ptr(),
		OptionalEnum: fern.UserStatusActive.Ptr(),
		NullableUnion: &fern.NotificationMethod{
			Email: &fern.EmailNotification{
				EmailAddress: "emailAddress",
				Subject:      "subject",
				HtmlContent: fern.String(
					"htmlContent",
				),
			},
		},
		OptionalUnion: &fern.SearchResult{
			User: &fern.UserResponse{
				Id:       "id",
				Username: "username",
				Email: fern.String(
					"email",
				),
				Phone: fern.String(
					"phone",
				),
				CreatedAt: fern.MustParseDateTime(
					"2024-01-15T09:30:00Z",
				),
				UpdatedAt: fern.Time(
					fern.MustParseDateTime(
						"2024-01-15T09:30:00Z",
					),
				),
				Address: &fern.Address{
					Street: "street",
					City: fern.String(
						"city",
					),
					State: fern.String(
						"state",
					),
					ZipCode: "zipCode",
					Country: fern.String(
						"country",
					),
					BuildingId: fern.String(
						"buildingId",
					),
					TenantId: fern.String(
						"tenantId",
					),
				},
			},
		},
		NullableList: []string{
			"nullableList",
			"nullableList",
		},
		NullableMap: map[string]int{
			"nullableMap": 1,
		},
		NullableObject: &fern.Address{
			Street: "street",
			City: fern.String(
				"city",
			),
			State: fern.String(
				"state",
			),
			ZipCode: "zipCode",
			Country: fern.String(
				"country",
			),
			BuildingId: fern.String(
				"buildingId",
			),
			TenantId: fern.String(
				"tenantId",
			),
		},
		OptionalObject: &fern.Organization{
			Id:   "id",
			Name: "name",
			Domain: fern.String(
				"domain",
			),
			EmployeeCount: fern.Int(
				1,
			),
		},
	}
	_, invocationErr := client.NullableOptional.TestDeserialization(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalFilterByRoleWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/users/filter")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			[]interface{}{map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, map[string]interface{}{"id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.FilterByRoleRequest{
		Role:          fern.UserRoleAdmin.Ptr(),
		Status:        fern.UserStatusActive.Ptr(),
		SecondaryRole: fern.UserRoleAdmin.Ptr(),
	}
	_, invocationErr := client.NullableOptional.FilterByRole(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalGetNotificationSettingsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/api/users/{userId}/notifications")).WithPathParam(
		"userId",
		gowiremock.Matching("userId"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"type": "email", "emailAddress": "emailAddress", "subject": "subject", "htmlContent": "htmlContent"},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.NullableOptional.GetNotificationSettings(
		context.TODO(),
		"userId",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalUpdateTagsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Put(gowiremock.URLPathTemplate("/api/users/{userId}/tags")).WithPathParam(
		"userId",
		gowiremock.Matching("userId"),
	).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["tags"],
                    "properties": {
                        "tags": {"type": "array", "items": {"type": "string"}}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			[]interface{}{"string", "string"},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.UpdateTagsRequest{
		Tags: []string{
			"tags",
			"tags",
		},
		Categories: []string{
			"categories",
			"categories",
		},
		Labels: []string{
			"labels",
			"labels",
		},
	}
	_, invocationErr := client.NullableOptional.UpdateTags(
		context.TODO(),
		"userId",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestNullableOptionalGetSearchResultsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/api/search")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["query", "includeTypes"],
                    "properties": {
                        "query": {"type": "string"}, "includeTypes": {"type": "array", "items": {"type": "string"}}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			[]interface{}{map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}, map[string]interface{}{"type": "user", "id": "id", "username": "username", "email": "email", "phone": "phone", "createdAt": "2024-01-15T09:30:00Z", "updatedAt": "2024-01-15T09:30:00Z", "address": map[string]interface{}{"street": "street", "city": "city", "state": "state", "zipCode": "zipCode", "country": "country", "buildingId": "buildingId", "tenantId": "tenantId"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &fern.SearchRequest{
		Query: "query",
		Filters: map[string]*string{
			"filters": fern.String(
				"filters",
			),
		},
		IncludeTypes: []string{
			"includeTypes",
			"includeTypes",
		},
	}
	_, invocationErr := client.NullableOptional.GetSearchResults(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

// Code generated by Fern. DO NOT EDIT.

package commons

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/examples/fern/internal"
	big "math/big"
)

type Data struct {
	Type        string
	FieldString string
	Base64      []byte
}

func NewDataFromFieldString(value string) *Data {
	return &Data{Type: "string", FieldString: value}
}

func NewDataFromBase64(value []byte) *Data {
	return &Data{Type: "base64", Base64: value}
}

func (d *Data) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *Data) GetFieldString() string {
	if d == nil {
		return ""
	}
	return d.FieldString
}

func (d *Data) GetBase64() []byte {
	if d == nil {
		return nil
	}
	return d.Base64
}

func (d *Data) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			FieldString string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.FieldString = valueUnmarshaler.FieldString
	case "base64":
		var valueUnmarshaler struct {
			Base64 []byte `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.Base64 = valueUnmarshaler.Base64
	}
	return nil
}

func (d Data) MarshalJSON() ([]byte, error) {
	if err := d.validate(); err != nil {
		return nil, err
	}
	switch d.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "string":
		var marshaler = struct {
			Type        string `json:"type"`
			FieldString string `json:"value"`
		}{
			Type:        "string",
			FieldString: d.FieldString,
		}
		return json.Marshal(marshaler)
	case "base64":
		var marshaler = struct {
			Type   string `json:"type"`
			Base64 []byte `json:"value"`
		}{
			Type:   "base64",
			Base64: d.Base64,
		}
		return json.Marshal(marshaler)
	}
}

type DataVisitor interface {
	VisitFieldString(string) error
	VisitBase64([]byte) error
}

func (d *Data) Accept(visitor DataVisitor) error {
	switch d.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "string":
		return visitor.VisitFieldString(d.FieldString)
	case "base64":
		return visitor.VisitBase64(d.Base64)
	}
}

func (d *Data) validate() error {
	if d == nil {
		return fmt.Errorf("type %T is nil", d)
	}
	var fields []string
	if d.FieldString != "" {
		fields = append(fields, "string")
	}
	if d.Base64 != nil {
		fields = append(fields, "base64")
	}
	if len(fields) == 0 {
		if d.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", d, d.Type)
		}
		return fmt.Errorf("type %T is empty", d)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", d, fields)
	}
	if d.Type != "" {
		field := fields[0]
		if d.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				d,
				d.Type,
				d,
			)
		}
	}
	return nil
}

type EventInfo struct {
	Type     string
	Metadata *Metadata
	Tag      Tag
}

func NewEventInfoFromMetadata(value *Metadata) *EventInfo {
	return &EventInfo{Type: "metadata", Metadata: value}
}

func NewEventInfoFromTag(value Tag) *EventInfo {
	return &EventInfo{Type: "tag", Tag: value}
}

func (e *EventInfo) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EventInfo) GetMetadata() *Metadata {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EventInfo) GetTag() Tag {
	if e == nil {
		return ""
	}
	return e.Tag
}

func (e *EventInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "metadata":
		value := new(Metadata)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Metadata = value
	case "tag":
		var valueUnmarshaler struct {
			Tag Tag `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Tag = valueUnmarshaler.Tag
	}
	return nil
}

func (e EventInfo) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "metadata":
		return internal.MarshalJSONWithExtraProperty(e.Metadata, "type", "metadata")
	case "tag":
		var marshaler = struct {
			Type string `json:"type"`
			Tag  Tag    `json:"value"`
		}{
			Type: "tag",
			Tag:  e.Tag,
		}
		return json.Marshal(marshaler)
	}
}

type EventInfoVisitor interface {
	VisitMetadata(*Metadata) error
	VisitTag(Tag) error
}

func (e *EventInfo) Accept(visitor EventInfoVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "metadata":
		return visitor.VisitMetadata(e.Metadata)
	case "tag":
		return visitor.VisitTag(e.Tag)
	}
}

func (e *EventInfo) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if e.Tag != "" {
		fields = append(fields, "tag")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	metadataFieldId         = big.NewInt(1 << 0)
	metadataFieldData       = big.NewInt(1 << 1)
	metadataFieldJsonString = big.NewInt(1 << 2)
)

type Metadata struct {
	Id         string            `json:"id" url:"id"`
	Data       map[string]string `json:"data,omitempty" url:"data,omitempty"`
	JsonString *string           `json:"jsonString,omitempty" url:"jsonString,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Metadata) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *Metadata) GetData() map[string]string {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *Metadata) GetJsonString() *string {
	if m == nil {
		return nil
	}
	return m.JsonString
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Metadata) SetId(id string) {
	m.Id = id
	m.require(metadataFieldId)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Metadata) SetData(data map[string]string) {
	m.Data = data
	m.require(metadataFieldData)
}

// SetJsonString sets the JsonString field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Metadata) SetJsonString(jsonString *string) {
	m.JsonString = jsonString
	m.require(metadataFieldJsonString)
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) MarshalJSON() ([]byte, error) {
	type embed Metadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Metadata) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Tag = string

// Code generated by Fern. DO NOT EDIT.

package internal

import (
	"net/http"
	"sync"
	"time"
)

const bufferInMinutes = 2

type TokenCache struct {
	token     string
	expiresAt time.Time
	mu        sync.RWMutex
}
type InferredAuthProvider struct {
	cache        *TokenCache
	ClientId     string
	ClientSecret string
	Audience     string
	GrantType    string
	Scope        string
}

func NewInferredAuthProvider(
	clientId string,
	clientSecret string,
	audience string,
	grantType string,
	scope string,
) *InferredAuthProvider {
	return &InferredAuthProvider{
		cache:        &TokenCache{},
		ClientId:     clientId,
		ClientSecret: clientSecret,
		Audience:     audience,
		GrantType:    grantType,
		Scope:        scope,
	}
}
func (p *InferredAuthProvider) GetOrFetch(tokenFetcher func() (string, error)) (http.Header, error) {
	token, err := p.getOrFetchToken(tokenFetcher)
	if err != nil {
		return nil, err
	}

	headers := make(http.Header)
	headers.Set("Authorization", "Bearer "+token)
	return headers, nil
}
func (p *InferredAuthProvider) getOrFetchToken(tokenFetcher func() (string, error)) (string, error) {
	p.cache.mu.RLock()
	if p.cache.token != "" && time.Now().Before(p.cache.expiresAt) {
		token := p.cache.token
		p.cache.mu.RUnlock()
		return token, nil
	}
	p.cache.mu.RUnlock()

	p.cache.mu.Lock()
	defer p.cache.mu.Unlock()

	// Double-check pattern
	if p.cache.token != "" && time.Now().Before(p.cache.expiresAt) {
		return p.cache.token, nil
	}

	token, err := tokenFetcher()
	if err != nil {
		return "", err
	}

	p.cache.token = token
	return token, nil
}

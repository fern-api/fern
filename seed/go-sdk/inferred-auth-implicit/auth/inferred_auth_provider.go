// Code generated by Fern. DO NOT EDIT.

package auth

import (
	context "context"
	fern "github.com/inferred-auth-implicit/fern"
	core "github.com/inferred-auth-implicit/fern/core"
	http "net/http"
	sync "sync"
	time "time"
)

type InferredAuthProvider struct {
	mu          sync.Mutex
	client      *Client
	options     *core.RequestOptions
	expiresAt   *time.Time
	cachedToken *fern.TokenResponse
}

func NewInferredAuthProvider(options *core.RequestOptions) *InferredAuthProvider {
	return &InferredAuthProvider{
		client:  NewClient(options),
		options: options,
	}
}

// AuthHeaders returns the authentication headers for the request. It handles token caching and automatic refresh when tokens expire.
func (i *InferredAuthProvider) AuthHeaders(
	ctx context.Context,
) (http.Header, error) {
	p.mu.Lock()
	defer p.mu.Unlock()

	// Check if we have a valid cached token
	if p.cachedToken != nil && p.expiresAt != nil && time.Now().Before(*p.expiresAt) {
		return p.buildHeaders(), nil
	}

	// Fetch a new token
	token, err := p.client.endpoint_auth.getTokenWithClientCredentials(ctx)
	if err != nil {
		return nil, err
	}

	p.cachedToken = token

	// Calculate expiry time with buffer
	expiresIn := token.ExpiresIn
	expiresAt := time.Now().Add(time.Duration(expiresIn)*time.Second - time.Duration(2)*time.Minute)
	p.expiresAt = &expiresAt

	return p.buildHeaders(), nil
}

// buildHeaders constructs the authentication headers from the cached token.
func (i *InferredAuthProvider) buildHeaders() http.Header {
	headers := make(http.Header)
	headers.Set("Authorization", "Bearer "+p.cachedToken.AccessToken)
	return headers
}

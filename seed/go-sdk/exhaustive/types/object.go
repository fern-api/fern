// Code generated by Fern. DO NOT EDIT.

package types

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/exhaustive/fern/internal"
	uuid "github.com/google/uuid"
	big "math/big"
	time "time"
)

var (
	doubleOptionalFieldOptionalAlias = big.NewInt(1 << 0)
)

type DoubleOptional struct {
	OptionalAlias *OptionalAlias `json:"optionalAlias,omitempty" url:"optionalAlias,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DoubleOptional) GetOptionalAlias() *OptionalAlias {
	if d == nil {
		return nil
	}
	return d.OptionalAlias
}

func (d *DoubleOptional) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleOptional) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetOptionalAlias sets the OptionalAlias field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleOptional) SetOptionalAlias(optionalAlias *OptionalAlias) {
	d.OptionalAlias = optionalAlias
	d.require(doubleOptionalFieldOptionalAlias)
}

func (d *DoubleOptional) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleOptional
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleOptional(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DoubleOptional) MarshalJSON() ([]byte, error) {
	type embed DoubleOptional
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DoubleOptional) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	nestedObjectWithOptionalFieldFieldString       = big.NewInt(1 << 0)
	nestedObjectWithOptionalFieldFieldNestedObject = big.NewInt(1 << 1)
)

type NestedObjectWithOptionalField struct {
	String       *string                  `json:"string,omitempty" url:"string,omitempty"`
	NestedObject *ObjectWithOptionalField `json:"NestedObject,omitempty" url:"NestedObject,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NestedObjectWithOptionalField) GetString() *string {
	if n == nil {
		return nil
	}
	return n.String
}

func (n *NestedObjectWithOptionalField) GetNestedObject() *ObjectWithOptionalField {
	if n == nil {
		return nil
	}
	return n.NestedObject
}

func (n *NestedObjectWithOptionalField) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NestedObjectWithOptionalField) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetString sets the String field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedObjectWithOptionalField) SetString(string_ *string) {
	n.String = string_
	n.require(nestedObjectWithOptionalFieldFieldString)
}

// SetNestedObject sets the NestedObject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedObjectWithOptionalField) SetNestedObject(nestedObject *ObjectWithOptionalField) {
	n.NestedObject = nestedObject
	n.require(nestedObjectWithOptionalFieldFieldNestedObject)
}

func (n *NestedObjectWithOptionalField) UnmarshalJSON(data []byte) error {
	type unmarshaler NestedObjectWithOptionalField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NestedObjectWithOptionalField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NestedObjectWithOptionalField) MarshalJSON() ([]byte, error) {
	type embed NestedObjectWithOptionalField
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NestedObjectWithOptionalField) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nestedObjectWithRequiredFieldFieldString       = big.NewInt(1 << 0)
	nestedObjectWithRequiredFieldFieldNestedObject = big.NewInt(1 << 1)
)

type NestedObjectWithRequiredField struct {
	String       string                   `json:"string" url:"string"`
	NestedObject *ObjectWithOptionalField `json:"NestedObject" url:"NestedObject"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NestedObjectWithRequiredField) GetString() string {
	if n == nil {
		return ""
	}
	return n.String
}

func (n *NestedObjectWithRequiredField) GetNestedObject() *ObjectWithOptionalField {
	if n == nil {
		return nil
	}
	return n.NestedObject
}

func (n *NestedObjectWithRequiredField) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NestedObjectWithRequiredField) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetString sets the String field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedObjectWithRequiredField) SetString(string_ string) {
	n.String = string_
	n.require(nestedObjectWithRequiredFieldFieldString)
}

// SetNestedObject sets the NestedObject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NestedObjectWithRequiredField) SetNestedObject(nestedObject *ObjectWithOptionalField) {
	n.NestedObject = nestedObject
	n.require(nestedObjectWithRequiredFieldFieldNestedObject)
}

func (n *NestedObjectWithRequiredField) UnmarshalJSON(data []byte) error {
	type unmarshaler NestedObjectWithRequiredField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NestedObjectWithRequiredField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NestedObjectWithRequiredField) MarshalJSON() ([]byte, error) {
	type embed NestedObjectWithRequiredField
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NestedObjectWithRequiredField) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	objectWithMapOfMapFieldMap = big.NewInt(1 << 0)
)

type ObjectWithMapOfMap struct {
	Map map[string]map[string]string `json:"map" url:"map"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectWithMapOfMap) GetMap() map[string]map[string]string {
	if o == nil {
		return nil
	}
	return o.Map
}

func (o *ObjectWithMapOfMap) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectWithMapOfMap) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetMap sets the Map field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithMapOfMap) SetMap(map_ map[string]map[string]string) {
	o.Map = map_
	o.require(objectWithMapOfMapFieldMap)
}

func (o *ObjectWithMapOfMap) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectWithMapOfMap
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectWithMapOfMap(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectWithMapOfMap) MarshalJSON() ([]byte, error) {
	type embed ObjectWithMapOfMap
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectWithMapOfMap) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	objectWithOptionalFieldFieldString   = big.NewInt(1 << 0)
	objectWithOptionalFieldFieldInteger  = big.NewInt(1 << 1)
	objectWithOptionalFieldFieldLong     = big.NewInt(1 << 2)
	objectWithOptionalFieldFieldDouble   = big.NewInt(1 << 3)
	objectWithOptionalFieldFieldBool     = big.NewInt(1 << 4)
	objectWithOptionalFieldFieldDatetime = big.NewInt(1 << 5)
	objectWithOptionalFieldFieldDate     = big.NewInt(1 << 6)
	objectWithOptionalFieldFieldUuid     = big.NewInt(1 << 7)
	objectWithOptionalFieldFieldBase64   = big.NewInt(1 << 8)
	objectWithOptionalFieldFieldList     = big.NewInt(1 << 9)
	objectWithOptionalFieldFieldSet      = big.NewInt(1 << 10)
	objectWithOptionalFieldFieldMap      = big.NewInt(1 << 11)
	objectWithOptionalFieldFieldBigint   = big.NewInt(1 << 12)
)

type ObjectWithOptionalField struct {
	// This is a rather long descriptor of this single field in a more complex type. If you ask me I think this is a pretty good description for this field all things considered.
	String   *string        `json:"string,omitempty" url:"string,omitempty"`
	Integer  *int           `json:"integer,omitempty" url:"integer,omitempty"`
	Long     *int64         `json:"long,omitempty" url:"long,omitempty"`
	Double   *float64       `json:"double,omitempty" url:"double,omitempty"`
	Bool     *bool          `json:"bool,omitempty" url:"bool,omitempty"`
	Datetime *time.Time     `json:"datetime,omitempty" url:"datetime,omitempty"`
	Date     *time.Time     `json:"date,omitempty" url:"date,omitempty" format:"date"`
	Uuid     *uuid.UUID     `json:"uuid,omitempty" url:"uuid,omitempty"`
	Base64   *[]byte        `json:"base64,omitempty" url:"base64,omitempty"`
	List     []string       `json:"list,omitempty" url:"list,omitempty"`
	Set      []string       `json:"set,omitempty" url:"set,omitempty"`
	Map      map[int]string `json:"map,omitempty" url:"map,omitempty"`
	Bigint   *string        `json:"bigint,omitempty" url:"bigint,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectWithOptionalField) GetString() *string {
	if o == nil {
		return nil
	}
	return o.String
}

func (o *ObjectWithOptionalField) GetInteger() *int {
	if o == nil {
		return nil
	}
	return o.Integer
}

func (o *ObjectWithOptionalField) GetLong() *int64 {
	if o == nil {
		return nil
	}
	return o.Long
}

func (o *ObjectWithOptionalField) GetDouble() *float64 {
	if o == nil {
		return nil
	}
	return o.Double
}

func (o *ObjectWithOptionalField) GetBool() *bool {
	if o == nil {
		return nil
	}
	return o.Bool
}

func (o *ObjectWithOptionalField) GetDatetime() *time.Time {
	if o == nil {
		return nil
	}
	return o.Datetime
}

func (o *ObjectWithOptionalField) GetDate() *time.Time {
	if o == nil {
		return nil
	}
	return o.Date
}

func (o *ObjectWithOptionalField) GetUuid() *uuid.UUID {
	if o == nil {
		return nil
	}
	return o.Uuid
}

func (o *ObjectWithOptionalField) GetBase64() *[]byte {
	if o == nil {
		return nil
	}
	return o.Base64
}

func (o *ObjectWithOptionalField) GetList() []string {
	if o == nil {
		return nil
	}
	return o.List
}

func (o *ObjectWithOptionalField) GetSet() []string {
	if o == nil {
		return nil
	}
	return o.Set
}

func (o *ObjectWithOptionalField) GetMap() map[int]string {
	if o == nil {
		return nil
	}
	return o.Map
}

func (o *ObjectWithOptionalField) GetBigint() *string {
	if o == nil {
		return nil
	}
	return o.Bigint
}

func (o *ObjectWithOptionalField) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectWithOptionalField) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetString sets the String field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetString(string_ *string) {
	o.String = string_
	o.require(objectWithOptionalFieldFieldString)
}

// SetInteger sets the Integer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetInteger(integer *int) {
	o.Integer = integer
	o.require(objectWithOptionalFieldFieldInteger)
}

// SetLong sets the Long field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetLong(long *int64) {
	o.Long = long
	o.require(objectWithOptionalFieldFieldLong)
}

// SetDouble sets the Double field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetDouble(double *float64) {
	o.Double = double
	o.require(objectWithOptionalFieldFieldDouble)
}

// SetBool sets the Bool field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetBool(bool_ *bool) {
	o.Bool = bool_
	o.require(objectWithOptionalFieldFieldBool)
}

// SetDatetime sets the Datetime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetDatetime(datetime *time.Time) {
	o.Datetime = datetime
	o.require(objectWithOptionalFieldFieldDatetime)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetDate(date *time.Time) {
	o.Date = date
	o.require(objectWithOptionalFieldFieldDate)
}

// SetUuid sets the Uuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetUuid(uuid *uuid.UUID) {
	o.Uuid = uuid
	o.require(objectWithOptionalFieldFieldUuid)
}

// SetBase64 sets the Base64 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetBase64(base64 *[]byte) {
	o.Base64 = base64
	o.require(objectWithOptionalFieldFieldBase64)
}

// SetList sets the List field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetList(list []string) {
	o.List = list
	o.require(objectWithOptionalFieldFieldList)
}

// SetSet sets the Set field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetSet(set []string) {
	o.Set = set
	o.require(objectWithOptionalFieldFieldSet)
}

// SetMap sets the Map field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetMap(map_ map[int]string) {
	o.Map = map_
	o.require(objectWithOptionalFieldFieldMap)
}

// SetBigint sets the Bigint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithOptionalField) SetBigint(bigint *string) {
	o.Bigint = bigint
	o.require(objectWithOptionalFieldFieldBigint)
}

func (o *ObjectWithOptionalField) UnmarshalJSON(data []byte) error {
	type embed ObjectWithOptionalField
	var unmarshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime,omitempty"`
		Date     *internal.Date     `json:"date,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = ObjectWithOptionalField(unmarshaler.embed)
	o.Datetime = unmarshaler.Datetime.TimePtr()
	o.Date = unmarshaler.Date.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectWithOptionalField) MarshalJSON() ([]byte, error) {
	type embed ObjectWithOptionalField
	var marshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime,omitempty"`
		Date     *internal.Date     `json:"date,omitempty"`
	}{
		embed:    embed(*o),
		Datetime: internal.NewOptionalDateTime(o.Datetime),
		Date:     internal.NewOptionalDate(o.Date),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectWithOptionalField) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	objectWithRequiredFieldFieldString = big.NewInt(1 << 0)
)

type ObjectWithRequiredField struct {
	String string `json:"string" url:"string"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectWithRequiredField) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *ObjectWithRequiredField) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectWithRequiredField) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetString sets the String field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectWithRequiredField) SetString(string_ string) {
	o.String = string_
	o.require(objectWithRequiredFieldFieldString)
}

func (o *ObjectWithRequiredField) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectWithRequiredField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectWithRequiredField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectWithRequiredField) MarshalJSON() ([]byte, error) {
	type embed ObjectWithRequiredField
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectWithRequiredField) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OptionalAlias = *string

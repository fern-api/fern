// This file was auto-generated by Fern from our API Definition.

package enum

import (
	json "encoding/json"
	fmt "fmt"
)

type Color string

const (
	ColorRed  Color = "red"
	ColorBlue Color = "blue"
)

func NewColorFromString(s string) (Color, error) {
	switch s {
	case "red":
		return ColorRed, nil
	case "blue":
		return ColorBlue, nil
	}
	var t Color
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Color) Ptr() *Color {
	return &c
}

type ColorOrOperand struct {
	Color   Color
	Operand Operand

	typ string
}

func NewColorOrOperandFromColor(value Color) *ColorOrOperand {
	return &ColorOrOperand{typ: "Color", Color: value}
}

func NewColorOrOperandFromOperand(value Operand) *ColorOrOperand {
	return &ColorOrOperand{typ: "Operand", Operand: value}
}

func (c *ColorOrOperand) GetColor() Color {
	if c == nil {
		return ""
	}
	return c.Color
}

func (c *ColorOrOperand) GetOperand() Operand {
	if c == nil {
		return ""
	}
	return c.Operand
}

func (c *ColorOrOperand) UnmarshalJSON(data []byte) error {
	var valueColor Color
	if err := json.Unmarshal(data, &valueColor); err == nil {
		c.typ = "Color"
		c.Color = valueColor
		return nil
	}
	var valueOperand Operand
	if err := json.Unmarshal(data, &valueOperand); err == nil {
		c.typ = "Operand"
		c.Operand = valueOperand
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ColorOrOperand) MarshalJSON() ([]byte, error) {
	if c.typ == "Color" || c.Color != "" {
		return json.Marshal(c.Color)
	}
	if c.typ == "Operand" || c.Operand != "" {
		return json.Marshal(c.Operand)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ColorOrOperandVisitor interface {
	VisitColor(Color) error
	VisitOperand(Operand) error
}

func (c *ColorOrOperand) Accept(visitor ColorOrOperandVisitor) error {
	if c.typ == "Color" || c.Color != "" {
		return visitor.VisitColor(c.Color)
	}
	if c.typ == "Operand" || c.Operand != "" {
		return visitor.VisitOperand(c.Operand)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type EnumWithCustom string

const (
	EnumWithCustomSafe   EnumWithCustom = "safe"
	EnumWithCustomCustom EnumWithCustom = "Custom"
)

func NewEnumWithCustomFromString(s string) (EnumWithCustom, error) {
	switch s {
	case "safe":
		return EnumWithCustomSafe, nil
	case "Custom":
		return EnumWithCustomCustom, nil
	}
	var t EnumWithCustom
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumWithCustom) Ptr() *EnumWithCustom {
	return &e
}

// Tests enum name and value can be
// different.
type Operand string

const (
	OperandGreaterThan Operand = ">"
	OperandEqualTo     Operand = "="
	// The name and value should be similar
	// are similar for less than.
	OperandLessThan Operand = "less_than"
)

func NewOperandFromString(s string) (Operand, error) {
	switch s {
	case ">":
		return OperandGreaterThan, nil
	case "=":
		return OperandEqualTo, nil
	case "less_than":
		return OperandLessThan, nil
	}
	var t Operand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Operand) Ptr() *Operand {
	return &o
}

// Code generated by Fern. DO NOT EDIT.

package propertyaccess

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/property-access/fern/internal"
)

// Admin user object
type Admin struct {
	// The unique identifier for the user.
	Id string `json:"id" url:"id"`
	// The email address of the user.
	Email string `json:"email" url:"email"`
	// The password for the user.
	Password string `json:"password" url:"password"`
	// User profile object
	Profile *UserProfile `json:"profile" url:"profile"`
	// The level of admin privileges.
	AdminLevel string `json:"adminLevel" url:"adminLevel"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Admin) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Admin) GetEmail() string {
	if a == nil {
		return ""
	}
	return a.Email
}

func (a *Admin) GetPassword() string {
	if a == nil {
		return ""
	}
	return a.Password
}

func (a *Admin) GetProfile() *UserProfile {
	if a == nil {
		return nil
	}
	return a.Profile
}

func (a *Admin) GetAdminLevel() string {
	if a == nil {
		return ""
	}
	return a.AdminLevel
}

func (a *Admin) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Admin) UnmarshalJSON(data []byte) error {
	type unmarshaler Admin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Admin(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Admin) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Foo struct {
	Normal string `json:"normal" url:"normal"`
	Read   string `json:"read" url:"read"`
	Write  string `json:"write" url:"write"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Foo) GetNormal() string {
	if f == nil {
		return ""
	}
	return f.Normal
}

func (f *Foo) GetRead() string {
	if f == nil {
		return ""
	}
	return f.Read
}

func (f *Foo) GetWrite() string {
	if f == nil {
		return ""
	}
	return f.Write
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Foo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// User object
type User struct {
	// The unique identifier for the user.
	Id string `json:"id" url:"id"`
	// The email address of the user.
	Email string `json:"email" url:"email"`
	// The password for the user.
	Password string `json:"password" url:"password"`
	// User profile object
	Profile *UserProfile `json:"profile" url:"profile"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() string {
	if u == nil {
		return ""
	}
	return u.Id
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetPassword() string {
	if u == nil {
		return ""
	}
	return u.Password
}

func (u *User) GetProfile() *UserProfile {
	if u == nil {
		return nil
	}
	return u.Profile
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Example of an undiscriminated union
type UserOrAdmin struct {
	User  *User
	Admin *Admin

	typ string
}

func (u *UserOrAdmin) GetUser() *User {
	if u == nil {
		return nil
	}
	return u.User
}

func (u *UserOrAdmin) GetAdmin() *Admin {
	if u == nil {
		return nil
	}
	return u.Admin
}

func (u *UserOrAdmin) UnmarshalJSON(data []byte) error {
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		u.typ = "User"
		u.User = valueUser
		return nil
	}
	valueAdmin := new(Admin)
	if err := json.Unmarshal(data, &valueAdmin); err == nil {
		u.typ = "Admin"
		u.Admin = valueAdmin
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserOrAdmin) MarshalJSON() ([]byte, error) {
	if u.typ == "User" || u.User != nil {
		return json.Marshal(u.User)
	}
	if u.typ == "Admin" || u.Admin != nil {
		return json.Marshal(u.Admin)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserOrAdminVisitor interface {
	VisitUser(*User) error
	VisitAdmin(*Admin) error
}

func (u *UserOrAdmin) Accept(visitor UserOrAdminVisitor) error {
	if u.typ == "User" || u.User != nil {
		return visitor.VisitUser(u.User)
	}
	if u.typ == "Admin" || u.Admin != nil {
		return visitor.VisitAdmin(u.Admin)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// Example of an discriminated union
type UserOrAdminDiscriminated struct {
	Type   string
	Normal string
	Read   string
	Write  string
	Normal string
	Foo    *Foo
	User   *User
	Admin  *Admin
	Empty  interface{}
}

func (u *UserOrAdminDiscriminated) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UserOrAdminDiscriminated) GetNormal() string {
	if u == nil {
		return ""
	}
	return u.Normal
}

func (u *UserOrAdminDiscriminated) GetRead() string {
	if u == nil {
		return ""
	}
	return u.Read
}

func (u *UserOrAdminDiscriminated) GetWrite() string {
	if u == nil {
		return ""
	}
	return u.Write
}

func (u *UserOrAdminDiscriminated) GetNormal() string {
	if u == nil {
		return ""
	}
	return u.Normal
}

func (u *UserOrAdminDiscriminated) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UserOrAdminDiscriminated) GetUser() *User {
	if u == nil {
		return nil
	}
	return u.User
}

func (u *UserOrAdminDiscriminated) GetAdmin() *Admin {
	if u == nil {
		return nil
	}
	return u.Admin
}

func (u *UserOrAdminDiscriminated) GetEmpty() interface{} {
	if u == nil {
		return nil
	}
	return u.Empty
}

func (u *UserOrAdminDiscriminated) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type   string `json:"type"`
		Normal string `json:"normal" url:"normal"`
		Read   string `json:"read" url:"read"`
		Write  string `json:"write" url:"write"`
		Normal string `json:"normal"`
		Foo    *Foo   `json:"foo"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	u.Normal = unmarshaler.Normal
	u.Read = unmarshaler.Read
	u.Write = unmarshaler.Write
	u.Normal = unmarshaler.Normal
	u.Foo = unmarshaler.Foo
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "user":
		value := new(User)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.User = value
	case "admin":
		var valueUnmarshaler struct {
			Admin *Admin `json:"admin"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Admin = valueUnmarshaler.Admin
	case "empty":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Empty = value
	}
	return nil
}

func (u UserOrAdminDiscriminated) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	if u.User != nil {
		return internal.MarshalJSONWithExtraProperty(u.User, "type", "user")
	}
	if u.Admin != nil {
		var marshaler = struct {
			Type   string `json:"type"`
			Normal string `json:"normal" url:"normal"`
			Read   string `json:"read" url:"read"`
			Write  string `json:"write" url:"write"`
			Normal string `json:"normal"`
			Foo    *Foo   `json:"foo"`
			Admin  *Admin `json:"admin"`
		}{
			Type:   "admin",
			Normal: u.Normal,
			Read:   u.Read,
			Write:  u.Write,
			Normal: u.Normal,
			Foo:    u.Foo,
			Admin:  u.Admin,
		}
		return json.Marshal(marshaler)
	}
	if u.Empty != nil {
		var marshaler = struct {
			Type   string      `json:"type"`
			Normal string      `json:"normal" url:"normal"`
			Read   string      `json:"read" url:"read"`
			Write  string      `json:"write" url:"write"`
			Normal string      `json:"normal"`
			Foo    *Foo        `json:"foo"`
			Empty  interface{} `json:"empty,omitempty"`
		}{
			Type:   "empty",
			Normal: u.Normal,
			Read:   u.Read,
			Write:  u.Write,
			Normal: u.Normal,
			Foo:    u.Foo,
			Empty:  u.Empty,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UserOrAdminDiscriminatedVisitor interface {
	VisitUser(*User) error
	VisitAdmin(*Admin) error
	VisitEmpty(interface{}) error
}

func (u *UserOrAdminDiscriminated) Accept(visitor UserOrAdminDiscriminatedVisitor) error {
	if u.User != nil {
		return visitor.VisitUser(u.User)
	}
	if u.Admin != nil {
		return visitor.VisitAdmin(u.Admin)
	}
	if u.Empty != nil {
		return visitor.VisitEmpty(u.Empty)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

func (u *UserOrAdminDiscriminated) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.User != nil {
		fields = append(fields, "user")
	}
	if u.Admin != nil {
		fields = append(fields, "admin")
	}
	if u.Empty != nil {
		fields = append(fields, "empty")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

// User profile object
type UserProfile struct {
	// The name of the user.
	Name string `json:"name" url:"name"`
	// User profile verification object
	Verification *UserProfileVerification `json:"verification" url:"verification"`
	// The social security number of the user.
	Ssn string `json:"ssn" url:"ssn"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserProfile) GetName() string {
	if u == nil {
		return ""
	}
	return u.Name
}

func (u *UserProfile) GetVerification() *UserProfileVerification {
	if u == nil {
		return nil
	}
	return u.Verification
}

func (u *UserProfile) GetSsn() string {
	if u == nil {
		return ""
	}
	return u.Ssn
}

func (u *UserProfile) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfile) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// User profile verification object
type UserProfileVerification struct {
	// User profile verification status
	Verified string `json:"verified" url:"verified"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserProfileVerification) GetVerified() string {
	if u == nil {
		return ""
	}
	return u.Verified
}

func (u *UserProfileVerification) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserProfileVerification) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfileVerification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfileVerification(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfileVerification) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

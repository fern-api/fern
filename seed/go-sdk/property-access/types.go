// Code generated by Fern. DO NOT EDIT.

package propertyaccess

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/property-access/fern/internal"
	big "math/big"
)

// Admin user object
var (
	adminFieldId         = big.NewInt(1 << 0)
	adminFieldEmail      = big.NewInt(1 << 1)
	adminFieldPassword   = big.NewInt(1 << 2)
	adminFieldProfile    = big.NewInt(1 << 3)
	adminFieldAdminLevel = big.NewInt(1 << 4)
)

type Admin struct {
	// The unique identifier for the user.
	Id string `json:"id" url:"id"`
	// The email address of the user.
	Email string `json:"email" url:"email"`
	// The password for the user.
	Password string `json:"password" url:"password"`
	// User profile object
	Profile *UserProfile `json:"profile" url:"profile"`
	// The level of admin privileges.
	AdminLevel string `json:"adminLevel" url:"adminLevel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Admin) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Admin) GetEmail() string {
	if a == nil {
		return ""
	}
	return a.Email
}

func (a *Admin) GetPassword() string {
	if a == nil {
		return ""
	}
	return a.Password
}

func (a *Admin) GetProfile() *UserProfile {
	if a == nil {
		return nil
	}
	return a.Profile
}

func (a *Admin) GetAdminLevel() string {
	if a == nil {
		return ""
	}
	return a.AdminLevel
}

func (a *Admin) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Admin) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Admin) SetId(id string) {
	a.Id = id
	a.require(adminFieldId)
}

// SetEmail sets the Email field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Admin) SetEmail(email string) {
	a.Email = email
	a.require(adminFieldEmail)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Admin) SetPassword(password string) {
	a.Password = password
	a.require(adminFieldPassword)
}

// SetProfile sets the Profile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Admin) SetProfile(profile *UserProfile) {
	a.Profile = profile
	a.require(adminFieldProfile)
}

// SetAdminLevel sets the AdminLevel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Admin) SetAdminLevel(adminLevel string) {
	a.AdminLevel = adminLevel
	a.require(adminFieldAdminLevel)
}

func (a *Admin) UnmarshalJSON(data []byte) error {
	type unmarshaler Admin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Admin(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Admin) MarshalJSON() ([]byte, error) {
	type embed Admin
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Admin) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	fooFieldNormal = big.NewInt(1 << 0)
	fooFieldRead   = big.NewInt(1 << 1)
	fooFieldWrite  = big.NewInt(1 << 2)
)

type Foo struct {
	Normal string `json:"normal" url:"normal"`
	Read   string `json:"read" url:"read"`
	Write  string `json:"write" url:"write"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Foo) GetNormal() string {
	if f == nil {
		return ""
	}
	return f.Normal
}

func (f *Foo) GetRead() string {
	if f == nil {
		return ""
	}
	return f.Read
}

func (f *Foo) GetWrite() string {
	if f == nil {
		return ""
	}
	return f.Write
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetNormal sets the Normal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Foo) SetNormal(normal string) {
	f.Normal = normal
	f.require(fooFieldNormal)
}

// SetRead sets the Read field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Foo) SetRead(read string) {
	f.Read = read
	f.require(fooFieldRead)
}

// SetWrite sets the Write field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Foo) SetWrite(write string) {
	f.Write = write
	f.require(fooFieldWrite)
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Foo) MarshalJSON() ([]byte, error) {
	type embed Foo
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Foo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// User object
var (
	userFieldId       = big.NewInt(1 << 0)
	userFieldEmail    = big.NewInt(1 << 1)
	userFieldPassword = big.NewInt(1 << 2)
	userFieldProfile  = big.NewInt(1 << 3)
)

type User struct {
	// The unique identifier for the user.
	Id string `json:"id" url:"id"`
	// The email address of the user.
	Email string `json:"email" url:"email"`
	// The password for the user.
	Password string `json:"password" url:"password"`
	// User profile object
	Profile *UserProfile `json:"profile" url:"profile"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() string {
	if u == nil {
		return ""
	}
	return u.Id
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetPassword() string {
	if u == nil {
		return ""
	}
	return u.Password
}

func (u *User) GetProfile() *UserProfile {
	if u == nil {
		return nil
	}
	return u.Profile
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetId(id string) {
	u.Id = id
	u.require(userFieldId)
}

// SetEmail sets the Email field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetEmail(email string) {
	u.Email = email
	u.require(userFieldEmail)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetPassword(password string) {
	u.Password = password
	u.require(userFieldPassword)
}

// SetProfile sets the Profile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *User) SetProfile(profile *UserProfile) {
	u.Profile = profile
	u.require(userFieldProfile)
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Example of an undiscriminated union
type UserOrAdmin struct {
	User  *User
	Admin *Admin

	typ string
}

func (u *UserOrAdmin) GetUser() *User {
	if u == nil {
		return nil
	}
	return u.User
}

func (u *UserOrAdmin) GetAdmin() *Admin {
	if u == nil {
		return nil
	}
	return u.Admin
}

func (u *UserOrAdmin) UnmarshalJSON(data []byte) error {
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		u.typ = "User"
		u.User = valueUser
		return nil
	}
	valueAdmin := new(Admin)
	if err := json.Unmarshal(data, &valueAdmin); err == nil {
		u.typ = "Admin"
		u.Admin = valueAdmin
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserOrAdmin) MarshalJSON() ([]byte, error) {
	if u.typ == "User" || u.User != nil {
		return json.Marshal(u.User)
	}
	if u.typ == "Admin" || u.Admin != nil {
		return json.Marshal(u.Admin)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserOrAdminVisitor interface {
	VisitUser(*User) error
	VisitAdmin(*Admin) error
}

func (u *UserOrAdmin) Accept(visitor UserOrAdminVisitor) error {
	if u.typ == "User" || u.User != nil {
		return visitor.VisitUser(u.User)
	}
	if u.typ == "Admin" || u.Admin != nil {
		return visitor.VisitAdmin(u.Admin)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

// Example of an discriminated union
type UserOrAdminDiscriminated struct {
	Type   string
	Normal string
	Read   string
	Write  string
	Normal string
	Foo    *Foo
	User   *User
	Admin  *Admin
	Empty  interface{}
}

func (u *UserOrAdminDiscriminated) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UserOrAdminDiscriminated) GetNormal() string {
	if u == nil {
		return ""
	}
	return u.Normal
}

func (u *UserOrAdminDiscriminated) GetRead() string {
	if u == nil {
		return ""
	}
	return u.Read
}

func (u *UserOrAdminDiscriminated) GetWrite() string {
	if u == nil {
		return ""
	}
	return u.Write
}

func (u *UserOrAdminDiscriminated) GetNormal() string {
	if u == nil {
		return ""
	}
	return u.Normal
}

func (u *UserOrAdminDiscriminated) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *UserOrAdminDiscriminated) GetUser() *User {
	if u == nil {
		return nil
	}
	return u.User
}

func (u *UserOrAdminDiscriminated) GetAdmin() *Admin {
	if u == nil {
		return nil
	}
	return u.Admin
}

func (u *UserOrAdminDiscriminated) GetEmpty() interface{} {
	if u == nil {
		return nil
	}
	return u.Empty
}

func (u *UserOrAdminDiscriminated) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type   string `json:"type"`
		Normal string `json:"normal" url:"normal"`
		Read   string `json:"read" url:"read"`
		Write  string `json:"write" url:"write"`
		Normal string `json:"normal"`
		Foo    *Foo   `json:"foo"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	u.Normal = unmarshaler.Normal
	u.Read = unmarshaler.Read
	u.Write = unmarshaler.Write
	u.Normal = unmarshaler.Normal
	u.Foo = unmarshaler.Foo
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "user":
		value := new(User)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.User = value
	case "admin":
		var valueUnmarshaler struct {
			Admin *Admin `json:"admin"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Admin = valueUnmarshaler.Admin
	case "empty":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Empty = value
	}
	return nil
}

func (u UserOrAdminDiscriminated) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	if u.User != nil {
		return internal.MarshalJSONWithExtraProperty(u.User, "type", "user")
	}
	if u.Admin != nil {
		var marshaler = struct {
			Type   string `json:"type"`
			Normal string `json:"normal" url:"normal"`
			Read   string `json:"read" url:"read"`
			Write  string `json:"write" url:"write"`
			Normal string `json:"normal"`
			Foo    *Foo   `json:"foo"`
			Admin  *Admin `json:"admin"`
		}{
			Type:   "admin",
			Normal: u.Normal,
			Read:   u.Read,
			Write:  u.Write,
			Normal: u.Normal,
			Foo:    u.Foo,
			Admin:  u.Admin,
		}
		return json.Marshal(marshaler)
	}
	if u.Empty != nil {
		var marshaler = struct {
			Type   string      `json:"type"`
			Normal string      `json:"normal" url:"normal"`
			Read   string      `json:"read" url:"read"`
			Write  string      `json:"write" url:"write"`
			Normal string      `json:"normal"`
			Foo    *Foo        `json:"foo"`
			Empty  interface{} `json:"empty,omitempty"`
		}{
			Type:   "empty",
			Normal: u.Normal,
			Read:   u.Read,
			Write:  u.Write,
			Normal: u.Normal,
			Foo:    u.Foo,
			Empty:  u.Empty,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UserOrAdminDiscriminatedVisitor interface {
	VisitUser(*User) error
	VisitAdmin(*Admin) error
	VisitEmpty(interface{}) error
}

func (u *UserOrAdminDiscriminated) Accept(visitor UserOrAdminDiscriminatedVisitor) error {
	if u.User != nil {
		return visitor.VisitUser(u.User)
	}
	if u.Admin != nil {
		return visitor.VisitAdmin(u.Admin)
	}
	if u.Empty != nil {
		return visitor.VisitEmpty(u.Empty)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

func (u *UserOrAdminDiscriminated) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.User != nil {
		fields = append(fields, "user")
	}
	if u.Admin != nil {
		fields = append(fields, "admin")
	}
	if u.Empty != nil {
		fields = append(fields, "empty")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

// User profile object
var (
	userProfileFieldName         = big.NewInt(1 << 0)
	userProfileFieldVerification = big.NewInt(1 << 1)
	userProfileFieldSsn          = big.NewInt(1 << 2)
)

type UserProfile struct {
	// The name of the user.
	Name string `json:"name" url:"name"`
	// User profile verification object
	Verification *UserProfileVerification `json:"verification" url:"verification"`
	// The social security number of the user.
	Ssn string `json:"ssn" url:"ssn"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserProfile) GetName() string {
	if u == nil {
		return ""
	}
	return u.Name
}

func (u *UserProfile) GetVerification() *UserProfileVerification {
	if u == nil {
		return nil
	}
	return u.Verification
}

func (u *UserProfile) GetSsn() string {
	if u == nil {
		return ""
	}
	return u.Ssn
}

func (u *UserProfile) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserProfile) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserProfile) SetName(name string) {
	u.Name = name
	u.require(userProfileFieldName)
}

// SetVerification sets the Verification field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserProfile) SetVerification(verification *UserProfileVerification) {
	u.Verification = verification
	u.require(userProfileFieldVerification)
}

// SetSsn sets the Ssn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserProfile) SetSsn(ssn string) {
	u.Ssn = ssn
	u.require(userProfileFieldSsn)
}

func (u *UserProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfile) MarshalJSON() ([]byte, error) {
	type embed UserProfile
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserProfile) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// User profile verification object
var (
	userProfileVerificationFieldVerified = big.NewInt(1 << 0)
)

type UserProfileVerification struct {
	// User profile verification status
	Verified string `json:"verified" url:"verified"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserProfileVerification) GetVerified() string {
	if u == nil {
		return ""
	}
	return u.Verified
}

func (u *UserProfileVerification) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserProfileVerification) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetVerified sets the Verified field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserProfileVerification) SetVerified(verified string) {
	u.Verified = verified
	u.require(userProfileVerificationFieldVerified)
}

func (u *UserProfileVerification) UnmarshalJSON(data []byte) error {
	type unmarshaler UserProfileVerification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserProfileVerification(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserProfileVerification) MarshalJSON() ([]byte, error) {
	type embed UserProfileVerification
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserProfileVerification) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/circular-references-advanced/fern/internal"
)

type ContainerValue struct {
	Type     string
	List     []*FieldValue
	Optional *FieldValue
}

func NewContainerValueFromList(value []*FieldValue) *ContainerValue {
	return &ContainerValue{Type: "list", List: value}
}

func NewContainerValueFromOptional(value *FieldValue) *ContainerValue {
	return &ContainerValue{Type: "optional", Optional: value}
}

func (c *ContainerValue) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContainerValue) GetList() []*FieldValue {
	if c == nil {
		return nil
	}
	return c.List
}

func (c *ContainerValue) GetOptional() *FieldValue {
	if c == nil {
		return nil
	}
	return c.Optional
}

func (c *ContainerValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*FieldValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "optional":
		var valueUnmarshaler struct {
			Optional *FieldValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	}
	return nil
}

func (c ContainerValue) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string        `json:"type"`
			List []*FieldValue `json:"value,omitempty"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string      `json:"type"`
			Optional *FieldValue `json:"value,omitempty"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerValueVisitor interface {
	VisitList([]*FieldValue) error
	VisitOptional(*FieldValue) error
}

func (c *ContainerValue) Accept(visitor ContainerValueVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	}
}

func (c *ContainerValue) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.List != nil {
		fields = append(fields, "list")
	}
	if c.Optional != nil {
		fields = append(fields, "optional")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type FieldName = string

type FieldValue struct {
	Type           string
	PrimitiveValue PrimitiveValue
	ObjectValue    *ObjectValue
	ContainerValue *ContainerValue
}

func NewFieldValueFromPrimitiveValue(value PrimitiveValue) *FieldValue {
	return &FieldValue{Type: "primitive_value", PrimitiveValue: value}
}

func NewFieldValueFromObjectValue(value *ObjectValue) *FieldValue {
	return &FieldValue{Type: "object_value", ObjectValue: value}
}

func NewFieldValueFromContainerValue(value *ContainerValue) *FieldValue {
	return &FieldValue{Type: "container_value", ContainerValue: value}
}

func (f *FieldValue) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FieldValue) GetPrimitiveValue() PrimitiveValue {
	if f == nil {
		return ""
	}
	return f.PrimitiveValue
}

func (f *FieldValue) GetObjectValue() *ObjectValue {
	if f == nil {
		return nil
	}
	return f.ObjectValue
}

func (f *FieldValue) GetContainerValue() *ContainerValue {
	if f == nil {
		return nil
	}
	return f.ContainerValue
}

func (f *FieldValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "primitive_value":
		var valueUnmarshaler struct {
			PrimitiveValue PrimitiveValue `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.PrimitiveValue = valueUnmarshaler.PrimitiveValue
	case "object_value":
		value := new(ObjectValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.ObjectValue = value
	case "container_value":
		var valueUnmarshaler struct {
			ContainerValue *ContainerValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.ContainerValue = valueUnmarshaler.ContainerValue
	}
	return nil
}

func (f FieldValue) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "primitive_value":
		var marshaler = struct {
			Type           string         `json:"type"`
			PrimitiveValue PrimitiveValue `json:"value"`
		}{
			Type:           "primitive_value",
			PrimitiveValue: f.PrimitiveValue,
		}
		return json.Marshal(marshaler)
	case "object_value":
		return internal.MarshalJSONWithExtraProperty(f.ObjectValue, "type", "object_value")
	case "container_value":
		var marshaler = struct {
			Type           string          `json:"type"`
			ContainerValue *ContainerValue `json:"value,omitempty"`
		}{
			Type:           "container_value",
			ContainerValue: f.ContainerValue,
		}
		return json.Marshal(marshaler)
	}
}

type FieldValueVisitor interface {
	VisitPrimitiveValue(PrimitiveValue) error
	VisitObjectValue(*ObjectValue) error
	VisitContainerValue(*ContainerValue) error
}

func (f *FieldValue) Accept(visitor FieldValueVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "primitive_value":
		return visitor.VisitPrimitiveValue(f.PrimitiveValue)
	case "object_value":
		return visitor.VisitObjectValue(f.ObjectValue)
	case "container_value":
		return visitor.VisitContainerValue(f.ContainerValue)
	}
}

func (f *FieldValue) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.PrimitiveValue != "" {
		fields = append(fields, "primitive_value")
	}
	if f.ObjectValue != nil {
		fields = append(fields, "object_value")
	}
	if f.ContainerValue != nil {
		fields = append(fields, "container_value")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type FirstUnion struct {
	FirstUnionFirstElement  *FirstUnionFirstElement
	FirstUnionSecondElement *FirstUnionSecondElement

	typ string
}

func NewFirstUnionFromFirstUnionFirstElement(value *FirstUnionFirstElement) *FirstUnion {
	return &FirstUnion{typ: "FirstUnionFirstElement", FirstUnionFirstElement: value}
}

func NewFirstUnionFromFirstUnionSecondElement(value *FirstUnionSecondElement) *FirstUnion {
	return &FirstUnion{typ: "FirstUnionSecondElement", FirstUnionSecondElement: value}
}

func (f *FirstUnion) GetFirstUnionFirstElement() *FirstUnionFirstElement {
	if f == nil {
		return nil
	}
	return f.FirstUnionFirstElement
}

func (f *FirstUnion) GetFirstUnionSecondElement() *FirstUnionSecondElement {
	if f == nil {
		return nil
	}
	return f.FirstUnionSecondElement
}

func (f *FirstUnion) UnmarshalJSON(data []byte) error {
	valueFirstUnionFirstElement := new(FirstUnionFirstElement)
	if err := json.Unmarshal(data, &valueFirstUnionFirstElement); err == nil {
		f.typ = "FirstUnionFirstElement"
		f.FirstUnionFirstElement = valueFirstUnionFirstElement
		return nil
	}
	valueFirstUnionSecondElement := new(FirstUnionSecondElement)
	if err := json.Unmarshal(data, &valueFirstUnionSecondElement); err == nil {
		f.typ = "FirstUnionSecondElement"
		f.FirstUnionSecondElement = valueFirstUnionSecondElement
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FirstUnion) MarshalJSON() ([]byte, error) {
	if f.typ == "FirstUnionFirstElement" || f.FirstUnionFirstElement != nil {
		return json.Marshal(f.FirstUnionFirstElement)
	}
	if f.typ == "FirstUnionSecondElement" || f.FirstUnionSecondElement != nil {
		return json.Marshal(f.FirstUnionSecondElement)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FirstUnionVisitor interface {
	VisitFirstUnionFirstElement(*FirstUnionFirstElement) error
	VisitFirstUnionSecondElement(*FirstUnionSecondElement) error
}

func (f *FirstUnion) Accept(visitor FirstUnionVisitor) error {
	if f.typ == "FirstUnionFirstElement" || f.FirstUnionFirstElement != nil {
		return visitor.VisitFirstUnionFirstElement(f.FirstUnionFirstElement)
	}
	if f.typ == "FirstUnionSecondElement" || f.FirstUnionSecondElement != nil {
		return visitor.VisitFirstUnionSecondElement(f.FirstUnionSecondElement)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FirstUnionFirstElement struct {
	Child *SecondUnion `json:"child,omitempty" url:"child,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FirstUnionFirstElement) GetChild() *SecondUnion {
	if f == nil {
		return nil
	}
	return f.Child
}

func (f *FirstUnionFirstElement) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FirstUnionFirstElement) UnmarshalJSON(data []byte) error {
	type unmarshaler FirstUnionFirstElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirstUnionFirstElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirstUnionFirstElement) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirstUnionSecondElement struct {
	Child *SecondUnion `json:"child,omitempty" url:"child,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FirstUnionSecondElement) GetChild() *SecondUnion {
	if f == nil {
		return nil
	}
	return f.Child
}

func (f *FirstUnionSecondElement) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FirstUnionSecondElement) UnmarshalJSON(data []byte) error {
	type unmarshaler FirstUnionSecondElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirstUnionSecondElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirstUnionSecondElement) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This type allows us to test a circular reference with a union type (see FieldValue).
type ObjectFieldValue struct {
	Name  FieldName   `json:"name" url:"name"`
	Value *FieldValue `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectFieldValue) GetName() FieldName {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ObjectFieldValue) GetValue() *FieldValue {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *ObjectFieldValue) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectFieldValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectFieldValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectFieldValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectFieldValue) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectValue struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectValue) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectValue) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveValue string

const (
	PrimitiveValueString PrimitiveValue = "STRING"
	PrimitiveValueNumber PrimitiveValue = "NUMBER"
)

func NewPrimitiveValueFromString(s string) (PrimitiveValue, error) {
	switch s {
	case "STRING":
		return PrimitiveValueString, nil
	case "NUMBER":
		return PrimitiveValueNumber, nil
	}
	var t PrimitiveValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveValue) Ptr() *PrimitiveValue {
	return &p
}

type SecondUnion struct {
	SecondUnionFirstElement  *SecondUnionFirstElement
	SecondUnionSecondElement *SecondUnionSecondElement

	typ string
}

func NewSecondUnionFromSecondUnionFirstElement(value *SecondUnionFirstElement) *SecondUnion {
	return &SecondUnion{typ: "SecondUnionFirstElement", SecondUnionFirstElement: value}
}

func NewSecondUnionFromSecondUnionSecondElement(value *SecondUnionSecondElement) *SecondUnion {
	return &SecondUnion{typ: "SecondUnionSecondElement", SecondUnionSecondElement: value}
}

func (s *SecondUnion) GetSecondUnionFirstElement() *SecondUnionFirstElement {
	if s == nil {
		return nil
	}
	return s.SecondUnionFirstElement
}

func (s *SecondUnion) GetSecondUnionSecondElement() *SecondUnionSecondElement {
	if s == nil {
		return nil
	}
	return s.SecondUnionSecondElement
}

func (s *SecondUnion) UnmarshalJSON(data []byte) error {
	valueSecondUnionFirstElement := new(SecondUnionFirstElement)
	if err := json.Unmarshal(data, &valueSecondUnionFirstElement); err == nil {
		s.typ = "SecondUnionFirstElement"
		s.SecondUnionFirstElement = valueSecondUnionFirstElement
		return nil
	}
	valueSecondUnionSecondElement := new(SecondUnionSecondElement)
	if err := json.Unmarshal(data, &valueSecondUnionSecondElement); err == nil {
		s.typ = "SecondUnionSecondElement"
		s.SecondUnionSecondElement = valueSecondUnionSecondElement
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SecondUnion) MarshalJSON() ([]byte, error) {
	if s.typ == "SecondUnionFirstElement" || s.SecondUnionFirstElement != nil {
		return json.Marshal(s.SecondUnionFirstElement)
	}
	if s.typ == "SecondUnionSecondElement" || s.SecondUnionSecondElement != nil {
		return json.Marshal(s.SecondUnionSecondElement)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SecondUnionVisitor interface {
	VisitSecondUnionFirstElement(*SecondUnionFirstElement) error
	VisitSecondUnionSecondElement(*SecondUnionSecondElement) error
}

func (s *SecondUnion) Accept(visitor SecondUnionVisitor) error {
	if s.typ == "SecondUnionFirstElement" || s.SecondUnionFirstElement != nil {
		return visitor.VisitSecondUnionFirstElement(s.SecondUnionFirstElement)
	}
	if s.typ == "SecondUnionSecondElement" || s.SecondUnionSecondElement != nil {
		return visitor.VisitSecondUnionSecondElement(s.SecondUnionSecondElement)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SecondUnionFirstElement struct {
	Child *FirstUnion `json:"child,omitempty" url:"child,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecondUnionFirstElement) GetChild() *FirstUnion {
	if s == nil {
		return nil
	}
	return s.Child
}

func (s *SecondUnionFirstElement) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecondUnionFirstElement) UnmarshalJSON(data []byte) error {
	type unmarshaler SecondUnionFirstElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecondUnionFirstElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecondUnionFirstElement) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SecondUnionSecondElement struct {
	Child *FirstUnion `json:"child,omitempty" url:"child,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecondUnionSecondElement) GetChild() *FirstUnion {
	if s == nil {
		return nil
	}
	return s.Child
}

func (s *SecondUnionSecondElement) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecondUnionSecondElement) UnmarshalJSON(data []byte) error {
	type unmarshaler SecondUnionSecondElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecondUnionSecondElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecondUnionSecondElement) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

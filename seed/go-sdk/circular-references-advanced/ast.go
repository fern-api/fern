// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/circular-references-advanced/fern/internal"
)

type Acai struct {
	Animal *Animal `json:"animal,omitempty" url:"animal,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Acai) GetAnimal() *Animal {
	if a == nil {
		return nil
	}
	return a.Animal
}

func (a *Acai) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Acai) UnmarshalJSON(data []byte) error {
	type unmarshaler Acai
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Acai(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Acai) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Animal struct {
	Cat *Cat
	Dog *Dog

	typ string
}

func NewAnimalFromCat(value *Cat) *Animal {
	return &Animal{typ: "Cat", Cat: value}
}

func NewAnimalFromDog(value *Dog) *Animal {
	return &Animal{typ: "Dog", Dog: value}
}

func (a *Animal) GetCat() *Cat {
	if a == nil {
		return nil
	}
	return a.Cat
}

func (a *Animal) GetDog() *Dog {
	if a == nil {
		return nil
	}
	return a.Dog
}

func (a *Animal) UnmarshalJSON(data []byte) error {
	valueCat := new(Cat)
	if err := json.Unmarshal(data, &valueCat); err == nil {
		a.typ = "Cat"
		a.Cat = valueCat
		return nil
	}
	valueDog := new(Dog)
	if err := json.Unmarshal(data, &valueDog); err == nil {
		a.typ = "Dog"
		a.Dog = valueDog
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a Animal) MarshalJSON() ([]byte, error) {
	if a.typ == "Cat" || a.Cat != nil {
		return json.Marshal(a.Cat)
	}
	if a.typ == "Dog" || a.Dog != nil {
		return json.Marshal(a.Dog)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnimalVisitor interface {
	VisitCat(*Cat) error
	VisitDog(*Dog) error
}

func (a *Animal) Accept(visitor AnimalVisitor) error {
	if a.typ == "Cat" || a.Cat != nil {
		return visitor.VisitCat(a.Cat)
	}
	if a.typ == "Dog" || a.Dog != nil {
		return visitor.VisitDog(a.Dog)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type Cat struct {
	Fruit *Fruit `json:"fruit,omitempty" url:"fruit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Cat) GetFruit() *Fruit {
	if c == nil {
		return nil
	}
	return c.Fruit
}

func (c *Cat) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cat) UnmarshalJSON(data []byte) error {
	type unmarshaler Cat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Cat) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContainerValue struct {
	Type     string
	List     []*FieldValue
	Optional *FieldValue
}

func NewContainerValueFromList(value []*FieldValue) *ContainerValue {
	return &ContainerValue{Type: "list", List: value}
}

func NewContainerValueFromOptional(value *FieldValue) *ContainerValue {
	return &ContainerValue{Type: "optional", Optional: value}
}

func (c *ContainerValue) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContainerValue) GetList() []*FieldValue {
	if c == nil {
		return nil
	}
	return c.List
}

func (c *ContainerValue) GetOptional() *FieldValue {
	if c == nil {
		return nil
	}
	return c.Optional
}

func (c *ContainerValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*FieldValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "optional":
		var valueUnmarshaler struct {
			Optional *FieldValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	}
	return nil
}

func (c ContainerValue) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string        `json:"type"`
			List []*FieldValue `json:"value,omitempty"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string      `json:"type"`
			Optional *FieldValue `json:"value,omitempty"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerValueVisitor interface {
	VisitList([]*FieldValue) error
	VisitOptional(*FieldValue) error
}

func (c *ContainerValue) Accept(visitor ContainerValueVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	}
}

func (c *ContainerValue) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.List != nil {
		fields = append(fields, "list")
	}
	if c.Optional != nil {
		fields = append(fields, "optional")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type Dog struct {
	Fruit *Fruit `json:"fruit,omitempty" url:"fruit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Dog) GetFruit() *Fruit {
	if d == nil {
		return nil
	}
	return d.Fruit
}

func (d *Dog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dog) UnmarshalJSON(data []byte) error {
	type unmarshaler Dog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FieldName = string

type FieldValue struct {
	Type           string
	PrimitiveValue PrimitiveValue
	ObjectValue    *ObjectValue
	ContainerValue *ContainerValue
}

func NewFieldValueFromPrimitiveValue(value PrimitiveValue) *FieldValue {
	return &FieldValue{Type: "primitive_value", PrimitiveValue: value}
}

func NewFieldValueFromObjectValue(value *ObjectValue) *FieldValue {
	return &FieldValue{Type: "object_value", ObjectValue: value}
}

func NewFieldValueFromContainerValue(value *ContainerValue) *FieldValue {
	return &FieldValue{Type: "container_value", ContainerValue: value}
}

func (f *FieldValue) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FieldValue) GetPrimitiveValue() PrimitiveValue {
	if f == nil {
		return ""
	}
	return f.PrimitiveValue
}

func (f *FieldValue) GetObjectValue() *ObjectValue {
	if f == nil {
		return nil
	}
	return f.ObjectValue
}

func (f *FieldValue) GetContainerValue() *ContainerValue {
	if f == nil {
		return nil
	}
	return f.ContainerValue
}

func (f *FieldValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "primitive_value":
		var valueUnmarshaler struct {
			PrimitiveValue PrimitiveValue `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.PrimitiveValue = valueUnmarshaler.PrimitiveValue
	case "object_value":
		value := new(ObjectValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.ObjectValue = value
	case "container_value":
		var valueUnmarshaler struct {
			ContainerValue *ContainerValue `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.ContainerValue = valueUnmarshaler.ContainerValue
	}
	return nil
}

func (f FieldValue) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "primitive_value":
		var marshaler = struct {
			Type           string         `json:"type"`
			PrimitiveValue PrimitiveValue `json:"value"`
		}{
			Type:           "primitive_value",
			PrimitiveValue: f.PrimitiveValue,
		}
		return json.Marshal(marshaler)
	case "object_value":
		return internal.MarshalJSONWithExtraProperty(f.ObjectValue, "type", "object_value")
	case "container_value":
		var marshaler = struct {
			Type           string          `json:"type"`
			ContainerValue *ContainerValue `json:"value,omitempty"`
		}{
			Type:           "container_value",
			ContainerValue: f.ContainerValue,
		}
		return json.Marshal(marshaler)
	}
}

type FieldValueVisitor interface {
	VisitPrimitiveValue(PrimitiveValue) error
	VisitObjectValue(*ObjectValue) error
	VisitContainerValue(*ContainerValue) error
}

func (f *FieldValue) Accept(visitor FieldValueVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "primitive_value":
		return visitor.VisitPrimitiveValue(f.PrimitiveValue)
	case "object_value":
		return visitor.VisitObjectValue(f.ObjectValue)
	case "container_value":
		return visitor.VisitContainerValue(f.ContainerValue)
	}
}

func (f *FieldValue) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.PrimitiveValue != "" {
		fields = append(fields, "primitive_value")
	}
	if f.ObjectValue != nil {
		fields = append(fields, "object_value")
	}
	if f.ContainerValue != nil {
		fields = append(fields, "container_value")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type Fig struct {
	Animal *Animal `json:"animal,omitempty" url:"animal,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Fig) GetAnimal() *Animal {
	if f == nil {
		return nil
	}
	return f.Animal
}

func (f *Fig) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fig) UnmarshalJSON(data []byte) error {
	type unmarshaler Fig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fig) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Fruit struct {
	Acai *Acai
	Fig  *Fig

	typ string
}

func NewFruitFromAcai(value *Acai) *Fruit {
	return &Fruit{typ: "Acai", Acai: value}
}

func NewFruitFromFig(value *Fig) *Fruit {
	return &Fruit{typ: "Fig", Fig: value}
}

func (f *Fruit) GetAcai() *Acai {
	if f == nil {
		return nil
	}
	return f.Acai
}

func (f *Fruit) GetFig() *Fig {
	if f == nil {
		return nil
	}
	return f.Fig
}

func (f *Fruit) UnmarshalJSON(data []byte) error {
	valueAcai := new(Acai)
	if err := json.Unmarshal(data, &valueAcai); err == nil {
		f.typ = "Acai"
		f.Acai = valueAcai
		return nil
	}
	valueFig := new(Fig)
	if err := json.Unmarshal(data, &valueFig); err == nil {
		f.typ = "Fig"
		f.Fig = valueFig
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f Fruit) MarshalJSON() ([]byte, error) {
	if f.typ == "Acai" || f.Acai != nil {
		return json.Marshal(f.Acai)
	}
	if f.typ == "Fig" || f.Fig != nil {
		return json.Marshal(f.Fig)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FruitVisitor interface {
	VisitAcai(*Acai) error
	VisitFig(*Fig) error
}

func (f *Fruit) Accept(visitor FruitVisitor) error {
	if f.typ == "Acai" || f.Acai != nil {
		return visitor.VisitAcai(f.Acai)
	}
	if f.typ == "Fig" || f.Fig != nil {
		return visitor.VisitFig(f.Fig)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// This type allows us to test a circular reference with a union type (see FieldValue).
type ObjectFieldValue struct {
	Name  FieldName   `json:"name" url:"name"`
	Value *FieldValue `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectFieldValue) GetName() FieldName {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ObjectFieldValue) GetValue() *FieldValue {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *ObjectFieldValue) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectFieldValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectFieldValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectFieldValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectFieldValue) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectValue struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *ObjectValue) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObjectValue) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveValue string

const (
	PrimitiveValueString PrimitiveValue = "STRING"
	PrimitiveValueNumber PrimitiveValue = "NUMBER"
)

func NewPrimitiveValueFromString(s string) (PrimitiveValue, error) {
	switch s {
	case "STRING":
		return PrimitiveValueString, nil
	case "NUMBER":
		return PrimitiveValueNumber, nil
	}
	var t PrimitiveValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveValue) Ptr() *PrimitiveValue {
	return &p
}

// This file was auto-generated by Fern from our API Definition.

package examples

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/examples-minimal/fern/internal"
)

type BigEntity struct {
	ExtendedMovie *ExtendedMovie `json:"extendedMovie,omitempty" url:"extendedMovie,omitempty"`
	Test          *Test          `json:"test,omitempty" url:"test,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BigEntity) GetExtendedMovie() *ExtendedMovie {
	if b == nil {
		return nil
	}
	return b.ExtendedMovie
}

func (b *BigEntity) GetTest() *Test {
	if b == nil {
		return nil
	}
	return b.Test
}

func (b *BigEntity) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BigEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler BigEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BigEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BigEntity) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ExtendedMovie struct {
	Foo  string   `json:"foo" url:"foo"`
	Bar  int      `json:"bar" url:"bar"`
	Cast []string `json:"cast,omitempty" url:"cast,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExtendedMovie) GetFoo() string {
	if e == nil {
		return ""
	}
	return e.Foo
}

func (e *ExtendedMovie) GetBar() int {
	if e == nil {
		return 0
	}
	return e.Bar
}

func (e *ExtendedMovie) GetCast() []string {
	if e == nil {
		return nil
	}
	return e.Cast
}

func (e *ExtendedMovie) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExtendedMovie) UnmarshalJSON(data []byte) error {
	type unmarshaler ExtendedMovie
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExtendedMovie(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExtendedMovie) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Movie struct {
	Foo string `json:"foo" url:"foo"`
	Bar int    `json:"bar" url:"bar"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Movie) GetFoo() string {
	if m == nil {
		return ""
	}
	return m.Foo
}

func (m *Movie) GetBar() int {
	if m == nil {
		return 0
	}
	return m.Bar
}

func (m *Movie) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Movie) UnmarshalJSON(data []byte) error {
	type unmarshaler Movie
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Movie(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Movie) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Test struct {
	Type string
	U    map[string]string
	V    []string
	And  bool
	Or   bool
}

func NewTestFromAnd(value bool) *Test {
	return &Test{Type: "and", And: value}
}

func NewTestFromOr(value bool) *Test {
	return &Test{Type: "or", Or: value}
}

func (t *Test) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Test) GetU() map[string]string {
	if t == nil {
		return nil
	}
	return t.U
}

func (t *Test) GetV() []string {
	if t == nil {
		return nil
	}
	return t.V
}

func (t *Test) GetAnd() bool {
	if t == nil {
		return false
	}
	return t.And
}

func (t *Test) GetOr() bool {
	if t == nil {
		return false
	}
	return t.Or
}

func (t *Test) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string            `json:"type"`
		U    map[string]string `json:"u,omitempty"`
		V    []string          `json:"v,omitempty"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	t.U = unmarshaler.U
	t.V = unmarshaler.V
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "and":
		var valueUnmarshaler struct {
			And bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.And = valueUnmarshaler.And
	case "or":
		var valueUnmarshaler struct {
			Or bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Or = valueUnmarshaler.Or
	}
	return nil
}

func (t Test) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "and":
		var marshaler = struct {
			Type string            `json:"type"`
			U    map[string]string `json:"u,omitempty"`
			V    []string          `json:"v,omitempty"`
			And  bool              `json:"value"`
		}{
			Type: "and",
			U:    t.U,
			V:    t.V,
			And:  t.And,
		}
		return json.Marshal(marshaler)
	case "or":
		var marshaler = struct {
			Type string            `json:"type"`
			U    map[string]string `json:"u,omitempty"`
			V    []string          `json:"v,omitempty"`
			Or   bool              `json:"value"`
		}{
			Type: "or",
			U:    t.U,
			V:    t.V,
			Or:   t.Or,
		}
		return json.Marshal(marshaler)
	}
}

type TestVisitor interface {
	VisitAnd(bool) error
	VisitOr(bool) error
}

func (t *Test) Accept(visitor TestVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "and":
		return visitor.VisitAnd(t.And)
	case "or":
		return visitor.VisitOr(t.Or)
	}
}

func (t *Test) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.And != false {
		fields = append(fields, "and")
	}
	if t.Or != false {
		fields = append(fields, "or")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/simple-fhir/fern/internal"
	big "math/big"
)

var (
	accountFieldId               = big.NewInt(1 << 0)
	accountFieldRelatedResources = big.NewInt(1 << 1)
	accountFieldMemo             = big.NewInt(1 << 2)
	accountFieldName             = big.NewInt(1 << 3)
	accountFieldPatient          = big.NewInt(1 << 4)
	accountFieldPractitioner     = big.NewInt(1 << 5)
)

type Account struct {
	Id               string          `json:"id" url:"id"`
	RelatedResources []*ResourceList `json:"related_resources" url:"related_resources"`
	Memo             *Memo           `json:"memo" url:"memo"`
	Name             string          `json:"name" url:"name"`
	Patient          *Patient        `json:"patient,omitempty" url:"patient,omitempty"`
	Practitioner     *Practitioner   `json:"practitioner,omitempty" url:"practitioner,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	resourceType   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Account) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *Account) GetRelatedResources() []*ResourceList {
	if a == nil {
		return nil
	}
	return a.RelatedResources
}

func (a *Account) GetMemo() *Memo {
	if a == nil {
		return nil
	}
	return a.Memo
}

func (a *Account) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *Account) GetPatient() *Patient {
	if a == nil {
		return nil
	}
	return a.Patient
}

func (a *Account) GetPractitioner() *Practitioner {
	if a == nil {
		return nil
	}
	return a.Practitioner
}

func (a *Account) ResourceType() string {
	return a.resourceType
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetId(id string) {
	a.Id = id
	a.require(accountFieldId)
}

// SetRelatedResources sets the RelatedResources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetRelatedResources(relatedResources []*ResourceList) {
	a.RelatedResources = relatedResources
	a.require(accountFieldRelatedResources)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetMemo(memo *Memo) {
	a.Memo = memo
	a.require(accountFieldMemo)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetName(name string) {
	a.Name = name
	a.require(accountFieldName)
}

// SetPatient sets the Patient field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetPatient(patient *Patient) {
	a.Patient = patient
	a.require(accountFieldPatient)
}

// SetPractitioner sets the Practitioner field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Account) SetPractitioner(practitioner *Practitioner) {
	a.Practitioner = practitioner
	a.require(accountFieldPractitioner)
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	if unmarshaler.ResourceType != "Account" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "Account", unmarshaler.ResourceType)
	}
	a.resourceType = unmarshaler.ResourceType
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "resource_type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed:        embed(*a),
		ResourceType: "Account",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Account) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	baseResourceFieldId               = big.NewInt(1 << 0)
	baseResourceFieldRelatedResources = big.NewInt(1 << 1)
	baseResourceFieldMemo             = big.NewInt(1 << 2)
)

type BaseResource struct {
	Id               string          `json:"id" url:"id"`
	RelatedResources []*ResourceList `json:"related_resources" url:"related_resources"`
	Memo             *Memo           `json:"memo" url:"memo"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseResource) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BaseResource) GetRelatedResources() []*ResourceList {
	if b == nil {
		return nil
	}
	return b.RelatedResources
}

func (b *BaseResource) GetMemo() *Memo {
	if b == nil {
		return nil
	}
	return b.Memo
}

func (b *BaseResource) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseResource) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseResource) SetId(id string) {
	b.Id = id
	b.require(baseResourceFieldId)
}

// SetRelatedResources sets the RelatedResources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseResource) SetRelatedResources(relatedResources []*ResourceList) {
	b.RelatedResources = relatedResources
	b.require(baseResourceFieldRelatedResources)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseResource) SetMemo(memo *Memo) {
	b.Memo = memo
	b.require(baseResourceFieldMemo)
}

func (b *BaseResource) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseResource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseResource) MarshalJSON() ([]byte, error) {
	type embed BaseResource
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseResource) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	memoFieldDescription = big.NewInt(1 << 0)
	memoFieldAccount     = big.NewInt(1 << 1)
)

type Memo struct {
	Description string   `json:"description" url:"description"`
	Account     *Account `json:"account,omitempty" url:"account,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Memo) GetDescription() string {
	if m == nil {
		return ""
	}
	return m.Description
}

func (m *Memo) GetAccount() *Account {
	if m == nil {
		return nil
	}
	return m.Account
}

func (m *Memo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Memo) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Memo) SetDescription(description string) {
	m.Description = description
	m.require(memoFieldDescription)
}

// SetAccount sets the Account field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Memo) SetAccount(account *Account) {
	m.Account = account
	m.require(memoFieldAccount)
}

func (m *Memo) UnmarshalJSON(data []byte) error {
	type unmarshaler Memo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Memo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Memo) MarshalJSON() ([]byte, error) {
	type embed Memo
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Memo) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	patientFieldId               = big.NewInt(1 << 0)
	patientFieldRelatedResources = big.NewInt(1 << 1)
	patientFieldMemo             = big.NewInt(1 << 2)
	patientFieldName             = big.NewInt(1 << 3)
	patientFieldScripts          = big.NewInt(1 << 4)
)

type Patient struct {
	Id               string          `json:"id" url:"id"`
	RelatedResources []*ResourceList `json:"related_resources" url:"related_resources"`
	Memo             *Memo           `json:"memo" url:"memo"`
	Name             string          `json:"name" url:"name"`
	Scripts          []*Script       `json:"scripts" url:"scripts"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	resourceType   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Patient) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *Patient) GetRelatedResources() []*ResourceList {
	if p == nil {
		return nil
	}
	return p.RelatedResources
}

func (p *Patient) GetMemo() *Memo {
	if p == nil {
		return nil
	}
	return p.Memo
}

func (p *Patient) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *Patient) GetScripts() []*Script {
	if p == nil {
		return nil
	}
	return p.Scripts
}

func (p *Patient) ResourceType() string {
	return p.resourceType
}

func (p *Patient) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Patient) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Patient) SetId(id string) {
	p.Id = id
	p.require(patientFieldId)
}

// SetRelatedResources sets the RelatedResources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Patient) SetRelatedResources(relatedResources []*ResourceList) {
	p.RelatedResources = relatedResources
	p.require(patientFieldRelatedResources)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Patient) SetMemo(memo *Memo) {
	p.Memo = memo
	p.require(patientFieldMemo)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Patient) SetName(name string) {
	p.Name = name
	p.require(patientFieldName)
}

// SetScripts sets the Scripts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Patient) SetScripts(scripts []*Script) {
	p.Scripts = scripts
	p.require(patientFieldScripts)
}

func (p *Patient) UnmarshalJSON(data []byte) error {
	type embed Patient
	var unmarshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Patient(unmarshaler.embed)
	if unmarshaler.ResourceType != "Patient" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "Patient", unmarshaler.ResourceType)
	}
	p.resourceType = unmarshaler.ResourceType
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "resource_type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Patient) MarshalJSON() ([]byte, error) {
	type embed Patient
	var marshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed:        embed(*p),
		ResourceType: "Patient",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Patient) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	practitionerFieldId               = big.NewInt(1 << 0)
	practitionerFieldRelatedResources = big.NewInt(1 << 1)
	practitionerFieldMemo             = big.NewInt(1 << 2)
	practitionerFieldName             = big.NewInt(1 << 3)
)

type Practitioner struct {
	Id               string          `json:"id" url:"id"`
	RelatedResources []*ResourceList `json:"related_resources" url:"related_resources"`
	Memo             *Memo           `json:"memo" url:"memo"`
	Name             string          `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	resourceType   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Practitioner) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *Practitioner) GetRelatedResources() []*ResourceList {
	if p == nil {
		return nil
	}
	return p.RelatedResources
}

func (p *Practitioner) GetMemo() *Memo {
	if p == nil {
		return nil
	}
	return p.Memo
}

func (p *Practitioner) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *Practitioner) ResourceType() string {
	return p.resourceType
}

func (p *Practitioner) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Practitioner) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Practitioner) SetId(id string) {
	p.Id = id
	p.require(practitionerFieldId)
}

// SetRelatedResources sets the RelatedResources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Practitioner) SetRelatedResources(relatedResources []*ResourceList) {
	p.RelatedResources = relatedResources
	p.require(practitionerFieldRelatedResources)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Practitioner) SetMemo(memo *Memo) {
	p.Memo = memo
	p.require(practitionerFieldMemo)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Practitioner) SetName(name string) {
	p.Name = name
	p.require(practitionerFieldName)
}

func (p *Practitioner) UnmarshalJSON(data []byte) error {
	type embed Practitioner
	var unmarshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Practitioner(unmarshaler.embed)
	if unmarshaler.ResourceType != "Practitioner" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "Practitioner", unmarshaler.ResourceType)
	}
	p.resourceType = unmarshaler.ResourceType
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "resource_type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Practitioner) MarshalJSON() ([]byte, error) {
	type embed Practitioner
	var marshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed:        embed(*p),
		ResourceType: "Practitioner",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Practitioner) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceList struct {
	Account      *Account
	Patient      *Patient
	Practitioner *Practitioner
	Script       *Script

	typ string
}

func (r *ResourceList) GetAccount() *Account {
	if r == nil {
		return nil
	}
	return r.Account
}

func (r *ResourceList) GetPatient() *Patient {
	if r == nil {
		return nil
	}
	return r.Patient
}

func (r *ResourceList) GetPractitioner() *Practitioner {
	if r == nil {
		return nil
	}
	return r.Practitioner
}

func (r *ResourceList) GetScript() *Script {
	if r == nil {
		return nil
	}
	return r.Script
}

func (r *ResourceList) UnmarshalJSON(data []byte) error {
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		r.typ = "Account"
		r.Account = valueAccount
		return nil
	}
	valuePatient := new(Patient)
	if err := json.Unmarshal(data, &valuePatient); err == nil {
		r.typ = "Patient"
		r.Patient = valuePatient
		return nil
	}
	valuePractitioner := new(Practitioner)
	if err := json.Unmarshal(data, &valuePractitioner); err == nil {
		r.typ = "Practitioner"
		r.Practitioner = valuePractitioner
		return nil
	}
	valueScript := new(Script)
	if err := json.Unmarshal(data, &valueScript); err == nil {
		r.typ = "Script"
		r.Script = valueScript
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r ResourceList) MarshalJSON() ([]byte, error) {
	if r.typ == "Account" || r.Account != nil {
		return json.Marshal(r.Account)
	}
	if r.typ == "Patient" || r.Patient != nil {
		return json.Marshal(r.Patient)
	}
	if r.typ == "Practitioner" || r.Practitioner != nil {
		return json.Marshal(r.Practitioner)
	}
	if r.typ == "Script" || r.Script != nil {
		return json.Marshal(r.Script)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResourceListVisitor interface {
	VisitAccount(*Account) error
	VisitPatient(*Patient) error
	VisitPractitioner(*Practitioner) error
	VisitScript(*Script) error
}

func (r *ResourceList) Accept(visitor ResourceListVisitor) error {
	if r.typ == "Account" || r.Account != nil {
		return visitor.VisitAccount(r.Account)
	}
	if r.typ == "Patient" || r.Patient != nil {
		return visitor.VisitPatient(r.Patient)
	}
	if r.typ == "Practitioner" || r.Practitioner != nil {
		return visitor.VisitPractitioner(r.Practitioner)
	}
	if r.typ == "Script" || r.Script != nil {
		return visitor.VisitScript(r.Script)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

var (
	scriptFieldId               = big.NewInt(1 << 0)
	scriptFieldRelatedResources = big.NewInt(1 << 1)
	scriptFieldMemo             = big.NewInt(1 << 2)
	scriptFieldName             = big.NewInt(1 << 3)
)

type Script struct {
	Id               string          `json:"id" url:"id"`
	RelatedResources []*ResourceList `json:"related_resources" url:"related_resources"`
	Memo             *Memo           `json:"memo" url:"memo"`
	Name             string          `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	resourceType   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Script) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *Script) GetRelatedResources() []*ResourceList {
	if s == nil {
		return nil
	}
	return s.RelatedResources
}

func (s *Script) GetMemo() *Memo {
	if s == nil {
		return nil
	}
	return s.Memo
}

func (s *Script) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *Script) ResourceType() string {
	return s.resourceType
}

func (s *Script) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Script) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Script) SetId(id string) {
	s.Id = id
	s.require(scriptFieldId)
}

// SetRelatedResources sets the RelatedResources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Script) SetRelatedResources(relatedResources []*ResourceList) {
	s.RelatedResources = relatedResources
	s.require(scriptFieldRelatedResources)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Script) SetMemo(memo *Memo) {
	s.Memo = memo
	s.require(scriptFieldMemo)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Script) SetName(name string) {
	s.Name = name
	s.require(scriptFieldName)
}

func (s *Script) UnmarshalJSON(data []byte) error {
	type embed Script
	var unmarshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Script(unmarshaler.embed)
	if unmarshaler.ResourceType != "Script" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "Script", unmarshaler.ResourceType)
	}
	s.resourceType = unmarshaler.ResourceType
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "resource_type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Script) MarshalJSON() ([]byte, error) {
	type embed Script
	var marshaler = struct {
		embed
		ResourceType string `json:"resource_type"`
	}{
		embed:        embed(*s),
		ResourceType: "Script",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Script) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

# This file was auto-generated by Fern from our API Definition.

import asyncio
import datetime as dt
import threading
import typing
from asyncio import Lock as asyncio_Lock
from threading import Lock as threading_Lock

from ..auth.client import AsyncAuthClient, AuthClient
from .client_wrapper import AsyncClientWrapper, SyncClientWrapper


class InferredAuthTokenProvider:
    BUFFER_IN_MINUTES = 2

    def __init__(self, *, api_key: str, client_wrapper: SyncClientWrapper):
        self._api_key = api_key
        self._cached_headers: typing.Optional[typing.Dict[str, str]] = None
        self._expires_at: dt.datetime = dt.datetime.now()
        self._auth_client = AuthClient(client_wrapper=client_wrapper)
        self._lock: threading_Lock = threading.Lock()

    def get_headers(self) -> typing.Dict[str, str]:
        if self._cached_headers and self._expires_at > dt.datetime.now():
            return self._cached_headers
        with self._lock:
            if self._cached_headers and self._expires_at > dt.datetime.now():
                return self._cached_headers
            return self._fetch_token()

    def _fetch_token(self) -> typing.Dict[str, str]:
        token_response = self._auth_client.get_token(api_key=self._api_key)
        headers: typing.Dict[str, str] = {}
        headers["Authorization"] = f"Bearer {token_response.access_token}"
        self._cached_headers = headers
        self._expires_at = self._get_expires_at(
            expires_in_seconds=token_response.expires_in, buffer_in_minutes=self.BUFFER_IN_MINUTES
        )
        return headers

    def _get_expires_at(self, *, expires_in_seconds: int, buffer_in_minutes: int):
        return dt.datetime.now() + dt.timedelta(seconds=expires_in_seconds) - dt.timedelta(minutes=buffer_in_minutes)


class AsyncInferredAuthTokenProvider:
    BUFFER_IN_MINUTES = 2

    def __init__(self, *, api_key: str, client_wrapper: AsyncClientWrapper):
        self._api_key = api_key
        self._cached_headers: typing.Optional[typing.Dict[str, str]] = None
        self._expires_at: dt.datetime = dt.datetime.now()
        self._auth_client = AsyncAuthClient(client_wrapper=client_wrapper)
        self._lock: asyncio_Lock = asyncio.Lock()

    async def get_headers(self) -> typing.Dict[str, str]:
        if self._cached_headers and self._expires_at > dt.datetime.now():
            return self._cached_headers
        async with self._lock:
            if self._cached_headers and self._expires_at > dt.datetime.now():
                return self._cached_headers
            return await self._fetch_token()

    async def _fetch_token(self) -> typing.Dict[str, str]:
        token_response = await self._auth_client.get_token(api_key=self._api_key)
        headers: typing.Dict[str, str] = {}
        headers["Authorization"] = f"Bearer {token_response.access_token}"
        self._cached_headers = headers
        self._expires_at = self._get_expires_at(
            expires_in_seconds=token_response.expires_in, buffer_in_minutes=self.BUFFER_IN_MINUTES
        )
        return headers

    def _get_expires_at(self, *, expires_in_seconds: int, buffer_in_minutes: int):
        return dt.datetime.now() + dt.timedelta(seconds=expires_in_seconds) - dt.timedelta(minutes=buffer_in_minutes)

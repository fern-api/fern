# This file was auto-generated by Fern from our API Definition.

import asyncio
import threading
import typing
from asyncio import Lock as asyncio_Lock
from threading import Lock as threading_Lock

from ..auth.client import AsyncAuthClient, AuthClient
from .client_wrapper import AsyncClientWrapper, SyncClientWrapper


class InferredAuthTokenProvider:
    BUFFER_IN_MINUTES = 2

    def __init__(
        self,
        *,
        x_api_key: str,
        client_id: str,
        client_secret: str,
        scope: typing.Optional[str] = None,
        client_wrapper: SyncClientWrapper,
    ):
        self._x_api_key = x_api_key
        self._client_id = client_id
        self._client_secret = client_secret
        self._scope = scope
        self._cached_headers: typing.Optional[typing.Dict[str, str]] = None
        self._auth_client = AuthClient(client_wrapper=client_wrapper)
        self._lock: threading_Lock = threading.Lock()

    def get_headers(self) -> typing.Dict[str, str]:
        if self._cached_headers:
            return self._cached_headers
        with self._lock:
            if self._cached_headers:
                return self._cached_headers
            return self._fetch_token()

    def _fetch_token(self) -> typing.Dict[str, str]:
        token_response = self._auth_client.get_token_with_client_credentials(
            x_api_key=self._x_api_key, client_id=self._client_id, client_secret=self._client_secret, scope=self._scope
        )
        headers: typing.Dict[str, str] = {}
        headers["Authorization"] = f"Bearer {token_response.access_token}"
        self._cached_headers = headers
        return headers


class AsyncInferredAuthTokenProvider:
    BUFFER_IN_MINUTES = 2

    def __init__(
        self,
        *,
        x_api_key: str,
        client_id: str,
        client_secret: str,
        scope: typing.Optional[str] = None,
        client_wrapper: AsyncClientWrapper,
    ):
        self._x_api_key = x_api_key
        self._client_id = client_id
        self._client_secret = client_secret
        self._scope = scope
        self._cached_headers: typing.Optional[typing.Dict[str, str]] = None
        self._auth_client = AsyncAuthClient(client_wrapper=client_wrapper)
        self._lock: asyncio_Lock = asyncio.Lock()

    async def get_headers(self) -> typing.Dict[str, str]:
        if self._cached_headers:
            return self._cached_headers
        async with self._lock:
            if self._cached_headers:
                return self._cached_headers
            return await self._fetch_token()

    async def _fetch_token(self) -> typing.Dict[str, str]:
        token_response = await self._auth_client.get_token_with_client_credentials(
            x_api_key=self._x_api_key, client_id=self._client_id, client_secret=self._client_secret, scope=self._scope
        )
        headers: typing.Dict[str, str] = {}
        headers["Authorization"] = f"Bearer {token_response.access_token}"
        self._cached_headers = headers
        return headers

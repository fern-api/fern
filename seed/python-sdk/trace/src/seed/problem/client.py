# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.problem_description import ProblemDescription
from ..commons.types.language import Language
from .types.problem_files import ProblemFiles
from .types.variable_type_and_name import VariableTypeAndName
from ..commons.types.variable_type import VariableType
from ..commons.types.test_case_with_expected_result import TestCaseWithExpectedResult
from ..core.request_options import RequestOptions
from .types.create_problem_response import CreateProblemResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.pydantic_utilities import parse_obj_as
from ..commons.types.problem_id import ProblemId
from .types.update_problem_response import UpdateProblemResponse
from ..core.jsonable_encoder import jsonable_encoder
from .types.get_default_starter_files_response import GetDefaultStarterFilesResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProblemClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_problem(
        self,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateProblemResponse:
        """
        Creates a problem

        Parameters
        ----------
        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateProblemResponse

        Examples
        --------
        from seed import SeedTrace
        from seed.commons import (
            FileInfo,
            TestCase,
            TestCaseWithExpectedResult,
            VariableType,
            VariableValue_IntegerValue,
        )
        from seed.problem import (
            ProblemDescription,
            ProblemDescriptionBoard_Html,
            ProblemFiles,
            VariableTypeAndName,
        )

        client = SeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )
        client.problem.create_problem(
            problem_name="problemName",
            problem_description=ProblemDescription(
                boards=[
                    ProblemDescriptionBoard_Html(value="boards"),
                    ProblemDescriptionBoard_Html(value="boards"),
                ],
            ),
            files={
                "JAVA": ProblemFiles(
                    solution_file=FileInfo(
                        filename="filename",
                        contents="contents",
                    ),
                    read_only_files=[
                        FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                        FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                    ],
                )
            },
            input_params=[
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
            ],
            output_type=VariableType(),
            testcases=[
                TestCaseWithExpectedResult(
                    test_case=TestCase(
                        id="id",
                        params=[
                            VariableValue_IntegerValue(value=1),
                            VariableValue_IntegerValue(value=1),
                        ],
                    ),
                    expected_result=VariableValue_IntegerValue(value=1),
                ),
                TestCaseWithExpectedResult(
                    test_case=TestCase(
                        id="id",
                        params=[
                            VariableValue_IntegerValue(value=1),
                            VariableValue_IntegerValue(value=1),
                        ],
                    ),
                    expected_result=VariableValue_IntegerValue(value=1),
                ),
            ],
            method_name="methodName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "problem-crud/create",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description,
                    annotation=ProblemDescription,
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Dict[Language, ProblemFiles],
                    direction="write",
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases,
                    annotation=typing.Sequence[TestCaseWithExpectedResult],
                    direction="write",
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CreateProblemResponse,
                parse_obj_as(
                    type_=CreateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_problem(
        self,
        problem_id: ProblemId,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateProblemResponse:
        """
        Updates a problem

        Parameters
        ----------
        problem_id : ProblemId

        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateProblemResponse

        Examples
        --------
        from seed import SeedTrace
        from seed.commons import (
            FileInfo,
            TestCase,
            TestCaseWithExpectedResult,
            VariableType,
            VariableValue_IntegerValue,
        )
        from seed.problem import (
            ProblemDescription,
            ProblemDescriptionBoard_Html,
            ProblemFiles,
            VariableTypeAndName,
        )

        client = SeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )
        client.problem.update_problem(
            problem_id="problemId",
            problem_name="problemName",
            problem_description=ProblemDescription(
                boards=[
                    ProblemDescriptionBoard_Html(value="boards"),
                    ProblemDescriptionBoard_Html(value="boards"),
                ],
            ),
            files={
                "JAVA": ProblemFiles(
                    solution_file=FileInfo(
                        filename="filename",
                        contents="contents",
                    ),
                    read_only_files=[
                        FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                        FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                    ],
                )
            },
            input_params=[
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
            ],
            output_type=VariableType(),
            testcases=[
                TestCaseWithExpectedResult(
                    test_case=TestCase(
                        id="id",
                        params=[
                            VariableValue_IntegerValue(value=1),
                            VariableValue_IntegerValue(value=1),
                        ],
                    ),
                    expected_result=VariableValue_IntegerValue(value=1),
                ),
                TestCaseWithExpectedResult(
                    test_case=TestCase(
                        id="id",
                        params=[
                            VariableValue_IntegerValue(value=1),
                            VariableValue_IntegerValue(value=1),
                        ],
                    ),
                    expected_result=VariableValue_IntegerValue(value=1),
                ),
            ],
            method_name="methodName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"problem-crud/update/{jsonable_encoder(problem_id)}",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description,
                    annotation=ProblemDescription,
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Dict[Language, ProblemFiles],
                    direction="write",
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases,
                    annotation=typing.Sequence[TestCaseWithExpectedResult],
                    direction="write",
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                UpdateProblemResponse,
                parse_obj_as(
                    type_=UpdateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_problem(
        self,
        problem_id: ProblemId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Soft deletes a problem

        Parameters
        ----------
        problem_id : ProblemId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from seed import SeedTrace

        client = SeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )
        client.problem.delete_problem(
            problem_id="problemId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"problem-crud/delete/{jsonable_encoder(problem_id)}",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_default_starter_files(
        self,
        *,
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetDefaultStarterFilesResponse:
        """
        Returns default starter files for problem

        Parameters
        ----------
        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        method_name : str
            The name of the `method` that the student has to complete.
            The method name cannot include the following characters:
              - Greater Than `>`
              - Less Than `<``
              - Equals `=`
              - Period `.`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetDefaultStarterFilesResponse

        Examples
        --------
        from seed import SeedTrace
        from seed.commons import VariableType
        from seed.problem import VariableTypeAndName

        client = SeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )
        client.problem.get_default_starter_files(
            input_params=[
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
                VariableTypeAndName(
                    variable_type=VariableType(),
                    name="name",
                ),
            ],
            output_type=VariableType(),
            method_name="methodName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "problem-crud/default-starter-files",
            method="POST",
            json={
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                GetDefaultStarterFilesResponse,
                parse_obj_as(
                    type_=GetDefaultStarterFilesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProblemClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_problem(
        self,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateProblemResponse:
        """
        Creates a problem

        Parameters
        ----------
        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateProblemResponse

        Examples
        --------
        import asyncio

        from seed import AsyncSeedTrace
        from seed.commons import (
            FileInfo,
            TestCase,
            TestCaseWithExpectedResult,
            VariableType,
            VariableValue_IntegerValue,
        )
        from seed.problem import (
            ProblemDescription,
            ProblemDescriptionBoard_Html,
            ProblemFiles,
            VariableTypeAndName,
        )

        client = AsyncSeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.problem.create_problem(
                problem_name="problemName",
                problem_description=ProblemDescription(
                    boards=[
                        ProblemDescriptionBoard_Html(value="boards"),
                        ProblemDescriptionBoard_Html(value="boards"),
                    ],
                ),
                files={
                    "JAVA": ProblemFiles(
                        solution_file=FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                        read_only_files=[
                            FileInfo(
                                filename="filename",
                                contents="contents",
                            ),
                            FileInfo(
                                filename="filename",
                                contents="contents",
                            ),
                        ],
                    )
                },
                input_params=[
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                ],
                output_type=VariableType(),
                testcases=[
                    TestCaseWithExpectedResult(
                        test_case=TestCase(
                            id="id",
                            params=[
                                VariableValue_IntegerValue(value=1),
                                VariableValue_IntegerValue(value=1),
                            ],
                        ),
                        expected_result=VariableValue_IntegerValue(value=1),
                    ),
                    TestCaseWithExpectedResult(
                        test_case=TestCase(
                            id="id",
                            params=[
                                VariableValue_IntegerValue(value=1),
                                VariableValue_IntegerValue(value=1),
                            ],
                        ),
                        expected_result=VariableValue_IntegerValue(value=1),
                    ),
                ],
                method_name="methodName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "problem-crud/create",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description,
                    annotation=ProblemDescription,
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Dict[Language, ProblemFiles],
                    direction="write",
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases,
                    annotation=typing.Sequence[TestCaseWithExpectedResult],
                    direction="write",
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                CreateProblemResponse,
                parse_obj_as(
                    type_=CreateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_problem(
        self,
        problem_id: ProblemId,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateProblemResponse:
        """
        Updates a problem

        Parameters
        ----------
        problem_id : ProblemId

        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateProblemResponse

        Examples
        --------
        import asyncio

        from seed import AsyncSeedTrace
        from seed.commons import (
            FileInfo,
            TestCase,
            TestCaseWithExpectedResult,
            VariableType,
            VariableValue_IntegerValue,
        )
        from seed.problem import (
            ProblemDescription,
            ProblemDescriptionBoard_Html,
            ProblemFiles,
            VariableTypeAndName,
        )

        client = AsyncSeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.problem.update_problem(
                problem_id="problemId",
                problem_name="problemName",
                problem_description=ProblemDescription(
                    boards=[
                        ProblemDescriptionBoard_Html(value="boards"),
                        ProblemDescriptionBoard_Html(value="boards"),
                    ],
                ),
                files={
                    "JAVA": ProblemFiles(
                        solution_file=FileInfo(
                            filename="filename",
                            contents="contents",
                        ),
                        read_only_files=[
                            FileInfo(
                                filename="filename",
                                contents="contents",
                            ),
                            FileInfo(
                                filename="filename",
                                contents="contents",
                            ),
                        ],
                    )
                },
                input_params=[
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                ],
                output_type=VariableType(),
                testcases=[
                    TestCaseWithExpectedResult(
                        test_case=TestCase(
                            id="id",
                            params=[
                                VariableValue_IntegerValue(value=1),
                                VariableValue_IntegerValue(value=1),
                            ],
                        ),
                        expected_result=VariableValue_IntegerValue(value=1),
                    ),
                    TestCaseWithExpectedResult(
                        test_case=TestCase(
                            id="id",
                            params=[
                                VariableValue_IntegerValue(value=1),
                                VariableValue_IntegerValue(value=1),
                            ],
                        ),
                        expected_result=VariableValue_IntegerValue(value=1),
                    ),
                ],
                method_name="methodName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"problem-crud/update/{jsonable_encoder(problem_id)}",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description,
                    annotation=ProblemDescription,
                    direction="write",
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Dict[Language, ProblemFiles],
                    direction="write",
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases,
                    annotation=typing.Sequence[TestCaseWithExpectedResult],
                    direction="write",
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                UpdateProblemResponse,
                parse_obj_as(
                    type_=UpdateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_problem(
        self,
        problem_id: ProblemId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Soft deletes a problem

        Parameters
        ----------
        problem_id : ProblemId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from seed import AsyncSeedTrace

        client = AsyncSeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.problem.delete_problem(
                problem_id="problemId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"problem-crud/delete/{jsonable_encoder(problem_id)}",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_default_starter_files(
        self,
        *,
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetDefaultStarterFilesResponse:
        """
        Returns default starter files for problem

        Parameters
        ----------
        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        method_name : str
            The name of the `method` that the student has to complete.
            The method name cannot include the following characters:
              - Greater Than `>`
              - Less Than `<``
              - Equals `=`
              - Period `.`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetDefaultStarterFilesResponse

        Examples
        --------
        import asyncio

        from seed import AsyncSeedTrace
        from seed.commons import VariableType
        from seed.problem import VariableTypeAndName

        client = AsyncSeedTrace(
            x_random_header="YOUR_X_RANDOM_HEADER",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.problem.get_default_starter_files(
                input_params=[
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                    VariableTypeAndName(
                        variable_type=VariableType(),
                        name="name",
                    ),
                ],
                output_type=VariableType(),
                method_name="methodName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "problem-crud/default-starter-files",
            method="POST",
            json={
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params,
                    annotation=typing.Sequence[VariableTypeAndName],
                    direction="write",
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return typing.cast(
                GetDefaultStarterFilesResponse,
                parse_obj_as(
                    type_=GetDefaultStarterFilesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
        raise ApiError(status_code=_response.status_code, body=_response_json)

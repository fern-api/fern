# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.problem_description import ProblemDescription
from ..commons.types.language import Language
from .types.problem_files import ProblemFiles
from .types.variable_type_and_name import VariableTypeAndName
from ..commons.types.variable_type import VariableType
from ..commons.types.test_case_with_expected_result import TestCaseWithExpectedResult
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponse
from .types.create_problem_response import CreateProblemResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.pydantic_utilities import parse_obj_as
from ..commons.types.problem_id import ProblemId
from .types.update_problem_response import UpdateProblemResponse
from ..core.jsonable_encoder import jsonable_encoder
from .types.get_default_starter_files_response import GetDefaultStarterFilesResponse
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawProblemClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_problem(
        self,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateProblemResponse]:
        """
        Creates a problem

        Parameters
        ----------
        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateProblemResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            "problem-crud/create",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description, annotation=ProblemDescription, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Dict[Language, ProblemFiles], direction="write"
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases, annotation=typing.Sequence[TestCaseWithExpectedResult], direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                CreateProblemResponse,
                parse_obj_as(
                    type_=CreateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_problem(
        self,
        problem_id: ProblemId,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateProblemResponse]:
        """
        Updates a problem

        Parameters
        ----------
        problem_id : ProblemId

        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateProblemResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"problem-crud/update/{jsonable_encoder(problem_id)}",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description, annotation=ProblemDescription, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Dict[Language, ProblemFiles], direction="write"
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases, annotation=typing.Sequence[TestCaseWithExpectedResult], direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                UpdateProblemResponse,
                parse_obj_as(
                    type_=UpdateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_problem(
        self, problem_id: ProblemId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Soft deletes a problem

        Parameters
        ----------
        problem_id : ProblemId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"problem-crud/delete/{jsonable_encoder(problem_id)}",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return HttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_default_starter_files(
        self,
        *,
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetDefaultStarterFilesResponse]:
        """
        Returns default starter files for problem

        Parameters
        ----------
        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        method_name : str
            The name of the `method` that the student has to complete.
            The method name cannot include the following characters:
              - Greater Than `>`
              - Less Than `<``
              - Equals `=`
              - Period `.`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetDefaultStarterFilesResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            "problem-crud/default-starter-files",
            method="POST",
            json={
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                GetDefaultStarterFilesResponse,
                parse_obj_as(
                    type_=GetDefaultStarterFilesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawProblemClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_problem(
        self,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateProblemResponse]:
        """
        Creates a problem

        Parameters
        ----------
        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateProblemResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "problem-crud/create",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description, annotation=ProblemDescription, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Dict[Language, ProblemFiles], direction="write"
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases, annotation=typing.Sequence[TestCaseWithExpectedResult], direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                CreateProblemResponse,
                parse_obj_as(
                    type_=CreateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_problem(
        self,
        problem_id: ProblemId,
        *,
        problem_name: str,
        problem_description: ProblemDescription,
        files: typing.Dict[Language, ProblemFiles],
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        testcases: typing.Sequence[TestCaseWithExpectedResult],
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateProblemResponse]:
        """
        Updates a problem

        Parameters
        ----------
        problem_id : ProblemId

        problem_name : str

        problem_description : ProblemDescription

        files : typing.Dict[Language, ProblemFiles]

        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        testcases : typing.Sequence[TestCaseWithExpectedResult]

        method_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateProblemResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"problem-crud/update/{jsonable_encoder(problem_id)}",
            method="POST",
            json={
                "problemName": problem_name,
                "problemDescription": convert_and_respect_annotation_metadata(
                    object_=problem_description, annotation=ProblemDescription, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Dict[Language, ProblemFiles], direction="write"
                ),
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "testcases": convert_and_respect_annotation_metadata(
                    object_=testcases, annotation=typing.Sequence[TestCaseWithExpectedResult], direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                UpdateProblemResponse,
                parse_obj_as(
                    type_=UpdateProblemResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_problem(
        self, problem_id: ProblemId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Soft deletes a problem

        Parameters
        ----------
        problem_id : ProblemId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"problem-crud/delete/{jsonable_encoder(problem_id)}",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return AsyncHttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_default_starter_files(
        self,
        *,
        input_params: typing.Sequence[VariableTypeAndName],
        output_type: VariableType,
        method_name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetDefaultStarterFilesResponse]:
        """
        Returns default starter files for problem

        Parameters
        ----------
        input_params : typing.Sequence[VariableTypeAndName]

        output_type : VariableType

        method_name : str
            The name of the `method` that the student has to complete.
            The method name cannot include the following characters:
              - Greater Than `>`
              - Less Than `<``
              - Equals `=`
              - Period `.`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetDefaultStarterFilesResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "problem-crud/default-starter-files",
            method="POST",
            json={
                "inputParams": convert_and_respect_annotation_metadata(
                    object_=input_params, annotation=typing.Sequence[VariableTypeAndName], direction="write"
                ),
                "outputType": convert_and_respect_annotation_metadata(
                    object_=output_type, annotation=VariableType, direction="write"
                ),
                "methodName": method_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            data = typing.cast(
                GetDefaultStarterFilesResponse,
                parse_obj_as(
                    type_=GetDefaultStarterFilesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=data)
        raise ApiError(status_code=_response.status_code, body=_response_json)

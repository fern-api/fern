# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..commons.types.types.data import Data
from ..commons.types.types.event_info import EventInfo
from ..commons.types.types.metadata import Metadata as commons_types_types_metadata_Metadata
from ..commons.types.types.tag import Tag
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.types.cast_member import CastMember
from ..types.types.directory import Directory
from ..types.types.entity import Entity
from ..types.types.exception import Exception
from ..types.types.extended_movie import ExtendedMovie
from ..types.types.metadata import Metadata as types_types_metadata_Metadata
from ..types.types.migration import Migration
from ..types.types.moment import Moment
from ..types.types.movie import Movie
from ..types.types.movie_id import MovieId
from ..types.types.node import Node
from ..types.types.response import Response
from ..types.types.test import Test

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawServiceClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_movie(
        self, movie_id: MovieId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Movie]:
        """
        Parameters
        ----------
        movie_id : MovieId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Movie]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"movie/{jsonable_encoder(movie_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Movie,
                    parse_obj_as(
                        type_=Movie,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_movie(
        self,
        *,
        id: MovieId,
        title: str,
        from_: str,
        rating: float,
        tag: Tag,
        metadata: typing.Dict[str, typing.Optional[typing.Any]],
        revenue: int,
        prequel: typing.Optional[MovieId] = OMIT,
        book: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[MovieId]:
        """
        Parameters
        ----------
        id : MovieId

        title : str

        from_ : str

        rating : float
            The rating scale is one to five stars

        tag : Tag

        metadata : typing.Dict[str, typing.Optional[typing.Any]]

        revenue : int

        prequel : typing.Optional[MovieId]

        book : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MovieId]
        """
        _response = self._client_wrapper.httpx_client.request(
            "movie",
            method="POST",
            json={
                "id": id,
                "prequel": prequel,
                "title": title,
                "from": from_,
                "rating": rating,
                "tag": tag,
                "book": book,
                "metadata": metadata,
                "revenue": revenue,
                "type": "movie",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MovieId,
                    parse_obj_as(
                        type_=MovieId,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_metadata(
        self,
        *,
        x_api_version: str,
        shallow: typing.Optional[bool] = None,
        tag: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[types_types_metadata_Metadata]:
        """
        Parameters
        ----------
        x_api_version : str

        shallow : typing.Optional[bool]

        tag : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[types_types_metadata_Metadata]
        """
        _response = self._client_wrapper.httpx_client.request(
            "metadata",
            method="GET",
            params={
                "shallow": shallow,
                "tag": tag,
            },
            headers={
                "X-API-Version": str(x_api_version) if x_api_version is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    types_types_metadata_Metadata,
                    parse_obj_as(
                        type_=types_types_metadata_Metadata,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_big_entity(
        self,
        *,
        cast_member: typing.Optional[CastMember] = OMIT,
        extended_movie: typing.Optional[ExtendedMovie] = OMIT,
        entity: typing.Optional[Entity] = OMIT,
        metadata: typing.Optional[types_types_metadata_Metadata] = OMIT,
        common_metadata: typing.Optional[commons_types_types_metadata_Metadata] = OMIT,
        event_info: typing.Optional[EventInfo] = OMIT,
        data: typing.Optional[Data] = OMIT,
        migration: typing.Optional[Migration] = OMIT,
        exception: typing.Optional[Exception] = OMIT,
        test: typing.Optional[Test] = OMIT,
        node: typing.Optional[Node] = OMIT,
        directory: typing.Optional[Directory] = OMIT,
        moment: typing.Optional[Moment] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Response]:
        """
        Parameters
        ----------
        cast_member : typing.Optional[CastMember]

        extended_movie : typing.Optional[ExtendedMovie]

        entity : typing.Optional[Entity]

        metadata : typing.Optional[types_types_metadata_Metadata]

        common_metadata : typing.Optional[commons_types_types_metadata_Metadata]

        event_info : typing.Optional[EventInfo]

        data : typing.Optional[Data]

        migration : typing.Optional[Migration]

        exception : typing.Optional[Exception]

        test : typing.Optional[Test]

        node : typing.Optional[Node]

        directory : typing.Optional[Directory]

        moment : typing.Optional[Moment]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Response]
        """
        _response = self._client_wrapper.httpx_client.request(
            "big-entity",
            method="POST",
            json={
                "castMember": convert_and_respect_annotation_metadata(
                    object_=cast_member, annotation=CastMember, direction="write"
                ),
                "extendedMovie": convert_and_respect_annotation_metadata(
                    object_=extended_movie, annotation=ExtendedMovie, direction="write"
                ),
                "entity": convert_and_respect_annotation_metadata(object_=entity, annotation=Entity, direction="write"),
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=types_types_metadata_Metadata, direction="write"
                ),
                "commonMetadata": convert_and_respect_annotation_metadata(
                    object_=common_metadata, annotation=commons_types_types_metadata_Metadata, direction="write"
                ),
                "eventInfo": convert_and_respect_annotation_metadata(
                    object_=event_info, annotation=EventInfo, direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=Data, direction="write"),
                "migration": convert_and_respect_annotation_metadata(
                    object_=migration, annotation=Migration, direction="write"
                ),
                "exception": convert_and_respect_annotation_metadata(
                    object_=exception, annotation=Exception, direction="write"
                ),
                "test": convert_and_respect_annotation_metadata(object_=test, annotation=Test, direction="write"),
                "node": convert_and_respect_annotation_metadata(object_=node, annotation=Node, direction="write"),
                "directory": convert_and_respect_annotation_metadata(
                    object_=directory, annotation=Directory, direction="write"
                ),
                "moment": convert_and_respect_annotation_metadata(object_=moment, annotation=Moment, direction="write"),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Response,
                    parse_obj_as(
                        type_=Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawServiceClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_movie(
        self, movie_id: MovieId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Movie]:
        """
        Parameters
        ----------
        movie_id : MovieId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Movie]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"movie/{jsonable_encoder(movie_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Movie,
                    parse_obj_as(
                        type_=Movie,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_movie(
        self,
        *,
        id: MovieId,
        title: str,
        from_: str,
        rating: float,
        tag: Tag,
        metadata: typing.Dict[str, typing.Optional[typing.Any]],
        revenue: int,
        prequel: typing.Optional[MovieId] = OMIT,
        book: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[MovieId]:
        """
        Parameters
        ----------
        id : MovieId

        title : str

        from_ : str

        rating : float
            The rating scale is one to five stars

        tag : Tag

        metadata : typing.Dict[str, typing.Optional[typing.Any]]

        revenue : int

        prequel : typing.Optional[MovieId]

        book : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MovieId]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "movie",
            method="POST",
            json={
                "id": id,
                "prequel": prequel,
                "title": title,
                "from": from_,
                "rating": rating,
                "tag": tag,
                "book": book,
                "metadata": metadata,
                "revenue": revenue,
                "type": "movie",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MovieId,
                    parse_obj_as(
                        type_=MovieId,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_metadata(
        self,
        *,
        x_api_version: str,
        shallow: typing.Optional[bool] = None,
        tag: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[types_types_metadata_Metadata]:
        """
        Parameters
        ----------
        x_api_version : str

        shallow : typing.Optional[bool]

        tag : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[types_types_metadata_Metadata]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "metadata",
            method="GET",
            params={
                "shallow": shallow,
                "tag": tag,
            },
            headers={
                "X-API-Version": str(x_api_version) if x_api_version is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    types_types_metadata_Metadata,
                    parse_obj_as(
                        type_=types_types_metadata_Metadata,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_big_entity(
        self,
        *,
        cast_member: typing.Optional[CastMember] = OMIT,
        extended_movie: typing.Optional[ExtendedMovie] = OMIT,
        entity: typing.Optional[Entity] = OMIT,
        metadata: typing.Optional[types_types_metadata_Metadata] = OMIT,
        common_metadata: typing.Optional[commons_types_types_metadata_Metadata] = OMIT,
        event_info: typing.Optional[EventInfo] = OMIT,
        data: typing.Optional[Data] = OMIT,
        migration: typing.Optional[Migration] = OMIT,
        exception: typing.Optional[Exception] = OMIT,
        test: typing.Optional[Test] = OMIT,
        node: typing.Optional[Node] = OMIT,
        directory: typing.Optional[Directory] = OMIT,
        moment: typing.Optional[Moment] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Response]:
        """
        Parameters
        ----------
        cast_member : typing.Optional[CastMember]

        extended_movie : typing.Optional[ExtendedMovie]

        entity : typing.Optional[Entity]

        metadata : typing.Optional[types_types_metadata_Metadata]

        common_metadata : typing.Optional[commons_types_types_metadata_Metadata]

        event_info : typing.Optional[EventInfo]

        data : typing.Optional[Data]

        migration : typing.Optional[Migration]

        exception : typing.Optional[Exception]

        test : typing.Optional[Test]

        node : typing.Optional[Node]

        directory : typing.Optional[Directory]

        moment : typing.Optional[Moment]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Response]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "big-entity",
            method="POST",
            json={
                "castMember": convert_and_respect_annotation_metadata(
                    object_=cast_member, annotation=CastMember, direction="write"
                ),
                "extendedMovie": convert_and_respect_annotation_metadata(
                    object_=extended_movie, annotation=ExtendedMovie, direction="write"
                ),
                "entity": convert_and_respect_annotation_metadata(object_=entity, annotation=Entity, direction="write"),
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=types_types_metadata_Metadata, direction="write"
                ),
                "commonMetadata": convert_and_respect_annotation_metadata(
                    object_=common_metadata, annotation=commons_types_types_metadata_Metadata, direction="write"
                ),
                "eventInfo": convert_and_respect_annotation_metadata(
                    object_=event_info, annotation=EventInfo, direction="write"
                ),
                "data": convert_and_respect_annotation_metadata(object_=data, annotation=Data, direction="write"),
                "migration": convert_and_respect_annotation_metadata(
                    object_=migration, annotation=Migration, direction="write"
                ),
                "exception": convert_and_respect_annotation_metadata(
                    object_=exception, annotation=Exception, direction="write"
                ),
                "test": convert_and_respect_annotation_metadata(object_=test, annotation=Test, direction="write"),
                "node": convert_and_respect_annotation_metadata(object_=node, annotation=Node, direction="write"),
                "directory": convert_and_respect_annotation_metadata(
                    object_=directory, annotation=Directory, direction="write"
                ),
                "moment": convert_and_respect_annotation_metadata(object_=moment, annotation=Moment, direction="write"),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Response,
                    parse_obj_as(
                        type_=Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

# This file was auto-generated by Fern from our API Definition.

"""
Utilities for smoke tests that validate response structure and types
without requiring exact value matches.
"""

import datetime
import typing
import uuid

import pydantic


def get_type_name(value: typing.Any) -> str:
    """Get a human-readable type name for a value."""
    if value is None:
        return "None"
    if isinstance(value, bool):
        return "bool"
    if isinstance(value, int):
        return "int"
    if isinstance(value, float):
        return "float"
    if isinstance(value, str):
        return "str"
    if isinstance(value, list):
        return "list"
    if isinstance(value, dict):
        return "dict"
    if isinstance(value, datetime.datetime):
        return "datetime"
    if isinstance(value, datetime.date):
        return "date"
    if isinstance(value, uuid.UUID):
        return "uuid"
    return type(value).__name__


def validate_type_match(
    actual_value: typing.Any,
    expected_type: typing.Any,
    field_path: str = "",
) -> None:
    """
    Validate that the actual value matches the expected type.
    Does not compare exact values, only validates the type/structure.
    """
    if expected_type == "no_validate":
        return

    if expected_type is None:
        # No type expectation, just ensure the value exists
        return

    if expected_type == "uuid":
        assert isinstance(actual_value, (str, uuid.UUID)), (
            f"Field '{field_path}': Expected UUID, got {get_type_name(actual_value)}"
        )
        if isinstance(actual_value, str):
            try:
                uuid.UUID(actual_value)
            except ValueError:
                raise AssertionError(f"Field '{field_path}': Expected valid UUID string, got '{actual_value}'")
    elif expected_type == "date":
        assert isinstance(actual_value, (str, datetime.date)), (
            f"Field '{field_path}': Expected date, got {get_type_name(actual_value)}"
        )
    elif expected_type == "datetime":
        assert isinstance(actual_value, (str, datetime.datetime)), (
            f"Field '{field_path}': Expected datetime, got {get_type_name(actual_value)}"
        )
    elif expected_type == "integer":
        assert isinstance(actual_value, int), (
            f"Field '{field_path}': Expected integer, got {get_type_name(actual_value)}"
        )
    elif expected_type == "string":
        assert isinstance(actual_value, str), (
            f"Field '{field_path}': Expected string, got {get_type_name(actual_value)}"
        )
    elif expected_type == "boolean":
        assert isinstance(actual_value, bool), (
            f"Field '{field_path}': Expected boolean, got {get_type_name(actual_value)}"
        )
    elif expected_type == "float":
        assert isinstance(actual_value, (int, float)), (
            f"Field '{field_path}': Expected float, got {get_type_name(actual_value)}"
        )


def validate_structure(
    response: typing.Any,
    type_expectations: typing.Any,
    field_path: str = "",
) -> None:
    """
    Validate that the response matches the expected structure and types.
    This is a structural validation that checks:
    - All expected fields are present
    - Field types match the expected types
    - Nested structures are validated recursively

    Unlike strict validation, this does NOT compare exact values.
    """
    if type_expectations == "no_validate":
        return

    # Handle None response
    if response is None:
        # None is acceptable if we don't have strict type expectations
        return

    # Handle primitive types
    if (
        not isinstance(response, list)
        and not isinstance(response, dict)
        and not (hasattr(pydantic, "BaseModel") and isinstance(response, pydantic.BaseModel))
    ):
        validate_type_match(response, type_expectations, field_path)
        return

    # Handle lists
    if isinstance(response, list):
        if isinstance(type_expectations, tuple):
            container_type = type_expectations[0]
            contents_expectations = type_expectations[1]

            # Validate it's a list (or set)
            if container_type == "set":
                # Sets are represented as lists in JSON
                pass

            # Validate each item in the list
            if isinstance(contents_expectations, dict):
                for idx, item in enumerate(response):
                    item_path = f"{field_path}[{idx}]"
                    item_expectation = contents_expectations.get(idx)
                    if isinstance(item_expectation, dict):
                        validate_structure(item, item_expectation, item_path)
                    else:
                        validate_type_match(item, item_expectation, item_path)
        return

    # Handle dicts and Pydantic models
    response_dict = response
    if hasattr(pydantic, "BaseModel") and isinstance(response, pydantic.BaseModel):
        response_dict = response.dict(by_alias=True)

    if not isinstance(response_dict, dict):
        return

    if not isinstance(type_expectations, dict):
        return

    # Validate each expected field exists and has the correct type
    for key, expected_type in type_expectations.items():
        current_path = f"{field_path}.{key}" if field_path else key

        # Check field exists
        assert key in response_dict, (
            f"Field '{current_path}' not found in response. Available fields: {list(response_dict.keys())}"
        )

        actual_value = response_dict[key]

        # Recursively validate nested structures
        if isinstance(expected_type, dict):
            validate_structure(actual_value, expected_type, current_path)
        elif isinstance(expected_type, tuple):
            # Container type (list, set, dict)
            validate_structure(actual_value, expected_type, current_path)
        else:
            validate_type_match(actual_value, expected_type, current_path)


def validate_smoke_test_response(
    response: typing.Any,
    type_expectations: typing.Any,
) -> None:
    """
    Main entry point for smoke test structural validation.
    Validates that the response matches the expected structure and types.

    Args:
        response: The actual response from the API
        type_expectations: A nested structure describing expected types
    """
    validate_structure(response, type_expectations, "")


def _normalize_value(value: typing.Any) -> typing.Any:
    """Normalize a value for comparison (convert Pydantic models to dicts, etc.)."""
    if value is None:
        return None
    if hasattr(pydantic, "BaseModel") and isinstance(value, pydantic.BaseModel):
        return value.dict(by_alias=True)
    if isinstance(value, list):
        return [_normalize_value(item) for item in value]
    if isinstance(value, dict):
        return {k: _normalize_value(v) for k, v in value.items()}
    if isinstance(value, datetime.datetime):
        return value.isoformat()
    if isinstance(value, datetime.date):
        return value.isoformat()
    if isinstance(value, uuid.UUID):
        return str(value)
    return value


def validate_strict_response(
    response: typing.Any,
    expected_response: typing.Any,
) -> None:
    """
    Main entry point for smoke test strict validation.
    Validates that the response matches the expected values exactly.

    Args:
        response: The actual response from the API
        expected_response: The expected response values (from the example)
    """
    normalized_response = _normalize_value(response)
    normalized_expected = _normalize_value(expected_response)

    assert normalized_response == normalized_expected, (
        f"Response does not match expected values.\nExpected: {normalized_expected}\nActual: {normalized_response}"
    )

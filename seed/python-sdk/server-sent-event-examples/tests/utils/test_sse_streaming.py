# This file was auto-generated by Fern from our API Definition.

import logging
from unittest.mock import AsyncMock, Mock, patch
import pytest
from json.decoder import JSONDecodeError
from seed.completions.raw_client import AsyncRawCompletionsClient, RawCompletionsClient
from seed.core.http_sse._models import ServerSentEvent


class TestSSEStreamingLogic:
    """Test the SSE streaming logic in raw_client.py."""

    def test_stream_sync_success(self):
        """Test successful sync streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE events using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello", "tokens": 1}')
        sse2 = ServerSentEvent(data="[[DONE]]")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse1, sse2]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    def test_stream_sync_json_decode_error(self, caplog):
        """Test sync streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with invalid JSON using real ServerSentEvent dataclass
        sse = ServerSentEvent(data="invalid json")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Failed to parse SSE data field as JSON" in caplog.text

    def test_stream_sync_model_construction_error(self, caplog):
        """Test sync streaming with model construction error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with valid JSON but invalid model data using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"invalid": "data"}')
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_sync_unexpected_error(self, caplog):
        """Test sync streaming with unexpected error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event that will cause an unexpected error during processing
        # We use a valid JSON that will fail during model construction in an unexpected way
        sse = ServerSentEvent(data='{"delta": null}')
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            # Note: With real ServerSentEvent, the error will be caught as model construction error
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0

    @pytest.mark.asyncio
    async def test_stream_async_success(self):
        """Test successful async streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE events using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello", "tokens": 1}')
        sse2 = ServerSentEvent(data="[[DONE]]")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield sse1
                yield sse2
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    @pytest.mark.asyncio
    async def test_stream_async_json_decode_error(self, caplog):
        """Test async streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with invalid JSON using real ServerSentEvent dataclass
        sse = ServerSentEvent(data="invalid json")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield sse
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                async with client.stream(query="test") as response:
                    completions = []
                    async for completion in response.data:
                        completions.append(completion)
                    assert len(completions) == 0
                    assert "Failed to parse SSE data field as JSON" in caplog.text

    def test_stream_sync_error_response(self):
        """Test sync streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    @pytest.mark.asyncio
    async def test_stream_async_error_response(self):
        """Test async streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper async context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
        mock_stream_context.__aexit__ = AsyncMock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            async with client.stream(query="test") as response:
                pass

    def test_stream_empty_sse_events(self):
        """Test handling of empty SSE events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Empty SSE event using real ServerSentEvent dataclass
        sse = ServerSentEvent(data="")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 0

    def test_stream_multiple_done_markers(self):
        """Test handling of multiple [[DONE]] markers."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE events with multiple DONE markers using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello"}')
        sse2 = ServerSentEvent(data="[[DONE]]")
        sse3 = ServerSentEvent(data="[[DONE]]")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse1, sse2, sse3]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    def test_stream_immediate_done(self):
        """Test stream that immediately ends with [[DONE]]."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event using real ServerSentEvent dataclass
        sse = ServerSentEvent(data="[[DONE]]")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 0

    def test_stream_mixed_valid_invalid_events(self, caplog):
        """Test stream with both valid and invalid events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mix of valid and invalid events using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello", "tokens": 1}')
        sse2 = ServerSentEvent(data="invalid json")
        sse3 = ServerSentEvent(data='{"delta": "world", "tokens": 2}')
        sse4 = ServerSentEvent(data="[[DONE]]")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse1, sse2, sse3, sse4]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 2
                    assert completions[0].delta == "hello"
                    assert completions[0].tokens == 1
                    assert completions[1].delta == "world"
                    assert completions[1].tokens == 2
                    assert "Failed to parse SSE data field as JSON" in caplog.text

    def test_stream_missing_required_fields(self, caplog):
        """Test handling of SSE events missing required fields."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event missing required 'delta' field using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"tokens": 1}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_invalid_tokens_type(self, caplog):
        """Test handling of invalid tokens field type."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with invalid tokens type using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"delta": "hello", "tokens": "not_a_number"}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_unicode_data(self):
        """Test handling of Unicode characters in SSE data."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with Unicode characters using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"delta": "Hello 世界", "tokens": 1}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "Hello 世界"
                assert completions[0].tokens == 1

    def test_stream_299_status_code(self):
        """Test handling of 299 status code (upper bound of success range)."""
        mock_response = Mock()
        mock_response.status_code = 299
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"delta": "hello"}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    def test_stream_500_error_response(self):
        """Test handling of 500 error response."""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Internal server error"}
        
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    def test_stream_non_json_error_response(self):
        """Test handling of non-JSON error response."""
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "text/plain"}
        mock_response.text = "Bad Request"
        mock_response.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    def test_stream_with_request_options(self):
        """Test that request_options are properly passed through."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"delta": "hello"}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            # Create mock request options
            from seed.core.request_options import RequestOptions
            request_options = RequestOptions()
            
            with client.stream(query="test", request_options=request_options) as response:
                # Verify that request_options was passed to httpx_client.stream
                mock_client_wrapper.httpx_client.stream.assert_called_once()
                call_args = mock_client_wrapper.httpx_client.stream.call_args
                assert call_args[1]["request_options"] == request_options

    def test_stream_context_manager_cleanup(self):
        """Test that context manager properly cleans up on exception."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event that will cause an error during model construction using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"invalid": "data"}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            # Test that context manager is properly entered and exited even with exceptions
            with client.stream(query="test") as response:
                # The exception should be caught and logged, but context manager should still work
                completions = list(response.data)
                assert len(completions) == 0  # No completions due to exception
            
            # Verify that __exit__ was called
            mock_stream_context.__exit__.assert_called_once()

    @pytest.mark.asyncio
    async def test_stream_async_early_exit(self):
        """Test async stream with early exit from iteration."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE events using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello"}')
        sse2 = ServerSentEvent(data='{"delta": "world"}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield sse1
                yield sse2
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                    break  # Early exit after first completion
                
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    @pytest.mark.asyncio
    async def test_stream_async_mixed_valid_invalid_events(self, caplog):
        """Test async stream with both valid and invalid events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mix of valid and invalid events using real ServerSentEvent dataclass
        sse1 = ServerSentEvent(data='{"delta": "hello", "tokens": 1}')
        sse2 = ServerSentEvent(data="invalid json")
        sse3 = ServerSentEvent(data='{"delta": "world", "tokens": 2}')
        sse4 = ServerSentEvent(data="[[DONE]]")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield sse1
                yield sse2
                yield sse3
                yield sse4
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                async with client.stream(query="test") as response:
                    completions = []
                    async for completion in response.data:
                        completions.append(completion)
                    assert len(completions) == 2
                    assert completions[0].delta == "hello"
                    assert completions[0].tokens == 1
                    assert completions[1].delta == "world"
                    assert completions[1].tokens == 2
                    assert "Failed to parse SSE data field as JSON" in caplog.text

    @pytest.mark.asyncio
    async def test_stream_async_unicode_data(self):
        """Test async stream with Unicode characters."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with Unicode characters using real ServerSentEvent dataclass
        sse = ServerSentEvent(data='{"delta": "Hello 世界", "tokens": 1}')
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield sse
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                assert len(completions) == 1
                assert completions[0].delta == "Hello 世界"
                assert completions[0].tokens == 1

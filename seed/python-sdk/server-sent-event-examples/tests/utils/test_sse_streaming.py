# This file was auto-generated by Fern from our API Definition.

import logging
from unittest.mock import AsyncMock, Mock, patch
import pytest
from json.decoder import JSONDecodeError
from seed.completions.raw_client import AsyncRawCompletionsClient, RawCompletionsClient


class TestSSEStreamingLogic:
    """Test the SSE streaming logic in raw_client.py."""

    def test_stream_sync_success(self):
        """Test successful sync streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "[[DONE]]"
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse1, mock_sse2]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    def test_stream_sync_json_decode_error(self, caplog):
        """Test sync streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with invalid JSON
        mock_sse = Mock()
        mock_sse.data = "invalid json"
        mock_sse.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    def test_stream_sync_model_construction_error(self, caplog):
        """Test sync streaming with model construction error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with valid JSON but invalid model data
        mock_sse = Mock()
        mock_sse.data = '{"invalid": "data"}'
        mock_sse.json.return_value = {"invalid": "data"}
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_sync_unexpected_error(self, caplog):
        """Test sync streaming with unexpected error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event that raises unexpected error
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello"}'
        mock_sse.json.side_effect = RuntimeError("Unexpected error")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.ERROR):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Unexpected error processing SSE event" in caplog.text

    @pytest.mark.asyncio
    async def test_stream_async_success(self):
        """Test successful async streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "[[DONE]]"
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse1
                yield mock_sse2
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    @pytest.mark.asyncio
    async def test_stream_async_json_decode_error(self, caplog):
        """Test async streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with invalid JSON
        mock_sse = Mock()
        mock_sse.data = "invalid json"
        mock_sse.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                async with client.stream(query="test") as response:
                    completions = []
                    async for completion in response.data:
                        completions.append(completion)
                    assert len(completions) == 0
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    def test_stream_sync_error_response(self):
        """Test sync streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    @pytest.mark.asyncio
    async def test_stream_async_error_response(self):
        """Test async streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper async context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
        mock_stream_context.__aexit__ = AsyncMock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            async with client.stream(query="test") as response:
                pass

    def test_stream_empty_sse_events(self):
        """Test handling of empty SSE events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock empty SSE event
        mock_sse = Mock()
        mock_sse.data = ""
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 0

    def test_stream_multiple_done_markers(self):
        """Test handling of multiple [[DONE]] markers."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE events with multiple DONE markers
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello"}'
        mock_sse1.json.return_value = {"delta": "hello"}
        
        mock_sse2 = Mock()
        mock_sse2.data = "[[DONE]]"
        
        mock_sse3 = Mock()
        mock_sse3.data = "[[DONE]]"
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse1, mock_sse2, mock_sse3]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    def test_stream_immediate_done(self):
        """Test stream that immediately ends with [[DONE]]."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        mock_sse = Mock()
        mock_sse.data = "[[DONE]]"
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 0

    def test_stream_mixed_valid_invalid_events(self, caplog):
        """Test stream with both valid and invalid events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mix of valid and invalid events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "invalid json"
        mock_sse2.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        mock_sse3 = Mock()
        mock_sse3.data = '{"delta": "world", "tokens": 2}'
        mock_sse3.json.return_value = {"delta": "world", "tokens": 2}
        
        mock_sse4 = Mock()
        mock_sse4.data = "[[DONE]]"
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse1, mock_sse2, mock_sse3, mock_sse4]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 2
                    assert completions[0].delta == "hello"
                    assert completions[0].tokens == 1
                    assert completions[1].delta == "world"
                    assert completions[1].tokens == 2
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    def test_stream_missing_required_fields(self, caplog):
        """Test handling of SSE events missing required fields."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event missing required 'delta' field
        mock_sse = Mock()
        mock_sse.data = '{"tokens": 1}'
        mock_sse.json.return_value = {"tokens": 1}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_invalid_tokens_type(self, caplog):
        """Test handling of invalid tokens field type."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with invalid tokens type
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello", "tokens": "not_a_number"}'
        mock_sse.json.return_value = {"delta": "hello", "tokens": "not_a_number"}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_unicode_data(self):
        """Test handling of Unicode characters in SSE data."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with Unicode characters
        mock_sse = Mock()
        mock_sse.data = '{"delta": "Hello 世界", "tokens": 1}'
        mock_sse.json.return_value = {"delta": "Hello 世界", "tokens": 1}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "Hello 世界"
                assert completions[0].tokens == 1

    def test_stream_299_status_code(self):
        """Test handling of 299 status code (upper bound of success range)."""
        mock_response = Mock()
        mock_response.status_code = 299
        mock_response.headers = {"content-type": "text/event-stream"}
        
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello"}'
        mock_sse.json.return_value = {"delta": "hello"}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    def test_stream_500_error_response(self):
        """Test handling of 500 error response."""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Internal server error"}
        
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    def test_stream_non_json_error_response(self):
        """Test handling of non-JSON error response."""
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "text/plain"}
        mock_response.text = "Bad Request"
        mock_response.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    def test_stream_with_request_options(self):
        """Test that request_options are properly passed through."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello"}'
        mock_sse.json.return_value = {"delta": "hello"}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            # Create mock request options
            from seed.core.request_options import RequestOptions
            request_options = RequestOptions()
            
            with client.stream(query="test", request_options=request_options) as response:
                # Verify that request_options was passed to httpx_client.stream
                mock_client_wrapper.httpx_client.stream.assert_called_once()
                call_args = mock_client_wrapper.httpx_client.stream.call_args
                assert call_args[1]["request_options"] == request_options

    def test_stream_context_manager_cleanup(self):
        """Test that context manager properly cleans up on exception."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event that will cause an exception during processing
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello"}'
        mock_sse.json.side_effect = RuntimeError("Test exception during JSON parsing")
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            # Test that context manager is properly entered and exited even with exceptions
            with client.stream(query="test") as response:
                # The exception should be caught and logged, but context manager should still work
                completions = list(response.data)
                assert len(completions) == 0  # No completions due to exception
            
            # Verify that __exit__ was called
            mock_stream_context.__exit__.assert_called_once()

    @pytest.mark.asyncio
    async def test_stream_async_early_exit(self):
        """Test async stream with early exit from iteration."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello"}'
        mock_sse1.json.return_value = {"delta": "hello"}
        
        mock_sse2 = Mock()
        mock_sse2.data = '{"delta": "world"}'
        mock_sse2.json.return_value = {"delta": "world"}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse1
                yield mock_sse2
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                    break  # Early exit after first completion
                
                assert len(completions) == 1
                assert completions[0].delta == "hello"

    @pytest.mark.asyncio
    async def test_stream_async_mixed_valid_invalid_events(self, caplog):
        """Test async stream with both valid and invalid events."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mix of valid and invalid events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "invalid json"
        mock_sse2.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        mock_sse3 = Mock()
        mock_sse3.data = '{"delta": "world", "tokens": 2}'
        mock_sse3.json.return_value = {"delta": "world", "tokens": 2}
        
        mock_sse4 = Mock()
        mock_sse4.data = "[[DONE]]"
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse1
                yield mock_sse2
                yield mock_sse3
                yield mock_sse4
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                async with client.stream(query="test") as response:
                    completions = []
                    async for completion in response.data:
                        completions.append(completion)
                    assert len(completions) == 2
                    assert completions[0].delta == "hello"
                    assert completions[0].tokens == 1
                    assert completions[1].delta == "world"
                    assert completions[1].tokens == 2
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    @pytest.mark.asyncio
    async def test_stream_async_unicode_data(self):
        """Test async stream with Unicode characters."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # SSE event with Unicode characters
        mock_sse = Mock()
        mock_sse.data = '{"delta": "Hello 世界", "tokens": 1}'
        mock_sse.json.return_value = {"delta": "Hello 世界", "tokens": 1}
        
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                assert len(completions) == 1
                assert completions[0].delta == "Hello 世界"
                assert completions[0].tokens == 1

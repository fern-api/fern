# This file was auto-generated by Fern from our API Definition.

import asyncio
import json
import logging
from io import BytesIO
from typing import Any, AsyncIterator, Iterator
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import httpx
import pytest
from json.decoder import JSONDecodeError

from seed.completions.raw_client import AsyncRawCompletionsClient, RawCompletionsClient
from seed.completions.types.streamed_completion import StreamedCompletion
from seed.core.http_sse._api import EventSource
from seed.core.http_sse._decoders import SSEDecoder
from seed.core.http_sse._exceptions import SSEError
from seed.core.http_sse._models import ServerSentEvent


class TestSSEDecoder:
    """Test the SSEDecoder class for parsing Server-Sent Events."""

    def test_decode_empty_line_returns_none_when_no_data(self):
        """Test that empty line returns None when no data is accumulated."""
        decoder = SSEDecoder()
        assert decoder.decode("") is None

    def test_decode_empty_line_returns_sse_when_data_accumulated(self):
        """Test that empty line returns SSE when data is accumulated."""
        decoder = SSEDecoder()
        decoder._data = ["hello"]
        decoder._event = "test"
        decoder._last_event_id = "123"
        decoder._retry = 5000

        sse = decoder.decode("")
        assert sse is not None
        assert sse.event == "test"
        assert sse.data == "hello"
        assert sse.id == "123"
        assert sse.retry == 5000

    def test_decode_comment_line_returns_none(self):
        """Test that comment lines (starting with :) return None."""
        decoder = SSEDecoder()
        assert decoder.decode(": this is a comment") is None

    def test_decode_event_field(self):
        """Test parsing event field."""
        decoder = SSEDecoder()
        assert decoder.decode("event: test-event") is None
        assert decoder._event == "test-event"

    def test_decode_data_field(self):
        """Test parsing data field."""
        decoder = SSEDecoder()
        assert decoder.decode("data: hello world") is None
        assert decoder._data == ["hello world"]

    def test_decode_multiple_data_fields(self):
        """Test parsing multiple data fields."""
        decoder = SSEDecoder()
        assert decoder.decode("data: line1") is None
        assert decoder.decode("data: line2") is None
        assert decoder._data == ["line1", "line2"]

    def test_decode_id_field(self):
        """Test parsing id field."""
        decoder = SSEDecoder()
        assert decoder.decode("id: 123") is None
        assert decoder._last_event_id == "123"

    def test_decode_id_field_with_null_character(self):
        """Test that id field with null character is ignored."""
        decoder = SSEDecoder()
        original_id = decoder._last_event_id
        assert decoder.decode("id: test\x00id") is None
        assert decoder._last_event_id == original_id

    def test_decode_retry_field(self):
        """Test parsing retry field."""
        decoder = SSEDecoder()
        assert decoder.decode("retry: 5000") is None
        assert decoder._retry == 5000

    def test_decode_retry_field_invalid_number(self):
        """Test that invalid retry number is ignored."""
        decoder = SSEDecoder()
        assert decoder.decode("retry: invalid") is None
        assert decoder._retry is None

    def test_decode_unknown_field(self):
        """Test that unknown fields are ignored."""
        decoder = SSEDecoder()
        assert decoder.decode("unknown: value") is None

    def test_decode_data_with_leading_space(self):
        """Test that data field with leading space is handled correctly."""
        decoder = SSEDecoder()
        assert decoder.decode("data:  hello world") is None
        assert decoder._data == [" hello world"]

    def test_decode_complete_sse_event(self):
        """Test parsing a complete SSE event."""
        decoder = SSEDecoder()
        
        # Build up the event
        assert decoder.decode("event: test") is None
        assert decoder.decode("data: hello") is None
        assert decoder.decode("data: world") is None
        assert decoder.decode("id: 123") is None
        assert decoder.decode("retry: 5000") is None
        
        # Empty line should return the complete event
        sse = decoder.decode("")
        assert sse is not None
        assert sse.event == "test"
        assert sse.data == "hello\nworld"
        assert sse.id == "123"
        assert sse.retry == 5000

    def test_decode_resets_fields_after_complete_event(self):
        """Test that fields are reset after returning a complete event."""
        decoder = SSEDecoder()
        
        # Build and return first event
        decoder.decode("event: first")
        decoder.decode("data: data1")
        first_sse = decoder.decode("")
        assert first_sse is not None
        assert first_sse.event == "first"
        assert first_sse.data == "data1"
        
        # Build second event
        decoder.decode("event: second")
        decoder.decode("data: data2")
        second_sse = decoder.decode("")
        assert second_sse is not None
        assert second_sse.event == "second"
        assert second_sse.data == "data2"


class TestEventSource:
    """Test the EventSource class for handling SSE streams."""

    def test_check_content_type_valid(self):
        """Test that valid content type passes."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        event_source = EventSource(response)
        # Should not raise
        event_source._check_content_type()

    def test_check_content_type_with_charset(self):
        """Test that content type with charset passes."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream; charset=utf-8"}
        event_source = EventSource(response)
        # Should not raise
        event_source._check_content_type()

    def test_check_content_type_invalid(self):
        """Test that invalid content type raises SSEError."""
        response = Mock()
        response.headers = {"content-type": "application/json"}
        event_source = EventSource(response)
        
        with pytest.raises(SSEError, match="Expected response header Content-Type to contain 'text/event-stream'"):
            event_source._check_content_type()

    def test_check_content_type_missing(self):
        """Test that missing content type raises SSEError."""
        response = Mock()
        response.headers = {}
        event_source = EventSource(response)
        
        with pytest.raises(SSEError, match="Expected response header Content-Type to contain 'text/event-stream'"):
            event_source._check_content_type()

    def test_iter_sse_basic(self):
        """Test basic SSE iteration."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        response.iter_bytes.return_value = [
            b"data: hello\n",
            b"data: world\n",
            b"\n"
        ]
        
        event_source = EventSource(response)
        events = list(event_source.iter_sse())
        
        assert len(events) == 1
        assert events[0].data == "hello\nworld"

    def test_iter_sse_multiple_events(self):
        """Test multiple SSE events."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        response.iter_bytes.return_value = [
            b"data: event1\n\n",
            b"data: event2\n\n"
        ]
        
        event_source = EventSource(response)
        events = list(event_source.iter_sse())
        
        assert len(events) == 2
        assert events[0].data == "event1"
        assert events[1].data == "event2"

    def test_iter_sse_with_remaining_buffer(self):
        """Test SSE iteration with remaining buffer data."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        response.iter_bytes.return_value = [
            b"data: incomplete\n\n"
        ]
        
        event_source = EventSource(response)
        events = list(event_source.iter_sse())
        
        assert len(events) == 1
        assert events[0].data == "incomplete"

    @pytest.mark.asyncio
    async def test_aiter_sse_basic(self):
        """Test basic async SSE iteration."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        
        async def mock_aiter_lines():
            yield "data: hello\n"
            yield "data: world\n"
            yield "\n"
        
        response.aiter_lines.return_value = mock_aiter_lines()
        
        event_source = EventSource(response)
        events = []
        async for event in event_source.aiter_sse():
            events.append(event)
        
        assert len(events) == 1
        assert events[0].data == "hello\nworld"

    @pytest.mark.asyncio
    async def test_aiter_sse_multiple_events(self):
        """Test multiple async SSE events."""
        response = Mock()
        response.headers = {"content-type": "text/event-stream"}
        
        async def mock_aiter_lines():
            yield "data: event1\n"
            yield "\n"
            yield "data: event2\n"
            yield "\n"
        
        response.aiter_lines.return_value = mock_aiter_lines()
        
        event_source = EventSource(response)
        events = []
        async for event in event_source.aiter_sse():
            events.append(event)
        
        assert len(events) == 2
        assert events[0].data == "event1"
        assert events[1].data == "event2"


class TestSSEStreamingLogic:
    """Test the SSE streaming logic in raw_client.py."""

    def test_stream_sync_success(self):
        """Test successful sync streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "[[DONE]]"
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse1, mock_sse2]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = list(response.data)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    def test_stream_sync_json_decode_error(self, caplog):
        """Test sync streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with invalid JSON
        mock_sse = Mock()
        mock_sse.data = "invalid json"
        mock_sse.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    def test_stream_sync_model_construction_error(self, caplog):
        """Test sync streaming with model construction error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with valid JSON but invalid model data
        mock_sse = Mock()
        mock_sse.data = '{"invalid": "data"}'
        mock_sse.json.return_value = {"invalid": "data"}
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Skipping SSE event due to model construction error" in caplog.text

    def test_stream_sync_unexpected_error(self, caplog):
        """Test sync streaming with unexpected error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event that raises unexpected error
        mock_sse = Mock()
        mock_sse.data = '{"delta": "hello"}'
        mock_sse.json.side_effect = RuntimeError("Unexpected error")
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            mock_event_source.iter_sse.return_value = [mock_sse]
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__enter__ = Mock(return_value=mock_response)
            mock_stream_context.__exit__ = Mock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.ERROR):
                with client.stream(query="test") as response:
                    completions = list(response.data)
                    assert len(completions) == 0
                    assert "Unexpected error processing SSE event" in caplog.text

    @pytest.mark.asyncio
    async def test_stream_async_success(self):
        """Test successful async streaming."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE events
        mock_sse1 = Mock()
        mock_sse1.data = '{"delta": "hello", "tokens": 1}'
        mock_sse1.json.return_value = {"delta": "hello", "tokens": 1}
        
        mock_sse2 = Mock()
        mock_sse2.data = "[[DONE]]"
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse1
                yield mock_sse2
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            async with client.stream(query="test") as response:
                assert response._response == mock_response
                completions = []
                async for completion in response.data:
                    completions.append(completion)
                assert len(completions) == 1
                assert completions[0].delta == "hello"
                assert completions[0].tokens == 1

    @pytest.mark.asyncio
    async def test_stream_async_json_decode_error(self, caplog):
        """Test async streaming with JSON decode error."""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.headers = {"content-type": "text/event-stream"}
        
        # Mock SSE event with invalid JSON
        mock_sse = Mock()
        mock_sse.data = "invalid json"
        mock_sse.json.side_effect = JSONDecodeError("msg", "doc", 0)
        
        # Mock EventSource
        with patch('seed.completions.raw_client.EventSource') as mock_event_source_class:
            mock_event_source = Mock()
            
            async def mock_aiter_sse():
                yield mock_sse
            
            mock_event_source.aiter_sse.return_value = mock_aiter_sse()
            mock_event_source_class.return_value = mock_event_source
            
            # Mock client wrapper with proper async context manager
            mock_client_wrapper = Mock()
            mock_stream_context = Mock()
            mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
            mock_stream_context.__aexit__ = AsyncMock(return_value=None)
            mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
            
            client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
            
            with caplog.at_level(logging.WARNING):
                async with client.stream(query="test") as response:
                    completions = []
                    async for completion in response.data:
                        completions.append(completion)
                    assert len(completions) == 0
                    assert "Skipping SSE event with invalid JSON" in caplog.text

    def test_stream_sync_error_response(self):
        """Test sync streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__enter__ = Mock(return_value=mock_response)
        mock_stream_context.__exit__ = Mock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = RawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            with client.stream(query="test") as response:
                pass

    @pytest.mark.asyncio
    async def test_stream_async_error_response(self):
        """Test async streaming with error response."""
        # Mock response with error status
        mock_response = Mock()
        mock_response.status_code = 400
        mock_response.headers = {"content-type": "application/json"}
        mock_response.json.return_value = {"error": "Bad request"}
        
        # Mock client wrapper with proper async context manager
        mock_client_wrapper = Mock()
        mock_stream_context = Mock()
        mock_stream_context.__aenter__ = AsyncMock(return_value=mock_response)
        mock_stream_context.__aexit__ = AsyncMock(return_value=None)
        mock_client_wrapper.httpx_client.stream.return_value = mock_stream_context
        
        client = AsyncRawCompletionsClient(client_wrapper=mock_client_wrapper)
        
        with pytest.raises(Exception):  # Should raise ApiError
            async with client.stream(query="test") as response:
                pass


class TestServerSentEvent:
    """Test the ServerSentEvent model."""

    def test_default_values(self):
        """Test default values for ServerSentEvent."""
        sse = ServerSentEvent()
        assert sse.event == "message"
        assert sse.data == ""
        assert sse.id == ""
        assert sse.retry is None

    def test_json_parsing(self):
        """Test JSON parsing of SSE data."""
        sse = ServerSentEvent(data='{"delta": "hello", "tokens": 1}')
        json_data = sse.json()
        assert json_data == {"delta": "hello", "tokens": 1}

    def test_json_parsing_invalid(self):
        """Test JSON parsing with invalid JSON."""
        sse = ServerSentEvent(data="invalid json")
        with pytest.raises(json.JSONDecodeError):
            sse.json()

    def test_immutable(self):
        """Test that ServerSentEvent is immutable."""
        sse = ServerSentEvent(event="test", data="hello")
        with pytest.raises(AttributeError):
            sse.event = "modified"

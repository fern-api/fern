# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalRootModel, copy_and_update_model, update_forward_refs
from .active_diamond import ActiveDiamond as bigunion_types_active_diamond_ActiveDiamond
from .attractive_script import AttractiveScript as bigunion_types_attractive_script_AttractiveScript
from .circular_card import CircularCard as bigunion_types_circular_card_CircularCard
from .colorful_cover import ColorfulCover as bigunion_types_colorful_cover_ColorfulCover
from .diligent_deal import DiligentDeal as bigunion_types_diligent_deal_DiligentDeal
from .disloyal_value import DisloyalValue as bigunion_types_disloyal_value_DisloyalValue
from .distinct_failure import DistinctFailure as bigunion_types_distinct_failure_DistinctFailure
from .false_mirror import FalseMirror as bigunion_types_false_mirror_FalseMirror
from .frozen_sleep import FrozenSleep as bigunion_types_frozen_sleep_FrozenSleep
from .gaseous_road import GaseousRoad as bigunion_types_gaseous_road_GaseousRoad
from .gruesome_coach import GruesomeCoach as bigunion_types_gruesome_coach_GruesomeCoach
from .harmonious_play import HarmoniousPlay as bigunion_types_harmonious_play_HarmoniousPlay
from .hasty_pain import HastyPain as bigunion_types_hasty_pain_HastyPain
from .hoarse_mouse import HoarseMouse as bigunion_types_hoarse_mouse_HoarseMouse
from .jumbo_end import JumboEnd as bigunion_types_jumbo_end_JumboEnd
from .limping_step import LimpingStep as bigunion_types_limping_step_LimpingStep
from .misty_snow import MistySnow as bigunion_types_misty_snow_MistySnow
from .normal_sweet import NormalSweet as bigunion_types_normal_sweet_NormalSweet
from .popular_limit import PopularLimit as bigunion_types_popular_limit_PopularLimit
from .potable_bad import PotableBad as bigunion_types_potable_bad_PotableBad
from .practical_principle import PracticalPrinciple as bigunion_types_practical_principle_PracticalPrinciple
from .primary_block import PrimaryBlock as bigunion_types_primary_block_PrimaryBlock
from .rotating_ratio import RotatingRatio as bigunion_types_rotating_ratio_RotatingRatio
from .thankful_factor import ThankfulFactor as bigunion_types_thankful_factor_ThankfulFactor
from .total_work import TotalWork as bigunion_types_total_work_TotalWork
from .triangular_repair import TriangularRepair as bigunion_types_triangular_repair_TriangularRepair
from .unique_stress import UniqueStress as bigunion_types_unique_stress_UniqueStress
from .unwilling_smoke import UnwillingSmoke as bigunion_types_unwilling_smoke_UnwillingSmoke
from .vibrant_excitement import VibrantExcitement as bigunion_types_vibrant_excitement_VibrantExcitement

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def normal_sweet(self, value: bigunion_types_normal_sweet_NormalSweet) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.NormalSweet, update={"type": "normalSweet"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.NormalSweet, update={"type": "normalSweet"})
            )  # type: ignore

    def thankful_factor(self, value: bigunion_types_thankful_factor_ThankfulFactor) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.ThankfulFactor, update={"type": "thankfulFactor"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.ThankfulFactor, update={"type": "thankfulFactor"})
            )  # type: ignore

    def jumbo_end(self, value: bigunion_types_jumbo_end_JumboEnd) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.JumboEnd, update={"type": "jumboEnd"}))  # type: ignore
        else:
            return BigUnion(__root__=copy_and_update_model(value, _BigUnion.JumboEnd, update={"type": "jumboEnd"}))  # type: ignore

    def hasty_pain(self, value: bigunion_types_hasty_pain_HastyPain) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.HastyPain, update={"type": "hastyPain"}))  # type: ignore
        else:
            return BigUnion(__root__=copy_and_update_model(value, _BigUnion.HastyPain, update={"type": "hastyPain"}))  # type: ignore

    def misty_snow(self, value: bigunion_types_misty_snow_MistySnow) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.MistySnow, update={"type": "mistySnow"}))  # type: ignore
        else:
            return BigUnion(__root__=copy_and_update_model(value, _BigUnion.MistySnow, update={"type": "mistySnow"}))  # type: ignore

    def distinct_failure(self, value: bigunion_types_distinct_failure_DistinctFailure) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.DistinctFailure, update={"type": "distinctFailure"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.DistinctFailure, update={"type": "distinctFailure"})
            )  # type: ignore

    def practical_principle(self, value: bigunion_types_practical_principle_PracticalPrinciple) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.PracticalPrinciple, update={"type": "practicalPrinciple"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(
                    value, _BigUnion.PracticalPrinciple, update={"type": "practicalPrinciple"}
                )
            )  # type: ignore

    def limping_step(self, value: bigunion_types_limping_step_LimpingStep) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.LimpingStep, update={"type": "limpingStep"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.LimpingStep, update={"type": "limpingStep"})
            )  # type: ignore

    def vibrant_excitement(self, value: bigunion_types_vibrant_excitement_VibrantExcitement) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.VibrantExcitement, update={"type": "vibrantExcitement"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.VibrantExcitement, update={"type": "vibrantExcitement"})
            )  # type: ignore

    def active_diamond(self, value: bigunion_types_active_diamond_ActiveDiamond) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.ActiveDiamond, update={"type": "activeDiamond"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.ActiveDiamond, update={"type": "activeDiamond"})
            )  # type: ignore

    def popular_limit(self, value: bigunion_types_popular_limit_PopularLimit) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.PopularLimit, update={"type": "popularLimit"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.PopularLimit, update={"type": "popularLimit"})
            )  # type: ignore

    def false_mirror(self, value: bigunion_types_false_mirror_FalseMirror) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.FalseMirror, update={"type": "falseMirror"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.FalseMirror, update={"type": "falseMirror"})
            )  # type: ignore

    def primary_block(self, value: bigunion_types_primary_block_PrimaryBlock) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.PrimaryBlock, update={"type": "primaryBlock"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.PrimaryBlock, update={"type": "primaryBlock"})
            )  # type: ignore

    def rotating_ratio(self, value: bigunion_types_rotating_ratio_RotatingRatio) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.RotatingRatio, update={"type": "rotatingRatio"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.RotatingRatio, update={"type": "rotatingRatio"})
            )  # type: ignore

    def colorful_cover(self, value: bigunion_types_colorful_cover_ColorfulCover) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.ColorfulCover, update={"type": "colorfulCover"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.ColorfulCover, update={"type": "colorfulCover"})
            )  # type: ignore

    def disloyal_value(self, value: bigunion_types_disloyal_value_DisloyalValue) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.DisloyalValue, update={"type": "disloyalValue"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.DisloyalValue, update={"type": "disloyalValue"})
            )  # type: ignore

    def gruesome_coach(self, value: bigunion_types_gruesome_coach_GruesomeCoach) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.GruesomeCoach, update={"type": "gruesomeCoach"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.GruesomeCoach, update={"type": "gruesomeCoach"})
            )  # type: ignore

    def total_work(self, value: bigunion_types_total_work_TotalWork) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.TotalWork, update={"type": "totalWork"}))  # type: ignore
        else:
            return BigUnion(__root__=copy_and_update_model(value, _BigUnion.TotalWork, update={"type": "totalWork"}))  # type: ignore

    def harmonious_play(self, value: bigunion_types_harmonious_play_HarmoniousPlay) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.HarmoniousPlay, update={"type": "harmoniousPlay"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.HarmoniousPlay, update={"type": "harmoniousPlay"})
            )  # type: ignore

    def unique_stress(self, value: bigunion_types_unique_stress_UniqueStress) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.UniqueStress, update={"type": "uniqueStress"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.UniqueStress, update={"type": "uniqueStress"})
            )  # type: ignore

    def unwilling_smoke(self, value: bigunion_types_unwilling_smoke_UnwillingSmoke) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.UnwillingSmoke, update={"type": "unwillingSmoke"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.UnwillingSmoke, update={"type": "unwillingSmoke"})
            )  # type: ignore

    def frozen_sleep(self, value: bigunion_types_frozen_sleep_FrozenSleep) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.FrozenSleep, update={"type": "frozenSleep"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.FrozenSleep, update={"type": "frozenSleep"})
            )  # type: ignore

    def diligent_deal(self, value: bigunion_types_diligent_deal_DiligentDeal) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.DiligentDeal, update={"type": "diligentDeal"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.DiligentDeal, update={"type": "diligentDeal"})
            )  # type: ignore

    def attractive_script(self, value: bigunion_types_attractive_script_AttractiveScript) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.AttractiveScript, update={"type": "attractiveScript"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.AttractiveScript, update={"type": "attractiveScript"})
            )  # type: ignore

    def hoarse_mouse(self, value: bigunion_types_hoarse_mouse_HoarseMouse) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.HoarseMouse, update={"type": "hoarseMouse"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.HoarseMouse, update={"type": "hoarseMouse"})
            )  # type: ignore

    def circular_card(self, value: bigunion_types_circular_card_CircularCard) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.CircularCard, update={"type": "circularCard"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.CircularCard, update={"type": "circularCard"})
            )  # type: ignore

    def potable_bad(self, value: bigunion_types_potable_bad_PotableBad) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.PotableBad, update={"type": "potableBad"}))  # type: ignore
        else:
            return BigUnion(__root__=copy_and_update_model(value, _BigUnion.PotableBad, update={"type": "potableBad"}))  # type: ignore

    def triangular_repair(self, value: bigunion_types_triangular_repair_TriangularRepair) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(
                root=copy_and_update_model(value, _BigUnion.TriangularRepair, update={"type": "triangularRepair"})
            )  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.TriangularRepair, update={"type": "triangularRepair"})
            )  # type: ignore

    def gaseous_road(self, value: bigunion_types_gaseous_road_GaseousRoad) -> BigUnion:
        if IS_PYDANTIC_V2:
            return BigUnion(root=copy_and_update_model(value, _BigUnion.GaseousRoad, update={"type": "gaseousRoad"}))  # type: ignore
        else:
            return BigUnion(
                __root__=copy_and_update_model(value, _BigUnion.GaseousRoad, update={"type": "gaseousRoad"})
            )  # type: ignore


class BigUnion(UniversalRootModel):
    """
    Examples
    --------
    from seed.bigunion import BigUnion_NormalSweet

    BigUnion_NormalSweet(
        value="example1",
    )
    """

    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _BigUnion.NormalSweet,
                _BigUnion.ThankfulFactor,
                _BigUnion.JumboEnd,
                _BigUnion.HastyPain,
                _BigUnion.MistySnow,
                _BigUnion.DistinctFailure,
                _BigUnion.PracticalPrinciple,
                _BigUnion.LimpingStep,
                _BigUnion.VibrantExcitement,
                _BigUnion.ActiveDiamond,
                _BigUnion.PopularLimit,
                _BigUnion.FalseMirror,
                _BigUnion.PrimaryBlock,
                _BigUnion.RotatingRatio,
                _BigUnion.ColorfulCover,
                _BigUnion.DisloyalValue,
                _BigUnion.GruesomeCoach,
                _BigUnion.TotalWork,
                _BigUnion.HarmoniousPlay,
                _BigUnion.UniqueStress,
                _BigUnion.UnwillingSmoke,
                _BigUnion.FrozenSleep,
                _BigUnion.DiligentDeal,
                _BigUnion.AttractiveScript,
                _BigUnion.HoarseMouse,
                _BigUnion.CircularCard,
                _BigUnion.PotableBad,
                _BigUnion.TriangularRepair,
                _BigUnion.GaseousRoad,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _BigUnion.NormalSweet,
            _BigUnion.ThankfulFactor,
            _BigUnion.JumboEnd,
            _BigUnion.HastyPain,
            _BigUnion.MistySnow,
            _BigUnion.DistinctFailure,
            _BigUnion.PracticalPrinciple,
            _BigUnion.LimpingStep,
            _BigUnion.VibrantExcitement,
            _BigUnion.ActiveDiamond,
            _BigUnion.PopularLimit,
            _BigUnion.FalseMirror,
            _BigUnion.PrimaryBlock,
            _BigUnion.RotatingRatio,
            _BigUnion.ColorfulCover,
            _BigUnion.DisloyalValue,
            _BigUnion.GruesomeCoach,
            _BigUnion.TotalWork,
            _BigUnion.HarmoniousPlay,
            _BigUnion.UniqueStress,
            _BigUnion.UnwillingSmoke,
            _BigUnion.FrozenSleep,
            _BigUnion.DiligentDeal,
            _BigUnion.AttractiveScript,
            _BigUnion.HoarseMouse,
            _BigUnion.CircularCard,
            _BigUnion.PotableBad,
            _BigUnion.TriangularRepair,
            _BigUnion.GaseousRoad,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _BigUnion.NormalSweet,
                _BigUnion.ThankfulFactor,
                _BigUnion.JumboEnd,
                _BigUnion.HastyPain,
                _BigUnion.MistySnow,
                _BigUnion.DistinctFailure,
                _BigUnion.PracticalPrinciple,
                _BigUnion.LimpingStep,
                _BigUnion.VibrantExcitement,
                _BigUnion.ActiveDiamond,
                _BigUnion.PopularLimit,
                _BigUnion.FalseMirror,
                _BigUnion.PrimaryBlock,
                _BigUnion.RotatingRatio,
                _BigUnion.ColorfulCover,
                _BigUnion.DisloyalValue,
                _BigUnion.GruesomeCoach,
                _BigUnion.TotalWork,
                _BigUnion.HarmoniousPlay,
                _BigUnion.UniqueStress,
                _BigUnion.UnwillingSmoke,
                _BigUnion.FrozenSleep,
                _BigUnion.DiligentDeal,
                _BigUnion.AttractiveScript,
                _BigUnion.HoarseMouse,
                _BigUnion.CircularCard,
                _BigUnion.PotableBad,
                _BigUnion.TriangularRepair,
                _BigUnion.GaseousRoad,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _BigUnion.NormalSweet,
            _BigUnion.ThankfulFactor,
            _BigUnion.JumboEnd,
            _BigUnion.HastyPain,
            _BigUnion.MistySnow,
            _BigUnion.DistinctFailure,
            _BigUnion.PracticalPrinciple,
            _BigUnion.LimpingStep,
            _BigUnion.VibrantExcitement,
            _BigUnion.ActiveDiamond,
            _BigUnion.PopularLimit,
            _BigUnion.FalseMirror,
            _BigUnion.PrimaryBlock,
            _BigUnion.RotatingRatio,
            _BigUnion.ColorfulCover,
            _BigUnion.DisloyalValue,
            _BigUnion.GruesomeCoach,
            _BigUnion.TotalWork,
            _BigUnion.HarmoniousPlay,
            _BigUnion.UniqueStress,
            _BigUnion.UnwillingSmoke,
            _BigUnion.FrozenSleep,
            _BigUnion.DiligentDeal,
            _BigUnion.AttractiveScript,
            _BigUnion.HoarseMouse,
            _BigUnion.CircularCard,
            _BigUnion.PotableBad,
            _BigUnion.TriangularRepair,
            _BigUnion.GaseousRoad,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        normal_sweet: typing.Callable[[bigunion_types_normal_sweet_NormalSweet], T_Result],
        thankful_factor: typing.Callable[[bigunion_types_thankful_factor_ThankfulFactor], T_Result],
        jumbo_end: typing.Callable[[bigunion_types_jumbo_end_JumboEnd], T_Result],
        hasty_pain: typing.Callable[[bigunion_types_hasty_pain_HastyPain], T_Result],
        misty_snow: typing.Callable[[bigunion_types_misty_snow_MistySnow], T_Result],
        distinct_failure: typing.Callable[[bigunion_types_distinct_failure_DistinctFailure], T_Result],
        practical_principle: typing.Callable[[bigunion_types_practical_principle_PracticalPrinciple], T_Result],
        limping_step: typing.Callable[[bigunion_types_limping_step_LimpingStep], T_Result],
        vibrant_excitement: typing.Callable[[bigunion_types_vibrant_excitement_VibrantExcitement], T_Result],
        active_diamond: typing.Callable[[bigunion_types_active_diamond_ActiveDiamond], T_Result],
        popular_limit: typing.Callable[[bigunion_types_popular_limit_PopularLimit], T_Result],
        false_mirror: typing.Callable[[bigunion_types_false_mirror_FalseMirror], T_Result],
        primary_block: typing.Callable[[bigunion_types_primary_block_PrimaryBlock], T_Result],
        rotating_ratio: typing.Callable[[bigunion_types_rotating_ratio_RotatingRatio], T_Result],
        colorful_cover: typing.Callable[[bigunion_types_colorful_cover_ColorfulCover], T_Result],
        disloyal_value: typing.Callable[[bigunion_types_disloyal_value_DisloyalValue], T_Result],
        gruesome_coach: typing.Callable[[bigunion_types_gruesome_coach_GruesomeCoach], T_Result],
        total_work: typing.Callable[[bigunion_types_total_work_TotalWork], T_Result],
        harmonious_play: typing.Callable[[bigunion_types_harmonious_play_HarmoniousPlay], T_Result],
        unique_stress: typing.Callable[[bigunion_types_unique_stress_UniqueStress], T_Result],
        unwilling_smoke: typing.Callable[[bigunion_types_unwilling_smoke_UnwillingSmoke], T_Result],
        frozen_sleep: typing.Callable[[bigunion_types_frozen_sleep_FrozenSleep], T_Result],
        diligent_deal: typing.Callable[[bigunion_types_diligent_deal_DiligentDeal], T_Result],
        attractive_script: typing.Callable[[bigunion_types_attractive_script_AttractiveScript], T_Result],
        hoarse_mouse: typing.Callable[[bigunion_types_hoarse_mouse_HoarseMouse], T_Result],
        circular_card: typing.Callable[[bigunion_types_circular_card_CircularCard], T_Result],
        potable_bad: typing.Callable[[bigunion_types_potable_bad_PotableBad], T_Result],
        triangular_repair: typing.Callable[[bigunion_types_triangular_repair_TriangularRepair], T_Result],
        gaseous_road: typing.Callable[[bigunion_types_gaseous_road_GaseousRoad], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "normalSweet":
            return normal_sweet(
                copy_and_update_model(unioned_value, bigunion_types_normal_sweet_NormalSweet, exclude={"type"})
            )
        if unioned_value.type == "thankfulFactor":
            return thankful_factor(
                copy_and_update_model(unioned_value, bigunion_types_thankful_factor_ThankfulFactor, exclude={"type"})
            )
        if unioned_value.type == "jumboEnd":
            return jumbo_end(copy_and_update_model(unioned_value, bigunion_types_jumbo_end_JumboEnd, exclude={"type"}))
        if unioned_value.type == "hastyPain":
            return hasty_pain(
                copy_and_update_model(unioned_value, bigunion_types_hasty_pain_HastyPain, exclude={"type"})
            )
        if unioned_value.type == "mistySnow":
            return misty_snow(
                copy_and_update_model(unioned_value, bigunion_types_misty_snow_MistySnow, exclude={"type"})
            )
        if unioned_value.type == "distinctFailure":
            return distinct_failure(
                copy_and_update_model(unioned_value, bigunion_types_distinct_failure_DistinctFailure, exclude={"type"})
            )
        if unioned_value.type == "practicalPrinciple":
            return practical_principle(
                copy_and_update_model(
                    unioned_value, bigunion_types_practical_principle_PracticalPrinciple, exclude={"type"}
                )
            )
        if unioned_value.type == "limpingStep":
            return limping_step(
                copy_and_update_model(unioned_value, bigunion_types_limping_step_LimpingStep, exclude={"type"})
            )
        if unioned_value.type == "vibrantExcitement":
            return vibrant_excitement(
                copy_and_update_model(
                    unioned_value, bigunion_types_vibrant_excitement_VibrantExcitement, exclude={"type"}
                )
            )
        if unioned_value.type == "activeDiamond":
            return active_diamond(
                copy_and_update_model(unioned_value, bigunion_types_active_diamond_ActiveDiamond, exclude={"type"})
            )
        if unioned_value.type == "popularLimit":
            return popular_limit(
                copy_and_update_model(unioned_value, bigunion_types_popular_limit_PopularLimit, exclude={"type"})
            )
        if unioned_value.type == "falseMirror":
            return false_mirror(
                copy_and_update_model(unioned_value, bigunion_types_false_mirror_FalseMirror, exclude={"type"})
            )
        if unioned_value.type == "primaryBlock":
            return primary_block(
                copy_and_update_model(unioned_value, bigunion_types_primary_block_PrimaryBlock, exclude={"type"})
            )
        if unioned_value.type == "rotatingRatio":
            return rotating_ratio(
                copy_and_update_model(unioned_value, bigunion_types_rotating_ratio_RotatingRatio, exclude={"type"})
            )
        if unioned_value.type == "colorfulCover":
            return colorful_cover(
                copy_and_update_model(unioned_value, bigunion_types_colorful_cover_ColorfulCover, exclude={"type"})
            )
        if unioned_value.type == "disloyalValue":
            return disloyal_value(
                copy_and_update_model(unioned_value, bigunion_types_disloyal_value_DisloyalValue, exclude={"type"})
            )
        if unioned_value.type == "gruesomeCoach":
            return gruesome_coach(
                copy_and_update_model(unioned_value, bigunion_types_gruesome_coach_GruesomeCoach, exclude={"type"})
            )
        if unioned_value.type == "totalWork":
            return total_work(
                copy_and_update_model(unioned_value, bigunion_types_total_work_TotalWork, exclude={"type"})
            )
        if unioned_value.type == "harmoniousPlay":
            return harmonious_play(
                copy_and_update_model(unioned_value, bigunion_types_harmonious_play_HarmoniousPlay, exclude={"type"})
            )
        if unioned_value.type == "uniqueStress":
            return unique_stress(
                copy_and_update_model(unioned_value, bigunion_types_unique_stress_UniqueStress, exclude={"type"})
            )
        if unioned_value.type == "unwillingSmoke":
            return unwilling_smoke(
                copy_and_update_model(unioned_value, bigunion_types_unwilling_smoke_UnwillingSmoke, exclude={"type"})
            )
        if unioned_value.type == "frozenSleep":
            return frozen_sleep(
                copy_and_update_model(unioned_value, bigunion_types_frozen_sleep_FrozenSleep, exclude={"type"})
            )
        if unioned_value.type == "diligentDeal":
            return diligent_deal(
                copy_and_update_model(unioned_value, bigunion_types_diligent_deal_DiligentDeal, exclude={"type"})
            )
        if unioned_value.type == "attractiveScript":
            return attractive_script(
                copy_and_update_model(
                    unioned_value, bigunion_types_attractive_script_AttractiveScript, exclude={"type"}
                )
            )
        if unioned_value.type == "hoarseMouse":
            return hoarse_mouse(
                copy_and_update_model(unioned_value, bigunion_types_hoarse_mouse_HoarseMouse, exclude={"type"})
            )
        if unioned_value.type == "circularCard":
            return circular_card(
                copy_and_update_model(unioned_value, bigunion_types_circular_card_CircularCard, exclude={"type"})
            )
        if unioned_value.type == "potableBad":
            return potable_bad(
                copy_and_update_model(unioned_value, bigunion_types_potable_bad_PotableBad, exclude={"type"})
            )
        if unioned_value.type == "triangularRepair":
            return triangular_repair(
                copy_and_update_model(
                    unioned_value, bigunion_types_triangular_repair_TriangularRepair, exclude={"type"}
                )
            )
        if unioned_value.type == "gaseousRoad":
            return gaseous_road(
                copy_and_update_model(unioned_value, bigunion_types_gaseous_road_GaseousRoad, exclude={"type"})
            )

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


class _BigUnion:
    class NormalSweet(bigunion_types_normal_sweet_NormalSweet):
        type: typing.Literal["normalSweet"] = "normalSweet"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class ThankfulFactor(bigunion_types_thankful_factor_ThankfulFactor):
        type: typing.Literal["thankfulFactor"] = "thankfulFactor"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class JumboEnd(bigunion_types_jumbo_end_JumboEnd):
        type: typing.Literal["jumboEnd"] = "jumboEnd"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class HastyPain(bigunion_types_hasty_pain_HastyPain):
        type: typing.Literal["hastyPain"] = "hastyPain"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class MistySnow(bigunion_types_misty_snow_MistySnow):
        type: typing.Literal["mistySnow"] = "mistySnow"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class DistinctFailure(bigunion_types_distinct_failure_DistinctFailure):
        type: typing.Literal["distinctFailure"] = "distinctFailure"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class PracticalPrinciple(bigunion_types_practical_principle_PracticalPrinciple):
        type: typing.Literal["practicalPrinciple"] = "practicalPrinciple"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class LimpingStep(bigunion_types_limping_step_LimpingStep):
        type: typing.Literal["limpingStep"] = "limpingStep"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class VibrantExcitement(bigunion_types_vibrant_excitement_VibrantExcitement):
        type: typing.Literal["vibrantExcitement"] = "vibrantExcitement"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class ActiveDiamond(bigunion_types_active_diamond_ActiveDiamond):
        type: typing.Literal["activeDiamond"] = "activeDiamond"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class PopularLimit(bigunion_types_popular_limit_PopularLimit):
        type: typing.Literal["popularLimit"] = "popularLimit"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class FalseMirror(bigunion_types_false_mirror_FalseMirror):
        type: typing.Literal["falseMirror"] = "falseMirror"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class PrimaryBlock(bigunion_types_primary_block_PrimaryBlock):
        type: typing.Literal["primaryBlock"] = "primaryBlock"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class RotatingRatio(bigunion_types_rotating_ratio_RotatingRatio):
        type: typing.Literal["rotatingRatio"] = "rotatingRatio"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class ColorfulCover(bigunion_types_colorful_cover_ColorfulCover):
        type: typing.Literal["colorfulCover"] = "colorfulCover"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class DisloyalValue(bigunion_types_disloyal_value_DisloyalValue):
        type: typing.Literal["disloyalValue"] = "disloyalValue"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class GruesomeCoach(bigunion_types_gruesome_coach_GruesomeCoach):
        type: typing.Literal["gruesomeCoach"] = "gruesomeCoach"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class TotalWork(bigunion_types_total_work_TotalWork):
        type: typing.Literal["totalWork"] = "totalWork"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class HarmoniousPlay(bigunion_types_harmonious_play_HarmoniousPlay):
        type: typing.Literal["harmoniousPlay"] = "harmoniousPlay"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class UniqueStress(bigunion_types_unique_stress_UniqueStress):
        type: typing.Literal["uniqueStress"] = "uniqueStress"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class UnwillingSmoke(bigunion_types_unwilling_smoke_UnwillingSmoke):
        type: typing.Literal["unwillingSmoke"] = "unwillingSmoke"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class FrozenSleep(bigunion_types_frozen_sleep_FrozenSleep):
        type: typing.Literal["frozenSleep"] = "frozenSleep"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class DiligentDeal(bigunion_types_diligent_deal_DiligentDeal):
        type: typing.Literal["diligentDeal"] = "diligentDeal"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class AttractiveScript(bigunion_types_attractive_script_AttractiveScript):
        type: typing.Literal["attractiveScript"] = "attractiveScript"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class HoarseMouse(bigunion_types_hoarse_mouse_HoarseMouse):
        type: typing.Literal["hoarseMouse"] = "hoarseMouse"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class CircularCard(bigunion_types_circular_card_CircularCard):
        type: typing.Literal["circularCard"] = "circularCard"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class PotableBad(bigunion_types_potable_bad_PotableBad):
        type: typing.Literal["potableBad"] = "potableBad"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class TriangularRepair(bigunion_types_triangular_repair_TriangularRepair):
        type: typing.Literal["triangularRepair"] = "triangularRepair"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class GaseousRoad(bigunion_types_gaseous_road_GaseousRoad):
        type: typing.Literal["gaseousRoad"] = "gaseousRoad"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(BigUnion)

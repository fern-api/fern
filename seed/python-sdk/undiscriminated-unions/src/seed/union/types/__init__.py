# This file was auto-generated by Fern from our API Definition.

# isort: skip_file

import typing
from importlib import import_module

if typing.TYPE_CHECKING:
    from .convert_token import ConvertToken
    from .key import Key
    from .key_type import KeyType
    from .metadata import Metadata
    from .metadata_union import MetadataUnion
    from .my_union import MyUnion
    from .named_metadata import NamedMetadata
    from .nested_union_l_1 import NestedUnionL1
    from .nested_union_l_2 import NestedUnionL2
    from .nested_union_root import NestedUnionRoot
    from .optional_metadata import OptionalMetadata
    from .payment_method_union import PaymentMethodUnion
    from .request import Request
    from .tokenize_card import TokenizeCard
    from .type_with_optional_union import TypeWithOptionalUnion
    from .union_with_duplicate_types import UnionWithDuplicateTypes
    from .union_with_identical_primitives import UnionWithIdenticalPrimitives
    from .union_with_identical_strings import UnionWithIdenticalStrings
_dynamic_imports: typing.Dict[str, str] = {
    "ConvertToken": ".convert_token",
    "Key": ".key",
    "KeyType": ".key_type",
    "Metadata": ".metadata",
    "MetadataUnion": ".metadata_union",
    "MyUnion": ".my_union",
    "NamedMetadata": ".named_metadata",
    "NestedUnionL1": ".nested_union_l_1",
    "NestedUnionL2": ".nested_union_l_2",
    "NestedUnionRoot": ".nested_union_root",
    "OptionalMetadata": ".optional_metadata",
    "PaymentMethodUnion": ".payment_method_union",
    "Request": ".request",
    "TokenizeCard": ".tokenize_card",
    "TypeWithOptionalUnion": ".type_with_optional_union",
    "UnionWithDuplicateTypes": ".union_with_duplicate_types",
    "UnionWithIdenticalPrimitives": ".union_with_identical_primitives",
    "UnionWithIdenticalStrings": ".union_with_identical_strings",
}


def __getattr__(attr_name: str) -> typing.Any:
    module_name = _dynamic_imports.get(attr_name)
    if module_name is None:
        raise AttributeError(f"No {attr_name} found in _dynamic_imports for module name -> {__name__}")
    try:
        module = import_module(module_name, __package__)
        if module_name == f".{attr_name}":
            return module
        else:
            return getattr(module, attr_name)
    except ImportError as e:
        raise ImportError(f"Failed to import {attr_name} from {module_name}: {e}") from e
    except AttributeError as e:
        raise AttributeError(f"Failed to get {attr_name} from {module_name}: {e}") from e


def __dir__():
    lazy_attrs = list(_dynamic_imports.keys())
    return sorted(lazy_attrs)


__all__ = [
    "ConvertToken",
    "Key",
    "KeyType",
    "Metadata",
    "MetadataUnion",
    "MyUnion",
    "NamedMetadata",
    "NestedUnionL1",
    "NestedUnionL2",
    "NestedUnionRoot",
    "OptionalMetadata",
    "PaymentMethodUnion",
    "Request",
    "TokenizeCard",
    "TypeWithOptionalUnion",
    "UnionWithDuplicateTypes",
    "UnionWithIdenticalPrimitives",
    "UnionWithIdenticalStrings",
]

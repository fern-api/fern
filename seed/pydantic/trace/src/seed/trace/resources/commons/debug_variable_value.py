# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations
from ...core.pydantic_utilities import UniversalBaseModel
import typing
import pydantic
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from .node_id import NodeId
from .binary_tree_value import BinaryTreeValue
from .singly_linked_list_value import SinglyLinkedListValue
from .doubly_linked_list_value import DoublyLinkedListValue
from ...core.pydantic_utilities import update_forward_refs


class DebugVariableValue_IntegerValue(UniversalBaseModel):
    value: int
    type: typing.Literal["integerValue"] = "integerValue"


class DebugVariableValue_BooleanValue(UniversalBaseModel):
    value: bool
    type: typing.Literal["booleanValue"] = "booleanValue"


class DebugVariableValue_DoubleValue(UniversalBaseModel):
    value: float
    type: typing.Literal["doubleValue"] = "doubleValue"


class DebugVariableValue_StringValue(UniversalBaseModel):
    value: str
    type: typing.Literal["stringValue"] = "stringValue"


class DebugVariableValue_CharValue(UniversalBaseModel):
    value: str
    type: typing.Literal["charValue"] = "charValue"


class DebugVariableValue_MapValue(UniversalBaseModel):
    type: typing.Literal["mapValue"] = "mapValue"
    key_value_pairs: typing.List["DebugKeyValuePairs"] = pydantic.Field(alias="keyValuePairs")

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


from .debug_map_value import DebugMapValue  # noqa: E402, F401


class DebugVariableValue_ListValue(UniversalBaseModel):
    value: typing.List["DebugVariableValue"]
    type: typing.Literal["listValue"] = "listValue"


class DebugVariableValue_BinaryTreeNodeValue(UniversalBaseModel):
    type: typing.Literal["binaryTreeNodeValue"] = "binaryTreeNodeValue"
    node_id: NodeId = pydantic.Field(alias="nodeId")
    full_tree: BinaryTreeValue = pydantic.Field(alias="fullTree")

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


class DebugVariableValue_SinglyLinkedListNodeValue(UniversalBaseModel):
    type: typing.Literal["singlyLinkedListNodeValue"] = "singlyLinkedListNodeValue"
    node_id: NodeId = pydantic.Field(alias="nodeId")
    full_list: SinglyLinkedListValue = pydantic.Field(alias="fullList")

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


class DebugVariableValue_DoublyLinkedListNodeValue(UniversalBaseModel):
    type: typing.Literal["doublyLinkedListNodeValue"] = "doublyLinkedListNodeValue"
    node_id: NodeId = pydantic.Field(alias="nodeId")
    full_list: DoublyLinkedListValue = pydantic.Field(alias="fullList")

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


class DebugVariableValue_UndefinedValue(UniversalBaseModel):
    type: typing.Literal["undefinedValue"] = "undefinedValue"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


class DebugVariableValue_NullValue(UniversalBaseModel):
    type: typing.Literal["nullValue"] = "nullValue"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


class DebugVariableValue_GenericValue(UniversalBaseModel):
    type: typing.Literal["genericValue"] = "genericValue"
    stringified_type: typing.Optional[str] = pydantic.Field(alias="stringifiedType", default=None)
    stringified_value: str = pydantic.Field(alias="stringifiedValue")

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow


DebugVariableValue = typing.Union[
    DebugVariableValue_IntegerValue,
    DebugVariableValue_BooleanValue,
    DebugVariableValue_DoubleValue,
    DebugVariableValue_StringValue,
    DebugVariableValue_CharValue,
    DebugVariableValue_MapValue,
    DebugVariableValue_ListValue,
    DebugVariableValue_BinaryTreeNodeValue,
    DebugVariableValue_SinglyLinkedListNodeValue,
    DebugVariableValue_DoublyLinkedListNodeValue,
    DebugVariableValue_UndefinedValue,
    DebugVariableValue_NullValue,
    DebugVariableValue_GenericValue,
]
from .debug_key_value_pairs import DebugKeyValuePairs  # noqa: E402, F401

update_forward_refs(DebugVariableValue_MapValue)
update_forward_refs(DebugVariableValue_ListValue)

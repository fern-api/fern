/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.seed.websocket.core;

import static java.util.concurrent.TimeUnit.*;

import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
import okhttp3.Response;
import okhttp3.WebSocket;
import okhttp3.WebSocketListener;

/**
 * WebSocketListener with automatic reconnection, exponential backoff, and message queuing.
 * Provides production-ready resilience for WebSocket connections.
 */
public abstract class ReconnectingWebSocketListener extends WebSocketListener {
    private final long minReconnectionDelayMs;

    private final long maxReconnectionDelayMs;

    private final double reconnectionDelayGrowFactor;

    private final int maxRetries;

    private final int maxEnqueuedMessages;

    private final AtomicInteger retryCount = new AtomicInteger(0);

    private final AtomicBoolean connectLock = new AtomicBoolean(false);

    private final AtomicBoolean shouldReconnect = new AtomicBoolean(true);

    protected volatile WebSocket webSocket;

    private volatile long connectionEstablishedTime = 0L;

    private final ConcurrentLinkedQueue<String> messageQueue = new ConcurrentLinkedQueue<>();

    private final ScheduledExecutorService reconnectExecutor = Executors.newSingleThreadScheduledExecutor();

    private final Supplier<? extends WebSocket> connectionSupplier;

    /**
     * Creates a new reconnecting WebSocket listener.
     *
     * @param options Reconnection configuration options
     * @param connectionSupplier Supplier that creates new WebSocket connections
     */
    public ReconnectingWebSocketListener(
            ReconnectingWebSocketListener.ReconnectOptions options, Supplier<? extends WebSocket> connectionSupplier) {
        this.minReconnectionDelayMs = options.minReconnectionDelayMs;
        this.maxReconnectionDelayMs = options.maxReconnectionDelayMs;
        this.reconnectionDelayGrowFactor = options.reconnectionDelayGrowFactor;
        this.maxRetries = options.maxRetries;
        this.maxEnqueuedMessages = options.maxEnqueuedMessages;
        this.connectionSupplier = connectionSupplier;
    }

    /**
     * Initiates a WebSocket connection with automatic reconnection enabled.
     *
     * Connection behavior:
     * - Times out after 4000 milliseconds
     * - Thread-safe via atomic lock (returns immediately if connection in progress)
     * - Retry count not incremented for initial connection attempt
     *
     * Error handling:
     * - TimeoutException: Includes retry attempt context
     * - InterruptedException: Preserves thread interruption status
     * - ExecutionException: Extracts actual cause and adds context
     */
    public void connect() {
        if (!connectLock.compareAndSet(false, true)) {
            return;
        }
        if (retryCount.get() >= maxRetries) {
            connectLock.set(false);
            return;
        }
        try {
            CompletableFuture<? extends WebSocket> connectionFuture = CompletableFuture.supplyAsync(connectionSupplier);
            try {
                webSocket = connectionFuture.get(4000, MILLISECONDS);
            } catch (TimeoutException e) {
                connectionFuture.cancel(true);
                TimeoutException timeoutError =
                        new TimeoutException("WebSocket connection timeout after " + 4000 + " milliseconds"
                                + (retryCount.get() > 0
                                        ? " (retry attempt #" + retryCount.get()
                                        : " (initial connection attempt)"));
                onWebSocketFailure(null, timeoutError, null);
                if (shouldReconnect.get()) {
                    scheduleReconnect();
                }
            } catch (InterruptedException e) {
                connectionFuture.cancel(true);
                Thread.currentThread().interrupt();
                InterruptedException interruptError = new InterruptedException("WebSocket connection interrupted"
                        + (retryCount.get() > 0
                                ? " during retry attempt #" + retryCount.get()
                                : " during initial connection"));
                interruptError.initCause(e);
                onWebSocketFailure(null, interruptError, null);
            } catch (ExecutionException e) {
                Throwable cause = e.getCause() != null ? e.getCause() : e;
                String context = retryCount.get() > 0
                        ? "WebSocket connection failed during retry attempt #" + retryCount.get()
                        : "WebSocket connection failed during initial attempt";
                RuntimeException wrappedException = new RuntimeException(
                        context + ": " + cause.getClass().getSimpleName() + ": " + cause.getMessage());
                wrappedException.initCause(cause);
                onWebSocketFailure(null, wrappedException, null);
                if (shouldReconnect.get()) {
                    scheduleReconnect();
                }
            }
        } finally {
            connectLock.set(false);
        }
    }

    /**
     * Disconnects the WebSocket and disables automatic reconnection.
     *
     * This method:
     * - Disables automatic reconnection
     * - Clears queued messages to prevent stale data
     * - Closes the WebSocket with standard close code 1000
     * - Properly shuts down the reconnect executor to prevent thread leaks
     * - Waits up to 5 seconds for executor termination
     */
    public void disconnect() {
        shouldReconnect.set(false);
        messageQueue.clear();
        if (webSocket != null) {
            webSocket.close(1000, "Client disconnecting");
        }
        reconnectExecutor.shutdown();
        try {
            if (!reconnectExecutor.awaitTermination(5, SECONDS)) {
                reconnectExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            reconnectExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Sends a message or queues it if not connected.
     *
     * Thread-safe: Synchronized to prevent race conditions with flushMessageQueue().
     *
     * Behavior:
     * - If connected: Attempts direct send, queues if buffer full
     * - If disconnected: Queues message up to maxEnqueuedMessages limit
     * - If queue full: Message is dropped
     *
     * @param message The message to send
     * @return true if sent immediately, false if queued or dropped
     */
    public synchronized boolean send(String message) {
        WebSocket ws = webSocket;
        if (ws != null) {
            boolean sent = ws.send(message);
            if (!sent && messageQueue.size() < maxEnqueuedMessages) {
                messageQueue.offer(message);
                return false;
            }
            return sent;
        } else {
            if (messageQueue.size() < maxEnqueuedMessages) {
                messageQueue.offer(message);
                return false;
            }
            return false;
        }
    }

    /**
     * Gets the current WebSocket instance.
     * Thread-safe method to access the WebSocket connection.
     * @return the WebSocket or null if not connected
     */
    public WebSocket getWebSocket() {
        return webSocket;
    }

    /**
     * @hidden
     */
    @Override
    public void onOpen(WebSocket webSocket, Response response) {
        this.webSocket = webSocket;
        connectionEstablishedTime = System.currentTimeMillis();
        retryCount.set(0);
        flushMessageQueue();
        onWebSocketOpen(webSocket, response);
    }

    @Override
    public void onMessage(WebSocket webSocket, String text) {
        onWebSocketMessage(webSocket, text);
    }

    /**
     * @hidden
     */
    @Override
    public void onFailure(WebSocket webSocket, Throwable t, Response response) {
        this.webSocket = null;
        long uptime = 0L;
        if (connectionEstablishedTime > 0) {
            uptime = System.currentTimeMillis() - connectionEstablishedTime;
            if (uptime >= 5000) {
                retryCount.set(0);
            }
        }
        connectionEstablishedTime = 0L;
        Throwable enhancedError = t;
        if (t != null) {
            String errorContext = "WebSocket connection failed";
            if (uptime > 0) {
                errorContext += " after " + (uptime / 1000) + " seconds";
            }
            if (response != null) {
                errorContext += " with HTTP " + response.code() + " " + response.message();
            }
            enhancedError =
                    new RuntimeException(errorContext + ": " + t.getClass().getSimpleName() + ": " + t.getMessage());
            enhancedError.initCause(t);
        }
        onWebSocketFailure(webSocket, enhancedError, response);
        if (shouldReconnect.get()) {
            scheduleReconnect();
        }
    }

    /**
     * @hidden
     */
    @Override
    public void onClosed(WebSocket webSocket, int code, String reason) {
        this.webSocket = null;
        if (connectionEstablishedTime > 0) {
            long uptime = System.currentTimeMillis() - connectionEstablishedTime;
            if (uptime >= 5000) {
                retryCount.set(0);
            }
        }
        connectionEstablishedTime = 0L;
        onWebSocketClosed(webSocket, code, reason);
        if (code != 1000 && shouldReconnect.get()) {
            scheduleReconnect();
        }
    }

    /**
     * Calculates the next reconnection delay using exponential backoff.
     *
     * Uses 0-based retry count where:
     * - 0 = initial connection (not used by this method)
     * - 1 = first retry (returns minReconnectionDelayMs)
     * - 2+ = exponential backoff up to maxReconnectionDelayMs
     */
    private long getNextDelay() {
        if (retryCount.get() == 1) {
            return minReconnectionDelayMs;
        }
        long delay = (long) (minReconnectionDelayMs * Math.pow(reconnectionDelayGrowFactor, retryCount.get() - 1));
        return Math.min(delay, maxReconnectionDelayMs);
    }

    /**
     * Schedules a reconnection attempt with appropriate delay.
     * Increments retry count and uses exponential backoff.
     */
    private void scheduleReconnect() {
        retryCount.incrementAndGet();
        long delay = getNextDelay();
        reconnectExecutor.schedule(this::connect, delay, MILLISECONDS);
    }

    /**
     * Sends all queued messages after reconnection.
     *
     * Thread-safe: Synchronized to prevent race conditions with send() method.
     *
     * Algorithm:
     * 1. Drains queue into temporary list to avoid holding lock during sends
     * 2. Attempts to send each message in order
     * 3. If any send fails, re-queues that message and all subsequent messages
     * 4. Preserves message ordering during re-queueing
     */
    private synchronized void flushMessageQueue() {
        WebSocket ws = webSocket;
        if (ws != null) {
            ArrayList<String> tempQueue = new ArrayList<>();
            String message;
            while ((message = messageQueue.poll()) != null) {
                tempQueue.add(message);
            }
            for (String msg : tempQueue) {
                if (!ws.send(msg)) {
                    messageQueue.offer(msg);
                    for (int i = tempQueue.indexOf(msg) + 1; i < tempQueue.size(); i++) {
                        messageQueue.offer(tempQueue.get(i));
                    }
                    break;
                }
            }
        }
    }

    protected abstract void onWebSocketOpen(WebSocket webSocket, Response response);

    protected abstract void onWebSocketMessage(WebSocket webSocket, String text);

    protected abstract void onWebSocketFailure(WebSocket webSocket, Throwable t, Response response);

    protected abstract void onWebSocketClosed(WebSocket webSocket, int code, String reason);

    /**
     * Configuration options for automatic reconnection.
     */
    public static final class ReconnectOptions {
        public final long minReconnectionDelayMs;

        public final long maxReconnectionDelayMs;

        public final double reconnectionDelayGrowFactor;

        public final int maxRetries;

        public final int maxEnqueuedMessages;

        private ReconnectOptions(Builder builder) {
            this.minReconnectionDelayMs = builder.minReconnectionDelayMs;
            this.maxReconnectionDelayMs = builder.maxReconnectionDelayMs;
            this.reconnectionDelayGrowFactor = builder.reconnectionDelayGrowFactor;
            this.maxRetries = builder.maxRetries;
            this.maxEnqueuedMessages = builder.maxEnqueuedMessages;
        }

        public static Builder builder() {
            return new Builder();
        }

        public static final class Builder {
            private long minReconnectionDelayMs;

            private long maxReconnectionDelayMs;

            private double reconnectionDelayGrowFactor;

            private int maxRetries;

            private int maxEnqueuedMessages;

            public Builder() {
                this.minReconnectionDelayMs = 1000;
                this.maxReconnectionDelayMs = 10000;
                this.reconnectionDelayGrowFactor = 1.3;
                this.maxRetries = 2147483647;
                this.maxEnqueuedMessages = 1000;
            }

            public Builder minReconnectionDelayMs(long minReconnectionDelayMs) {
                this.minReconnectionDelayMs = minReconnectionDelayMs;
                return this;
            }

            public Builder maxReconnectionDelayMs(long maxReconnectionDelayMs) {
                this.maxReconnectionDelayMs = maxReconnectionDelayMs;
                return this;
            }

            public Builder reconnectionDelayGrowFactor(double reconnectionDelayGrowFactor) {
                this.reconnectionDelayGrowFactor = reconnectionDelayGrowFactor;
                return this;
            }

            public Builder maxRetries(int maxRetries) {
                this.maxRetries = maxRetries;
                return this;
            }

            public Builder maxEnqueuedMessages(int maxEnqueuedMessages) {
                this.maxEnqueuedMessages = maxEnqueuedMessages;
                return this;
            }

            /**
             * Builds the ReconnectOptions with validation.
             *
             * Validates that:
             * - All delay values are positive
             * - minReconnectionDelayMs <= maxReconnectionDelayMs
             * - reconnectionDelayGrowFactor >= 1.0
             * - maxRetries and maxEnqueuedMessages are non-negative
             *
             * @return The validated ReconnectOptions instance
             * @throws IllegalArgumentException if configuration is invalid
             */
            public ReconnectOptions build() {
                if (minReconnectionDelayMs <= 0) {
                    throw new IllegalArgumentException("minReconnectionDelayMs must be positive");
                }
                if (maxReconnectionDelayMs <= 0) {
                    throw new IllegalArgumentException("maxReconnectionDelayMs must be positive");
                }
                if (minReconnectionDelayMs > maxReconnectionDelayMs) {
                    throw new IllegalArgumentException("minReconnectionDelayMs (" + minReconnectionDelayMs
                            + ") must not exceed maxReconnectionDelayMs (" + maxReconnectionDelayMs + ")");
                }
                if (reconnectionDelayGrowFactor < 1.0) {
                    throw new IllegalArgumentException("reconnectionDelayGrowFactor must be >= 1.0");
                }
                if (maxRetries < 0) {
                    throw new IllegalArgumentException("maxRetries must be non-negative");
                }
                if (maxEnqueuedMessages < 0) {
                    throw new IllegalArgumentException("maxEnqueuedMessages must be non-negative");
                }
                return new ReconnectOptions(this);
            }
        }
    }
}

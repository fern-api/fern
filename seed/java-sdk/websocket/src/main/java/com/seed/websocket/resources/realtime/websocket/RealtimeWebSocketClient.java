/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.seed.websocket.resources.realtime.websocket;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.seed.websocket.core.ClientOptions;
import com.seed.websocket.core.ObjectMappers;
import com.seed.websocket.core.ReconnectingWebSocketListener;
import com.seed.websocket.resources.realtime.types.ReceiveEvent;
import com.seed.websocket.resources.realtime.types.ReceiveEvent2;
import com.seed.websocket.resources.realtime.types.ReceiveEvent3;
import com.seed.websocket.resources.realtime.types.ReceiveSnakeCase;
import com.seed.websocket.resources.realtime.types.SendEvent;
import com.seed.websocket.resources.realtime.types.SendEvent2;
import com.seed.websocket.resources.realtime.types.SendSnakeCase;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.WebSocket;

/**
 * WebSocket client for the realtime channel.
 * Provides real-time bidirectional communication with strongly-typed messages.
 */
public class RealtimeWebSocketClient {
    protected final ClientOptions clientOptions;

    private final ObjectMapper objectMapper;

    private final OkHttpClient okHttpClient;

    private ScheduledExecutorService timeoutExecutor;

    private volatile WebSocketReadyState readyState = WebSocketReadyState.CLOSED;

    private final String id;

    private final Optional<String> model;

    private final Optional<Integer> temperature;

    private Runnable onConnectedHandler;

    private Consumer<DisconnectReason> onDisconnectedHandler;

    private Consumer<Exception> onErrorHandler;

    private CompletableFuture<Void> connectionFuture;

    private ReconnectingWebSocketListener reconnectingListener;

    private Consumer<ReceiveEvent> receiveHandler;

    private Consumer<ReceiveSnakeCase> receiveSnakeCaseHandler;

    private Consumer<ReceiveEvent2> receive2Handler;

    private Consumer<ReceiveEvent3> receive3Handler;

    /**
     * Creates a new async WebSocket client for the realtime channel.
     * @param id the id path parameter
     * @param model Optional model query parameter
     * @param temperature Optional temperature query parameter
     */
    public RealtimeWebSocketClient(
            ClientOptions clientOptions, String id, Optional<String> model, Optional<Integer> temperature) {
        this.clientOptions = clientOptions;
        this.objectMapper = ObjectMappers.JSON_MAPPER;
        this.okHttpClient = clientOptions.httpClient();
        this.id = id;
        this.model = model;
        this.temperature = temperature;
    }

    /**
     * Establishes the WebSocket connection asynchronously with automatic reconnection.
     * @return a CompletableFuture that completes when the connection is established
     */
    public CompletableFuture<Void> connect() {
        connectionFuture = new CompletableFuture<>();
        String baseUrl = clientOptions.environment().getUrl();
        StringBuilder pathBuilder = new StringBuilder();
        pathBuilder.append("/realtime/");
        pathBuilder.append(id);
        pathBuilder.append("");
        String fullPath = pathBuilder.toString();
        if (baseUrl.endsWith("/") && fullPath.startsWith("/")) {
            fullPath = fullPath.substring(1);
        } else if (!baseUrl.endsWith("/") && !fullPath.startsWith("/")) {
            fullPath = "/" + fullPath;
        }
        HttpUrl.Builder urlBuilder = HttpUrl.parse(baseUrl + fullPath).newBuilder();
        if (model != null && model.isPresent()) {
            urlBuilder.addQueryParameter("model", String.valueOf(model.get()));
        }
        if (temperature != null && temperature.isPresent()) {
            urlBuilder.addQueryParameter("temperature", String.valueOf(temperature.get()));
        }
        Request.Builder requestBuilder = new Request.Builder().url(urlBuilder.build());
        clientOptions.headers(null).forEach(requestBuilder::addHeader);
        final Request request = requestBuilder.build();
        this.readyState = WebSocketReadyState.CONNECTING;
        ReconnectingWebSocketListener.ReconnectOptions reconnectOptions =
                ReconnectingWebSocketListener.ReconnectOptions.builder().build();
        this.reconnectingListener =
                new ReconnectingWebSocketListener(reconnectOptions, () -> {
                    if (clientOptions.webSocketFactory().isPresent()) {
                        return clientOptions.webSocketFactory().get().create(request, this.reconnectingListener);
                    } else {
                        return okHttpClient.newWebSocket(request, this.reconnectingListener);
                    }
                }) {
                    @Override
                    protected void onWebSocketOpen(WebSocket webSocket, Response response) {
                        readyState = WebSocketReadyState.OPEN;
                        if (onConnectedHandler != null) {
                            onConnectedHandler.run();
                        }
                        connectionFuture.complete(null);
                    }

                    @Override
                    protected void onWebSocketMessage(WebSocket webSocket, String text) {
                        handleIncomingMessage(text);
                    }

                    @Override
                    protected void onWebSocketFailure(WebSocket webSocket, Throwable t, Response response) {
                        readyState = WebSocketReadyState.CLOSED;
                        if (onErrorHandler != null) {
                            onErrorHandler.accept(new RuntimeException(t));
                        }
                        connectionFuture.completeExceptionally(t);
                    }

                    @Override
                    protected void onWebSocketClosed(WebSocket webSocket, int code, String reason) {
                        readyState = WebSocketReadyState.CLOSED;
                        if (onDisconnectedHandler != null) {
                            onDisconnectedHandler.accept(new DisconnectReason(code, reason));
                        }
                    }
                };
        reconnectingListener.connect();
        return connectionFuture;
    }

    /**
     * Disconnects the WebSocket connection and releases resources.
     */
    public void disconnect() {
        reconnectingListener.disconnect();
        if (timeoutExecutor != null) {
            timeoutExecutor.shutdownNow();
            timeoutExecutor = null;
        }
    }

    /**
     * Checks if a WebSocket instance exists (not necessarily connected).
     *
     * This method only verifies that a WebSocket object has been created, not whether
     * it's actively connected. For actual connection state, use getReadyState().
     *
     * @return true if a WebSocket instance exists, false otherwise
     * @deprecated Use getReadyState() for accurate connection status
     */
    @Deprecated
    public boolean hasWebSocketInstance() {
        // Check if WebSocket connection is open based on ready state
        return readyState == WebSocketReadyState.OPEN || readyState == WebSocketReadyState.CONNECTING;
    }

    /**
     * Gets the current state of the WebSocket connection.
     *
     * This provides the actual connection state, similar to the W3C WebSocket API.
     *
     * @return the current WebSocket ready state
     */
    public WebSocketReadyState getReadyState() {
        return readyState;
    }

    /**
     * Sends a send message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSend(SendEvent message) {
        return sendMessage("send", message);
    }

    /**
     * Sends a send_snake_case message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSendSnakeCase(SendSnakeCase message) {
        return sendMessage("send_snake_case", message);
    }

    /**
     * Sends a send2 message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSend2(SendEvent2 message) {
        return sendMessage("send2", message);
    }

    /**
     * Registers a handler for receive messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive(Consumer<ReceiveEvent> handler) {
        this.receiveHandler = handler;
    }

    /**
     * Registers a handler for receive_snake_case messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceiveSnakeCase(Consumer<ReceiveSnakeCase> handler) {
        this.receiveSnakeCaseHandler = handler;
    }

    /**
     * Registers a handler for receive2 messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive2(Consumer<ReceiveEvent2> handler) {
        this.receive2Handler = handler;
    }

    /**
     * Registers a handler for receive3 messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive3(Consumer<ReceiveEvent3> handler) {
        this.receive3Handler = handler;
    }

    /**
     * Registers a handler called when the connection is established.
     * @param handler the handler to invoke when connected
     */
    public void onConnected(Runnable handler) {
        this.onConnectedHandler = handler;
    }

    /**
     * Registers a handler called when the connection is closed.
     * @param handler the handler to invoke when disconnected
     */
    public void onDisconnected(Consumer<DisconnectReason> handler) {
        this.onDisconnectedHandler = handler;
    }

    /**
     * Registers a handler called when an error occurs.
     * @param handler the handler to invoke on error
     */
    public void onError(Consumer<Exception> handler) {
        this.onErrorHandler = handler;
    }

    /**
     * Ensures the WebSocket is connected and ready to send messages.
     * @throws IllegalStateException if the socket is not connected or not open
     */
    private void assertSocketIsOpen() {
        if (reconnectingListener.getWebSocket() == null) {
            throw new IllegalStateException("WebSocket is not connected. Call connect() first.");
        }
        if (readyState != WebSocketReadyState.OPEN) {
            throw new IllegalStateException("WebSocket is not open. Current state: " + readyState);
        }
    }

    private CompletableFuture<Void> sendMessage(String type, Object body) {
        CompletableFuture<Void> future = new CompletableFuture<>();
        try {
            assertSocketIsOpen();
            Map<String, Object> envelope = new HashMap<>();
            envelope.put("type", type);
            envelope.put("body", body);
            String json = objectMapper.writeValueAsString(envelope);
            // Use reconnecting listener's send method which handles queuing
            boolean sent = reconnectingListener.send(json);
            if (sent) {
                future.complete(null);
            } else {
                // Message was queued for later delivery when reconnected
                future.complete(null);
            }
        } catch (IllegalStateException e) {
            future.completeExceptionally(e);
        } catch (Exception e) {
            future.completeExceptionally(new RuntimeException("Failed to send message", e));
        }
        return future;
    }

    private void handleIncomingMessage(String json) {
        try {
            JsonNode envelope = objectMapper.readTree(json);
            if (envelope == null || envelope.isNull()) {
                throw new IllegalArgumentException("Received null or invalid JSON envelope");
            }
            JsonNode typeNode = envelope.get("type");
            if (typeNode == null || typeNode.isNull()) {
                throw new IllegalArgumentException("Message envelope missing 'type' field");
            }
            String type = typeNode.asText();
            JsonNode body = envelope.get("body");
            if (body == null) {
                throw new IllegalArgumentException("Message envelope missing 'body' field");
            }
            switch (type) {
                case "receive":
                    if (receiveHandler != null) {
                        ReceiveEvent event = objectMapper.treeToValue(body, ReceiveEvent.class);
                        if (event != null) {
                            receiveHandler.accept(event);
                        }
                    }
                    break;
                case "receive_snake_case":
                    if (receiveSnakeCaseHandler != null) {
                        ReceiveSnakeCase event = objectMapper.treeToValue(body, ReceiveSnakeCase.class);
                        if (event != null) {
                            receiveSnakeCaseHandler.accept(event);
                        }
                    }
                    break;
                case "receive2":
                    if (receive2Handler != null) {
                        ReceiveEvent2 event = objectMapper.treeToValue(body, ReceiveEvent2.class);
                        if (event != null) {
                            receive2Handler.accept(event);
                        }
                    }
                    break;
                case "receive3":
                    if (receive3Handler != null) {
                        ReceiveEvent3 event = objectMapper.treeToValue(body, ReceiveEvent3.class);
                        if (event != null) {
                            receive3Handler.accept(event);
                        }
                    }
                    break;
                default:
                    // Unknown message type - log or ignore;
                    break;
            }
        } catch (IllegalArgumentException e) {
            if (onErrorHandler != null) {
                onErrorHandler.accept(e);
            }
        } catch (Exception e) {
            if (onErrorHandler != null) {
                onErrorHandler.accept(e);
            }
        }
    }

    /**
     * Reason for WebSocket disconnection.
     */
    public static class DisconnectReason {
        private final int code;

        private final String reason;

        public DisconnectReason(int code, String reason) {
            this.code = code;
            this.reason = reason;
        }

        public int getCode() {
            return code;
        }

        public String getReason() {
            return reason;
        }
    }

    /**
     * WebSocket connection ready state, based on the W3C WebSocket API.
     */
    public enum WebSocketReadyState {
        /**
         * The connection is being established.
         */
        CONNECTING,

        /**
         * The connection is open and ready to communicate.
         */
        OPEN,

        /**
         * The connection is in the process of closing.
         */
        CLOSING,

        /**
         * The connection is closed.
         */
        CLOSED
    }
}

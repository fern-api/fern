/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.seed.websocket.resources.realtime.websocket;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.seed.websocket.core.ClientOptions;
import com.seed.websocket.core.ObjectMappers;
import com.seed.websocket.resources.realtime.types.ReceiveEvent;
import com.seed.websocket.resources.realtime.types.ReceiveEvent2;
import com.seed.websocket.resources.realtime.types.ReceiveEvent3;
import com.seed.websocket.resources.realtime.types.ReceiveSnakeCase;
import com.seed.websocket.resources.realtime.types.SendEvent;
import com.seed.websocket.resources.realtime.types.SendEvent2;
import com.seed.websocket.resources.realtime.types.SendSnakeCase;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.WebSocket;
import okhttp3.WebSocketListener;

/**
 * WebSocket client for the realtime channel.
 * Provides real-time bidirectional communication with strongly-typed messages.
 */
public class RealtimeWebSocketClient {
    protected final ClientOptions clientOptions;

    private final ObjectMapper objectMapper;

    private final OkHttpClient okHttpClient;

    private WebSocket webSocket;

    private final String id;

    private final Optional<String> model;

    private final Optional<Integer> temperature;

    private Runnable onConnectedHandler;

    private Consumer<DisconnectReason> onDisconnectedHandler;

    private Consumer<Exception> onErrorHandler;

    private CompletableFuture<Void> connectionFuture;

    private Consumer<ReceiveEvent> receiveHandler;

    private Consumer<ReceiveSnakeCase> receiveSnakeCaseHandler;

    private Consumer<ReceiveEvent2> receive2Handler;

    private Consumer<ReceiveEvent3> receive3Handler;

    /**
     * Creates a new async WebSocket client for the realtime channel.
     * @param id the id path parameter
     * @param model Optional model query parameter
     * @param temperature Optional temperature query parameter
     */
    public RealtimeWebSocketClient(
            ClientOptions clientOptions, String id, Optional<String> model, Optional<Integer> temperature) {
        this.clientOptions = clientOptions;
        this.objectMapper = ObjectMappers.JSON_MAPPER;
        this.okHttpClient = clientOptions.httpClient();
        this.id = id;
        this.model = model;
        this.temperature = temperature;
    }

    /**
     * Establishes the WebSocket connection asynchronously.
     * @return a CompletableFuture that completes when the connection is established
     */
    public CompletableFuture<Void> connect() {
        connectionFuture = new CompletableFuture<>();
        String baseUrl = clientOptions.environment().getUrl();
        StringBuilder pathBuilder = new StringBuilder();
        pathBuilder.append("/realtime/");
        pathBuilder.append(id);
        pathBuilder.append("");
        String fullPath = pathBuilder.toString();
        if (baseUrl.endsWith("/") && fullPath.startsWith("/")) {
            fullPath = fullPath.substring(1);
        } else if (!baseUrl.endsWith("/") && !fullPath.startsWith("/")) {
            fullPath = "/" + fullPath;
        }
        HttpUrl.Builder urlBuilder = HttpUrl.parse(baseUrl + fullPath).newBuilder();
        if (model != null && model.isPresent()) {
            urlBuilder.addQueryParameter("model", String.valueOf(model.get()));
        }
        if (temperature != null && temperature.isPresent()) {
            urlBuilder.addQueryParameter("temperature", String.valueOf(temperature.get()));
        }
        Request.Builder requestBuilder = new Request.Builder().url(urlBuilder.build());
        clientOptions.headers(null).forEach(requestBuilder::addHeader);
        Request request = requestBuilder.build();
        this.webSocket = okHttpClient.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket webSocket, Response response) {
                if (onConnectedHandler != null) {
                    onConnectedHandler.run();
                }
                connectionFuture.complete(null);
            }

            @Override
            public void onMessage(WebSocket webSocket, String text) {
                handleIncomingMessage(text);
            }

            @Override
            public void onFailure(WebSocket webSocket, Throwable t, Response response) {
                if (onErrorHandler != null) {
                    onErrorHandler.accept(new RuntimeException(t));
                }
                connectionFuture.completeExceptionally(t);
            }

            @Override
            public void onClosed(WebSocket webSocket, int code, String reason) {
                if (onDisconnectedHandler != null) {
                    onDisconnectedHandler.accept(new DisconnectReason(code, reason));
                }
            }
        });
        Executors.newSingleThreadScheduledExecutor()
                .schedule(
                        () -> {
                            ;
                            if (!connectionFuture.isDone()) {
                                connectionFuture.completeExceptionally(new TimeoutException("Connection timeout"));
                                if (webSocket != null) {
                                    webSocket.close(1000, "Connection timeout");
                                    webSocket = null;
                                }
                            }
                        },
                        10,
                        TimeUnit.SECONDS);
        return connectionFuture;
    }

    /**
     * Disconnects the WebSocket connection.
     */
    public void disconnect() {
        if (webSocket != null) {
            webSocket.close(1000, "Client disconnecting");
        }
    }

    /**
     * Checks if the WebSocket is currently connected.
     *
     * NOTE: This method only checks if a WebSocket object exists, not if the connection
     * is actively connected. The connection may have been closed by the server or due to
     * network issues without immediate notification. For accurate connection state tracking,
     * use the onDisconnected() callback or handle errors from send operations.
     *
     * @return true if a WebSocket object exists (may be disconnected), false otherwise
     */
    public boolean isConnected() {
        return webSocket != null;
    }

    /**
     * Sends a send message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSend(SendEvent message) {
        return sendMessage("send", message);
    }

    /**
     * Sends a send_snake_case message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSendSnakeCase(SendSnakeCase message) {
        return sendMessage("send_snake_case", message);
    }

    /**
     * Sends a send2 message to the server asynchronously.
     * @param message the message to send
     * @return a CompletableFuture that completes when the message is sent
     */
    public CompletableFuture<Void> sendSend2(SendEvent2 message) {
        return sendMessage("send2", message);
    }

    /**
     * Registers a handler for receive messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive(Consumer<ReceiveEvent> handler) {
        this.receiveHandler = handler;
    }

    /**
     * Registers a handler for receive_snake_case messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceiveSnakeCase(Consumer<ReceiveSnakeCase> handler) {
        this.receiveSnakeCaseHandler = handler;
    }

    /**
     * Registers a handler for receive2 messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive2(Consumer<ReceiveEvent2> handler) {
        this.receive2Handler = handler;
    }

    /**
     * Registers a handler for receive3 messages from the server.
     * @param handler the handler to invoke when a message is received
     */
    public void onReceive3(Consumer<ReceiveEvent3> handler) {
        this.receive3Handler = handler;
    }

    /**
     * Registers a handler called when the connection is established.
     * @param handler the handler to invoke when connected
     */
    public void onConnected(Runnable handler) {
        this.onConnectedHandler = handler;
    }

    /**
     * Registers a handler called when the connection is closed.
     * @param handler the handler to invoke when disconnected
     */
    public void onDisconnected(Consumer<DisconnectReason> handler) {
        this.onDisconnectedHandler = handler;
    }

    /**
     * Registers a handler called when an error occurs.
     * @param handler the handler to invoke on error
     */
    public void onError(Consumer<Exception> handler) {
        this.onErrorHandler = handler;
    }

    /**
     * Ensures the WebSocket is connected and ready to send messages.
     * @throws IllegalStateException if the socket is not connected or not open
     */
    private void assertSocketIsOpen() {
        if (webSocket == null) {
            throw new IllegalStateException("WebSocket is not connected. Call connect() first.");
        }
    }

    private CompletableFuture<Void> sendMessage(String type, Object body) {
        CompletableFuture<Void> future = new CompletableFuture<>();
        try {
            assertSocketIsOpen();
            Map<String, Object> envelope = new HashMap<>();
            envelope.put("type", type);
            envelope.put("body", body);
            String json = objectMapper.writeValueAsString(envelope);
            boolean queued = webSocket.send(json);
            if (queued) {
                future.complete(null);
            } else {
                future.completeExceptionally(
                        new RuntimeException("Failed to queue message - WebSocket may be closing or closed"));
            }
        } catch (IllegalStateException e) {
            future.completeExceptionally(e);
        } catch (Exception e) {
            future.completeExceptionally(new RuntimeException("Failed to send message", e));
        }
        return future;
    }

    private void handleIncomingMessage(String json) {
        try {
            JsonNode envelope = objectMapper.readTree(json);
            if (envelope == null || envelope.isNull()) {
                throw new IllegalArgumentException("Received null or invalid JSON envelope");
            }
            JsonNode typeNode = envelope.get("type");
            if (typeNode == null || typeNode.isNull()) {
                throw new IllegalArgumentException("Message envelope missing 'type' field");
            }
            String type = typeNode.asText();
            JsonNode body = envelope.get("body");
            if (body == null) {
                throw new IllegalArgumentException("Message envelope missing 'body' field");
            }
            switch (type) {
                case "receive":
                    if (receiveHandler != null) {
                        ReceiveEvent event = objectMapper.treeToValue(body, ReceiveEvent.class);
                        if (event != null) {
                            receiveHandler.accept(event);
                        }
                    }
                    break;
                case "receive_snake_case":
                    if (receiveSnakeCaseHandler != null) {
                        ReceiveSnakeCase event = objectMapper.treeToValue(body, ReceiveSnakeCase.class);
                        if (event != null) {
                            receiveSnakeCaseHandler.accept(event);
                        }
                    }
                    break;
                case "receive2":
                    if (receive2Handler != null) {
                        ReceiveEvent2 event = objectMapper.treeToValue(body, ReceiveEvent2.class);
                        if (event != null) {
                            receive2Handler.accept(event);
                        }
                    }
                    break;
                case "receive3":
                    if (receive3Handler != null) {
                        ReceiveEvent3 event = objectMapper.treeToValue(body, ReceiveEvent3.class);
                        if (event != null) {
                            receive3Handler.accept(event);
                        }
                    }
                    break;
                default:
                    // Unknown message type - log or ignore;
                    break;
            }
        } catch (IllegalArgumentException e) {
            if (onErrorHandler != null) {
                onErrorHandler.accept(e);
            }
        } catch (Exception e) {
            if (onErrorHandler != null) {
                onErrorHandler.accept(e);
            }
        }
    }

    /**
     * Reason for WebSocket disconnection.
     */
    public static class DisconnectReason {
        private final int code;

        private final String reason;

        public DisconnectReason(int code, String reason) {
            this.code = code;
            this.reason = reason;
        }

        public int getCode() {
            return code;
        }

        public String getReason() {
            return reason;
        }
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.seed.endpointSecurityAuth.core;

import com.seed.endpointSecurityAuth.resources.auth.AuthClient;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Auth provider for OAuth client credentials authentication.
 * Handles token acquisition and caching with automatic refresh on expiration.
 */
public final class OAuthAuthProvider implements AuthProvider {
    public static final String AUTH_SCHEME = "OAuth";

    public static final String AUTH_CONFIG_ERROR_MESSAGE =
            "Please provide clientId and clientSecret via .clientId()/.clientSecret() or set MY_CLIENT_ID and MY_CLIENT_SECRET environment variables";

    private static final long BUFFER_IN_MINUTES = 2;

    private final Supplier<String> clientIdSupplier;

    private final Supplier<String> clientSecretSupplier;

    private final AuthClient authClient;

    private String accessToken;

    private Instant expiresAt;

    private final Object refreshLock = new Object();

    public OAuthAuthProvider(
            Supplier<String> clientIdSupplier, Supplier<String> clientSecretSupplier, AuthClient authClient) {
        this.clientIdSupplier = clientIdSupplier;
        this.clientSecretSupplier = clientSecretSupplier;
        this.authClient = authClient;
        this.expiresAt = Instant.now();
    }

    @Override
    public Map<String, String> getAuthHeaders(EndpointMetadata endpointMetadata) {
        String token = getToken();
        Map<String, String> headers = new HashMap<>();
        headers.put("Authorization", "Bearer " + token);
        return headers;
    }

    private String getToken() {
        // Check if we have a valid cached token
        if (this.accessToken != null && this.expiresAt.isAfter(Instant.now())) {
            return this.accessToken;
        }
        // Need to refresh - synchronize to prevent concurrent refreshes
        synchronized (refreshLock) {
            // Double-check after acquiring lock
            if (this.accessToken != null && this.expiresAt.isAfter(Instant.now())) {
                return this.accessToken;
            }
            return refresh();
        }
    }

    private String refresh() {
        String clientId = this.clientIdSupplier.get();
        String clientSecret = this.clientSecretSupplier.get();
        if (clientId == null || clientSecret == null) {
            throw new RuntimeException(AUTH_CONFIG_ERROR_MESSAGE);
        }
        // Create a temporary token supplier to fetch the token
        OAuthTokenSupplier tokenSupplier = new OAuthTokenSupplier(clientId, clientSecret, this.authClient);
        // The token supplier's get() method handles fetching and returns the full auth header value
        String authHeader = tokenSupplier.get();
        // Extract just the token part (remove 'Bearer ' prefix)
        if (authHeader.startsWith("Bearer ")) {
            this.accessToken = authHeader.substring(7);
        } else {
            this.accessToken = authHeader;
        }
        // Set expiration with buffer (we don't have access to expires_in here, so use 1 hour default)
        this.expiresAt = getExpiresAt(3600);
        return this.accessToken;
    }

    private Instant getExpiresAt(long expiresInSeconds) {
        return Instant.now().plus(expiresInSeconds, ChronoUnit.SECONDS).minus(BUFFER_IN_MINUTES, ChronoUnit.MINUTES);
    }

    /**
     * Checks if this provider can be created with the given suppliers.
     */
    public static boolean canCreate(Supplier<String> clientIdSupplier, Supplier<String> clientSecretSupplier) {
        return (clientIdSupplier != null || System.getenv("MY_CLIENT_ID") != null)
                && (clientSecretSupplier != null || System.getenv("MY_CLIENT_SECRET") != null);
    }
}

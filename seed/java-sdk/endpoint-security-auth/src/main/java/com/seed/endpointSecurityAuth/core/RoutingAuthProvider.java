/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.seed.endpointSecurityAuth.core;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Auth provider that routes to the appropriate provider based on endpoint security requirements.
 * This implements the ENDPOINT_SECURITY auth mode where each endpoint can have different auth.
 */
public final class RoutingAuthProvider implements AuthProvider {
    private final Map<String, AuthProvider> authProviders;

    private final Map<String, String> authConfigErrorMessages;

    private RoutingAuthProvider(Map<String, AuthProvider> authProviders, Map<String, String> authConfigErrorMessages) {
        this.authProviders = authProviders;
        this.authConfigErrorMessages = authConfigErrorMessages;
    }

    private String getAuthConfigErrorMessage(String schemeKey) {
        String message = this.authConfigErrorMessages.get(schemeKey);
        if (message != null) {
            return message;
        }
        return "Please provide the required authentication credentials for " + schemeKey
                + " when initializing the client";
    }

    @Override
    public Map<String, String> getAuthHeaders(EndpointMetadata endpointMetadata) {
        List<Map<String, List<String>>> security = endpointMetadata.getSecurity();

        // If no security requirements, return empty headers
        if (security == null || security.isEmpty()) {
            return new HashMap<>();
        }

        // Check if any security requirement can be satisfied by available providers
        boolean canSatisfyAnyRequirement = security.stream()
                .anyMatch(securityRequirement -> securityRequirement.keySet().stream()
                        .allMatch(schemeKey -> authProviders.containsKey(schemeKey)));

        if (!canSatisfyAnyRequirement) {
            // Build user-friendly error message showing which auth options are missing
            String missingAuthHints = security.stream()
                    .map(req -> req.keySet().stream()
                            .filter(key -> !authProviders.containsKey(key))
                            .map(this::getAuthConfigErrorMessage)
                            .collect(Collectors.joining(" AND ")))
                    .collect(Collectors.joining(" OR "));
            throw new RuntimeException(
                    "No authentication credentials provided that satisfy the endpoint's security requirements. "
                            + missingAuthHints);
        }

        // Get the first security requirement that can be satisfied (OR relationship)
        Map<String, List<String>> satisfiableRequirement = security.stream()
                .filter(securityRequirement -> securityRequirement.keySet().stream()
                        .allMatch(schemeKey -> authProviders.containsKey(schemeKey)))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Internal error: no satisfiable requirement found"));

        // Get auth for all schemes in the satisfiable requirement (AND relationship)
        Map<String, String> combinedHeaders = new HashMap<>();
        for (String schemeKey : satisfiableRequirement.keySet()) {
            AuthProvider provider = authProviders.get(schemeKey);
            if (provider == null) {
                throw new RuntimeException("Internal error: auth provider not found for scheme: " + schemeKey);
            }
            Map<String, String> headers = provider.getAuthHeaders(endpointMetadata);
            combinedHeaders.putAll(headers);
        }

        return combinedHeaders;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static final class Builder {
        private final Map<String, AuthProvider> authProviders = new HashMap<>();

        private final Map<String, String> authConfigErrorMessages = new HashMap<>();

        public Builder addAuthProvider(String schemeName, AuthProvider provider) {
            this.authProviders.put(schemeName, provider);
            return this;
        }

        public Builder addAuthProvider(String schemeName, AuthProvider provider, String errorMessage) {
            this.authProviders.put(schemeName, provider);
            this.authConfigErrorMessages.put(schemeName, errorMessage);
            return this;
        }

        public RoutingAuthProvider build() {
            return new RoutingAuthProvider(this.authProviders, this.authConfigErrorMessages);
        }
    }
}

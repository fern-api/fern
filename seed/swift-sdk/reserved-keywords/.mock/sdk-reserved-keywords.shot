// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as core from \\"./core\\";
import { Package } from \\"./api/resources/package/client/Client\\";
export declare namespace FernApiClient {
    interface Options {
        environment: core.Supplier<string>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
    }
}
export declare class FernApiClient {
    protected readonly _options: FernApiClient.Options;
    constructor(_options: FernApiClient.Options);
    protected _package: Package | undefined;
    get package(): Package;
}
",
    "name": "Client.d.ts",
    "type": "file",
  },
  Object {
    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.FernApiClient = void 0;
const Client_1 = require(\\"./api/resources/package/client/Client\\");
class FernApiClient {
    constructor(_options) {
        this._options = _options;
    }
    get package() {
        var _a;
        return ((_a = this._package) !== null && _a !== void 0 ? _a : (this._package = new Client_1.Package(this._options)));
    }
}
exports.FernApiClient = FernApiClient;
",
    "name": "Client.js",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./resources\\"), exports);
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
export * from \\"./package/client/requests\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.package_ = void 0;
exports.package_ = __importStar(require(\\"./package\\"));
__exportStar(require(\\"./package/types\\"), exports);
__exportStar(require(\\"./package/client/requests\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as core from \\"../../../../core\\";
import * as FernApi from \\"../../..\\";
export declare namespace Package {
    interface Options {
        environment: core.Supplier<string>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
    }
}
export declare class Package {
    protected readonly _options: Package.Options;
    constructor(_options: Package.Options);
    test(request: FernApi.TestRequest, requestOptions?: Package.RequestOptions): Promise<core.APIResponse<void, FernApi.package_.test.Error>>;
}
",
                    "name": "Client.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { \\"default\\": mod };
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Package = void 0;
const core = __importStar(require(\\"../../../../core\\"));
const FernApi = __importStar(require(\\"../../..\\"));
const url_search_params_1 = __importDefault(require(\\"@ungap/url-search-params\\"));
class Package {
    constructor(_options) {
        this._options = _options;
    }
    test(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { for: for_ } = request;
            const _queryParams = new url_search_params_1.default();
            _queryParams.append(\\"for\\", for_);
            const _response = yield core.fetcher({
                url: yield core.Supplier.get(this._options.environment),
                method: \\"POST\\",
                headers: {
                    \\"X-Fern-Language\\": \\"JavaScript\\",
                },
                contentType: \\"application/json\\",
                queryParameters: _queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            });
            if (_response.ok) {
                return {
                    ok: true,
                    body: undefined,
                };
            }
            return {
                ok: false,
                error: FernApi.package_.test.Error._unknown(_response.error),
            };
        });
    }
}
exports.Package = Package;
",
                    "name": "Client.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./requests\\";
export * as test from \\"./test\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.test = void 0;
__exportStar(require(\\"./requests\\"), exports);
exports.test = __importStar(require(\\"./test\\"));
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export interface TestRequest {
    for: string;
}
",
                        "name": "TestRequest.d.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                        "name": "TestRequest.js",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { TestRequest } from \\"./TestRequest\\";
",
                        "name": "index.d.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                        "name": "index.js",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as FernApi from \\"../../..\\";
import * as core from \\"../../../../core\\";
export declare type Error = FernApi.package_.test.Error._Unknown;
export declare namespace Error {
    interface _Unknown extends _Utils {
        errorName: void;
        content: core.Fetcher.Error;
    }
    interface _Utils {
        _visit: <_Result>(visitor: FernApi.package_.test.Error._Visitor<_Result>) => _Result;
    }
    interface _Visitor<_Result> {
        _other: (value: core.Fetcher.Error) => _Result;
    }
}
export declare const Error: {
    readonly _unknown: (fetcherError: core.Fetcher.Error) => FernApi.package_.test.Error._Unknown;
    readonly _visit: <_Result>(value: FernApi.package_.test.Error, visitor: FernApi.package_.test.Error._Visitor<_Result>) => _Result;
};
",
                    "name": "test.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Error = void 0;
const FernApi = __importStar(require(\\"../../..\\"));
exports.Error = {
    _unknown: (fetcherError) => {
        return {
            errorName: undefined,
            content: fetcherError,
            _visit: function (visitor) {
                return FernApi.package_.test.Error._visit(this, visitor);
            },
        };
    },
    _visit: (value, visitor) => {
        switch (value.errorName) {
            default:
                return visitor._other(value);
        }
    },
};
",
                    "name": "test.js",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./types\\"), exports);
__exportStar(require(\\"./client\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export interface Package {
    name: string;
}
",
                    "name": "Package.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "Package.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export interface Record_ {
    foo: Record<string, string>;
    \\"3D\\": number;
}
",
                    "name": "Record_.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "Record_.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
export * from \\"./Record_\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./Package\\"), exports);
__exportStar(require(\\"./Record_\\"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export declare type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;
export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}
export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
            "name": "APIResponse.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
            "name": "APIResponse.js",
            "type": "file",
          },
          Object {
            "contents": "import { default as URLSearchParams } from \\"@ungap/url-search-params\\";
import { AxiosAdapter } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";
export declare type FetchFunction = <R = unknown>(args: Fetcher.Args) => Promise<APIResponse<R, Fetcher.Error>>;
export declare namespace Fetcher {
    interface Args {
        url: string;
        method: string;
        contentType?: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
        responseType?: \\"json\\" | \\"blob\\";
        adapter?: AxiosAdapter;
        onUploadProgress?: (event: ProgressEvent) => void;
    }
    type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;
    interface FailedStatusCodeError {
        reason: \\"status-code\\";
        statusCode: number;
        body: unknown;
    }
    interface NonJsonError {
        reason: \\"non-json\\";
        statusCode: number;
        rawBody: string;
    }
    interface TimeoutError {
        reason: \\"timeout\\";
    }
    interface UnknownError {
        reason: \\"unknown\\";
        errorMessage: string;
    }
}
export declare const fetcher: FetchFunction;
",
            "name": "Fetcher.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { \\"default\\": mod };
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.fetcher = void 0;
const axios_1 = __importDefault(require(\\"axios\\"));
const axios_retry_1 = __importDefault(require(\\"axios-retry\\"));
const INITIAL_RETRY_DELAY = 1;
const MAX_RETRY_DELAY = 60;
const MAX_RETRIES = 5;
const AXIOS = axios_1.default.create();
function fetcherImpl(args) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {};
        if (args.body !== undefined && args.contentType != null) {
            headers[\\"Content-Type\\"] = args.contentType;
        }
        if (args.headers != null) {
            for (const [key, value] of Object.entries(args.headers)) {
                if (value != null) {
                    headers[key] = value;
                }
            }
        }
        (0, axios_retry_1.default)(AXIOS, {
            retries: MAX_RETRIES,
            retryCondition: (error) => {
                return error.response != null && [500, 502, 429].includes(error.response.status);
            },
            retryDelay: (count) => {
                if (count == 0) {
                    return INITIAL_RETRY_DELAY;
                }
                // Apply exponential backoff, but not more than the max.
                return Math.min(INITIAL_RETRY_DELAY * Math.pow(count - 1, 2), MAX_RETRY_DELAY);
            },
        });
        try {
            const response = yield AXIOS.request({
                url: args.url,
                params: args.queryParameters,
                method: args.method,
                headers,
                data: args.body,
                validateStatus: () => true,
                transformResponse: (response) => response,
                timeout: args.timeoutMs,
                transitional: {
                    clarifyTimeoutError: true,
                },
                withCredentials: args.withCredentials,
                adapter: args.adapter,
                onUploadProgress: args.onUploadProgress,
                maxBodyLength: Infinity,
                maxContentLength: Infinity,
                responseType: (_a = args.responseType) !== null && _a !== void 0 ? _a : \\"json\\",
            });
            let body;
            if (args.responseType === \\"blob\\") {
                body = response.data;
            }
            else if (response.data != null && response.data.length > 0) {
                try {
                    body = (_b = JSON.parse(response.data)) !== null && _b !== void 0 ? _b : undefined;
                }
                catch (_c) {
                    return {
                        ok: false,
                        error: {
                            reason: \\"non-json\\",
                            statusCode: response.status,
                            rawBody: response.data,
                        },
                    };
                }
            }
            if (response.status >= 200 && response.status < 400) {
                return {
                    ok: true,
                    body: body,
                };
            }
            else {
                return {
                    ok: false,
                    error: {
                        reason: \\"status-code\\",
                        statusCode: response.status,
                        body,
                    },
                };
            }
        }
        catch (error) {
            if (error.code === \\"ETIMEDOUT\\") {
                return {
                    ok: false,
                    error: {
                        reason: \\"timeout\\",
                    },
                };
            }
            return {
                ok: false,
                error: {
                    reason: \\"unknown\\",
                    errorMessage: error.message,
                },
            };
        }
    });
}
exports.fetcher = fetcherImpl;
",
            "name": "Fetcher.js",
            "type": "file",
          },
          Object {
            "contents": "export declare type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
export declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};
",
            "name": "Supplier.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Supplier = void 0;
exports.Supplier = {
    get: (supplier) => __awaiter(void 0, void 0, void 0, function* () {
        if (typeof supplier === \\"function\\") {
            return supplier();
        }
        else {
            return supplier;
        }
    }),
};
",
            "name": "Supplier.js",
            "type": "file",
          },
          Object {
            "contents": "export type { APIResponse } from \\"./APIResponse\\";
export { fetcher } from \\"./Fetcher\\";
export type { Fetcher, FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Supplier = exports.fetcher = void 0;
var Fetcher_1 = require(\\"./Fetcher\\");
Object.defineProperty(exports, \\"fetcher\\", { enumerable: true, get: function () { return Fetcher_1.fetcher; } });
var Supplier_1 = require(\\"./Supplier\\");
Object.defineProperty(exports, \\"Supplier\\", { enumerable: true, get: function () { return Supplier_1.Supplier; } });
",
            "name": "index.js",
            "type": "file",
          },
        ],
        "name": "fetcher",
        "type": "directory",
      },
      Object {
        "contents": "export * from \\"./fetcher\\";
export * as serialization from \\"./schemas\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.serialization = void 0;
__exportStar(require(\\"./fetcher\\"), exports);
exports.serialization = __importStar(require(\\"./schemas\\"));
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";
import { MaybePromise } from \\"./utils/MaybePromise\\";
export declare type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export declare type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export declare type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;
export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}
export declare const SchemaType: {
    readonly DATE: \\"date\\";
    readonly ENUM: \\"enum\\";
    readonly LIST: \\"list\\";
    readonly STRING_LITERAL: \\"stringLiteral\\";
    readonly OBJECT: \\"object\\";
    readonly ANY: \\"any\\";
    readonly BOOLEAN: \\"boolean\\";
    readonly NUMBER: \\"number\\";
    readonly STRING: \\"string\\";
    readonly UNKNOWN: \\"unknown\\";
    readonly RECORD: \\"record\\";
    readonly SET: \\"set\\";
    readonly UNION: \\"union\\";
    readonly UNDISCRIMINATED_UNION: \\"undiscriminatedUnion\\";
    readonly OPTIONAL: \\"optional\\";
};
export declare type SchemaType = typeof SchemaType[keyof typeof SchemaType];
export declare type MaybeValid<T> = Valid<T> | Invalid;
export interface Valid<T> {
    ok: true;
    value: T;
}
export interface Invalid {
    ok: false;
    errors: ValidationError[];
}
export interface ValidationError {
    path: string[];
    message: string;
}
export interface SchemaOptions {
    /**
     * how to handle unrecognized keys in objects
     *
     * @default \\"fail\\"
     */
    unrecognizedObjectKeys?: \\"fail\\" | \\"passthrough\\" | \\"strip\\";
    /**
     * whether to fail when an unrecognized discriminant value is
     * encountered in a union
     *
     * @default false
     */
    allowUnrecognizedUnionMembers?: boolean;
    /**
     * whether to fail when an unrecognized enum value is encountered
     *
     * @default false
     */
    allowUnrecognizedEnumValues?: boolean;
    /**
     * whether to allow data that doesn't conform to the schema.
     * invalid data is passed through without transformation.
     *
     * when this is enabled, .parse() and .json() will always
     * return \`ok: true\`. \`.parseOrThrow()\` and \`.jsonOrThrow()\`
     * will never fail.
     *
     * @default false
     */
    skipValidation?: boolean;
    /**
     * each validation failure contains a \\"path\\" property, which is
     * the breadcrumbs to the offending node in the JSON. you can supply
     * a prefix that is prepended to all the errors' paths. this can be
     * helpful for zurg's internal debug logging.
     */
    breadcrumbsPrefix?: string[];
}
",
            "name": "Schema.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.SchemaType = void 0;
exports.SchemaType = {
    DATE: \\"date\\",
    ENUM: \\"enum\\",
    LIST: \\"list\\",
    STRING_LITERAL: \\"stringLiteral\\",
    OBJECT: \\"object\\",
    ANY: \\"any\\",
    BOOLEAN: \\"boolean\\",
    NUMBER: \\"number\\",
    STRING: \\"string\\",
    UNKNOWN: \\"unknown\\",
    RECORD: \\"record\\",
    SET: \\"set\\",
    UNION: \\"union\\",
    UNDISCRIMINATED_UNION: \\"undiscriminatedUnion\\",
    OPTIONAL: \\"optional\\",
};
",
            "name": "Schema.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function date(): Schema<string, Date>;
",
                    "name": "date.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.date = void 0;
const Schema_1 = require(\\"../../Schema\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const schema_utils_1 = require(\\"../schema-utils\\");
// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX = /^([+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([.,]\\\\d+)?)?([zZ]|([+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;
function date() {
    const baseSchema = {
        parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
            if (typeof raw !== \\"string\\") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \\"string\\"),
                        },
                    ],
                };
            }
            if (!ISO_8601_REGEX.test(raw)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \\"ISO 8601 date string\\"),
                        },
                    ],
                };
            }
            return {
                ok: true,
                value: new Date(raw),
            };
        },
        json: (date, { breadcrumbsPrefix = [] } = {}) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date, \\"Date object\\"),
                        },
                    ],
                };
            }
        },
        getType: () => Schema_1.SchemaType.DATE,
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.date = date;
",
                    "name": "date.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.date = void 0;
var date_1 = require(\\"./date\\");
Object.defineProperty(exports, \\"date\\", { enumerable: true, get: function () { return date_1.date; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]>;
",
                    "name": "enum.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.enum_ = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
function enum_(values) {
    const validValues = new Set(values);
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {
        if (typeof value !== \\"string\\") {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"string\\"),
                    },
                ],
            };
        }
        if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"enum\\"),
                    },
                ],
            };
        }
        return {
            ok: true,
            value: value,
        };
    });
    return schemaCreator();
}
exports.enum_ = enum_;
",
                    "name": "enum.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.enum_ = void 0;
var enum_1 = require(\\"./enum\\");
Object.defineProperty(exports, \\"enum_\\", { enumerable: true, get: function () { return enum_1.enum_; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./undiscriminated-union\\";
export * from \\"./union\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./date\\"), exports);
__exportStar(require(\\"./enum\\"), exports);
__exportStar(require(\\"./lazy\\"), exports);
__exportStar(require(\\"./list\\"), exports);
__exportStar(require(\\"./literals\\"), exports);
__exportStar(require(\\"./object\\"), exports);
__exportStar(require(\\"./object-like\\"), exports);
__exportStar(require(\\"./primitives\\"), exports);
__exportStar(require(\\"./record\\"), exports);
__exportStar(require(\\"./schema-utils\\"), exports);
__exportStar(require(\\"./set\\"), exports);
__exportStar(require(\\"./undiscriminated-union\\"), exports);
__exportStar(require(\\"./union\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy } from \\"./lazy\\";
export type { SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.lazyObject = exports.lazy = void 0;
var lazy_1 = require(\\"./lazy\\");
Object.defineProperty(exports, \\"lazy\\", { enumerable: true, get: function () { return lazy_1.lazy; } });
var lazyObject_1 = require(\\"./lazyObject\\");
Object.defineProperty(exports, \\"lazyObject\\", { enumerable: true, get: function () { return lazyObject_1.lazyObject; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
export declare type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;
export declare function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed>;
export declare function constructLazyBaseSchema<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): BaseSchema<Raw, Parsed>;
export declare function getMemoizedSchema<SchemaType extends Schema<any, any>>(getter: SchemaGetter<SchemaType>): Promise<SchemaType>;
",
                    "name": "lazy.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.getMemoizedSchema = exports.constructLazyBaseSchema = exports.lazy = void 0;
const schema_utils_1 = require(\\"../schema-utils\\");
function lazy(getter) {
    const baseSchema = constructLazyBaseSchema(getter);
    return Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.lazy = lazy;
function constructLazyBaseSchema(getter) {
    return {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () { return (yield getMemoizedSchema(getter)).parse(raw, opts); }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () { return (yield getMemoizedSchema(getter)).json(parsed, opts); }),
        getType: () => __awaiter(this, void 0, void 0, function* () { return (yield getMemoizedSchema(getter)).getType(); }),
    };
}
exports.constructLazyBaseSchema = constructLazyBaseSchema;
function getMemoizedSchema(getter) {
    return __awaiter(this, void 0, void 0, function* () {
        const castedGetter = getter;
        if (castedGetter.__zurg_memoized == null) {
            castedGetter.__zurg_memoized = yield getter();
        }
        return castedGetter.__zurg_memoized;
    });
}
exports.getMemoizedSchema = getMemoizedSchema;
",
                    "name": "lazy.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ObjectSchema } from \\"../object/types\\";
import { SchemaGetter } from \\"./lazy\\";
export declare function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed>;
",
                    "name": "lazyObject.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.lazyObject = void 0;
const object_1 = require(\\"../object\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
const lazy_1 = require(\\"./lazy\\");
function lazyObject(getter) {
    const baseSchema = Object.assign(Object.assign({}, (0, lazy_1.constructLazyBaseSchema)(getter)), { _getRawProperties: () => __awaiter(this, void 0, void 0, function* () { return (yield (0, lazy_1.getMemoizedSchema)(getter))._getRawProperties(); }), _getParsedProperties: () => __awaiter(this, void 0, void 0, function* () { return (yield (0, lazy_1.getMemoizedSchema)(getter))._getParsedProperties(); }) });
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), (0, object_1.getObjectUtils)(baseSchema));
}
exports.lazyObject = lazyObject;
",
                    "name": "lazyObject.js",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.list = void 0;
var list_1 = require(\\"./list\\");
Object.defineProperty(exports, \\"list\\", { enumerable: true, get: function () { return list_1.list; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]>;
",
                    "name": "list.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.list = void 0;
const Schema_1 = require(\\"../../Schema\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function list(schema) {
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            return validateAndTransformArray(raw, (item, index) => {
                var _a;
                return schema.parse(item, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`[\${index}]\`] }));
            });
        }),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item, index) => {
            var _a;
            return schema.json(item, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`[\${index}]\`] }));
        }),
        getType: () => Schema_1.SchemaType.LIST,
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.list = list;
function validateAndTransformArray(value, transformItem) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(value)) {
            return {
                ok: false,
                errors: [
                    {
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"list\\"),
                        path: [],
                    },
                ],
            };
        }
        const maybeValidItems = yield Promise.all(value.map((item, index) => transformItem(item, index)));
        return maybeValidItems.reduce((acc, item) => {
            if (acc.ok && item.ok) {
                return {
                    ok: true,
                    value: [...acc.value, item.value],
                };
            }
            const errors = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!item.ok) {
                errors.push(...item.errors);
            }
            return {
                ok: false,
                errors,
            };
        }, { ok: true, value: [] });
    });
}
",
                    "name": "list.js",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringLiteral = void 0;
var stringLiteral_1 = require(\\"./stringLiteral\\");
Object.defineProperty(exports, \\"stringLiteral\\", { enumerable: true, get: function () { return stringLiteral_1.stringLiteral; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function stringLiteral<V extends string>(literal: V): Schema<V, V>;
",
                    "name": "stringLiteral.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringLiteral = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
function stringLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value, { breadcrumbsPrefix = [] } = {}) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \`\\"\${literal}\\"\`),
                    },
                ],
            };
        }
    });
    return schemaCreator();
}
exports.stringLiteral = stringLiteral;
",
                    "name": "stringLiteral.js",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { objectWithoutOptionalProperties } from \\"./objectWithoutOptionalProperties\\";
export type { inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas, inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas, } from \\"./objectWithoutOptionalProperties\\";
export { isProperty, property } from \\"./property\\";
export type { Property } from \\"./property\\";
export type { BaseObjectSchema, inferObjectSchemaFromPropertySchemas, inferParsedObject, inferParsedObjectFromPropertySchemas, inferParsedPropertySchema, inferRawKey, inferRawObject, inferRawObjectFromPropertySchemas, inferRawPropertySchema, ObjectSchema, ObjectUtils, PropertySchemas, } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.property = exports.isProperty = exports.objectWithoutOptionalProperties = exports.object = exports.getObjectUtils = void 0;
var object_1 = require(\\"./object\\");
Object.defineProperty(exports, \\"getObjectUtils\\", { enumerable: true, get: function () { return object_1.getObjectUtils; } });
Object.defineProperty(exports, \\"object\\", { enumerable: true, get: function () { return object_1.object; } });
var objectWithoutOptionalProperties_1 = require(\\"./objectWithoutOptionalProperties\\");
Object.defineProperty(exports, \\"objectWithoutOptionalProperties\\", { enumerable: true, get: function () { return objectWithoutOptionalProperties_1.objectWithoutOptionalProperties; } });
var property_1 = require(\\"./property\\");
Object.defineProperty(exports, \\"isProperty\\", { enumerable: true, get: function () { return property_1.isProperty; } });
Object.defineProperty(exports, \\"property\\", { enumerable: true, get: function () { return property_1.property; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseObjectSchema, inferObjectSchemaFromPropertySchemas, ObjectUtils, PropertySchemas } from \\"./types\\";
export declare function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(schemas: T): inferObjectSchemaFromPropertySchemas<T>;
export declare function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed>;
",
                    "name": "object.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.getObjectUtils = exports.object = void 0;
const Schema_1 = require(\\"../../Schema\\");
const entries_1 = require(\\"../../utils/entries\\");
const filterObject_1 = require(\\"../../utils/filterObject\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const keys_1 = require(\\"../../utils/keys\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const partition_1 = require(\\"../../utils/partition\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
const property_1 = require(\\"./property\\");
function object(schemas) {
    const baseSchema = {
        _getRawProperties: () => Promise.resolve(Object.entries(schemas).map(([parsedKey, propertySchema]) => (0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey)),
        _getParsedProperties: () => Promise.resolve((0, keys_1.keys)(schemas)),
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            const rawKeyToProperty = {};
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                const property = {
                    rawKey,
                    parsedKey: parsedKey,
                    valueSchema,
                };
                rawKeyToProperty[rawKey] = property;
                if (yield isSchemaRequired(valueSchema)) {
                    requiredKeys.push(rawKey);
                }
            }
            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => {
                            var _a;
                            return property.valueSchema.parse(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), rawKey] }));
                        },
                    };
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                if (yield isSchemaRequired(valueSchema)) {
                    requiredKeys.push(parsedKey);
                }
            }
            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (parsedKey) => {
                    const property = schemas[parsedKey];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }
                    if ((0, property_1.isProperty)(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => {
                                var _a;
                                return property.valueSchema.json(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), parsedKey] }));
                            },
                        };
                    }
                    else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => {
                                var _a;
                                return property.json(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), parsedKey] }));
                            },
                        };
                    }
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        getType: () => Schema_1.SchemaType.OBJECT,
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
}
exports.object = object;
function validateAndTransformObject({ value, requiredKeys, getProperty, unrecognizedObjectKeys = \\"fail\\", skipValidation = false, breadcrumbsPrefix = [], }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, isPlainObject_1.isPlainObject)(value)) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"object\\"),
                    },
                ],
            };
        }
        const missingRequiredKeys = new Set(requiredKeys);
        const errors = [];
        const transformed = {};
        for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
            const property = getProperty(preTransformedKey);
            if (property != null) {
                missingRequiredKeys.delete(preTransformedKey);
                const value = yield property.transform(preTransformedItemValue);
                if (value.ok) {
                    transformed[property.transformedKey] = value.value;
                }
                else {
                    transformed[preTransformedKey] = preTransformedItemValue;
                    errors.push(...value.errors);
                }
            }
            else {
                switch (unrecognizedObjectKeys) {
                    case \\"fail\\":
                        errors.push({
                            path: [...breadcrumbsPrefix, preTransformedKey],
                            message: \`Unexpected key \\"\${preTransformedKey}\\"\`,
                        });
                        break;
                    case \\"strip\\":
                        break;
                    case \\"passthrough\\":
                        transformed[preTransformedKey] = preTransformedItemValue;
                        break;
                }
            }
        }
        errors.push(...requiredKeys
            .filter((key) => missingRequiredKeys.has(key))
            .map((key) => ({
            path: breadcrumbsPrefix,
            message: \`Missing required key \\"\${key}\\"\`,
        })));
        if (errors.length === 0 || skipValidation) {
            return {
                ok: true,
                value: transformed,
            };
        }
        else {
            return {
                ok: false,
                errors,
            };
        }
    });
}
function getObjectUtils(schema) {
    return {
        extend: (extension) => {
            const baseSchema = {
                _getParsedProperties: () => __awaiter(this, void 0, void 0, function* () {
                    return [
                        ...(yield schema._getParsedProperties()),
                        ...(yield extension._getParsedProperties()),
                    ];
                }),
                _getRawProperties: () => __awaiter(this, void 0, void 0, function* () {
                    return [
                        ...(yield schema._getRawProperties()),
                        ...(yield extension._getRawProperties()),
                    ];
                }),
                parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
                    return validateAndTransformExtendedObject({
                        extensionKeys: yield extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                }),
                json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
                    return validateAndTransformExtendedObject({
                        extensionKeys: yield extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                }),
                getType: () => Schema_1.SchemaType.OBJECT,
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        },
    };
}
exports.getObjectUtils = getObjectUtils;
function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const extensionPropertiesSet = new Set(extensionKeys);
        const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key) => extensionPropertiesSet.has(key));
        const transformedBase = yield transformBase((0, filterObject_1.filterObject)(value, baseProperties));
        const transformedExtension = yield transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
        if (transformedBase.ok && transformedExtension.ok) {
            return {
                ok: true,
                value: Object.assign(Object.assign({}, transformedBase.value), transformedExtension.value),
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    ...(transformedBase.ok ? [] : transformedBase.errors),
                    ...(transformedExtension.ok ? [] : transformedExtension.errors),
                ],
            };
        }
    });
}
function isSchemaRequired(schema) {
    return __awaiter(this, void 0, void 0, function* () {
        return !(yield isSchemaOptional(schema));
    });
}
function isSchemaOptional(schema) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (yield schema.getType()) {
            case Schema_1.SchemaType.ANY:
            case Schema_1.SchemaType.UNKNOWN:
            case Schema_1.SchemaType.OPTIONAL:
                return true;
            default:
                return false;
        }
    });
}
",
                    "name": "object.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedPropertySchema, inferRawObjectFromPropertySchemas, ObjectSchema, PropertySchemas } from \\"./types\\";
export declare function objectWithoutOptionalProperties<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(schemas: T): inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T>;
export declare type inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T>>;
export declare type inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T extends PropertySchemas<keyof T>> = {
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
};
",
                    "name": "objectWithoutOptionalProperties.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.objectWithoutOptionalProperties = void 0;
const object_1 = require(\\"./object\\");
function objectWithoutOptionalProperties(schemas) {
    return (0, object_1.object)(schemas);
}
exports.objectWithoutOptionalProperties = objectWithoutOptionalProperties;
",
                    "name": "objectWithoutOptionalProperties.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function property<RawKey extends string, RawValue, ParsedValue>(rawKey: RawKey, valueSchema: Schema<RawValue, ParsedValue>): Property<RawKey, RawValue, ParsedValue>;
export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}
export declare function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O;
",
                    "name": "property.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.isProperty = exports.property = void 0;
function property(rawKey, valueSchema) {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}
exports.property = property;
function isProperty(maybeProperty) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return maybeProperty.isProperty;
}
exports.isProperty = isProperty;
",
                    "name": "property.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { ObjectLikeUtils } from \\"../object-like\\";
import { SchemaUtils } from \\"../schema-utils\\";
import { Property } from \\"./property\\";
export declare type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed> & ObjectUtils<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}
export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(schemas: ObjectSchema<RawExtension, ParsedExtension>) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}
export declare type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;
export declare type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed> ? Parsed : never;
export declare type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>>;
export declare type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
}>;
export declare type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
}>;
export declare type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<ParsedKeys, Property<any, any, any> | Schema<any, any>>;
export declare type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, infer Raw, any> ? Raw : P extends Schema<any, any> ? inferRaw<P> : never;
export declare type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, any, infer Parsed> ? Parsed : P extends Schema<any, any> ? inferParsed<P> : never;
export declare type inferRawKey<ParsedKey extends string | number | symbol, P extends Property<any, any, any> | Schema<any, any>> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema } from \\"../../Schema\\";
import { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
export declare function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed>;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
export declare function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>, properties: {
    [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]);
}): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties>;
",
                    "name": "getObjectLikeUtils.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
const filterObject_1 = require(\\"../../utils/filterObject\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function getObjectLikeUtils(schema) {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}
exports.getObjectLikeUtils = getObjectLikeUtils;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
function withParsedProperties(objectLike, properties) {
    const objectSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            const parsedObject = yield objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }
            const additionalProperties = Object.entries(properties).reduce((processed, [key, value]) => {
                return Object.assign(Object.assign({}, processed), { [key]: typeof value === \\"function\\" ? value(parsedObject.value) : value });
            }, {});
            return {
                ok: true,
                value: Object.assign(Object.assign({}, parsedObject.value), additionalProperties),
            };
        }),
        json: (parsed, opts) => {
            var _a;
            if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, \\"object\\"),
                        },
                    ],
                };
            }
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)));
            return objectLike.json(parsedWithoutAddedProperties, opts);
        },
        getType: () => objectLike.getType(),
    };
    return Object.assign(Object.assign(Object.assign({}, objectSchema), (0, schema_utils_1.getSchemaUtils)(objectSchema)), getObjectLikeUtils(objectSchema));
}
exports.withParsedProperties = withParsedProperties;
",
                    "name": "getObjectLikeUtils.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils, withParsedProperties } from \\"./getObjectLikeUtils\\";
export type { ObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
var getObjectLikeUtils_1 = require(\\"./getObjectLikeUtils\\");
Object.defineProperty(exports, \\"getObjectLikeUtils\\", { enumerable: true, get: function () { return getObjectLikeUtils_1.getObjectLikeUtils; } });
Object.defineProperty(exports, \\"withParsedProperties\\", { enumerable: true, get: function () { return getObjectLikeUtils_1.withParsedProperties; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
export declare type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> & BaseSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed>;
export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export declare const any: () => import(\\"../../Schema\\").Schema<any, any>;
",
                    "name": "any.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.any = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value) => ({ ok: true, value }));
",
                    "name": "any.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const boolean: () => import(\\"../../Schema\\").Schema<boolean, boolean>;
",
                    "name": "boolean.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.boolean = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value, { breadcrumbsPrefix = [] } = {}) => {
    if (typeof value === \\"boolean\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"boolean\\"),
                },
            ],
        };
    }
});
",
                    "name": "boolean.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.unknown = exports.string = exports.number = exports.boolean = exports.any = void 0;
var any_1 = require(\\"./any\\");
Object.defineProperty(exports, \\"any\\", { enumerable: true, get: function () { return any_1.any; } });
var boolean_1 = require(\\"./boolean\\");
Object.defineProperty(exports, \\"boolean\\", { enumerable: true, get: function () { return boolean_1.boolean; } });
var number_1 = require(\\"./number\\");
Object.defineProperty(exports, \\"number\\", { enumerable: true, get: function () { return number_1.number; } });
var string_1 = require(\\"./string\\");
Object.defineProperty(exports, \\"string\\", { enumerable: true, get: function () { return string_1.string; } });
var unknown_1 = require(\\"./unknown\\");
Object.defineProperty(exports, \\"unknown\\", { enumerable: true, get: function () { return unknown_1.unknown; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const number: () => import(\\"../../Schema\\").Schema<number, number>;
",
                    "name": "number.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.number = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value, { breadcrumbsPrefix = [] } = {}) => {
    if (typeof value === \\"number\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"number\\"),
                },
            ],
        };
    }
});
",
                    "name": "number.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const string: () => import(\\"../../Schema\\").Schema<string, string>;
",
                    "name": "string.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.string = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value, { breadcrumbsPrefix = [] } = {}) => {
    if (typeof value === \\"string\\") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"string\\"),
                },
            ],
        };
    }
});
",
                    "name": "string.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export declare const unknown: () => import(\\"../../Schema\\").Schema<unknown, unknown>;
",
                    "name": "unknown.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.unknown = void 0;
const Schema_1 = require(\\"../../Schema\\");
const createIdentitySchemaCreator_1 = require(\\"../../utils/createIdentitySchemaCreator\\");
exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                    "name": "unknown.js",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
export type { BaseRecordSchema, RecordSchema } from \\"./types\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.record = void 0;
var record_1 = require(\\"./record\\");
Object.defineProperty(exports, \\"record\\", { enumerable: true, get: function () { return record_1.record; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { RecordSchema } from \\"./types\\";
export declare function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(keySchema: Schema<RawKey, ParsedKey>, valueSchema: Schema<RawValue, ParsedValue>): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue>;
",
                    "name": "record.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.record = void 0;
const Schema_1 = require(\\"../../Schema\\");
const entries_1 = require(\\"../../utils/entries\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function record(keySchema, valueSchema) {
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (yield keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => {
                    var _a;
                    return keySchema.parse(key, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`\${key} (key)\`] }));
                },
                transformValue: (value, key) => {
                    var _a;
                    return valueSchema.parse(value, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`\${key}\`] }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (yield keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => {
                    var _a;
                    return keySchema.json(key, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`\${key} (key)\`] }));
                },
                transformValue: (value, key) => {
                    var _a;
                    return valueSchema.json(value, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), \`\${key}\`] }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        getType: () => Schema_1.SchemaType.RECORD,
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.record = record;
function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, breadcrumbsPrefix = [], }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, isPlainObject_1.isPlainObject)(value)) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"object\\"),
                    },
                ],
            };
        }
        return (0, entries_1.entries)(value).reduce((accPromise, [stringKey, value]) => __awaiter(this, void 0, void 0, function* () {
            // skip nullish keys
            if (value == null) {
                return accPromise;
            }
            const acc = yield accPromise;
            let key = stringKey;
            if (isKeyNumeric) {
                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
                if (!isNaN(numberKey)) {
                    key = numberKey;
                }
            }
            const transformedKey = yield transformKey(key);
            const transformedValue = yield transformValue(value, key);
            if (acc.ok && transformedKey.ok && transformedValue.ok) {
                return {
                    ok: true,
                    value: Object.assign(Object.assign({}, acc.value), { [transformedKey.value]: transformedValue.value }),
                };
            }
            const errors = [];
            if (!acc.ok) {
                errors.push(...acc.errors);
            }
            if (!transformedKey.ok) {
                errors.push(...transformedKey.errors);
            }
            if (!transformedValue.ok) {
                errors.push(...transformedValue.errors);
            }
            return {
                ok: false,
                errors,
            };
        }), Promise.resolve({ ok: true, value: {} }));
    });
}
",
                    "name": "record.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema } from \\"../../Schema\\";
import { SchemaUtils } from \\"../schema-utils\\";
export declare type RecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> & SchemaUtils<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;
export declare type BaseRecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>>;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare class JsonError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                    "name": "JsonError.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.JsonError = void 0;
const stringifyValidationErrors_1 = require(\\"./stringifyValidationErrors\\");
class JsonError extends Error {
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join(\\"; \\"));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
exports.JsonError = JsonError;
",
                    "name": "JsonError.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare class ParseError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                    "name": "ParseError.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.ParseError = void 0;
const stringifyValidationErrors_1 = require(\\"./stringifyValidationErrors\\");
class ParseError extends Error {
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join(\\"; \\"));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
exports.ParseError = ParseError;
",
                    "name": "ParseError.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema, SchemaOptions } from \\"../../Schema\\";
export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}
export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}
export declare function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed>;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
export declare function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): Schema<Raw | null | undefined, Parsed | undefined>;
export declare function transform<Raw, Parsed, Transformed>(schema: BaseSchema<Raw, Parsed>, transformer: SchemaTransformer<Parsed, Transformed>): Schema<Raw, Transformed>;
",
                    "name": "getSchemaUtils.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.transform = exports.optional = exports.getSchemaUtils = void 0;
const Schema_1 = require(\\"../../Schema\\");
const JsonError_1 = require(\\"./JsonError\\");
const ParseError_1 = require(\\"./ParseError\\");
function getSchemaUtils(schema) {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            const parsed = yield schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError_1.ParseError(parsed.errors);
        }),
        jsonOrThrow: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            const raw = yield schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError_1.JsonError(raw.errors);
        }),
    };
}
exports.getSchemaUtils = getSchemaUtils;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
function optional(schema) {
    const baseSchema = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => Schema_1.SchemaType.OPTIONAL,
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
exports.optional = optional;
function transform(schema, transformer) {
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            const parsed = yield schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        }),
        json: (transformed, opts) => __awaiter(this, void 0, void 0, function* () {
            const parsed = yield transformer.untransform(transformed);
            return schema.json(parsed, opts);
        }),
        getType: () => schema.getType(),
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
exports.transform = transform;
",
                    "name": "getSchemaUtils.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getSchemaUtils, optional, transform } from \\"./getSchemaUtils\\";
export type { SchemaUtils } from \\"./getSchemaUtils\\";
export { JsonError } from \\"./JsonError\\";
export { ParseError } from \\"./ParseError\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
var getSchemaUtils_1 = require(\\"./getSchemaUtils\\");
Object.defineProperty(exports, \\"getSchemaUtils\\", { enumerable: true, get: function () { return getSchemaUtils_1.getSchemaUtils; } });
Object.defineProperty(exports, \\"optional\\", { enumerable: true, get: function () { return getSchemaUtils_1.optional; } });
Object.defineProperty(exports, \\"transform\\", { enumerable: true, get: function () { return getSchemaUtils_1.transform; } });
var JsonError_1 = require(\\"./JsonError\\");
Object.defineProperty(exports, \\"JsonError\\", { enumerable: true, get: function () { return JsonError_1.JsonError; } });
var ParseError_1 = require(\\"./ParseError\\");
Object.defineProperty(exports, \\"ParseError\\", { enumerable: true, get: function () { return ParseError_1.ParseError; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ValidationError } from \\"../../Schema\\";
export declare function stringifyValidationError(error: ValidationError): string;
",
                    "name": "stringifyValidationErrors.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.stringifyValidationError = void 0;
function stringifyValidationError(error) {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(\\" -> \\")}: \${error.message}\`;
}
exports.stringifyValidationError = stringifyValidationError;
",
                    "name": "stringifyValidationErrors.js",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.set = void 0;
var set_1 = require(\\"./set\\");
Object.defineProperty(exports, \\"set\\", { enumerable: true, get: function () { return set_1.set; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
export declare function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>>;
",
                    "name": "set.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.set = void 0;
const Schema_1 = require(\\"../../Schema\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const list_1 = require(\\"../list\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function set(schema) {
    const listSchema = (0, list_1.list)(schema);
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            const parsedList = yield listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            }
            else {
                return parsedList;
            }
        }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, \\"Set\\"),
                        },
                    ],
                };
            }
            const jsonList = yield listSchema.json([...parsed], opts);
            return jsonList;
        }),
        getType: () => Schema_1.SchemaType.SET,
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.set = set;
",
                    "name": "set.js",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema, UndiscriminatedUnionSchema, } from \\"./types\\";
export { undiscriminatedUnion } from \\"./undiscriminatedUnion\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.undiscriminatedUnion = void 0;
var undiscriminatedUnion_1 = require(\\"./undiscriminatedUnion\\");
Object.defineProperty(exports, \\"undiscriminatedUnion\\", { enumerable: true, get: function () { return undiscriminatedUnion_1.undiscriminatedUnion; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
export declare type UndiscriminatedUnionSchema<Schemas extends [...Schema[]]> = Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>>;
export declare type inferRawUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferRaw<Schemas[number]>;
export declare type inferParsedUnidiscriminatedUnionSchema<Schemas extends [...Schema[]]> = inferParsed<Schemas[number]>;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema } from \\"./types\\";
export declare function undiscriminatedUnion<Schemas extends [Schema<any, any>, ...Schema<any, any>[]]>(schemas: Schemas): Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>>;
",
                    "name": "undiscriminatedUnion.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.undiscriminatedUnion = void 0;
const Schema_1 = require(\\"../../Schema\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function undiscriminatedUnion(schemas) {
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            return validateAndTransformUndiscriminatedUnion((schema, opts) => schema.parse(raw, opts), schemas, opts);
        }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            return validateAndTransformUndiscriminatedUnion((schema, opts) => schema.json(parsed, opts), schemas, opts);
        }),
        getType: () => Schema_1.SchemaType.UNDISCRIMINATED_UNION,
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
exports.undiscriminatedUnion = undiscriminatedUnion;
function validateAndTransformUndiscriminatedUnion(transform, schemas, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const errors = [];
        for (const [index, schema] of schemas.entries()) {
            const transformed = yield transform(schema, Object.assign(Object.assign({}, opts), { skipValidation: false }));
            if (transformed.ok) {
                return transformed;
            }
            else {
                for (const error of transformed.errors) {
                    errors.push({
                        path: error.path,
                        message: \`[Variant \${index}] \${error.message}\`,
                    });
                }
            }
        }
        return {
            ok: false,
            errors,
        };
    });
}
",
                    "name": "undiscriminatedUnion.js",
                    "type": "file",
                  },
                ],
                "name": "undiscriminated-union",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export declare function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(parsedDiscriminant: ParsedDiscriminant, rawDiscriminant: RawDiscriminant): Discriminant<RawDiscriminant, ParsedDiscriminant>;
export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.discriminant = void 0;
function discriminant(parsedDiscriminant, rawDiscriminant) {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}
exports.discriminant = discriminant;
",
                    "name": "discriminant.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant } from \\"./discriminant\\";
export type { Discriminant } from \\"./discriminant\\";
export type { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes, } from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.union = exports.discriminant = void 0;
var discriminant_1 = require(\\"./discriminant\\");
Object.defineProperty(exports, \\"discriminant\\", { enumerable: true, get: function () { return discriminant_1.discriminant; } });
var union_1 = require(\\"./union\\");
Object.defineProperty(exports, \\"union\\", { enumerable: true, get: function () { return union_1.union; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";
export declare type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};
export declare type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];
export declare type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];
export declare type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<infer Raw, any> ? Raw : never;
export declare type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<any, infer Parsed> ? Parsed : never;
",
                    "name": "types.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                    "name": "types.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { ObjectLikeSchema } from \\"../object-like\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedUnion, inferRawUnion, UnionSubtypes } from \\"./types\\";
export declare function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(discriminant: D, union: U): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>>;
",
                    "name": "union.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === \\"function\\")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.union = void 0;
const Schema_1 = require(\\"../../Schema\\");
const getErrorMessageForIncorrectType_1 = require(\\"../../utils/getErrorMessageForIncorrectType\\");
const isPlainObject_1 = require(\\"../../utils/isPlainObject\\");
const keys_1 = require(\\"../../utils/keys\\");
const maybeSkipValidation_1 = require(\\"../../utils/maybeSkipValidation\\");
const enum_1 = require(\\"../enum\\");
const object_like_1 = require(\\"../object-like\\");
const schema_utils_1 = require(\\"../schema-utils\\");
function union(discriminant, union) {
    const rawDiscriminant = typeof discriminant === \\"string\\" ? discriminant : discriminant.rawDiscriminant;
    const parsedDiscriminant = typeof discriminant === \\"string\\"
        ? discriminant
        : discriminant.parsedDiscriminant;
    const discriminantValueSchema = (0, enum_1.enum_)((0, keys_1.keys)(union));
    const baseSchema = {
        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {
            return transformAndValidateUnion({
                value: raw,
                discriminant: rawDiscriminant,
                transformedDiscriminant: parsedDiscriminant,
                transformDiscriminantValue: (discriminantValue) => {
                    var _a;
                    return discriminantValueSchema.parse(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), rawDiscriminant],
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        json: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {
            return transformAndValidateUnion({
                value: parsed,
                discriminant: parsedDiscriminant,
                transformedDiscriminant: rawDiscriminant,
                transformDiscriminantValue: (discriminantValue) => {
                    var _a;
                    return discriminantValueSchema.json(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [...((_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : []), parsedDiscriminant],
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            });
        }),
        getType: () => Schema_1.SchemaType.UNION,
    };
    return Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema));
}
exports.union = union;
function transformAndValidateUnion({ value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnrecognizedUnionMembers = false, transformAdditionalProperties, breadcrumbsPrefix = [], }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, isPlainObject_1.isPlainObject)(value)) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, \\"object\\"),
                    },
                ],
            };
        }
        const _a = value, _b = discriminant, discriminantValue = _a[_b], additionalProperties = __rest(_a, [typeof _b === \\"symbol\\" ? _b : _b + \\"\\"]);
        if (discriminantValue == null) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: \`Missing discriminant (\\"\${discriminant}\\")\`,
                    },
                ],
            };
        }
        const transformedDiscriminantValue = yield transformDiscriminantValue(discriminantValue);
        if (!transformedDiscriminantValue.ok) {
            return {
                ok: false,
                errors: transformedDiscriminantValue.errors,
            };
        }
        const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
        if (additionalPropertiesSchema == null) {
            if (allowUnrecognizedUnionMembers) {
                return {
                    ok: true,
                    value: Object.assign({ [transformedDiscriminant]: transformedDiscriminantValue.value }, additionalProperties),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [...breadcrumbsPrefix, discriminant],
                            message: \\"Unexpected discriminant value\\",
                        },
                    ],
                };
            }
        }
        const transformedAdditionalProperties = yield transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
        if (!transformedAdditionalProperties.ok) {
            return transformedAdditionalProperties;
        }
        return {
            ok: true,
            value: Object.assign({ [transformedDiscriminant]: discriminantValue }, transformedAdditionalProperties.value),
        };
    });
}
",
                    "name": "union.js",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export type { inferParsed, inferRaw, Schema, SchemaOptions } from \\"./Schema\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./builders\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export declare type MaybePromise<T> = T | Promise<T>;
",
                "name": "MaybePromise.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                "name": "MaybePromise.js",
                "type": "file",
              },
              Object {
                "contents": "export declare type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;
export declare type OptionalKeys<T> = {
    [K in keyof T]-?: undefined extends T[K] ? K : null extends T[K] ? K : 1 extends (any extends T[K] ? 0 : 1) ? never : K;
}[keyof T];
export declare type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>;
",
                "name": "addQuestionMarksToNullableProperties.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
",
                "name": "addQuestionMarksToNullableProperties.js",
                "type": "file",
              },
              Object {
                "contents": "import { MaybeValid, Schema, SchemaOptions, SchemaType } from \\"../Schema\\";
export declare function createIdentitySchemaCreator<T>(schemaType: SchemaType, validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>): () => Schema<T, T>;
",
                "name": "createIdentitySchemaCreator.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.createIdentitySchemaCreator = void 0;
const schema_utils_1 = require(\\"../builders/schema-utils\\");
const maybeSkipValidation_1 = require(\\"./maybeSkipValidation\\");
function createIdentitySchemaCreator(schemaType, validate) {
    return () => {
        const baseSchema = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };
        return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    };
}
exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
",
                "name": "createIdentitySchemaCreator.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function entries<T>(object: T): [keyof T, T[keyof T]][];
",
                "name": "entries.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.entries = void 0;
function entries(object) {
    return Object.entries(object);
}
exports.entries = entries;
",
                "name": "entries.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K>;
",
                "name": "filterObject.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.filterObject = void 0;
function filterObject(obj, keysToInclude) {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key)) {
            acc[key] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {});
}
exports.filterObject = filterObject;
",
                "name": "filterObject.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function getErrorMessageForIncorrectType(value: unknown, expectedType: string): string;
",
                "name": "getErrorMessageForIncorrectType.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.getErrorMessageForIncorrectType = void 0;
function getErrorMessageForIncorrectType(value, expectedType) {
    return \`Expected \${expectedType}. Received \${getTypeAsString(value)}.\`;
}
exports.getErrorMessageForIncorrectType = getErrorMessageForIncorrectType;
function getTypeAsString(value) {
    if (Array.isArray(value)) {
        return \\"list\\";
    }
    if (value === null) {
        return \\"null\\";
    }
    switch (typeof value) {
        case \\"string\\":
            return \`\\"\${value}\\"\`;
        case \\"number\\":
        case \\"boolean\\":
        case \\"undefined\\":
            return \`\${value}\`;
    }
    return typeof value;
}
",
                "name": "getErrorMessageForIncorrectType.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function isPlainObject(value: unknown): value is Record<string, unknown>;
",
                "name": "isPlainObject.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.isPlainObject = void 0;
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
function isPlainObject(value) {
    if (typeof value !== \\"object\\" || value === null) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
exports.isPlainObject = isPlainObject;
",
                "name": "isPlainObject.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function keys<T>(object: T): (keyof T)[];
",
                "name": "keys.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.keys = void 0;
function keys(object) {
    return Object.keys(object);
}
exports.keys = keys;
",
                "name": "keys.js",
                "type": "file",
              },
              Object {
                "contents": "import { BaseSchema } from \\"../Schema\\";
export declare function maybeSkipValidation<S extends BaseSchema<Raw, Parsed>, Raw, Parsed>(schema: S): S;
",
                "name": "maybeSkipValidation.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.maybeSkipValidation = void 0;
function maybeSkipValidation(schema) {
    return Object.assign(Object.assign({}, schema), { json: transformAndMaybeSkipValidation(schema.json), parse: transformAndMaybeSkipValidation(schema.parse) });
}
exports.maybeSkipValidation = maybeSkipValidation;
function transformAndMaybeSkipValidation(transform) {
    return (value, opts) => __awaiter(this, void 0, void 0, function* () {
        const transformed = yield transform(value, opts);
        const { skipValidation = false } = opts !== null && opts !== void 0 ? opts : {};
        if (!transformed.ok && skipValidation) {
            // eslint-disable-next-line no-console
            console.warn([
                \\"Failed to validate.\\",
                ...transformed.errors.map((error) => \\"  - \\" +
                    (error.path.length > 0 ? \`\${error.path.join(\\".\\")}: \${error.message}\` : error.message)),
            ].join(\\"\\\\n\\"));
            return {
                ok: true,
                value: value,
            };
        }
        else {
            return transformed;
        }
    });
}
",
                "name": "maybeSkipValidation.js",
                "type": "file",
              },
              Object {
                "contents": "export declare function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]];
",
                "name": "partition.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.partition = void 0;
function partition(items, predicate) {
    const trueItems = [], falseItems = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        }
        else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
exports.partition = partition;
",
                "name": "partition.js",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as FernApi from \\"./api\\";
export { FernApiClient } from \\"./Client\\";
",
    "name": "index.d.ts",
    "type": "file",
  },
  Object {
    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.FernApiClient = exports.FernApi = void 0;
exports.FernApi = __importStar(require(\\"./api\\"));
var Client_1 = require(\\"./Client\\");
Object.defineProperty(exports, \\"FernApiClient\\", { enumerable: true, get: function () { return Client_1.FernApiClient; } });
",
    "name": "index.js",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.d.ts",
        "type": "file",
      },
      Object {
        "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./resources\\"), exports);
",
        "name": "index.js",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.d.ts",
            "type": "file",
          },
          Object {
            "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.package_ = void 0;
exports.package_ = __importStar(require(\\"./package\\"));
__exportStar(require(\\"./package/types\\"), exports);
",
            "name": "index.js",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.d.ts",
                "type": "file",
              },
              Object {
                "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./types\\"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from \\"../../..\\";
import * as FernApi from \\"../../../../api\\";
import * as core from \\"../../../../core\\";
export declare const Package: core.serialization.ObjectSchema<serializers.Package.Raw, FernApi.Package>;
export declare namespace Package {
    interface Raw {
        name: string;
    }
}
",
                    "name": "Package.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Package = void 0;
const core = __importStar(require(\\"../../../../core\\"));
exports.Package = core.serialization.object({
    name: core.serialization.string(),
});
",
                    "name": "Package.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from \\"../../..\\";
import * as FernApi from \\"../../../../api\\";
import * as core from \\"../../../../core\\";
export declare const Record_: core.serialization.ObjectSchema<serializers.Record_.Raw, FernApi.Record_>;
export declare namespace Record_ {
    interface Raw {
        foo: Record<string, string>;
        \\"3d\\": number;
    }
}
",
                    "name": "Record_.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Record_ = void 0;
const core = __importStar(require(\\"../../../../core\\"));
exports.Record_ = core.serialization.object({
    foo: core.serialization.record(core.serialization.string(), core.serialization.string()),
    \\"3D\\": core.serialization.property(\\"3d\\", core.serialization.number()),
});
",
                    "name": "Record_.js",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
export * from \\"./Record_\\";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (\\"get\\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== \\"default\\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
__exportStar(require(\\"./Package\\"), exports);
__exportStar(require(\\"./Record_\\"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "serialization",
    "type": "directory",
  },
]
`;

// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	time "time"
)

type ApiAuth struct {
	Docs        *string                `json:"docs,omitempty"`
	Requirement AuthSchemesRequirement `json:"requirement,omitempty"`
	Schemes     []*AuthScheme          `json:"schemes,omitempty"`
}

type AuthScheme struct {
	Type   string
	Bearer *BearerAuthScheme
	Basic  *BasicAuthScheme
	Header *HeaderAuthScheme
}

func NewAuthSchemeFromBearer(value *BearerAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "bearer", Bearer: value}
}

func NewAuthSchemeFromBasic(value *BasicAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "basic", Basic: value}
}

func NewAuthSchemeFromHeader(value *HeaderAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "header", Header: value}
}

func (a *AuthScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bearer":
		value := new(BearerAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "basic":
		value := new(BasicAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "header":
		value := new(HeaderAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a AuthScheme) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		var marshaler = struct {
			Type string `json:"_type"`
			*BearerAuthScheme
		}{
			Type:             a.Type,
			BearerAuthScheme: a.Bearer,
		}
		return json.Marshal(marshaler)
	case "basic":
		var marshaler = struct {
			Type string `json:"_type"`
			*BasicAuthScheme
		}{
			Type:            a.Type,
			BasicAuthScheme: a.Basic,
		}
		return json.Marshal(marshaler)
	case "header":
		var marshaler = struct {
			Type string `json:"_type"`
			*HeaderAuthScheme
		}{
			Type:             a.Type,
			HeaderAuthScheme: a.Header,
		}
		return json.Marshal(marshaler)
	}
}

type AuthSchemeVisitor interface {
	VisitBearer(*BearerAuthScheme) error
	VisitBasic(*BasicAuthScheme) error
	VisitHeader(*HeaderAuthScheme) error
}

func (a *AuthScheme) Accept(visitor AuthSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

type AuthSchemesRequirement string

const (
	AuthSchemesRequirementAll AuthSchemesRequirement = "ALL"
	AuthSchemesRequirementAny AuthSchemesRequirement = "ANY"
)

func NewAuthSchemesRequirementFromString(s string) (AuthSchemesRequirement, error) {
	switch s {
	case "ALL":
		return AuthSchemesRequirementAll, nil
	case "ANY":
		return AuthSchemesRequirementAny, nil
	}
	var t AuthSchemesRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthSchemesRequirement) Ptr() *AuthSchemesRequirement {
	return &a
}

type BasicAuthScheme struct {
	Docs     *string `json:"docs,omitempty"`
	Username *Name   `json:"username,omitempty"`
	Password *Name   `json:"password,omitempty"`
}

type BearerAuthScheme struct {
	Docs  *string `json:"docs,omitempty"`
	Token *Name   `json:"token,omitempty"`
}

type HeaderAuthScheme struct {
	Docs      *string           `json:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty"`
	Prefix    *string           `json:"prefix,omitempty"`
}

type Availability struct {
	Status  AvailabilityStatus `json:"status,omitempty"`
	Message *string            `json:"message,omitempty"`
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

type Declaration struct {
	Docs         *string       `json:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty"`
}

type ErrorId = string

type FernFilepath struct {
	AllParts    []*Name `json:"allParts,omitempty"`
	PackagePath []*Name `json:"packagePath,omitempty"`
	File        *Name   `json:"file,omitempty"`
}

type Name struct {
	OriginalName       string               `json:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase,omitempty"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase,omitempty"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase,omitempty"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase,omitempty"`
}

type NameAndWireValue struct {
	WireValue string `json:"wireValue"`
	Name      *Name  `json:"name,omitempty"`
}

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName"`
}

type ServiceId = string

type SubpackageId = string

type TypeId = string

type WithDocs struct {
	Docs *string `json:"docs,omitempty"`
}

type WithJsonExample struct {
	JsonExample any `json:"jsonExample,omitempty"`
}

type Constants struct {
	ErrorInstanceIdKey *NameAndWireValue `json:"errorInstanceIdKey,omitempty"`
}

type EnvironmentBaseUrlId = string

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id"`
	Name *Name                `json:"name,omitempty"`
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func NewEnvironmentsFromSingleBaseUrl(value *SingleBaseUrlEnvironments) *Environments {
	return &Environments{Type: "singleBaseUrl", SingleBaseUrl: value}
}

func NewEnvironmentsFromMultipleBaseUrls(value *MultipleBaseUrlsEnvironments) *Environments {
	return &Environments{Type: "multipleBaseUrls", MultipleBaseUrls: value}
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		var marshaler = struct {
			Type string `json:"type"`
			*SingleBaseUrlEnvironments
		}{
			Type:                      e.Type,
			SingleBaseUrlEnvironments: e.SingleBaseUrl,
		}
		return json.Marshal(marshaler)
	case "multipleBaseUrls":
		var marshaler = struct {
			Type string `json:"type"`
			*MultipleBaseUrlsEnvironments
		}{
			Type:                         e.Type,
			MultipleBaseUrlsEnvironments: e.MultipleBaseUrls,
		}
		return json.Marshal(marshaler)
	}
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	case "multipleBaseUrls":
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
}

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments,omitempty"`
}

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id"`
	Name *Name                                   `json:"name,omitempty"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls,omitempty"`
}

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls,omitempty"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments,omitempty"`
}

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty"`
	Id   EnvironmentId  `json:"id"`
	Name *Name          `json:"name,omitempty"`
	Url  EnvironmentUrl `json:"url"`
}

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments,omitempty"`
}

type DeclaredErrorName struct {
	ErrorId      ErrorId       `json:"errorId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty"`
}

type ErrorDeclaration struct {
	Docs              *string            `json:"docs,omitempty"`
	Name              *DeclaredErrorName `json:"name,omitempty"`
	DiscriminantValue *NameAndWireValue  `json:"discriminantValue,omitempty"`
	Type              *TypeReference     `json:"type,omitempty"`
	StatusCode        int                `json:"statusCode"`
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *NameAndWireValue
	StatusCode any
}

func NewErrorDeclarationDiscriminantValueFromProperty(value *NameAndWireValue) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "property", Property: value}
}

func NewErrorDeclarationDiscriminantValueFromStatusCode(value any) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "statusCode", StatusCode: value}
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "property":
		value := new(NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*NameAndWireValue
		}{
			Type:             e.Type,
			NameAndWireValue: e.Property,
		}
		return json.Marshal(marshaler)
	case "statusCode":
		var marshaler = struct {
			Type       string `json:"type"`
			StatusCode any    `json:"statusCode,omitempty"`
		}{
			Type:       e.Type,
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*NameAndWireValue) error
	VisitStatusCode(any) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return visitor.VisitProperty(e.Property)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	}
}

type DeclaredServiceName struct {
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
}

type EndpointName = *Name

type ExampleEndpointCall struct {
	Docs                   *string                  `json:"docs,omitempty"`
	Name                   *Name                    `json:"name,omitempty"`
	Url                    string                   `json:"url"`
	RootPathParameters     []*ExamplePathParameter  `json:"rootPathParameters,omitempty"`
	ServicePathParameters  []*ExamplePathParameter  `json:"servicePathParameters,omitempty"`
	EndpointPathParameters []*ExamplePathParameter  `json:"endpointPathParameters,omitempty"`
	ServiceHeaders         []*ExampleHeader         `json:"serviceHeaders,omitempty"`
	EndpointHeaders        []*ExampleHeader         `json:"endpointHeaders,omitempty"`
	QueryParameters        []*ExampleQueryParameter `json:"queryParameters,omitempty"`
	Request                *ExampleRequestBody      `json:"request,omitempty"`
	Response               *ExampleResponse         `json:"response,omitempty"`
}

type ExampleEndpointErrorResponse struct {
	Error *DeclaredErrorName    `json:"error,omitempty"`
	Body  *ExampleTypeReference `json:"body,omitempty"`
}

type ExampleEndpointSuccessResponse struct {
	Body *ExampleTypeReference `json:"body,omitempty"`
}

type ExampleHeader struct {
	WireKey string                `json:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty"`
}

type ExampleInlinedRequestBody struct {
	JsonExample any                                  `json:"jsonExample,omitempty"`
	Properties  []*ExampleInlinedRequestBodyProperty `json:"properties,omitempty"`
}

type ExampleInlinedRequestBodyProperty struct {
	WireKey string                `json:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty"`
	// this property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty"`
}

type ExamplePathParameter struct {
	Key   string                `json:"key"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

type ExampleQueryParameter struct {
	WireKey string                `json:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty"`
}

type ExampleRequestBody struct {
	Type               string
	InlinedRequestBody *ExampleInlinedRequestBody
	Reference          *ExampleTypeReference
}

func NewExampleRequestBodyFromInlinedRequestBody(value *ExampleInlinedRequestBody) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewExampleRequestBodyFromReference(value *ExampleTypeReference) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "reference", Reference: value}
}

func (e *ExampleRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedRequestBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleRequestBody) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleInlinedRequestBody
		}{
			Type:                      e.Type,
			ExampleInlinedRequestBody: e.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 e.Type,
			ExampleTypeReference: e.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleRequestBodyVisitor interface {
	VisitInlinedRequestBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleRequestBody) Accept(visitor ExampleRequestBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(e.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

type ExampleResponse struct {
	Type  string
	Ok    *ExampleEndpointSuccessResponse
	Error *ExampleEndpointErrorResponse
}

func NewExampleResponseFromOk(value *ExampleEndpointSuccessResponse) *ExampleResponse {
	return &ExampleResponse{Type: "ok", Ok: value}
}

func NewExampleResponseFromError(value *ExampleEndpointErrorResponse) *ExampleResponse {
	return &ExampleResponse{Type: "error", Error: value}
}

func (e *ExampleResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "ok":
		value := new(ExampleEndpointSuccessResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Ok = value
	case "error":
		value := new(ExampleEndpointErrorResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExampleResponse) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointSuccessResponse
		}{
			Type:                           e.Type,
			ExampleEndpointSuccessResponse: e.Ok,
		}
		return json.Marshal(marshaler)
	case "error":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointErrorResponse
		}{
			Type:                         e.Type,
			ExampleEndpointErrorResponse: e.Error,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleResponseVisitor interface {
	VisitOk(*ExampleEndpointSuccessResponse) error
	VisitError(*ExampleEndpointErrorResponse) error
}

func (e *ExampleResponse) Accept(visitor ExampleResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return visitor.VisitOk(e.Ok)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

type FileDownloadResponse struct {
	Docs *string `json:"docs,omitempty"`
}

type FileProperty struct {
	Key        *NameAndWireValue `json:"key,omitempty"`
	IsOptional bool              `json:"isOptional"`
}

type FileUploadRequest struct {
	Name       *Name                        `json:"name,omitempty"`
	Properties []*FileUploadRequestProperty `json:"properties,omitempty"`
}

type FileUploadRequestProperty struct {
	Type         string
	File         *FileProperty
	BodyProperty *InlinedRequestBodyProperty
}

func NewFileUploadRequestPropertyFromFile(value *FileProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "file", File: value}
}

func NewFileUploadRequestPropertyFromBodyProperty(value *InlinedRequestBodyProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "file":
		value := new(FileProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "bodyProperty":
		value := new(InlinedRequestBodyProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestProperty) MarshalJSON() ([]byte, error) {
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		var marshaler = struct {
			Type string `json:"type"`
			*FileProperty
		}{
			Type:         f.Type,
			FileProperty: f.File,
		}
		return json.Marshal(marshaler)
	case "bodyProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBodyProperty
		}{
			Type:                       f.Type,
			InlinedRequestBodyProperty: f.BodyProperty,
		}
		return json.Marshal(marshaler)
	}
}

type FileUploadRequestPropertyVisitor interface {
	VisitFile(*FileProperty) error
	VisitBodyProperty(*InlinedRequestBodyProperty) error
}

func (f *FileUploadRequestProperty) Accept(visitor FileUploadRequestPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

type HttpEndpoint struct {
	Docs              *string                `json:"docs,omitempty"`
	Availability      *Availability          `json:"availability,omitempty"`
	Name              EndpointName           `json:"name,omitempty"`
	DisplayName       *string                `json:"displayName,omitempty"`
	Method            HttpMethod             `json:"method,omitempty"`
	Headers           []*HttpHeader          `json:"headers,omitempty"`
	BaseUrl           *EnvironmentBaseUrlId  `json:"baseUrl,omitempty"`
	Path              *HttpPath              `json:"path,omitempty"`
	FullPath          *HttpPath              `json:"fullPath,omitempty"`
	PathParameters    []*PathParameter       `json:"pathParameters,omitempty"`
	AllPathParameters []*PathParameter       `json:"allPathParameters,omitempty"`
	QueryParameters   []*QueryParameter      `json:"queryParameters,omitempty"`
	RequestBody       *HttpRequestBody       `json:"requestBody,omitempty"`
	SdkRequest        *SdkRequest            `json:"sdkRequest,omitempty"`
	Response          *HttpResponse          `json:"response,omitempty"`
	StreamingResponse *StreamingResponse     `json:"streamingResponse,omitempty"`
	SdkResponse       *SdkResponse           `json:"sdkResponse,omitempty"`
	Errors            ResponseErrors         `json:"errors,omitempty"`
	Auth              bool                   `json:"auth"`
	Examples          []*ExampleEndpointCall `json:"examples,omitempty"`
}

type HttpHeader struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty"`
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type HttpPath struct {
	Head  string          `json:"head"`
	Parts []*HttpPathPart `json:"parts,omitempty"`
}

type HttpPathPart struct {
	PathParameter string `json:"pathParameter"`
	Tail          string `json:"tail"`
}

type HttpRequestBody struct {
	Type               string
	InlinedRequestBody *InlinedRequestBody
	Reference          *HttpRequestBodyReference
	FileUpload         *FileUploadRequest
}

func NewHttpRequestBodyFromInlinedRequestBody(value *InlinedRequestBody) *HttpRequestBody {
	return &HttpRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewHttpRequestBodyFromReference(value *HttpRequestBodyReference) *HttpRequestBody {
	return &HttpRequestBody{Type: "reference", Reference: value}
}

func NewHttpRequestBodyFromFileUpload(value *FileUploadRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "fileUpload", FileUpload: value}
}

func (h *HttpRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(InlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.InlinedRequestBody = value
	case "reference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Reference = value
	case "fileUpload":
		value := new(FileUploadRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileUpload = value
	}
	return nil
}

func (h HttpRequestBody) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBody
		}{
			Type:               h.Type,
			InlinedRequestBody: h.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     h.Type,
			HttpRequestBodyReference: h.Reference,
		}
		return json.Marshal(marshaler)
	case "fileUpload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileUploadRequest
		}{
			Type:              h.Type,
			FileUploadRequest: h.FileUpload,
		}
		return json.Marshal(marshaler)
	}
}

type HttpRequestBodyVisitor interface {
	VisitInlinedRequestBody(*InlinedRequestBody) error
	VisitReference(*HttpRequestBodyReference) error
	VisitFileUpload(*FileUploadRequest) error
}

func (h *HttpRequestBody) Accept(visitor HttpRequestBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(h.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(h.Reference)
	case "fileUpload":
		return visitor.VisitFileUpload(h.FileUpload)
	}
}

type HttpRequestBodyReference struct {
	Docs            *string        `json:"docs,omitempty"`
	RequestBodyType *TypeReference `json:"requestBodyType,omitempty"`
}

type HttpResponse struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
}

func NewHttpResponseFromJson(value *JsonResponse) *HttpResponse {
	return &HttpResponse{Type: "json", Json: value}
}

func NewHttpResponseFromFileDownload(value *FileDownloadResponse) *HttpResponse {
	return &HttpResponse{Type: "fileDownload", FileDownload: value}
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		value := new(JsonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Json = value
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	}
	return nil
}

func (h HttpResponse) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponse
		}{
			Type:         h.Type,
			JsonResponse: h.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileDownloadResponse
		}{
			Type:                 h.Type,
			FileDownloadResponse: h.FileDownload,
		}
		return json.Marshal(marshaler)
	}
}

type HttpResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
}

func (h *HttpResponse) Accept(visitor HttpResponseVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return visitor.VisitJson(h.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(h.FileDownload)
	}
}

type HttpService struct {
	Availability   *Availability        `json:"availability,omitempty"`
	Name           *DeclaredServiceName `json:"name,omitempty"`
	DisplayName    *string              `json:"displayName,omitempty"`
	BasePath       *HttpPath            `json:"basePath,omitempty"`
	Endpoints      []*HttpEndpoint      `json:"endpoints,omitempty"`
	Headers        []*HttpHeader        `json:"headers,omitempty"`
	PathParameters []*PathParameter     `json:"pathParameters,omitempty"`
}

type InlinedRequestBody struct {
	Name       *Name                         `json:"name,omitempty"`
	Extends    []*DeclaredTypeName           `json:"extends,omitempty"`
	Properties []*InlinedRequestBodyProperty `json:"properties,omitempty"`
}

type InlinedRequestBodyProperty struct {
	Docs      *string           `json:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty"`
}

type JsonResponse struct {
	Docs             *string        `json:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty"`
}

type MaybeStreamingResponse struct {
	Condition    *StreamCondition   `json:"condition,omitempty"`
	NonStreaming *HttpResponse      `json:"nonStreaming,omitempty"`
	Streaming    *StreamingResponse `json:"streaming,omitempty"`
}

type PathParameter struct {
	Docs      *string               `json:"docs,omitempty"`
	Name      *Name                 `json:"name,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty"`
	Location  PathParameterLocation `json:"location,omitempty"`
	Variable  *VariableId           `json:"variable,omitempty"`
}

type PathParameterLocation string

const (
	PathParameterLocationRoot     PathParameterLocation = "ROOT"
	PathParameterLocationService  PathParameterLocation = "SERVICE"
	PathParameterLocationEndpoint PathParameterLocation = "ENDPOINT"
)

func NewPathParameterLocationFromString(s string) (PathParameterLocation, error) {
	switch s {
	case "ROOT":
		return PathParameterLocationRoot, nil
	case "SERVICE":
		return PathParameterLocationService, nil
	case "ENDPOINT":
		return PathParameterLocationEndpoint, nil
	}
	var t PathParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PathParameterLocation) Ptr() *PathParameterLocation {
	return &p
}

type QueryParameter struct {
	Docs          *string           `json:"docs,omitempty"`
	Availability  *Availability     `json:"availability,omitempty"`
	Name          *NameAndWireValue `json:"name,omitempty"`
	ValueType     *TypeReference    `json:"valueType,omitempty"`
	AllowMultiple bool              `json:"allowMultiple"`
}

type ResponseError struct {
	Docs  *string            `json:"docs,omitempty"`
	Error *DeclaredErrorName `json:"error,omitempty"`
}

type ResponseErrors = []*ResponseError

type SdkRequest struct {
	RequestParameterName *Name            `json:"requestParameterName,omitempty"`
	Shape                *SdkRequestShape `json:"shape,omitempty"`
}

type SdkRequestShape struct {
	Type            string
	JustRequestBody *HttpRequestBodyReference
	Wrapper         *SdkRequestWrapper
}

func NewSdkRequestShapeFromJustRequestBody(value *HttpRequestBodyReference) *SdkRequestShape {
	return &SdkRequestShape{Type: "justRequestBody", JustRequestBody: value}
}

func NewSdkRequestShapeFromWrapper(value *SdkRequestWrapper) *SdkRequestShape {
	return &SdkRequestShape{Type: "wrapper", Wrapper: value}
}

func (s *SdkRequestShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "justRequestBody":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.JustRequestBody = value
	case "wrapper":
		value := new(SdkRequestWrapper)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Wrapper = value
	}
	return nil
}

func (s SdkRequestShape) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     s.Type,
			HttpRequestBodyReference: s.JustRequestBody,
		}
		return json.Marshal(marshaler)
	case "wrapper":
		var marshaler = struct {
			Type string `json:"type"`
			*SdkRequestWrapper
		}{
			Type:              s.Type,
			SdkRequestWrapper: s.Wrapper,
		}
		return json.Marshal(marshaler)
	}
}

type SdkRequestShapeVisitor interface {
	VisitJustRequestBody(*HttpRequestBodyReference) error
	VisitWrapper(*SdkRequestWrapper) error
}

func (s *SdkRequestShape) Accept(visitor SdkRequestShapeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return visitor.VisitJustRequestBody(s.JustRequestBody)
	case "wrapper":
		return visitor.VisitWrapper(s.Wrapper)
	}
}

type SdkRequestWrapper struct {
	WrapperName *Name `json:"wrapperName,omitempty"`
	BodyKey     *Name `json:"bodyKey,omitempty"`
}

type SdkResponse struct {
	Type           string
	Json           *JsonResponse
	Streaming      *StreamingResponse
	MaybeStreaming *MaybeStreamingResponse
	FileDownload   *FileDownloadResponse
}

func NewSdkResponseFromJson(value *JsonResponse) *SdkResponse {
	return &SdkResponse{Type: "json", Json: value}
}

func NewSdkResponseFromStreaming(value *StreamingResponse) *SdkResponse {
	return &SdkResponse{Type: "streaming", Streaming: value}
}

func NewSdkResponseFromMaybeStreaming(value *MaybeStreamingResponse) *SdkResponse {
	return &SdkResponse{Type: "maybeStreaming", MaybeStreaming: value}
}

func NewSdkResponseFromFileDownload(value *FileDownloadResponse) *SdkResponse {
	return &SdkResponse{Type: "fileDownload", FileDownload: value}
}

func (s *SdkResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		value := new(JsonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Json = value
	case "streaming":
		value := new(StreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Streaming = value
	case "maybeStreaming":
		value := new(MaybeStreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.MaybeStreaming = value
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.FileDownload = value
	}
	return nil
}

func (s SdkResponse) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponse
		}{
			Type:         s.Type,
			JsonResponse: s.Json,
		}
		return json.Marshal(marshaler)
	case "streaming":
		var marshaler = struct {
			Type string `json:"type"`
			*StreamingResponse
		}{
			Type:              s.Type,
			StreamingResponse: s.Streaming,
		}
		return json.Marshal(marshaler)
	case "maybeStreaming":
		var marshaler = struct {
			Type string `json:"type"`
			*MaybeStreamingResponse
		}{
			Type:                   s.Type,
			MaybeStreamingResponse: s.MaybeStreaming,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileDownloadResponse
		}{
			Type:                 s.Type,
			FileDownloadResponse: s.FileDownload,
		}
		return json.Marshal(marshaler)
	}
}

type SdkResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitStreaming(*StreamingResponse) error
	VisitMaybeStreaming(*MaybeStreamingResponse) error
	VisitFileDownload(*FileDownloadResponse) error
}

func (s *SdkResponse) Accept(visitor SdkResponseVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return visitor.VisitJson(s.Json)
	case "streaming":
		return visitor.VisitStreaming(s.Streaming)
	case "maybeStreaming":
		return visitor.VisitMaybeStreaming(s.MaybeStreaming)
	case "fileDownload":
		return visitor.VisitFileDownload(s.FileDownload)
	}
}

type StreamCondition struct {
	Type string
	// The name of a boolean query parameter. If it is true, the response
	// should be streamed. Otherwise, it should not be streamed.
	QueryParameterKey string
	// The name of a boolean property on the request. If it is true, the response
	// should be streamed. Otherwise, it should not be streamed.
	RequestPropertyKey string
}

func NewStreamConditionFromQueryParameterKey(value string) *StreamCondition {
	return &StreamCondition{Type: "queryParameterKey", QueryParameterKey: value}
}

func NewStreamConditionFromRequestPropertyKey(value string) *StreamCondition {
	return &StreamCondition{Type: "requestPropertyKey", RequestPropertyKey: value}
}

func (s *StreamCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "queryParameterKey":
		var valueUnmarshaler struct {
			QueryParameterKey string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.QueryParameterKey = valueUnmarshaler.QueryParameterKey
	case "requestPropertyKey":
		var valueUnmarshaler struct {
			RequestPropertyKey string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.RequestPropertyKey = valueUnmarshaler.RequestPropertyKey
	}
	return nil
}

func (s StreamCondition) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "queryParameterKey":
		var marshaler = struct {
			Type              string `json:"type"`
			QueryParameterKey string `json:"value"`
		}{
			Type:              s.Type,
			QueryParameterKey: s.QueryParameterKey,
		}
		return json.Marshal(marshaler)
	case "requestPropertyKey":
		var marshaler = struct {
			Type               string `json:"type"`
			RequestPropertyKey string `json:"value"`
		}{
			Type:               s.Type,
			RequestPropertyKey: s.RequestPropertyKey,
		}
		return json.Marshal(marshaler)
	}
}

type StreamConditionVisitor interface {
	VisitQueryParameterKey(string) error
	VisitRequestPropertyKey(string) error
}

func (s *StreamCondition) Accept(visitor StreamConditionVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "queryParameterKey":
		return visitor.VisitQueryParameterKey(s.QueryParameterKey)
	case "requestPropertyKey":
		return visitor.VisitRequestPropertyKey(s.RequestPropertyKey)
	}
}

type StreamingResponse struct {
	DataEventType *TypeReference `json:"dataEventType,omitempty"`
	Terminator    *string        `json:"terminator,omitempty"`
}

type ErrorDiscriminationByPropertyStrategy struct {
	Discriminant    *NameAndWireValue `json:"discriminant,omitempty"`
	ContentProperty *NameAndWireValue `json:"contentProperty,omitempty"`
}

type ErrorDiscriminationStrategy struct {
	Type       string
	StatusCode any
	Property   *ErrorDiscriminationByPropertyStrategy
}

func NewErrorDiscriminationStrategyFromStatusCode(value any) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "statusCode", StatusCode: value}
}

func NewErrorDiscriminationStrategyFromProperty(value *ErrorDiscriminationByPropertyStrategy) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "property", Property: value}
}

func (e *ErrorDiscriminationStrategy) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "statusCode":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	case "property":
		value := new(ErrorDiscriminationByPropertyStrategy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	}
	return nil
}

func (e ErrorDiscriminationStrategy) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		var marshaler = struct {
			Type       string `json:"type"`
			StatusCode any    `json:"statusCode,omitempty"`
		}{
			Type:       e.Type,
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*ErrorDiscriminationByPropertyStrategy
		}{
			Type:                                  e.Type,
			ErrorDiscriminationByPropertyStrategy: e.Property,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDiscriminationStrategyVisitor interface {
	VisitStatusCode(any) error
	VisitProperty(*ErrorDiscriminationByPropertyStrategy) error
}

func (e *ErrorDiscriminationStrategy) Accept(visitor ErrorDiscriminationStrategyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	case "property":
		return visitor.VisitProperty(e.Property)
	}
}

// Complete representation of the API schema
type IntermediateRepresentation struct {
	// This is the human readable unique id for the API.
	ApiName        *Name    `json:"apiName,omitempty"`
	ApiDisplayName *string  `json:"apiDisplayName,omitempty"`
	ApiDocs        *string  `json:"apiDocs,omitempty"`
	Auth           *ApiAuth `json:"auth,omitempty"`
	// API Wide headers that are sent on every request
	Headers []*HttpHeader `json:"headers,omitempty"`
	// The types described by this API
	Types map[TypeId]*TypeDeclaration `json:"types,omitempty"`
	// The services exposed by this API
	Services                    map[ServiceId]*HttpService    `json:"services,omitempty"`
	Errors                      map[ErrorId]*ErrorDeclaration `json:"errors,omitempty"`
	Subpackages                 map[SubpackageId]*Subpackage  `json:"subpackages,omitempty"`
	RootPackage                 *Package                      `json:"rootPackage,omitempty"`
	Constants                   *Constants                    `json:"constants,omitempty"`
	Environments                *EnvironmentsConfig           `json:"environments,omitempty"`
	BasePath                    *HttpPath                     `json:"basePath,omitempty"`
	PathParameters              []*PathParameter              `json:"pathParameters,omitempty"`
	ErrorDiscriminationStrategy *ErrorDiscriminationStrategy  `json:"errorDiscriminationStrategy,omitempty"`
	SdkConfig                   *SdkConfig                    `json:"sdkConfig,omitempty"`
	Variables                   []*VariableDeclaration        `json:"variables,omitempty"`
}

type Package struct {
	Docs               *string        `json:"docs,omitempty"`
	FernFilepath       *FernFilepath  `json:"fernFilepath,omitempty"`
	Service            *ServiceId     `json:"service,omitempty"`
	Types              []TypeId       `json:"types,omitempty"`
	Errors             []ErrorId      `json:"errors,omitempty"`
	Subpackages        []SubpackageId `json:"subpackages,omitempty"`
	HasEndpointsInTree bool           `json:"hasEndpointsInTree"`
}

type PlatformHeaders struct {
	Language   string `json:"language"`
	SdkName    string `json:"sdkName"`
	SdkVersion string `json:"sdkVersion"`
}

type SdkConfig struct {
	IsAuthMandatory       bool             `json:"isAuthMandatory"`
	HasStreamingEndpoints bool             `json:"hasStreamingEndpoints"`
	PlatformHeaders       *PlatformHeaders `json:"platformHeaders,omitempty"`
}

type Subpackage struct {
	Docs               *string        `json:"docs,omitempty"`
	FernFilepath       *FernFilepath  `json:"fernFilepath,omitempty"`
	Service            *ServiceId     `json:"service,omitempty"`
	Types              []TypeId       `json:"types,omitempty"`
	Errors             []ErrorId      `json:"errors,omitempty"`
	Subpackages        []SubpackageId `json:"subpackages,omitempty"`
	HasEndpointsInTree bool           `json:"hasEndpointsInTree"`
	Name               *Name          `json:"name,omitempty"`
}

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf,omitempty"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType,omitempty"`
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func NewContainerTypeFromList(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "list", List: value}
}

func NewContainerTypeFromMap(value *MapType) *ContainerType {
	return &ContainerType{Type: "map", Map: value}
}

func NewContainerTypeFromOptional(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "optional", Optional: value}
}

func NewContainerTypeFromSet(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "set", Set: value}
}

func NewContainerTypeFromLiteral(value *Literal) *ContainerType {
	return &ContainerType{Type: "literal", Literal: value}
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list,omitempty"`
		}{
			Type: c.Type,
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string `json:"_type"`
			*MapType
		}{
			Type:    c.Type,
			MapType: c.Map,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional,omitempty"`
		}{
			Type:     c.Type,
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set,omitempty"`
		}{
			Type: c.Type,
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal,omitempty"`
		}{
			Type:    c.Type,
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "map":
		return visitor.VisitMap(c.Map)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	case "set":
		return visitor.VisitSet(c.Set)
	case "literal":
		return visitor.VisitLiteral(c.Literal)
	}
}

type DeclaredTypeName struct {
	TypeId       TypeId        `json:"typeId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty"`
}

type EnumTypeDeclaration struct {
	Values []*EnumValue `json:"values,omitempty"`
}

type EnumValue struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
}

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value,omitempty"`
}

type ExampleContainer struct {
	Type     string
	List     []*ExampleTypeReference
	Set      []*ExampleTypeReference
	Optional *ExampleTypeReference
	Map      []*ExampleKeyValuePair
}

func NewExampleContainerFromList(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "list", List: value}
}

func NewExampleContainerFromSet(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "set", Set: value}
}

func NewExampleContainerFromOptional(value *ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "optional", Optional: value}
}

func NewExampleContainerFromMap(value []*ExampleKeyValuePair) *ExampleContainer {
	return &ExampleContainer{Type: "map", Map: value}
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*ExampleTypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.List = valueUnmarshaler.List
	case "set":
		var valueUnmarshaler struct {
			Set []*ExampleTypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Set = valueUnmarshaler.Set
	case "optional":
		var valueUnmarshaler struct {
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Optional = valueUnmarshaler.Optional
	case "map":
		var valueUnmarshaler struct {
			Map []*ExampleKeyValuePair `json:"map,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Map = valueUnmarshaler.Map
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		var marshaler = struct {
			Type string                  `json:"type"`
			List []*ExampleTypeReference `json:"list,omitempty"`
		}{
			Type: e.Type,
			List: e.List,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string                  `json:"type"`
			Set  []*ExampleTypeReference `json:"set,omitempty"`
		}{
			Type: e.Type,
			Set:  e.Set,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string                `json:"type"`
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}{
			Type:     e.Type,
			Optional: e.Optional,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string                 `json:"type"`
			Map  []*ExampleKeyValuePair `json:"map,omitempty"`
		}{
			Type: e.Type,
			Map:  e.Map,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleContainerVisitor interface {
	VisitList([]*ExampleTypeReference) error
	VisitSet([]*ExampleTypeReference) error
	VisitOptional(*ExampleTypeReference) error
	VisitMap([]*ExampleKeyValuePair) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return visitor.VisitList(e.List)
	case "set":
		return visitor.VisitSet(e.Set)
	case "optional":
		return visitor.VisitOptional(e.Optional)
	case "map":
		return visitor.VisitMap(e.Map)
	}
}

type ExampleEnumType struct {
	WireValue string `json:"wireValue"`
}

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName,omitempty"`
	Shape    *ExampleTypeShape `json:"shape,omitempty"`
}

type ExampleObjectProperty struct {
	WireKey string                `json:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty"`
	// this property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty"`
}

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties,omitempty"`
}

type ExamplePrimitive struct {
	Type     string
	Integer  int
	Double   float64
	String   string
	Boolean  bool
	Long     int64
	Datetime time.Time
	Date     time.Time
	Uuid     uuid.UUID
}

func NewExamplePrimitiveFromInteger(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "integer", Integer: value}
}

func NewExamplePrimitiveFromDouble(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "double", Double: value}
}

func NewExamplePrimitiveFromString(value string) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "string", String: value}
}

func NewExamplePrimitiveFromBoolean(value bool) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "boolean", Boolean: value}
}

func NewExamplePrimitiveFromLong(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "long", Long: value}
}

func NewExamplePrimitiveFromDatetime(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "datetime", Datetime: value}
}

func NewExamplePrimitiveFromDate(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "date", Date: value}
}

func NewExamplePrimitiveFromUuid(value uuid.UUID) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uuid", Uuid: value}
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "datetime":
		var valueUnmarshaler struct {
			Datetime time.Time `json:"datetime"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Datetime = valueUnmarshaler.Datetime
	case "date":
		var valueUnmarshaler struct {
			Date time.Time `json:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    e.Type,
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	case "double":
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   e.Type,
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   e.Type,
			String: e.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    e.Type,
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	case "long":
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: e.Type,
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string    `json:"type"`
			Datetime time.Time `json:"datetime"`
		}{
			Type:     e.Type,
			Datetime: e.Datetime,
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string    `json:"type"`
			Date time.Time `json:"date"`
		}{
			Type: e.Type,
			Date: e.Date,
		}
		return json.Marshal(marshaler)
	case "uuid":
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: e.Type,
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	}
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
	VisitString(string) error
	VisitBoolean(bool) error
	VisitLong(int64) error
	VisitDatetime(time.Time) error
	VisitDate(time.Time) error
	VisitUuid(uuid.UUID) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "double":
		return visitor.VisitDouble(e.Double)
	case "string":
		return visitor.VisitString(e.String)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	case "long":
		return visitor.VisitLong(e.Long)
	case "datetime":
		return visitor.VisitDatetime(e.Datetime)
	case "date":
		return visitor.VisitDate(e.Date)
	case "uuid":
		return visitor.VisitUuid(e.Uuid)
	}
}

type ExampleSingleUnionType struct {
	WireDiscriminantValue string                            `json:"wireDiscriminantValue"`
	Properties            *ExampleSingleUnionTypeProperties `json:"properties,omitempty"`
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleNamedType
	SingleProperty         *ExampleTypeReference
	NoProperties           any
}

func NewExampleSingleUnionTypePropertiesFromSamePropertiesAsObject(value *ExampleNamedType) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewExampleSingleUnionTypePropertiesFromSingleProperty(value *ExampleTypeReference) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "singleProperty", SingleProperty: value}
}

func NewExampleSingleUnionTypePropertiesFromNoProperties(value any) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "noProperties", NoProperties: value}
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleNamedType
		}{
			Type:             e.Type,
			ExampleNamedType: e.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 e.Type,
			ExampleTypeReference: e.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			Type         string `json:"type"`
			NoProperties any    `json:"noProperties,omitempty"`
		}{
			Type:         e.Type,
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleNamedType) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(any) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(e.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(e.NoProperties)
	}
}

type ExampleType struct {
	JsonExample any               `json:"jsonExample,omitempty"`
	Docs        *string           `json:"docs,omitempty"`
	Name        *Name             `json:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape,omitempty"`
}

type ExampleTypeReference struct {
	JsonExample any                        `json:"jsonExample,omitempty"`
	Shape       *ExampleTypeReferenceShape `json:"shape,omitempty"`
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   any
	Named     *ExampleNamedType
}

func NewExampleTypeReferenceShapeFromPrimitive(value *ExamplePrimitive) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "primitive", Primitive: value}
}

func NewExampleTypeReferenceShapeFromContainer(value *ExampleContainer) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "container", Container: value}
}

func NewExampleTypeReferenceShapeFromUnknown(value any) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "unknown", Unknown: value}
}

func NewExampleTypeReferenceShapeFromNamed(value *ExampleNamedType) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "named", Named: value}
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown any `json:"unknown,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}{
			Type:      e.Type,
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	case "container":
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container,omitempty"`
		}{
			Type:      e.Type,
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string `json:"type"`
			Unknown any    `json:"unknown,omitempty"`
		}{
			Type:    e.Type,
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleNamedType
		}{
			Type:             e.Type,
			ExampleNamedType: e.Named,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(any) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		return visitor.VisitPrimitive(e.Primitive)
	case "container":
		return visitor.VisitContainer(e.Container)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	case "named":
		return visitor.VisitNamed(e.Named)
	}
}

type ExampleTypeShape struct {
	Type   string
	Alias  *ExampleAliasType
	Enum   *ExampleEnumType
	Object *ExampleObjectType
	Union  *ExampleSingleUnionType
}

func NewExampleTypeShapeFromAlias(value *ExampleAliasType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "alias", Alias: value}
}

func NewExampleTypeShapeFromEnum(value *ExampleEnumType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "enum", Enum: value}
}

func NewExampleTypeShapeFromObject(value *ExampleObjectType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "object", Object: value}
}

func NewExampleTypeShapeFromUnion(value *ExampleSingleUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "union", Union: value}
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleSingleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleAliasType
		}{
			Type:             e.Type,
			ExampleAliasType: e.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEnumType
		}{
			Type:            e.Type,
			ExampleEnumType: e.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleObjectType
		}{
			Type:              e.Type,
			ExampleObjectType: e.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleSingleUnionType
		}{
			Type:                   e.Type,
			ExampleSingleUnionType: e.Union,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleSingleUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return visitor.VisitAlias(e.Alias)
	case "enum":
		return visitor.VisitEnum(e.Enum)
	case "object":
		return visitor.VisitObject(e.Object)
	case "union":
		return visitor.VisitUnion(e.Union)
	}
}

type Literal struct {
	Type   string
	String string
}

func NewLiteralFromString(value string) *Literal {
	return &Literal{Type: "string", String: value}
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   l.Type,
			String: l.String,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralVisitor interface {
	VisitString(string) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		return visitor.VisitString(l.String)
	}
}

type MapType struct {
	KeyType   *TypeReference `json:"keyType,omitempty"`
	ValueType *TypeReference `json:"valueType,omitempty"`
}

type ObjectProperty struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty"`
}

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends,omitempty"`
	Properties []*ObjectProperty   `json:"properties,omitempty"`
}

type PrimitiveType string

const (
	PrimitiveTypeInteger PrimitiveType = "INTEGER"
	PrimitiveTypeDouble  PrimitiveType = "DOUBLE"
	PrimitiveTypeString  PrimitiveType = "STRING"
	PrimitiveTypeBoolean PrimitiveType = "BOOLEAN"
	// Within the range -2^53 to 2^53
	PrimitiveTypeLong     PrimitiveType = "LONG"
	PrimitiveTypeDateTime PrimitiveType = "DATE_TIME"
	PrimitiveTypeDate     PrimitiveType = "DATE"
	PrimitiveTypeUuid     PrimitiveType = "UUID"
	PrimitiveTypeBase64   PrimitiveType = "BASE_64"
)

func NewPrimitiveTypeFromString(s string) (PrimitiveType, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeInteger, nil
	case "DOUBLE":
		return PrimitiveTypeDouble, nil
	case "STRING":
		return PrimitiveTypeString, nil
	case "BOOLEAN":
		return PrimitiveTypeBoolean, nil
	case "LONG":
		return PrimitiveTypeLong, nil
	case "DATE_TIME":
		return PrimitiveTypeDateTime, nil
	case "DATE":
		return PrimitiveTypeDate, nil
	case "UUID":
		return PrimitiveTypeUuid, nil
	case "BASE_64":
		return PrimitiveTypeBase64, nil
	}
	var t PrimitiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveType) Ptr() *PrimitiveType {
	return &p
}

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name,omitempty"`
	Shape ShapeType         `json:"shape,omitempty"`
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive PrimitiveType
	Unknown   any
}

func NewResolvedTypeReferenceFromContainer(value *ContainerType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "container", Container: value}
}

func NewResolvedTypeReferenceFromNamed(value *ResolvedNamedType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "named", Named: value}
}

func NewResolvedTypeReferenceFromPrimitive(value PrimitiveType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "primitive", Primitive: value}
}

func NewResolvedTypeReferenceFromUnknown(value any) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "unknown", Unknown: value}
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      r.Type,
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*ResolvedNamedType
		}{
			Type:              r.Type,
			ResolvedNamedType: r.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      r.Type,
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string `json:"_type"`
			Unknown any    `json:"unknown,omitempty"`
		}{
			Type:    r.Type,
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(any) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		return visitor.VisitContainer(r.Container)
	case "named":
		return visitor.VisitNamed(r.Named)
	case "primitive":
		return visitor.VisitPrimitive(r.Primitive)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty"`
	DiscriminantValue *NameAndWireValue          `json:"discriminantValue,omitempty"`
	Shape             *SingleUnionTypeProperties `json:"shape,omitempty"`
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           any
}

func NewSingleUnionTypePropertiesFromSamePropertiesAsObject(value *DeclaredTypeName) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleUnionTypePropertiesFromSingleProperty(value *SingleUnionTypeProperty) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "singleProperty", SingleProperty: value}
}

func NewSingleUnionTypePropertiesFromNoProperties(value any) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "noProperties", NoProperties: value}
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch s.PropertiesType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*DeclaredTypeName
		}{
			PropertiesType:   s.PropertiesType,
			DeclaredTypeName: s.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*SingleUnionTypeProperty
		}{
			PropertiesType:          s.PropertiesType,
			SingleUnionTypeProperty: s.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			NoProperties   any    `json:"noProperties,omitempty"`
		}{
			PropertiesType: s.PropertiesType,
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(any) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	switch s.PropertiesType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

type SingleUnionTypeProperty struct {
	Name *NameAndWireValue `json:"name,omitempty"`
	Type *TypeReference    `json:"type,omitempty"`
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		var marshaler = struct {
			Type string `json:"_type"`
			*AliasTypeDeclaration
		}{
			Type:                 t.Type,
			AliasTypeDeclaration: t.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"_type"`
			*EnumTypeDeclaration
		}{
			Type:                t.Type,
			EnumTypeDeclaration: t.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"_type"`
			*ObjectTypeDeclaration
		}{
			Type:                  t.Type,
			ObjectTypeDeclaration: t.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"_type"`
			*UnionTypeDeclaration
		}{
			Type:                 t.Type,
			UnionTypeDeclaration: t.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"_type"`
			*UndiscriminatedUnionTypeDeclaration
		}{
			Type:                                t.Type,
			UndiscriminatedUnionTypeDeclaration: t.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return visitor.VisitAlias(t.Alias)
	case "enum":
		return visitor.VisitEnum(t.Enum)
	case "object":
		return visitor.VisitObject(t.Object)
	case "union":
		return visitor.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}

// A type, which is a name and a shape
type TypeDeclaration struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *DeclaredTypeName `json:"name,omitempty"`
	Shape        *Type             `json:"shape,omitempty"`
	Examples     []*ExampleType    `json:"examples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []*DeclaredTypeName `json:"referencedTypes,omitempty"`
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *DeclaredTypeName
	Primitive PrimitiveType
	Unknown   any
}

func NewTypeReferenceFromContainer(value *ContainerType) *TypeReference {
	return &TypeReference{Type: "container", Container: value}
}

func NewTypeReferenceFromNamed(value *DeclaredTypeName) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromPrimitive(value PrimitiveType) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromUnknown(value any) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      t.Type,
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*DeclaredTypeName
		}{
			Type:             t.Type,
			DeclaredTypeName: t.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      t.Type,
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string `json:"_type"`
			Unknown any    `json:"unknown,omitempty"`
		}{
			Type:    t.Type,
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*DeclaredTypeName) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(any) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		return visitor.VisitContainer(t.Container)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty"`
	Type *TypeReference `json:"type,omitempty"`
}

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members,omitempty"`
}

type UnionTypeDeclaration struct {
	Discriminant *NameAndWireValue `json:"discriminant,omitempty"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends,omitempty"`
	Types          []*SingleUnionType  `json:"types,omitempty"`
	BaseProperties []*ObjectProperty   `json:"baseProperties,omitempty"`
}

type VariableDeclaration struct {
	Docs *string        `json:"docs,omitempty"`
	Id   VariableId     `json:"id"`
	Name *Name          `json:"name,omitempty"`
	Type *TypeReference `json:"type,omitempty"`
}

type VariableId = string

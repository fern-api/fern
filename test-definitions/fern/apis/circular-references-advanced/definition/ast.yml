types:
  Animal:
    discriminated: false
    union:
      - Cat
      - Dog
  Fruit:
    discriminated: false
    union:
      - Acai
      - Fig
  Node:
    discriminated: false
    union:
      - BranchNode
      - LeafNode
  Cat:
    properties:
      fruit: Fruit
  Dog:
    properties:
      fruit: Fruit
  Acai:
    extends:
      - Berry
  Fig:
    properties:
      animal: Animal
  Berry:
    properties:
      animal: Animal
  BranchNode:
    properties:
      children: list<Node>
  LeafNode:
    properties: {}
  NodesWrapper:
    properties:
      nodes: list<list<Node>>
  ContainerValue:
    union:
      list: list<FieldValue>
      optional: optional<FieldValue>
  PrimitiveValue:
    enum:
      - STRING
      - NUMBER
  ObjectValue:
    properties: {}
  FieldName: string
  FieldValue:
    union:
      primitive_value: PrimitiveValue
      object_value: ObjectValue
      container_value: ContainerValue
  ObjectFieldValue:
    docs: This type allows us to test a circular reference with a union type (see FieldValue).
    properties:
      name: FieldName
      value: FieldValue
  # Test case for discriminated union with deeply nested self-referencing variants
  # This reproduces the circular import RecursionError issue found in ElevenLabs SDK
  # where multiple union variants reference lists of the same union type, creating
  # deep recursion during Pydantic V2 schema building.
  Expression:
    discriminant: type
    union:
      and_operator:
        type: AndExpression
      or_operator:
        type: OrExpression
      equals:
        type: EqualsExpression
      not_equals:
        type: NotEqualsExpression
      greater_than:
        type: GreaterThanExpression
      less_than:
        type: LessThanExpression
      number_literal:
        type: NumberLiteral
      boolean_literal:
        type: BooleanLiteral
      string_literal:
        type: StringLiteral
      variable:
        type: VariableExpression
  # Operators that take lists of expressions (like ElevenLabs AST nodes)
  AndExpression:
    properties:
      children: list<Expression>
  OrExpression:
    properties:
      children: list<Expression>
  # Binary operators that take two expressions
  EqualsExpression:
    properties:
      left: Expression
      right: Expression
  NotEqualsExpression:
    properties:
      left: Expression
      right: Expression
  GreaterThanExpression:
    properties:
      left: Expression
      right: Expression
  LessThanExpression:
    properties:
      left: Expression
      right: Expression
  # Leaf nodes (literals and variables)
  NumberLiteral:
    properties:
      value: double
  BooleanLiteral:
    properties:
      value: boolean
  StringLiteral:
    properties:
      value: string
  VariableExpression:
    properties:
      name: string

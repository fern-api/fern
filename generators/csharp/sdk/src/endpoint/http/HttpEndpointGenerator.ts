import { assertNever } from "@fern-api/core-utils";
import { ast, is, Writer } from "@fern-api/csharp-codegen";
import { FernIr } from "@fern-fern/ir-sdk";
import {
    CursorPagination,
    ExampleEndpointCall,
    HttpEndpoint,
    OffsetPagination,
    RequestProperty,
    ResponseError,
    ResponseProperty,
    ServiceId
} from "@fern-fern/ir-sdk/api";
import { fail } from "assert";
import { SdkGeneratorContext } from "../../SdkGeneratorContext";
import { AbstractEndpointGenerator } from "../AbstractEndpointGenerator";
import { EndpointSignatureInfo } from "../EndpointSignatureInfo";
import { SingleEndpointSnippet } from "../snippets/EndpointSnippetsGenerator";
import { getEndpointReturnType } from "../utils/getEndpointReturnType";
import { RawClient } from "./RawClient";

export declare namespace EndpointGenerator {
    export interface Args {
        /** the reference to the client */
        clientReference: string;
        /** the endpoint for the endpoint */
        endpoint: HttpEndpoint;
        /** reference to a variable that is the body */
        bodyReference?: string;
    }
}

export class HttpEndpointGenerator extends AbstractEndpointGenerator {
    public constructor({ context }: { context: SdkGeneratorContext }) {
        super({ context });
    }

    public generate(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        if (this.hasPagination(endpoint)) {
            this.generatePagerMethod(cls, {
                serviceId,
                endpoint,
                rawClientReference,
                rawClient
            });

            if (endpoint.pagination.type !== "custom") {
                this.generateUnpagedMethod(cls, {
                    serviceId,
                    endpoint,
                    rawClientReference,
                    rawClient
                });
            }
        } else {
            this.generateUnpagedMethod(cls, {
                serviceId,
                endpoint,
                rawClientReference,
                rawClient
            });
        }
    }

    private getHttpMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        // if this is a paginated endpoint, don't return a snippet for the internal method
        if (this.hasPagination(endpoint)) {
            return undefined;
        }
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private getHttpPagerMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        this.assertHasPagination(endpoint);
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private generateUnpagedMethod(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        const endpointSignatureInfo = this.getUnpagedEndpointSignatureInfo({
            serviceId,
            endpoint
        });
        const parameters = [...endpointSignatureInfo.baseParameters];
        parameters.push(this.getRequestOptionsParameter({ endpoint }));
        parameters.push(
            this.csharp.parameter({
                type: this.System.Threading.CancellationToken,
                name: this.names.parameters.cancellationToken,
                initializer: "default"
            })
        );
        const return_ = getEndpointReturnType({ context: this.context, endpoint });
        const snippet = this.getHttpMethodSnippet({ endpoint });

        // WithRawResponseTask methods use a different pattern:
        // - Public method is non-async and returns WithRawResponseTask<T>
        // - Private "Core" method is async and contains the actual implementation
        // - No exception handler wrapping (Core method handles it)
        const isWithRawResponseTask = return_ != null && "name" in return_ && return_.name === "WithRawResponseTask";

        const body = this.csharp.codeblock((writer) => {
            if (isWithRawResponseTask) {
                this.writeWithRawResponseTaskMethodBody(
                    endpointSignatureInfo,
                    writer,
                    rawClient,
                    endpoint,
                    rawClientReference
                );
            } else {
                this.writeUnpagedMethodBody(
                    endpointSignatureInfo,
                    writer,
                    rawClient,
                    endpoint,
                    rawClientReference,
                    serviceId
                );
            }
        });

        const publicMethod = cls.addMethod({
            name: this.getUnpagedEndpointMethodName(endpoint),
            access: this.hasPagination(endpoint) ? ast.Access.Private : ast.Access.Public,
            isAsync: !isWithRawResponseTask,
            parameters,
            summary: endpoint.docs,
            return_,
            body: isWithRawResponseTask ? body : this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });

        // For WithRawResponseTask methods, add a private async overload that does the actual work
        if (isWithRawResponseTask) {
            this.addWithRawResponseTaskCoreMethod(
                cls,
                endpointSignatureInfo,
                rawClient,
                endpoint,
                rawClientReference,
                parameters
            );
        }

        return publicMethod;
    }

    private getUnpagedEndpointMethodName(endpoint: HttpEndpoint): string {
        let name = this.context.getEndpointMethodName(endpoint);
        if (this.hasPagination(endpoint)) {
            name = name.replace("Async", "InternalAsync");
        }
        return name;
    }

    private writeUnpagedMethodBody(
        endpointSignatureInfo: EndpointSignatureInfo,
        writer: Writer,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string,
        serviceId: ServiceId
    ) {
        const request = endpointSignatureInfo.request;

        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }
        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryString: queryParameterCodeBlock?.queryStringReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }

        writer.write(`var ${this.names.variables.response} = `);
        writer.writeNodeStatement(
            rawClient.sendRequestWithRequestWrapper({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const successResponseStatements = this.getEndpointSuccessResponseStatements({ endpoint });
        if (successResponseStatements != null) {
            writer.writeNode(successResponseStatements);
        }
        writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
    }

    /**
     * Adds a private async overload method that does the actual async work for WithRawResponseTask methods.
     * This follows the C# pattern of having a public non-async method that calls a private async "Core" method.
     */
    private addWithRawResponseTaskCoreMethod(
        cls: ast.Class,
        endpointSignatureInfo: EndpointSignatureInfo,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string,
        parameters: ast.Parameter[]
    ) {
        const baseType = this.getBaseResponseType(endpoint);
        // For async methods, we don't wrap in Task<> because the C# compiler does that automatically
        const asyncReturnType = baseType
            ? this.csharp.classReference({
                  name: "WithRawResponse",
                  namespace: this.namespaces.root,
                  generics: [baseType]
              })
            : undefined;

        const body = this.csharp.codeblock((writer) => {
            const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
            if (queryParameterCodeBlock != null) {
                queryParameterCodeBlock.code.write(writer);
            }
            const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
            if (headerParameterCodeBlock != null) {
                headerParameterCodeBlock.code.write(writer);
            }
            const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
            if (requestBodyCodeBlock?.code != null) {
                writer.writeNode(requestBodyCodeBlock.code);
            }
            const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
                baseUrl: this.getBaseURLForEndpoint({ endpoint }),
                requestType: endpointSignatureInfo.request?.getRequestType(),
                endpoint,
                bodyReference: requestBodyCodeBlock?.requestBodyReference,
                pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
                headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
                queryString: queryParameterCodeBlock?.queryStringReference,
                endpointRequest: endpointSignatureInfo.request
            });
            if (apiRequestCodeBlock.code) {
                writer.writeNode(apiRequestCodeBlock.code);
            }

            // Call SendRequestAsync with await
            writer.write(`var ${this.names.variables.response} = `);
            writer.writeNode(
                rawClient.sendRequestWithRequestWrapper({
                    request: apiRequestCodeBlock.requestReference,
                    clientReference: rawClientReference
                })
            );
            writer.writeSemicolonIfLastCharacterIsNot();
            writer.writeLine();

            // Generate success and error handling that returns WithRawResponse<T>
            this.writeWithRawResponseSuccessAndErrorHandling(endpoint, writer);
        });

        cls.addMethod({
            name: this.getUnpagedEndpointMethodName(endpoint) + "Core",
            access: ast.Access.Private,
            isAsync: true,
            parameters,
            return_: asyncReturnType,
            body: this.wrapWithExceptionHandler({ body, returnType: asyncReturnType })
        });
    }

    private writeWithRawResponseTaskMethodBody(
        endpointSignatureInfo: EndpointSignatureInfo,
        writer: Writer,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string
    ) {
        // Generate synchronous method that returns WithRawResponseTask<T>
        // It calls a private async "Core" method that does the actual work

        // Return WithRawResponseTask<T> wrapping call to private Core method
        writer.write("return new ");
        const returnType = getEndpointReturnType({ context: this.context, endpoint });
        if (returnType) {
            writer.writeNode(returnType);
        }
        writer.write("(");
        writer.write(this.getUnpagedEndpointMethodName(endpoint) + "Core(");

        // Pass all parameters to the Core method
        // baseParameters already includes path parameters and request parameter
        const allParams = endpointSignatureInfo.baseParameters.map((p) => p.name);
        // Add the options and cancellation token parameters
        allParams.push(this.names.parameters.requestOptions);
        allParams.push(this.names.parameters.cancellationToken);

        writer.write(allParams.join(", "));
        writer.writeTextStatement("));");
    }

    /**
     * Gets the base response type (unwrapped from WithRawResponseTask) for an endpoint.
     * This is the inner T in WithRawResponseTask<T> or WithRawResponse<T>.
     */
    private getBaseResponseType(endpoint: HttpEndpoint): ast.Type | undefined {
        if (endpoint.response?.body == null) {
            if (endpoint.method === FernIr.HttpMethod.Head) {
                return this.System.Net.Http.HttpResponseHeaders;
            }
            return undefined;
        }

        return endpoint.response.body._visit<ast.Type | undefined>({
            streaming: () => undefined, // Streaming endpoints don't use WithRawResponseTask
            streamParameter: () => undefined,
            fileDownload: () => this.System.IO.Stream.asFullyQualified(),
            json: (reference) =>
                this.context.csharpTypeMapper.convert({
                    reference: reference.responseBodyType
                }),
            text: () => this.generation.Primitive.string,
            bytes: () => undefined,
            _other: () => undefined
        });
    }

    private writeWithRawResponseSuccessAndErrorHandling(endpoint: HttpEndpoint, writer: Writer) {
        // Generate success and error handling that returns WithRawResponse<T>
        // This is used inside the local async function for WithRawResponseTask methods

        writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
        writer.pushScope();

        const response = endpoint.response;
        if (response?.body != null) {
            response.body._visit({
                json: (reference) => {
                    const astType = this.context.csharpTypeMapper.convert({
                        reference: reference.responseBodyType
                    });

                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("var responseData = ");
                    writer.writeNode(this.Types.JsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(astType);
                    writer.writeTextStatement(`>(${this.names.variables.responseBody})!`);

                    // Return WithRawResponse<T>
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [astType]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine("Data = responseData,");
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeTextStatement(";");

                    writer.popScope();
                    writer.write("catch (", this.System.Text.Json.JsonException, " e)");
                    writer.pushScope();
                    writer.write("throw new ");
                    writer.writeNode(this.Types.BaseApiException);
                    writer.write('("Failed to deserialize response", ');
                    writer.write(`${this.names.variables.response}.StatusCode, `);
                    writer.write(`${this.names.variables.responseBody}, `);
                    writer.write("e");
                    writer.writeTextStatement(")");
                    writer.popScope();
                },
                text: () => {
                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );

                    // Return WithRawResponse<string>
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [this.Primitive.string]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`Data = ${this.names.variables.responseBody},`);
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeTextStatement(";");
                },
                fileDownload: () => {
                    writer.writeTextStatement(
                        `var stream = await ${this.names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                    );

                    // Return WithRawResponse<Stream>
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [this.System.IO.Stream.asFullyQualified()]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine("Data = stream,");
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeTextStatement(";");
                },
                bytes: () => this.context.logger.error("Bytes not supported"),
                streaming: () => this.context.logger.error("Streaming not supported with WithRawResponseTask"),
                streamParameter: () =>
                    this.context.logger.error("Stream parameter not supported with WithRawResponseTask"),
                _other: () => undefined
            });
        } else if (endpoint.method === FernIr.HttpMethod.Head) {
            // HEAD requests return headers wrapped in WithRawResponse
            writer.write("return new ");
            writer.writeNode(
                this.csharp.classReference({
                    name: "WithRawResponse",
                    namespace: this.context.namespaces.root,
                    generics: [this.System.Net.Http.HttpResponseHeaders]
                })
            );
            writer.writeLine("()");
            writer.pushScope();
            writer.writeLine(`Data = ${this.names.variables.response}.Raw.Headers,`);
            writer.write("RawResponse = new ");
            writer.writeNode(
                this.csharp.classReference({
                    name: "RawResponse",
                    namespace: this.context.namespaces.root
                })
            );
            writer.writeLine("()");
            writer.pushScope();
            writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
            writer.writeLine(
                `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
            );
            writer.write("Headers = ");
            writer.writeNode(
                this.csharp.classReference({
                    name: "ResponseHeaders",
                    namespace: this.context.namespaces.core
                })
            );
            writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
            writer.popScope(); // Close RawResponse{}
            writer.popScope(); // Close WithRawResponse{}
            writer.writeTextStatement(";");
        }

        writer.popScope();

        // Error handling
        writer.pushScope();
        writer.writeTextStatement(
            `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
        );

        if (
            endpoint.errors.length > 0 &&
            this.context.ir.errorDiscriminationStrategy.type === "statusCode" &&
            this.settings.generateErrorTypes
        ) {
            writer.writeLine("try");
            writer.pushScope();
            writer.write("switch (", this.names.variables.response, ".StatusCode)");
            writer.pushScope();

            const handled = new Set<number>();
            for (const error of endpoint.errors) {
                const errorDeclaration = this.context.ir.errors[error.error.errorId];
                if (errorDeclaration == null || handled.has(errorDeclaration.statusCode)) {
                    continue;
                }
                handled.add(errorDeclaration.statusCode);
                this.writeErrorCase(error, writer);
            }

            writer.popScope();
            writer.popScope();
            writer.write("catch (", this.System.Text.Json.JsonException, ")");
            writer.pushScope();
            writer.writeLine("// unable to map error response, throwing generic error");
            writer.popScope();
        }

        writer.write(
            "throw new ",
            this.Types.BaseApiException,
            `($"Error with status code {${this.names.variables.response}.StatusCode}", ${this.names.variables.response}.StatusCode, `
        );
        writer.writeTextStatement(`${this.names.variables.responseBody})`);
        writer.popScope();
    }

    private getBaseURLForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        if (endpoint.baseUrl != null && this.context.ir.environments?.environments.type === "multipleBaseUrls") {
            const baseUrl = this.context.ir.environments?.environments.baseUrls.find(
                (baseUrlWithId) => baseUrlWithId.id === endpoint.baseUrl
            );
            if (baseUrl != null) {
                return this.csharp.codeblock(`_client.Options.Environment.${baseUrl.name.pascalCase.safeName}`);
            }
        }
        return this.csharp.codeblock("_client.Options.BaseUrl");
    }

    private getEndpointErrorHandling({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        return this.csharp.codeblock((writer) => {
            writer.pushScope();
            writer.writeTextStatement(
                `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
            );
            if (
                endpoint.errors.length > 0 &&
                this.context.ir.errorDiscriminationStrategy.type === "statusCode" &&
                this.settings.generateErrorTypes
            ) {
                writer.writeLine("try");
                writer.pushScope();
                writer.write("switch (", this.names.variables.response, ".StatusCode)");
                writer.pushScope();

                // ensure that each response code is handled only once
                const handled = new Set<number>();
                for (const error of endpoint.errors) {
                    const errorDeclaration = this.context.ir.errors[error.error.errorId];
                    if (errorDeclaration == null || handled.has(errorDeclaration.statusCode)) {
                        continue;
                    }
                    handled.add(errorDeclaration.statusCode);
                    this.writeErrorCase(error, writer);
                }

                writer.popScope();
                writer.popScope();
                writer.write("catch (", this.System.Text.Json.JsonException, ")");
                writer.pushScope();
                writer.writeLine("// unable to map error response, throwing generic error");
                writer.popScope();
            }
            writer.write(
                "throw new ",
                this.Types.BaseApiException,
                `($"Error with status code {${this.names.variables.response}.StatusCode}", ${this.names.variables.response}.StatusCode, `
            );
            writer.writeTextStatement(`${this.names.variables.responseBody})`);
            writer.popScope();
        });
    }

    private writeErrorCase(error: ResponseError, writer: Writer) {
        const fullError = this.context.ir.errors[error.error.errorId];
        if (fullError == null) {
            throw new Error(`Unexpected no error found for error id: ${error.error.errorId}`);
        }
        writer.writeLine(`case ${fullError.statusCode}:`);
        writer.indent();
        writer.write("throw new ");
        writer.writeNode(this.context.getExceptionClassReference(fullError.name));
        writer.write("(");
        writer.writeNode(this.Types.JsonUtils);
        writer.write(".Deserialize<");
        writer.writeNode(
            fullError.type != null
                ? this.context.csharpTypeMapper.convert({ reference: fullError.type })
                : this.Primitive.object
        );
        writer.writeTextStatement(`>(${this.names.variables.responseBody}))`);
    }

    private getEndpointSuccessResponseStatements({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock | undefined {
        if (endpoint.response?.body == null) {
            return this.csharp.codeblock((writer) => {
                writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                if (endpoint.method === FernIr.HttpMethod.Head) {
                    writer.writeLine("return response.Raw.Headers;");
                } else {
                    writer.writeLine("return;");
                }
                writer.popScope();
            });
        }

        const body = endpoint.response.body;
        const context = this.context;
        const names = this.names;

        function handleStreaming(writer: Writer) {
            return (value: FernIr.StreamingResponse) => {
                function readLineFromResponse() {
                    writer.writeLine(`if (${names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(`string? line`);
                    writer.write(`using var reader = `);
                    writer.write(
                        context.System.IO.StreamReader.new({
                            arguments_: [
                                context.csharp.codeblock(
                                    `await ${names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                                )
                            ]
                        })
                    );
                    writer.writeTextStatement(";");
                    writer.writeLine("while (!string.IsNullOrEmpty(line = await reader.ReadLineAsync()))");
                    writer.pushScope();
                }

                function deserializeJsonChunk(
                    payloadType: ast.Type,
                    jsonUtils: ast.ClassReference,
                    exceptionClass: ast.ClassReference,
                    jsonString: string,
                    yieldResult: boolean
                ) {
                    if (is.OneOf.OneOf(payloadType)) {
                        // we have to tear this apart and figure out which one to deserialize
                        // based on the union type?
                        for (const each of payloadType.generics) {
                            writer.pushScope();
                            writer.write(
                                `if(`,
                                jsonUtils,
                                `.TryDeserialize(`,
                                jsonString,
                                `, out `,
                                each,
                                `? result))`
                            );
                            writer.pushScope();

                            if (yieldResult) {
                                writer.write("yield ");
                            }

                            writer.writeTextStatement(`return result!`);
                            writer.popScope();
                            writer.popScope();
                        }
                        return;
                    }

                    writer.writeStatement(payloadType.asOptional(), `result`);
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("result = ");
                    writer.writeNode(jsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(payloadType);
                    writer.writeTextStatement(`>(${jsonString})`);
                    writer.popScope();
                    writer.writeLine("catch (System.Text.Json.JsonException)");
                    writer.pushScope();
                    writer.writeStatement(
                        "throw new ",
                        exceptionClass,
                        `($"Unable to deserialize JSON response '`,
                        jsonString,
                        `'")`
                    );
                    writer.popScope();
                }

                value._visit({
                    json: (jsonChunk) => {
                        readLineFromResponse();
                        const payloadType = context.csharpTypeMapper.convert({
                            reference: jsonChunk.payload
                        });
                        deserializeJsonChunk(
                            payloadType,
                            context.generation.Types.JsonUtils,
                            context.generation.Types.BaseException,
                            "line",
                            true
                        );
                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    text: () => {
                        readLineFromResponse();
                        writer.writeLine("if(!string.IsNullOrEmpty(line))");
                        writer.pushScope();
                        writer.writeTextStatement("yield return line");
                        writer.popScope();

                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    sse: (sseChunk) => {
                        const payloadType = context.csharpTypeMapper.convert({
                            reference: sseChunk.payload
                        });
                        writer.writeLine(`if (${names.variables.response}.StatusCode is >= 200 and < 400)`);
                        writer.pushScope();

                        writer.write(`await foreach (var item in `);
                        writer.writeNode(context.System.Net.ServerSentEvents.SseParser);
                        writer.writeLine(
                            `.Create(await ${names.variables.response}.Raw.Content.ReadAsStreamAsync()).EnumerateAsync(cancellationToken))`
                        );
                        writer.pushScope();

                        writer.writeLine("if( !string.IsNullOrEmpty(item.Data))");
                        writer.pushScope();

                        if (sseChunk.terminator) {
                            writer.writeLine(`if( item.Data == "${sseChunk.terminator}")`);
                            writer.pushScope();
                            writer.writeTextStatement("break");
                            writer.popScope();
                        }

                        deserializeJsonChunk(
                            payloadType,
                            context.generation.Types.JsonUtils,
                            context.generation.Types.BaseException,
                            "item.Data",
                            true
                        );

                        writer.popScope();
                        writer.popScope();
                        writer.writeTextStatement("yield break");

                        writer.popScope();
                    },
                    _other: () => {
                        writer.write('/* "Other" Streaming not currently implemented */');
                    }
                });
            };
        }

        return this.csharp.codeblock((writer) => {
            body._visit({
                streamParameter: (ref) => {
                    return handleStreaming(writer)(ref.streamResponse);
                },
                fileDownload: (value) => {
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();
                    writer.writeTextStatement(
                        `var stream = await ${this.names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                    );

                    // Wrap in WithRawResponseTask
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponseTask",
                            namespace: this.context.namespaces.root,
                            generics: [this.System.IO.Stream.asFullyQualified()]
                        })
                    );
                    writer.writeLine("(");
                    writer.write(this.System.Threading.Tasks.Task());
                    writer.write(".FromResult(new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [this.System.IO.Stream.asFullyQualified()]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine("Data = stream,");
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeLine("));");
                    writer.popScope();
                },
                json: (reference) => {
                    const astType = this.context.csharpTypeMapper.convert({
                        reference: reference.responseBodyType
                    });
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    // Deserialize the response as json
                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("var responseData = ");
                    writer.writeNode(this.Types.JsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(astType);
                    // todo: Maybe remove ! below and handle potential null. Requires introspecting type to know if its
                    // nullable.
                    writer.writeLine(`>(${this.names.variables.responseBody})!;`);

                    // Wrap in WithRawResponseTask
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponseTask",
                            namespace: this.context.namespaces.root,
                            generics: [astType]
                        })
                    );
                    writer.writeLine("(");
                    writer.write(this.System.Threading.Tasks.Task());
                    writer.write(".FromResult(new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [astType]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine("Data = responseData,");
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeLine("));");
                    writer.popScope();

                    writer.write("catch (");
                    writer.writeNode(this.System.Text.Json.JsonException);
                    writer.writeLine(" e)");
                    writer.pushScope();

                    writer.write("throw new ");
                    writer.writeNode(this.Types.BaseApiException);
                    writer.write('("Failed to deserialize response", ');
                    writer.write(`${this.names.variables.response}.StatusCode, `);
                    writer.write(`${this.names.variables.responseBody}`);
                    writer.writeTextStatement(")");
                    writer.popScope();

                    writer.popScope();

                    writer.writeLine();
                },
                streaming: (ref) => handleStreaming(writer)(ref),
                text: () => {
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );

                    // Wrap in WithRawResponseTask
                    writer.write("return new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponseTask",
                            namespace: this.context.namespaces.root,
                            generics: [this.Primitive.string]
                        })
                    );
                    writer.writeLine("(");
                    writer.write(this.System.Threading.Tasks.Task());
                    writer.write(".FromResult(new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "WithRawResponse",
                            namespace: this.context.namespaces.root,
                            generics: [this.Primitive.string]
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`Data = ${this.names.variables.responseBody},`);
                    writer.write("RawResponse = new ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "RawResponse",
                            namespace: this.context.namespaces.root
                        })
                    );
                    writer.writeLine("()");
                    writer.pushScope();
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.Raw.StatusCode,`);
                    writer.writeLine(
                        `Url = ${this.names.variables.response}.Raw.RequestMessage?.RequestUri ?? new Uri("about:blank"),`
                    );
                    writer.write("Headers = ");
                    writer.writeNode(
                        this.csharp.classReference({
                            name: "ResponseHeaders",
                            namespace: this.context.namespaces.core
                        })
                    );
                    writer.writeLine(`.FromHttpResponseMessage(${this.names.variables.response}.Raw)`);
                    writer.popScope(); // Close RawResponse{}
                    writer.popScope(); // Close WithRawResponse{}
                    writer.writeLine("));");
                    writer.popScope();
                },
                bytes: () => this.context.logger.error("Bytes not supported"),
                _other: () => undefined
            });
        });
    }

    public generatePagerMethod(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        this.assertHasPagination(endpoint);
        const endpointSignatureInfo = this.getEndpointSignatureInfo({
            serviceId,
            endpoint
        });
        const parameters = [...endpointSignatureInfo.baseParameters];
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({
            endpoint
        });
        const requestOptionsParam = this.getRequestOptionsParameter({ endpoint });
        parameters.push(requestOptionsParam);
        parameters.push(
            this.csharp.parameter({
                type: this.System.Threading.CancellationToken,
                name: this.names.parameters.cancellationToken,
                initializer: "default"
            })
        );
        const requestOptionsType = requestOptionsParam.type;
        const itemType = this.getPaginationItemType(endpoint);
        const return_ = this.getPagerReturnType(endpoint);
        const snippet = this.getHttpPagerMethodSnippet({ endpoint });
        const body = this.csharp.codeblock((writer) => {
            const requestParameter = endpointSignatureInfo.requestParameter;
            // For pagination, we need the base response type (unwrapped from WithRawResponseTask)
            // because the pager lambdas work with the actual response data, not the task wrapper
            const unpagedEndpointResponseType = this.getBaseResponseType(endpoint);
            if (!unpagedEndpointResponseType) {
                throw new Error("Internal error; a response type is required for pagination endpoints");
            }

            switch (endpoint.pagination.type) {
                case "offset":
                    this.generateOffsetMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint,
                        serviceId
                    });
                    break;
                case "cursor":
                    this.generateCursorMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint,
                        serviceId
                    });
                    break;
                case "custom":
                    this.generateCustomPagerMethodBody({
                        serviceId,
                        endpoint,
                        rawClient,
                        rawClientReference,
                        writer
                    });
                    break;
                default:
                    assertNever(endpoint.pagination);
            }
        });
        return cls.addMethod({
            name: this.context.getEndpointMethodName(endpoint),
            access: ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });
    }

    private generateOffsetMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint,
        serviceId
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: OffsetPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type;
        unpagedEndpointResponseType: ast.Type;
        itemType: ast.Type;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
        serviceId: ServiceId;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        if (requestParameter.type.isOptional) {
            writer.writeLine("if (request is not null)");
            writer.pushScope();
        }

        writer.writeLine("request = request with { };");

        if (requestParameter.type.isOptional) {
            writer.popScope();
        }

        const offsetType = this.context.csharpTypeMapper.convert({
            reference: pagination.page.property.valueType
        });
        // use specified type or fallback to object
        const stepType = pagination.step
            ? this.context.csharpTypeMapper.convert({
                  reference: pagination.step?.property.valueType
              })
            : this.Primitive.object;
        const offsetPagerClassReference = this.Types.OffsetPager({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            offsetType,
            stepType,
            itemType
        });

        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: offsetPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    this.csharp.codeblock(requestParameter.name),
                    this.csharp.codeblock(optionsParamName),
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    this.csharp.codeblock(
                        `request => ${this.dotAccess(requestParameter.type, "request", pagination.page)} ?? 0`
                    ),
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, offset) =>");
                        writer.pushScope();

                        if (pagination.page.propertyPath && pagination.page.propertyPath.length > 0) {
                            writer.writeStatement(
                                "request.",
                                this.getDotAccess(unpagedEndpointResponseType, pagination.page, false).code,
                                " ??= new ()"
                            );
                        }

                        writer.writeTextStatement(
                            `${this.dotAccess(requestParameter.type, "request", pagination.page, false)} = offset`
                        );
                        writer.popScope();
                    }),
                    this.csharp.codeblock(
                        pagination.step
                            ? `request => ${this.dotAccess(requestParameter.type, "request", pagination.step)} ?? 0`
                            : "null"
                    ),
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(requestParameter.type, "response", pagination.results)}?.ToList()`
                    ),
                    this.csharp.codeblock(
                        pagination.hasNextPage
                            ? `response => ${this.dotAccess(requestParameter.type, "response", pagination.hasNextPage)}`
                            : "null"
                    ),
                    this.csharp.codeblock(this.names.parameters.cancellationToken)
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    private generateUnpagedEndpointCallback({
        requestParameter,
        endpoint
    }: {
        requestParameter: ast.Parameter | undefined;
        endpoint: HttpEndpoint;
    }): ast.CodeBlock {
        const { pathParameters } = this.getAllPathParameters({
            endpoint,
            requestParameter
        });
        // For pagination, the pager expects a function that returns Task<T> (the unwrapped response type).
        // Our unpaged methods return WithRawResponseTask<T>, which has an implicit conversion to Task<T>,
        // but older .NET frameworks don't handle this well with delegate type inference.
        // So we wrap the call in a lambda that uses the implicit conversion operator explicitly.
        return this.csharp.codeblock((writer) => {
            writer.write("async (request, options, cancellationToken) => ");
            if (pathParameters.length === 0) {
                writer.write(
                    `await ${this.getUnpagedEndpointMethodName(endpoint)}(request, options, cancellationToken)`
                );
            } else {
                writer.writeNode(
                    this.csharp.invokeMethod({
                        async: true,
                        method: this.getUnpagedEndpointMethodName(endpoint),
                        arguments_: [
                            ...pathParameters.map((parameter) => this.csharp.codeblock(parameter.name)),
                            this.csharp.codeblock("request"),
                            this.csharp.codeblock("options"),
                            this.csharp.codeblock("cancellationToken")
                        ]
                    })
                );
            }
        });
    }

    private generateCursorMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint,
        serviceId
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: CursorPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type;
        unpagedEndpointResponseType: ast.Type;
        itemType: ast.Type;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
        serviceId: ServiceId;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        writer.writeLine("if (request is not null)");
        writer.pushScope();
        writer.writeLine("request = request with { };");
        writer.popScope();

        const cursorType = this.context.csharpTypeMapper.convert({
            reference: pagination.next.property.valueType
        });
        const cursorPagerClassReference = this.Types.CursorPager({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            cursorType,
            itemType
        });

        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: cursorPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    // TRequest
                    this.csharp.codeblock(requestParameter.name),
                    // TRequestOptions parameter
                    this.csharp.codeblock(optionsParamName),
                    // SendRequest
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    // SetCursor
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, cursor) =>");
                        writer.pushScope();
                        if (pagination.page.propertyPath && pagination.page.propertyPath.length > 0) {
                            const { code, enclosingType } = this.getDotAccess(
                                requestParameter.type,
                                pagination.page,
                                false
                            );
                            writer.writeStatement(
                                "request.",
                                code,
                                "??=",
                                this.csharp.instantiateClass({
                                    classReference: enclosingType,
                                    arguments_: [],
                                    // If any fields require initialization (ie, required and no default value),
                                    // we have to provide it at least *some* value so that this code will actually compile
                                    properties: [...enclosingType.scope.fields]
                                        .map((each) => each.field)
                                        .filter(is.NonNullable)
                                        .filter((each) => each.needsIntialization)
                                        .map((each) => ({
                                            name: each.name,
                                            value: each.type.defaultValue
                                        }))
                                })
                            );
                        }
                        writer.writeTextStatement(
                            `${this.dotAccess(requestParameter.type, "request", pagination.page, false)} = cursor`
                        );
                        writer.popScope();
                    }),
                    // GetNextCursor
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(unpagedEndpointResponseType, "response", pagination.next)}`
                    ),
                    // GetItems
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(unpagedEndpointResponseType, "response", pagination.results)}?.ToList()`
                    ),
                    // CancellationToken
                    this.csharp.codeblock(this.names.parameters.cancellationToken)
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    public generateCustomPagerMethodBody({
        serviceId,
        endpoint,
        rawClient,
        rawClientReference,
        writer
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClient: RawClient;
        rawClientReference: string;
        writer: Writer;
    }): void {
        const endpointSignatureInfo = this.getEndpointSignatureInfo({
            serviceId,
            endpoint
        });
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({
            endpoint
        });
        const itemType = this.getPaginationItemType(endpoint);
        // For pagination, we need the base response type (unwrapped from WithRawResponseTask)
        // because the pager lambdas work with the actual response data, not the task wrapper
        const unpagedEndpointResponseType = this.getBaseResponseType(endpoint);
        if (!unpagedEndpointResponseType) {
            throw new Error("Internal error; a response type is required for pagination endpoints");
        }

        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }

        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }
        writer.write(`var ${this.names.variables.httpRequest} = `);
        writer.writeNodeStatement(
            rawClient.createHttpRequestAsync({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const cancellationTokenName = this.names.parameters.cancellationToken;
        writer.writeNodeStatement(
            this.csharp.codeblock((writer) => {
                writer.write(
                    `var ${this.names.variables.sendRequest} = async (HttpRequestMessage ${this.names.variables.httpRequest}, CancellationToken ${cancellationTokenName}) =>`
                );
                writer.pushScope();

                writer.write(`var ${this.names.variables.response} = `);
                writer.writeNodeStatement(
                    rawClient.sendRequestWithHttpRequest({
                        request: this.csharp.codeblock(this.names.variables.httpRequest),
                        options: this.csharp.codeblock(optionsParamName),
                        clientReference: rawClientReference,
                        cancellationToken: this.csharp.codeblock(cancellationTokenName)
                    })
                );

                writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                // Deserialize the response as json
                writer.writeTextStatement(`return ${this.names.variables.response}.Raw`);
                writer.popScope();
                writer.writeLine();

                writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
                writer.popScope();
            })
        );

        writer.write("return ");
        writer.writeNodeStatement(
            this.context.invokeCustomPagerFactoryMethod({
                itemType,
                sendRequestMethod: this.csharp.codeblock(this.names.variables.sendRequest),
                initialRequest: this.csharp.codeblock(this.names.variables.httpRequest),
                clientOptions: this.csharp.codeblock(`${rawClientReference}.Options`),
                requestOptions: this.csharp.codeblock(optionsParamName),
                cancellationToken: this.csharp.codeblock(this.names.parameters.cancellationToken)
            })
        );
    }

    private getDotAccess(
        encType: ast.Type,
        { property, propertyPath }: RequestProperty | ResponseProperty,
        allowOptional: boolean = true
    ): { code: string; enclosingType: ast.ClassReference } {
        encType = encType.asNonOptional();
        let enclosingType = is.ClassReference(encType)
            ? encType
            : fail(`Expected ClassReference, got ${encType.fullyQualifiedName}`);

        if (!propertyPath || propertyPath.length === 0) {
            return {
                code: this.csharp.getPropertyName(enclosingType, property),
                enclosingType
            };
        }
        let optional = "";

        return {
            code: propertyPath
                .map((val) => {
                    // get the property name for the current property
                    const propertyName = this.csharp.getPropertyName(enclosingType, val);

                    // get the type of the current property
                    let typeOfValue = this.context.csharpTypeMapper.convert({
                        reference: val.type
                    });
                    optional = allowOptional && is.Optional(typeOfValue) ? "?" : "";
                    typeOfValue = typeOfValue.asNonOptional();

                    // find the classRef for that type
                    if (is.ClassReference(typeOfValue)) {
                        enclosingType = typeOfValue;
                    }
                    // return the property name
                    return `${propertyName}${optional}`;
                })
                .join("."),
            enclosingType
        };
    }

    private dotAccess(
        encType: ast.Type,
        variableName: string,
        property: RequestProperty | ResponseProperty,
        allowOptional: boolean = true
    ): string {
        encType = encType.asNonOptional();
        let enclosingType = is.ClassReference(encType)
            ? encType
            : fail(`Expected ClassReference, got ${encType.fullyQualifiedName}`);

        if (!property.propertyPath || property.propertyPath.length === 0) {
            return `${variableName}.${this.csharp.getPropertyName(enclosingType, property.property)}`;
        }
        const dotAccess = this.getDotAccess(enclosingType, property, allowOptional);
        return `${variableName}.${dotAccess.code}.${this.csharp.getPropertyName(dotAccess.enclosingType, property.property)}`;
    }

    public override generateEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        requestOptions,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        requestOptions?: ast.CodeBlock;
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        const additionalEndParameters = requestOptions != null ? [requestOptions] : [];
        return this.hasPagination(endpoint)
            ? this.generateHttpPagerEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              })
            : this.generateHttpEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              });
    }

    public generateHttpPagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return this.generatePagerEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    public generateHttpEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return super.generateEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    private generatePagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        parseDatetimes,
        serviceId,
        additionalEndParameters
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        parseDatetimes: boolean;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
    }): ast.MethodInvocation | undefined {
        const service = this.context.getHttpService(serviceId) ?? fail(`Service with id ${serviceId} not found`);
        const serviceFilePath = service.name.fernFilepath;
        const args = this.getNonEndpointArguments({
            endpoint,
            example,
            parseDatetimes
        });
        const endpointRequestSnippet = this.getEndpointRequestSnippet(example, endpoint, serviceId, parseDatetimes);
        if (endpointRequestSnippet != null) {
            args.push(endpointRequestSnippet);
        }
        const on = this.csharp.codeblock((writer) => {
            writer.write(`${clientVariableName}`);
            for (const path of serviceFilePath.allParts) {
                writer.write(`.${path.pascalCase.safeName}`);
            }
        });
        for (const endParameter of additionalEndParameters ?? []) {
            args.push(endParameter);
        }

        getEndpointReturnType({ context: this.context, endpoint });
        return this.csharp.invokeMethod({
            method: this.context.getEndpointMethodName(endpoint),
            arguments_: args,
            on,
            async: true,
            configureAwait: true,
            generics: []
        });
    }

    private getRequestOptionsParameter({ endpoint }: { endpoint: HttpEndpoint }): ast.Parameter {
        const name = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        if (endpoint.idempotent) {
            return this.csharp.parameter({
                type: this.Types.IdempotentRequestOptions.asOptional(),
                name,
                initializer: "null"
            });
        } else {
            return this.csharp.parameter({
                type: this.Types.RequestOptions.asOptional(),
                name,
                initializer: "null"
            });
        }
    }

    private getRequestOptionsParamNameForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): string {
        if (endpoint.idempotent) {
            return this.names.parameters.idempotentOptions;
        } else {
            return this.names.parameters.requestOptions;
        }
    }
}

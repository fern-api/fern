import { assertNever } from "@fern-api/core-utils";
import { ast, Writer } from "@fern-api/csharp-codegen";
import { FernIr } from "@fern-fern/ir-sdk";
import {
    CursorPagination,
    ExampleEndpointCall,
    HttpEndpoint,
    OffsetPagination,
    RequestProperty,
    ResponseError,
    ResponseProperty,
    ServiceId
} from "@fern-fern/ir-sdk/api";
import { SdkGeneratorContext } from "../../SdkGeneratorContext";
import { AbstractEndpointGenerator } from "../AbstractEndpointGenerator";
import { EndpointSignatureInfo } from "../EndpointSignatureInfo";
import { SingleEndpointSnippet } from "../snippets/EndpointSnippetsGenerator";
import { getEndpointReturnType } from "../utils/getEndpointReturnType";
import { RawClient } from "./RawClient";

export declare namespace EndpointGenerator {
    export interface Args {
        /** the reference to the client */
        clientReference: string;
        /** the endpoint for the endpoint */
        endpoint: HttpEndpoint;
        /** reference to a variable that is the body */
        bodyReference?: string;
    }
}

const HTTP_REQUEST_VARIABLE_NAME = "httpRequest";
const SEND_REQUEST_LAMBDA_VARIABLE_NAME = "sendRequest";
const RESPONSE_VARIABLE_NAME = "response";
const RESPONSE_BODY_VARIABLE_NAME = "responseBody";

export class HttpEndpointGenerator extends AbstractEndpointGenerator {
    public constructor({ context }: { context: SdkGeneratorContext }) {
        super({ context });
    }

    public generate({
        serviceId,
        endpoint,
        rawClientReference,
        rawClient
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClientReference: string;
        rawClient: RawClient;
    }): ast.Method[] {
        const methods: ast.Method[] = [];
        if (this.hasPagination(endpoint)) {
            methods.push(
                this.generatePagerMethod({
                    serviceId,
                    endpoint,
                    rawClientReference,
                    rawClient
                })
            );
            if (endpoint.pagination.type !== "custom") {
                methods.push(
                    this.generateUnpagedMethod({
                        serviceId,
                        endpoint,
                        rawClientReference,
                        rawClient
                    })
                );
            }
        } else {
            methods.push(
                this.generateUnpagedMethod({
                    serviceId,
                    endpoint,
                    rawClientReference,
                    rawClient
                })
            );
        }

        return methods;
    }

    private getHttpMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        // if this is a paginated endpoint, don't return a snippet for the internal method
        if (this.hasPagination(endpoint)) {
            return undefined;
        }
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private getHttpPagerMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        this.assertHasPagination(endpoint);
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private generateUnpagedMethod({
        serviceId,
        endpoint,
        rawClientReference,
        rawClient
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClientReference: string;
        rawClient: RawClient;
    }): ast.Method {
        const endpointSignatureInfo = this.getUnpagedEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        parameters.push(this.getRequestOptionsParameter({ endpoint }));
        parameters.push(
            this.csharp.parameter({
                type: this.csharp.Type.reference(this.context.getCancellationTokenClassReference()),
                name: this.context.getCancellationTokenParameterName(),
                initializer: "default"
            })
        );
        const return_ = getEndpointReturnType({ context: this.context, endpoint });
        const snippet = this.getHttpMethodSnippet({ endpoint });
        const body = this.csharp.codeblock((writer) => {
            this.writeUnpagedMethodBody(endpointSignatureInfo, writer, rawClient, endpoint, rawClientReference);
        });

        return this.csharp.method({
            name: this.getUnpagedEndpointMethodName(endpoint),
            access: this.hasPagination(endpoint) ? ast.Access.Private : ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });
    }

    private getUnpagedEndpointMethodName(endpoint: HttpEndpoint): string {
        let name = this.context.getEndpointMethodName(endpoint);
        if (this.hasPagination(endpoint)) {
            name = name.replace("Async", "InternalAsync");
        }
        return name;
    }

    private writeUnpagedMethodBody(
        endpointSignatureInfo: EndpointSignatureInfo,
        writer: Writer,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string
    ) {
        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }
        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryBagReference: queryParameterCodeBlock?.queryParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }

        writer.write(`var ${RESPONSE_VARIABLE_NAME} = `);
        writer.writeNodeStatement(
            rawClient.sendRequestWithRequestWrapper({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const successResponseStatements = this.getEndpointSuccessResponseStatements({ endpoint });
        if (successResponseStatements != null) {
            writer.writeNode(successResponseStatements);
        }
        writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
    }

    private getBaseURLForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        if (endpoint.baseUrl != null && this.context.ir.environments?.environments.type === "multipleBaseUrls") {
            const baseUrl = this.context.ir.environments?.environments.baseUrls.find(
                (baseUrlWithId) => baseUrlWithId.id === endpoint.baseUrl
            );
            if (baseUrl != null) {
                return this.csharp.codeblock(`_client.Options.Environment.${baseUrl.name.pascalCase.safeName}`);
            }
        }
        return this.csharp.codeblock("_client.Options.BaseUrl");
    }

    private getEndpointErrorHandling({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        return this.csharp.codeblock((writer) => {
            writer.pushScope();
            writer.writeTextStatement(
                `var ${RESPONSE_BODY_VARIABLE_NAME} = await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStringAsync()`
            );
            if (
                endpoint.errors.length > 0 &&
                this.context.ir.errorDiscriminationStrategy.type === "statusCode" &&
                (this.context.customConfig["generate-error-types"] ?? true)
            ) {
                writer.writeLine("try");
                writer.pushScope();
                writer.write("switch (", RESPONSE_VARIABLE_NAME, ".StatusCode)");
                writer.pushScope();

                // ensure that each response code is handled only once
                const handled = new Set<number>();
                for (const error of endpoint.errors) {
                    const errorDeclaration = this.context.ir.errors[error.error.errorId];
                    if (errorDeclaration == null || handled.has(errorDeclaration.statusCode)) {
                        continue;
                    }
                    handled.add(errorDeclaration.statusCode);
                    this.writeErrorCase(error, writer);
                }

                writer.popScope();
                writer.popScope();
                writer.write("catch (", this.csharp.System.Text.Json.JsonException, ")");
                writer.pushScope();
                writer.writeLine("// unable to map error response, throwing generic error");
                writer.popScope();
            }
            writer.write(
                "throw new ",
                this.context.getBaseApiExceptionClassReference(),
                `($"Error with status code {${RESPONSE_VARIABLE_NAME}.StatusCode}", ${RESPONSE_VARIABLE_NAME}.StatusCode, `
            );
            writer.writeTextStatement(`${RESPONSE_BODY_VARIABLE_NAME})`);
            writer.popScope();
        });
    }

    private writeErrorCase(error: ResponseError, writer: Writer) {
        const fullError = this.context.ir.errors[error.error.errorId];
        if (fullError == null) {
            throw new Error("Unexpected no error found for error id: " + error.error.errorId);
        }
        writer.writeLine(`case ${fullError.statusCode}:`);
        writer.indent();
        writer.write("throw new ");
        writer.writeNode(this.context.getExceptionClassReference(fullError.name));
        writer.write("(");
        writer.writeNode(this.context.getJsonUtilsClassReference());
        writer.write(".Deserialize<");
        writer.writeNode(
            fullError.type != null
                ? this.context.csharpTypeMapper.convert({ reference: fullError.type })
                : this.csharp.Type.object()
        );
        writer.writeTextStatement(`>(${RESPONSE_BODY_VARIABLE_NAME}))`);
    }

    private getEndpointSuccessResponseStatements({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock | undefined {
        if (endpoint.response?.body == null) {
            return this.csharp.codeblock((writer) => {
                writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                if (endpoint.method === FernIr.HttpMethod.Head) {
                    writer.writeLine("return response.Raw.Headers;");
                } else {
                    writer.writeLine("return;");
                }
                writer.popScope();
            });
        }

        const body = endpoint.response.body;
        const context = this.context;

        function handleStreaming(writer: Writer) {
            return (value: FernIr.StreamingResponse) => {
                function readLineFromResponse() {
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(`string? line`);
                    writer.write(`using var reader = `);
                    writer.write(
                        context.System.IO.StreamReader.instantiate({
                            arguments_: [
                                context.csharp.codeblock(
                                    `await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStreamAsync()`
                                )
                            ]
                        })
                    );
                    writer.writeTextStatement(";");
                    writer.writeLine("while (!string.IsNullOrEmpty(line = await reader.ReadLineAsync()))");
                    writer.pushScope();
                }

                function deserializeJsonChunk(
                    payloadType: ast.Type,
                    jsonUtils: ast.ClassReference,
                    exceptionClass: ast.ClassReference,
                    jsonString: string,
                    yieldResult: boolean
                ) {
                    if (context.csharp.is.Type.oneOf(payloadType)) {
                        // we have to tear this apart and figure out which one to deserialize
                        // based on the union type?
                        for (const each of payloadType.oneOfTypes()) {
                            writer.pushScope();
                            writer.write(
                                `if(`,
                                jsonUtils,
                                `.TryDeserialize(`,
                                jsonString,
                                `, out `,
                                each,
                                `? result))`
                            );
                            writer.pushScope();

                            if (yieldResult) {
                                writer.write("yield ");
                            }

                            writer.writeTextStatement(`return result!`);
                            writer.popScope();
                            writer.popScope();
                        }
                        return;
                    }

                    writer.writeStatement(payloadType.toOptionalIfNotAlready(), `result`);
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("result = ");
                    writer.writeNode(jsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(payloadType);
                    writer.writeTextStatement(`>(${jsonString})`);
                    writer.popScope();
                    writer.writeLine("catch (System.Text.Json.JsonException)");
                    writer.pushScope();
                    writer.writeStatement(
                        "throw new ",
                        exceptionClass,
                        `($"Unable to deserialize JSON response '`,
                        jsonString,
                        `'")`
                    );
                    writer.popScope();
                }

                value._visit({
                    json: (jsonChunk) => {
                        readLineFromResponse();
                        const payloadType = context.csharpTypeMapper.convert({ reference: jsonChunk.payload });
                        deserializeJsonChunk(
                            payloadType,
                            context.getJsonUtilsClassReference(),
                            context.getBaseExceptionClassReference(),
                            "line",
                            true
                        );
                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    text: () => {
                        readLineFromResponse();
                        writer.writeLine("if(!string.IsNullOrEmpty(line))");
                        writer.pushScope();
                        writer.writeTextStatement("yield return line");
                        writer.popScope();

                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    sse: (sseChunk) => {
                        // todo: implement SSE - this is a placeholder for now
                        const payloadType = context.csharpTypeMapper.convert({ reference: sseChunk.payload });
                        writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                        writer.pushScope();

                        writer.write(`await foreach (var item in `);
                        writer.writeNode(context.System.Net.ServerSentEvents.SseParser);
                        writer.writeLine(
                            `.Create(await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStreamAsync()).EnumerateAsync(cancellationToken))`
                        );
                        writer.pushScope();

                        writer.writeLine("if( !string.IsNullOrEmpty(item.Data))");
                        writer.pushScope();

                        if (sseChunk.terminator) {
                            writer.writeLine(`if( item.Data == "${sseChunk.terminator}")`);
                            writer.pushScope();
                            writer.writeTextStatement("break");
                            writer.popScope();
                        }

                        deserializeJsonChunk(
                            payloadType,
                            context.getJsonUtilsClassReference(),
                            context.getBaseExceptionClassReference(),
                            "item.Data",
                            true
                        );

                        writer.popScope();
                        writer.popScope();
                        writer.writeTextStatement("yield break");

                        writer.popScope();
                    },
                    _other: () => {
                        writer.write('/* "Other" Streaming not currently implemented */');
                    }
                });
            };
        }

        return this.csharp.codeblock((writer) => {
            body._visit({
                streamParameter: (ref) => {
                    return handleStreaming(writer)(ref.streamResponse);
                },
                fileDownload: (value) => {
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();
                    writer.writeTextStatement(`return await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStreamAsync()`);
                    writer.popScope();
                },
                json: (reference) => {
                    const astType = this.context.csharpTypeMapper.convert({ reference: reference.responseBodyType });
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    // Deserialize the response as json
                    writer.writeTextStatement(
                        `var ${RESPONSE_BODY_VARIABLE_NAME} = await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("return ");
                    writer.writeNode(this.context.getJsonUtilsClassReference());
                    writer.write(".Deserialize<");
                    writer.writeNode(astType);
                    // todo: Maybe remove ! below and handle potential null. Requires introspecting type to know if its
                    // nullable.
                    writer.writeLine(`>(${RESPONSE_BODY_VARIABLE_NAME})!;`);
                    writer.popScope();

                    writer.write("catch (");
                    writer.writeNode(this.csharp.System.Text.Json.JsonException);
                    writer.writeLine(" e)");
                    writer.pushScope();

                    writer.write("throw new ");
                    writer.writeNode(this.context.getBaseExceptionClassReference());
                    writer.writeTextStatement('("Failed to deserialize response", e)');
                    writer.popScope();

                    writer.popScope();

                    writer.writeLine();
                },
                streaming: (ref) => handleStreaming(writer)(ref),
                text: () => {
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(
                        `var ${RESPONSE_BODY_VARIABLE_NAME} = await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeTextStatement(`return ${RESPONSE_BODY_VARIABLE_NAME}`);
                    writer.popScope();
                },
                bytes: () => this.context.logger.error("Bytes not supported"),
                _other: () => undefined
            });
        });
    }

    public generatePagerMethod({
        serviceId,
        endpoint,
        rawClientReference,
        rawClient
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClientReference: string;
        rawClient: RawClient;
    }): ast.Method {
        this.assertHasPagination(endpoint);
        const endpointSignatureInfo = this.getEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        const requestOptionsParam = this.getRequestOptionsParameter({ endpoint });
        parameters.push(requestOptionsParam);
        parameters.push(
            this.csharp.parameter({
                type: this.csharp.Type.reference(this.context.getCancellationTokenClassReference()),
                name: this.context.getCancellationTokenParameterName(),
                initializer: "default"
            })
        );
        const requestOptionsType = requestOptionsParam.type;
        const itemType = this.getPaginationItemType(endpoint);
        const return_ = this.getPagerReturnType(endpoint);
        const snippet = this.getHttpPagerMethodSnippet({ endpoint });
        const body = this.csharp.codeblock((writer) => {
            const requestParameter = endpointSignatureInfo.requestParameter;
            const unpagedEndpointResponseType = getEndpointReturnType({ context: this.context, endpoint });
            if (!unpagedEndpointResponseType) {
                throw new Error("Internal error; a response type is required for pagination endpoints");
            }

            switch (endpoint.pagination.type) {
                case "offset":
                    this.generateOffsetMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint
                    });
                    break;
                case "cursor":
                    this.generateCursorMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint
                    });
                    break;
                case "custom":
                    this.generateCustomPagerMethodBody({
                        serviceId,
                        endpoint,
                        rawClient,
                        rawClientReference,
                        writer
                    });
                    break;
                default:
                    assertNever(endpoint.pagination);
            }
        });
        return this.csharp.method({
            name: this.context.getEndpointMethodName(endpoint),
            access: ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });
    }

    private generateOffsetMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: OffsetPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type | ast.TypeParameter;
        unpagedEndpointResponseType: ast.Type;
        itemType: ast.Type;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        if (requestParameter.type.isOptional()) {
            writer.writeLine("if (request is not null)");
            writer.pushScope();
        }

        writer.writeLine("request = request with { };");

        if (requestParameter.type.isOptional()) {
            writer.popScope();
        }

        const offsetType = this.context.csharpTypeMapper.convert({
            reference: pagination.page.property.valueType
        });
        // use specified type or fallback to object
        const stepType = pagination.step
            ? this.context.csharpTypeMapper.convert({
                  reference: pagination.step?.property.valueType
              })
            : this.csharp.Type.object();
        const offsetPagerClassReference = this.context.getOffsetPagerClassReference({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            offsetType,
            stepType,
            itemType
        });
        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: offsetPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    this.csharp.codeblock(requestParameter.name),
                    this.csharp.codeblock(optionsParamName),
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    this.csharp.codeblock(`request => ${this.nullableDotGet("request", pagination.page)} ?? 0`),
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, offset) =>");
                        writer.pushScope();

                        this.initializeNestedObjects(writer, "request", pagination.page);
                        writer.writeTextStatement(`${this.dotGet("request", pagination.page)} = offset`);
                        writer.popScope();
                    }),
                    this.csharp.codeblock(
                        pagination.step ? `request => ${this.nullableDotGet("request", pagination.step)} ?? 0` : "null"
                    ),
                    this.csharp.codeblock(
                        `response => ${this.nullableDotGet("response", pagination.results)}?.ToList()`
                    ),
                    this.csharp.codeblock(
                        pagination.hasNextPage
                            ? `response => ${this.nullableDotGet("response", pagination.hasNextPage)}`
                            : "null"
                    ),
                    this.csharp.codeblock(this.context.getCancellationTokenParameterName())
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    private generateUnpagedEndpointCallback({
        requestParameter,
        endpoint
    }: {
        requestParameter: ast.Parameter | undefined;
        endpoint: HttpEndpoint;
    }): ast.CodeBlock {
        const { pathParameters } = this.getAllPathParameters({
            endpoint,
            requestParameter
        });
        if (pathParameters.length === 0) {
            return this.csharp.codeblock(this.getUnpagedEndpointMethodName(endpoint));
        }
        return this.csharp.codeblock((writer) => {
            writer.write("(request, options, cancellationToken) => ");
            writer.writeNode(
                this.csharp.invokeMethod({
                    method: this.getUnpagedEndpointMethodName(endpoint),
                    arguments_: [
                        ...pathParameters.map((parameter) => this.csharp.codeblock(parameter.name)),
                        this.csharp.codeblock("request"),
                        this.csharp.codeblock("options"),
                        this.csharp.codeblock("cancellationToken")
                    ]
                })
            );
        });
    }

    private generateCursorMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: CursorPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type | ast.TypeParameter;
        unpagedEndpointResponseType: ast.Type | ast.TypeParameter;
        itemType: ast.Type | ast.TypeParameter;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        writer.writeLine("if (request is not null)");
        writer.pushScope();
        writer.writeLine("request = request with { };");
        writer.popScope();

        const cursorType = this.context.csharpTypeMapper.convert({
            reference: pagination.next.property.valueType
        });
        const cursorPagerClassReference = this.context.getCursorPagerClassReference({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            cursorType,
            itemType
        });
        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: cursorPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    this.csharp.codeblock(requestParameter.name),
                    this.csharp.codeblock(optionsParamName),
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, cursor) =>");
                        writer.pushScope();
                        this.initializeNestedObjects(writer, "request", pagination.page);
                        writer.writeTextStatement(`${this.dotGet("request", pagination.page)} = cursor`);
                        writer.popScope();
                    }),
                    this.csharp.codeblock(`response => ${this.nullableDotGet("response", pagination.next)}`),
                    this.csharp.codeblock(
                        `response => ${this.nullableDotGet("response", pagination.results)}?.ToList()`
                    ),
                    this.csharp.codeblock(this.context.getCancellationTokenParameterName())
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    public generateCustomPagerMethodBody({
        serviceId,
        endpoint,
        rawClient,
        rawClientReference,
        writer
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClient: RawClient;
        rawClientReference: string;
        writer: Writer;
    }): void {
        const endpointSignatureInfo = this.getEndpointSignatureInfo({ serviceId, endpoint });
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        const itemType = this.getPaginationItemType(endpoint);
        const unpagedEndpointResponseType = getEndpointReturnType({ context: this.context, endpoint });
        if (!unpagedEndpointResponseType) {
            throw new Error("Internal error; a response type is required for pagination endpoints");
        }

        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }

        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryBagReference: queryParameterCodeBlock?.queryParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }
        writer.write(`var ${HTTP_REQUEST_VARIABLE_NAME} = `);
        writer.writeNodeStatement(
            rawClient.createHttpRequest({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const cancellationTokenName = this.context.getCancellationTokenParameterName();
        writer.writeNodeStatement(
            this.csharp.codeblock((writer) => {
                writer.write(
                    `var ${SEND_REQUEST_LAMBDA_VARIABLE_NAME} = async (HttpRequestMessage ${HTTP_REQUEST_VARIABLE_NAME}, CancellationToken ${cancellationTokenName}) =>`
                );
                writer.pushScope();

                writer.write(`var ${RESPONSE_VARIABLE_NAME} = `);
                writer.writeNodeStatement(
                    rawClient.sendRequestWithHttpRequest({
                        request: this.csharp.codeblock(HTTP_REQUEST_VARIABLE_NAME),
                        options: this.csharp.codeblock(optionsParamName),
                        clientReference: rawClientReference,
                        cancellationToken: this.csharp.codeblock(cancellationTokenName)
                    })
                );

                writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                // Deserialize the response as json
                writer.writeTextStatement(`return ${RESPONSE_VARIABLE_NAME}.Raw`);
                writer.popScope();
                writer.writeLine();

                writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
                writer.popScope();
            })
        );

        writer.write("return ");
        writer.writeNodeStatement(
            this.context.invokeCustomPagerFactoryMethod({
                itemType,
                sendRequestMethod: this.csharp.codeblock(SEND_REQUEST_LAMBDA_VARIABLE_NAME),
                initialRequest: this.csharp.codeblock(HTTP_REQUEST_VARIABLE_NAME),
                clientOptions: this.csharp.codeblock(`${rawClientReference}.Options`),
                requestOptions: this.csharp.codeblock(optionsParamName),
                cancellationToken: this.csharp.codeblock(this.context.getCancellationTokenParameterName())
            })
        );
    }

    private initializeNestedObjects(writer: Writer, variableName: string, { propertyPath }: RequestProperty) {
        if (!propertyPath || propertyPath.length === 0) {
            return;
        }

        for (let i = 0; i < propertyPath.length; i++) {
            const propertyPathPart = propertyPath.slice(0, i + 1);
            writer.writeTextStatement(
                `${variableName}.${propertyPathPart.map((val) => val.name.pascalCase.safeName).join(".")} ??= new ()`
            );
        }
    }

    private dotGet(variableName: string, { property, propertyPath }: RequestProperty | ResponseProperty): string {
        if (!propertyPath || propertyPath.length === 0) {
            return `${variableName}.${property.name.name.pascalCase.safeName}`;
        }
        return `${variableName}.${propertyPath.map((val) => val.name.pascalCase.safeName).join(".")}.${
            property.name.name.pascalCase.safeName
        }`;
    }

    private nullableDotGet(
        variableName: string,
        { property, propertyPath }: RequestProperty | ResponseProperty
    ): string {
        if (!propertyPath || propertyPath.length === 0) {
            return `${variableName}?.${property.name.name.pascalCase.safeName}`;
        }

        return `${variableName}?.${propertyPath.map((val) => val.name.pascalCase.safeName).join("?.")}?.${
            property.name.name.pascalCase.safeName
        }`;
    }

    public generateEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        requestOptions,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        requestOptions?: ast.CodeBlock;
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        const additionalEndParameters = requestOptions != null ? [requestOptions] : [];
        return this.hasPagination(endpoint)
            ? this.generateHttpPagerEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              })
            : this.generateHttpEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              });
    }

    public generateHttpPagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return this.generatePagerEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    public generateHttpEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return super.generateEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    private generatePagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        parseDatetimes,
        serviceId,
        additionalEndParameters
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        parseDatetimes: boolean;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
    }): ast.MethodInvocation | undefined {
        const service = this.context.getHttpServiceOrThrow(serviceId);
        const serviceFilePath = service.name.fernFilepath;
        const args = this.getNonEndpointArguments({ endpoint, example, parseDatetimes });
        const endpointRequestSnippet = this.getEndpointRequestSnippet(example, endpoint, serviceId, parseDatetimes);
        if (endpointRequestSnippet != null) {
            args.push(endpointRequestSnippet);
        }
        const on = this.csharp.codeblock((writer) => {
            writer.write(`${clientVariableName}`);
            for (const path of serviceFilePath.allParts) {
                writer.write(`.${path.pascalCase.safeName}`);
            }
        });
        for (const endParameter of additionalEndParameters ?? []) {
            args.push(endParameter);
        }

        getEndpointReturnType({ context: this.context, endpoint });
        return this.csharp.invokeMethod({
            method: this.context.getEndpointMethodName(endpoint),
            arguments_: args,
            on,
            async: true,
            configureAwait: true,
            generics: []
        });
    }

    private getRequestOptionsParameter({ endpoint }: { endpoint: HttpEndpoint }): ast.Parameter {
        const name = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        if (endpoint.idempotent) {
            return this.csharp.parameter({
                type: this.csharp.Type.optional(
                    this.csharp.Type.reference(this.context.getIdempotentRequestOptionsClassReference())
                ),
                name,
                initializer: "null"
            });
        } else {
            return this.csharp.parameter({
                type: this.csharp.Type.optional(
                    this.csharp.Type.reference(this.context.getRequestOptionsClassReference())
                ),
                name,
                initializer: "null"
            });
        }
    }

    private getRequestOptionsParamNameForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): string {
        if (endpoint.idempotent) {
            return this.context.getIdempotentRequestOptionsParameterName();
        } else {
            return this.context.getRequestOptionsParameterName();
        }
    }
}

import { assertNever } from "@fern-api/core-utils";
import { csharp } from "@fern-api/csharp-codegen";

import {
    CursorPagination,
    ExampleEndpointCall,
    HttpEndpoint,
    OffsetPagination,
    RequestProperty,
    ResponseError,
    ResponseProperty,
    ServiceId
} from "@fern-fern/ir-sdk/api";

import { SdkGeneratorContext } from "../../SdkGeneratorContext";
import { AbstractEndpointGenerator } from "../AbstractEndpointGenerator";
import { SingleEndpointSnippet } from "../snippets/EndpointSnippetsGenerator";
import { getEndpointReturnType } from "../utils/getEndpointReturnType";
import { RawClient } from "./RawClient";

export declare namespace EndpointGenerator {
    export interface Args {
        /** the reference to the client */
        clientReference: string;
        /** the endpoint for the endpoint */
        endpoint: HttpEndpoint;
        /** reference to a variable that is the body */
        bodyReference?: string;
    }
}

const RESPONSE_VARIABLE_NAME = "response";
const RESPONSE_BODY_VARIABLE_NAME = "responseBody";

export class HttpEndpointGenerator extends AbstractEndpointGenerator {
    public constructor({ context }: { context: SdkGeneratorContext }) {
        super({ context });
    }

    public generate({
        serviceId,
        endpoint,
        rawClientReference,
        rawClient
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClientReference: string;
        rawClient: RawClient;
    }): csharp.Method[] {
        const methods: csharp.Method[] = [
            this.generateHttpMethod({ serviceId, endpoint, rawClientReference, rawClient })
        ];
        if (this.hasPagination(endpoint)) {
            methods.push(this.generateHttpPagerMethod({ serviceId, endpoint }));
        }
        return methods;
    }

    private getHttpMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        // if this is a paginated endpoint, don't return a snippet for the internal method
        if (this.hasPagination(endpoint)) {
            return undefined;
        }
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private getHttpPagerMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        this.assertHasPagination(endpoint);
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    public generateHttpMethod({
        serviceId,
        endpoint,
        rawClientReference,
        rawClient
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClientReference: string;
        rawClient: RawClient;
    }): csharp.Method {
        const endpointSignatureInfo = this.getUnpagedEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        parameters.push(this.getRequestOptionsParameter({ endpoint }));
        parameters.push(
            csharp.parameter({
                type: csharp.Type.reference(this.context.getCancellationTokenClassReference()),
                name: this.context.getCancellationTokenParameterName(),
                initializer: "default"
            })
        );
        const return_ = getEndpointReturnType({ context: this.context, endpoint });
        const snippet = this.getHttpMethodSnippet({ endpoint });
        return csharp.method({
            name: this.context.getEndpointMethodName(endpoint),
            access: this.hasPagination(endpoint) ? csharp.Access.Internal : csharp.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: csharp.codeblock((writer) => {
                const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
                if (queryParameterCodeBlock != null) {
                    queryParameterCodeBlock.code.write(writer);
                }
                const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
                if (headerParameterCodeBlock != null) {
                    headerParameterCodeBlock.code.write(writer);
                }
                const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
                if (requestBodyCodeBlock?.code != null) {
                    writer.writeNode(requestBodyCodeBlock.code);
                }
                writer.write(`var ${RESPONSE_VARIABLE_NAME} = `);
                writer.writeNodeStatement(
                    rawClient.makeRequest({
                        baseUrl: this.getBaseURLForEndpoint({ endpoint }),
                        requestType: endpointSignatureInfo.request?.getRequestType(),
                        clientReference: rawClientReference,
                        endpoint,
                        bodyReference: requestBodyCodeBlock?.requestBodyReference,
                        pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
                        headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
                        queryBagReference: queryParameterCodeBlock?.queryParameterBagReference
                    })
                );
                const successResponseStatements = this.getEndpointSuccessResponseStatements({ endpoint });
                if (successResponseStatements != null) {
                    writer.writeNode(successResponseStatements);
                }
                writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
            }),
            codeExample: snippet?.endpointCall
        });
    }

    private getBaseURLForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): csharp.CodeBlock {
        if (endpoint.baseUrl != null && this.context.ir.environments?.environments.type === "multipleBaseUrls") {
            const baseUrl = this.context.ir.environments?.environments.baseUrls.find(
                (baseUrlWithId) => baseUrlWithId.id === endpoint.baseUrl
            );
            if (baseUrl != null) {
                return csharp.codeblock(`_client.Options.Environment.${baseUrl.name.pascalCase.safeName}`);
            }
        }
        return csharp.codeblock("_client.Options.BaseUrl");
    }

    private getNonEndpointParameters({ endpoint, serviceId }: { endpoint: HttpEndpoint; serviceId: ServiceId }): {
        parameters: csharp.Parameter[];
        pathParameterReferences: Record<string, string>;
    } {
        const parameters: csharp.Parameter[] = [];
        const service = this.context.getHttpServiceOrThrow(serviceId);
        const pathParameterReferences: Record<string, string> = {};
        for (const pathParam of [
            ...this.context.ir.pathParameters,
            ...service.pathParameters,
            ...endpoint.pathParameters
        ]) {
            const parameterName = pathParam.name.camelCase.safeName;
            pathParameterReferences[pathParam.name.originalName] = parameterName;
            parameters.push(
                csharp.parameter({
                    docs: pathParam.docs,
                    name: parameterName,
                    type: this.context.csharpTypeMapper.convert({ reference: pathParam.valueType })
                })
            );
        }
        return {
            parameters,
            pathParameterReferences
        };
    }

    private getEndpointErrorHandling({ endpoint }: { endpoint: HttpEndpoint }): csharp.CodeBlock {
        return csharp.codeblock((writer) => {
            if (endpoint.response?.body == null) {
                writer.writeTextStatement(
                    `var ${RESPONSE_BODY_VARIABLE_NAME} = await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStringAsync()`
                );
            }
            if (
                endpoint.errors.length > 0 &&
                this.context.ir.errorDiscriminationStrategy.type === "statusCode" &&
                (this.context.customConfig["generate-error-types"] ?? true)
            ) {
                writer.writeLine("try");
                writer.writeLine("{");
                writer.indent();
                writer.write("switch (");
                writer.write(`${RESPONSE_VARIABLE_NAME}.StatusCode)`);

                writer.writeLine("{");
                writer.indent();
                for (const error of endpoint.errors) {
                    this.writeErrorCase(error, writer);
                }
                writer.writeLine("}");
                writer.dedent();
                writer.writeLine("}");
                writer.writeLine("catch (");
                writer.writeNode(this.context.getJsonExceptionClassReference());
                writer.writeLine(")");
                writer.writeLine("{");
                writer.indent();
                writer.writeLine("// unable to map error response, throwing generic error");
                writer.dedent();
                writer.writeLine("}");
            }
            writer.write("throw new ");
            writer.writeNode(this.context.getBaseApiExceptionClassReference());
            writer.write(
                `($"Error with status code {${RESPONSE_VARIABLE_NAME}.StatusCode}", ${RESPONSE_VARIABLE_NAME}.StatusCode, `
            );
            writer.writeTextStatement(`${RESPONSE_BODY_VARIABLE_NAME})`);
        });
    }

    private writeErrorCase(error: ResponseError, writer: csharp.Writer) {
        const fullError = this.context.ir.errors[error.error.errorId];
        if (fullError == null) {
            throw new Error("Unexpected no error found for error id: " + error.error.errorId);
        }
        writer.writeLine(`case ${fullError.statusCode}:`);
        writer.indent();
        writer.write("throw new ");
        writer.writeNode(this.context.getExceptionClassReference(fullError.name));
        writer.write("(");
        writer.writeNode(this.context.getJsonUtilsClassReference());
        writer.write(".Deserialize<");
        writer.writeNode(
            fullError.type != null
                ? this.context.csharpTypeMapper.convert({ reference: fullError.type })
                : csharp.Type.object()
        );
        writer.writeTextStatement(`>(${RESPONSE_BODY_VARIABLE_NAME}))`);
    }

    private getEndpointSuccessResponseStatements({
        endpoint
    }: {
        endpoint: HttpEndpoint;
    }): csharp.CodeBlock | undefined {
        if (endpoint.response?.body == null) {
            return csharp.codeblock((writer) => {
                writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400) {`);
                writer.indent();
                writer.writeLine("return;");
                writer.dedent();
                writer.writeLine("}");
            });
        }
        const body = endpoint.response.body;
        return csharp.codeblock((writer) => {
            writer.writeTextStatement(
                `var ${RESPONSE_BODY_VARIABLE_NAME} = await ${RESPONSE_VARIABLE_NAME}.Raw.Content.ReadAsStringAsync()`
            );
            body._visit({
                streamParameter: () => this.context.logger.error("Stream parameters not supported"),
                fileDownload: () => this.context.logger.error("File download not supported"),
                json: (reference) => {
                    const astType = this.context.csharpTypeMapper.convert({ reference: reference.responseBodyType });
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400) {`);
                    writer.writeNewLineIfLastLineNot();

                    // Deserialize the response as json
                    writer.indent();
                    writer.writeLine("try");
                    writer.writeLine("{");
                    writer.indent();
                    writer.write("return ");
                    writer.writeNode(this.context.getJsonUtilsClassReference());
                    writer.write(".Deserialize<");
                    writer.writeNode(astType);
                    // todo: Maybe remove ! below and handle potential null. Requires introspecting type to know if its
                    // nullable.
                    writer.writeLine(`>(${RESPONSE_BODY_VARIABLE_NAME})!;`);
                    writer.dedent();
                    writer.writeLine("}");
                    writer.write("catch (");
                    writer.writeNode(this.context.getJsonExceptionClassReference());
                    writer.writeLine(" e)");
                    writer.writeLine("{");
                    writer.indent();
                    writer.write("throw new ");
                    writer.writeNode(this.context.getBaseExceptionClassReference());
                    writer.writeTextStatement('("Failed to deserialize response", e)');
                    writer.dedent();
                    writer.writeLine("}");
                    writer.dedent();
                    writer.writeLine("}");
                    writer.writeLine();
                },
                streaming: () => this.context.logger.error("Streaming not supported"),
                text: () => {
                    writer.writeLine(`if (${RESPONSE_VARIABLE_NAME}.StatusCode is >= 200 and < 400) {`);
                    writer.writeNewLineIfLastLineNot();

                    writer.writeTextStatement(`return ${RESPONSE_BODY_VARIABLE_NAME}`);

                    writer.indent();
                    writer.writeLine("}");
                    writer.dedent();
                },
                _other: () => undefined
            });
        });
    }

    public generateHttpPagerMethod({
        serviceId,
        endpoint
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
    }): csharp.Method {
        this.assertHasPagination(endpoint);
        const endpointSignatureInfo = this.getEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        const requestOptionsParam = this.getRequestOptionsParameter({ endpoint });
        const requestOptionsType = requestOptionsParam.type;
        parameters.push(requestOptionsParam);
        const itemType = this.getPaginationItemType(endpoint);
        const return_ = this.getPagerReturnType(endpoint);
        const snippet = this.getHttpPagerMethodSnippet({ endpoint });
        return csharp.method({
            name: this.context.getEndpointMethodName(endpoint),
            access: csharp.Access.Public,
            isAsync: false,
            parameters,
            summary: endpoint.docs,
            return_,
            body: csharp.codeblock((writer) => {
                const requestParam = endpointSignatureInfo.requestParameter;
                if (!requestParam) {
                    throw new Error("Request parameter is required for pagination");
                }
                const unpagedEndpointMethodName = this.context.getEndpointMethodName(endpoint);
                const unpagedEndpointResponseType = getEndpointReturnType({ context: this.context, endpoint });
                if (!unpagedEndpointResponseType) {
                    throw new Error("Internal error; a response type is required for pagination endpoints");
                }

                writer.writeLine("if (request is not null)");
                writer.writeLine("{");
                writer.indent();
                writer.writeLine("request = request with { };");
                writer.dedent();
                writer.writeLine("}");

                switch (endpoint.pagination.type) {
                    case "offset":
                        this.generateOffsetMethodBody({
                            pagination: endpoint.pagination,
                            requestParam,
                            requestOptionsType,
                            unpagedEndpointResponseType,
                            itemType,
                            writer,
                            optionsParamName,
                            unpagedEndpointMethodName
                        });
                        break;
                    case "cursor":
                        this.generateCursorMethodBody({
                            pagination: endpoint.pagination,
                            requestParam,
                            requestOptionsType,
                            unpagedEndpointResponseType,
                            itemType,
                            writer,
                            optionsParamName,
                            unpagedEndpointMethodName
                        });
                        break;
                    default:
                        assertNever(endpoint.pagination);
                }
            }),
            codeExample: snippet?.endpointCall
        });
    }

    private generateOffsetMethodBody({
        pagination,
        requestParam,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        unpagedEndpointMethodName
    }: {
        pagination: OffsetPagination;
        requestParam: csharp.Parameter;
        requestOptionsType: csharp.Type;
        unpagedEndpointResponseType: csharp.Type;
        itemType: csharp.Type;
        writer: csharp.Writer;
        optionsParamName: string;
        unpagedEndpointMethodName: string;
    }) {
        const offsetType = this.context.csharpTypeMapper.convert({
            reference: pagination.page.property.valueType
        });
        // use specified type or fallback to object
        const stepType = pagination.step
            ? this.context.csharpTypeMapper.convert({
                  reference: pagination.step?.property.valueType
              })
            : csharp.Type.object();
        const offsetPagerClassReference = this.context.getOffsetPagerClassReference({
            requestType: requestParam.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            offsetType,
            stepType,
            itemType
        });
        writer.write("var pager = ");
        writer.writeNodeStatement(
            csharp.instantiateClass({
                classReference: offsetPagerClassReference,
                arguments_: [
                    csharp.codeblock(requestParam.name),
                    csharp.codeblock(optionsParamName),
                    csharp.codeblock(unpagedEndpointMethodName),
                    csharp.codeblock(`request => ${this.nullableDotGet("request", pagination.page)} ?? 0`),
                    csharp.codeblock((writer) => {
                        writer.writeLine("(request, offset) => {");
                        writer.indent();
                        this.initializeNestedObjects(writer, "request", pagination.page);
                        writer.writeTextStatement(`${this.dotGet("request", pagination.page)} = offset`);
                        writer.dedent();
                        writer.writeLine("}");
                    }),
                    csharp.codeblock(
                        pagination.step ? `request => ${this.nullableDotGet("request", pagination.step)} ?? 0` : "null"
                    ),
                    csharp.codeblock(`response => ${this.nullableDotGet("response", pagination.results)}?.ToList()`),
                    csharp.codeblock(
                        pagination.hasNextPage
                            ? `response => ${this.nullableDotGet("response", pagination.hasNextPage)}`
                            : "null"
                    )
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    private generateCursorMethodBody({
        pagination,
        requestParam,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        unpagedEndpointMethodName
    }: {
        pagination: CursorPagination;
        requestParam: csharp.Parameter;
        requestOptionsType: csharp.Type;
        unpagedEndpointResponseType: csharp.Type;
        itemType: csharp.Type;
        writer: csharp.Writer;
        optionsParamName: string;
        unpagedEndpointMethodName: string;
    }) {
        const cursorType = this.context.csharpTypeMapper.convert({
            reference: pagination.next.property.valueType
        });

        const cursorPagerClassReference = this.context.getCursorPagerClassReference({
            requestType: requestParam.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            cursorType,
            itemType
        });
        writer.write("var pager = ");
        writer.writeNodeStatement(
            csharp.instantiateClass({
                classReference: cursorPagerClassReference,
                arguments_: [
                    csharp.codeblock(requestParam.name),
                    csharp.codeblock(optionsParamName),
                    csharp.codeblock(unpagedEndpointMethodName),
                    csharp.codeblock((writer) => {
                        writer.writeLine("(request, cursor) => {");
                        writer.indent();
                        this.initializeNestedObjects(writer, "request", pagination.page);
                        writer.writeTextStatement(`${this.dotGet("request", pagination.page)} = cursor`);
                        writer.dedent();
                        writer.writeLine("}");
                    }),
                    csharp.codeblock(`response => ${this.nullableDotGet("response", pagination.next)}`),
                    csharp.codeblock(`response => ${this.nullableDotGet("response", pagination.results)}?.ToList()`)
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    private initializeNestedObjects(writer: csharp.Writer, variableName: string, { propertyPath }: RequestProperty) {
        if (!propertyPath || propertyPath.length === 0) {
            return;
        }

        for (let i = 0; i < propertyPath.length; i++) {
            const propertyPathPart = propertyPath.slice(0, i + 1);
            writer.writeTextStatement(
                `${variableName}.${propertyPathPart.map((val) => val.pascalCase.safeName).join(".")} ??= new ()`
            );
        }
    }

    private dotGet(variableName: string, { property, propertyPath }: RequestProperty | ResponseProperty): string {
        if (!propertyPath || propertyPath.length === 0) {
            return `${variableName}.${property.name.name.pascalCase.safeName}`;
        }
        return `${variableName}.${propertyPath.map((val) => val.pascalCase.safeName).join(".")}.${
            property.name.name.pascalCase.safeName
        }`;
    }

    private nullableDotGet(
        variableName: string,
        { property, propertyPath }: RequestProperty | ResponseProperty
    ): string {
        if (!propertyPath || propertyPath.length === 0) {
            return `${variableName}?.${property.name.name.pascalCase.safeName}`;
        }

        return `${variableName}?.${propertyPath.map((val) => val.pascalCase.safeName).join("?.")}?.${
            property.name.name.pascalCase.safeName
        }`;
    }

    public generateEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        requestOptions,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        requestOptions?: csharp.CodeBlock;
        getResult?: boolean;
        parseDatetimes: boolean;
    }): csharp.MethodInvocation | undefined {
        const additionalEndParameters = requestOptions != null ? [requestOptions] : [];
        return this.hasPagination(endpoint)
            ? this.generateHttpPagerEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              })
            : this.generateHttpEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              });
    }

    public generateHttpPagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: csharp.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): csharp.MethodInvocation | undefined {
        return this.generatePagerEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    public generateHttpEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: csharp.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): csharp.MethodInvocation | undefined {
        return super.generateEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    private generatePagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        parseDatetimes,
        serviceId,
        additionalEndParameters
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        parseDatetimes: boolean;
        additionalEndParameters?: csharp.CodeBlock[];
        getResult?: boolean;
    }): csharp.MethodInvocation | undefined {
        const service = this.context.getHttpServiceOrThrow(serviceId);
        const serviceFilePath = service.name.fernFilepath;
        const args = this.getNonEndpointArguments(example, parseDatetimes);
        const endpointRequestSnippet = this.getEndpointRequestSnippet(example, endpoint, serviceId, parseDatetimes);
        if (endpointRequestSnippet != null) {
            args.push(endpointRequestSnippet);
        }
        const on = csharp.codeblock((writer) => {
            writer.write(`${clientVariableName}`);
            for (const path of serviceFilePath.allParts) {
                writer.write(`.${path.pascalCase.safeName}`);
            }
        });
        for (const endParameter of additionalEndParameters ?? []) {
            args.push(endParameter);
        }

        getEndpointReturnType({ context: this.context, endpoint });
        return csharp.invokeMethod({
            method: this.context.getEndpointMethodName(endpoint),
            arguments_: args,
            on,
            async: false,
            configureAwait: true,
            generics: []
        });
    }

    private getRequestOptionsParameter({ endpoint }: { endpoint: HttpEndpoint }): csharp.Parameter {
        const name = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        if (endpoint.idempotent) {
            return csharp.parameter({
                type: csharp.Type.optional(
                    csharp.Type.reference(this.context.getIdempotentRequestOptionsClassReference())
                ),
                name,
                initializer: "null"
            });
        } else {
            return csharp.parameter({
                type: csharp.Type.optional(csharp.Type.reference(this.context.getRequestOptionsClassReference())),
                name,
                initializer: "null"
            });
        }
    }

    private getRequestOptionsParamNameForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): string {
        if (endpoint.idempotent) {
            return this.context.getIdempotentRequestOptionsParameterName();
        } else {
            return this.context.getRequestOptionsParameterName();
        }
    }
}

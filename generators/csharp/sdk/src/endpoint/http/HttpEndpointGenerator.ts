import { assertNever } from "@fern-api/core-utils";
import { ast, is, Writer } from "@fern-api/csharp-codegen";
import { FernIr } from "@fern-fern/ir-sdk";
import {
    CursorPagination,
    ExampleEndpointCall,
    HttpEndpoint,
    OffsetPagination,
    RequestProperty,
    ResponseError,
    ResponseProperty,
    ServiceId
} from "@fern-fern/ir-sdk/api";
import { fail } from "assert";
import { SdkGeneratorContext } from "../../SdkGeneratorContext";
import { AbstractEndpointGenerator } from "../AbstractEndpointGenerator";
import { EndpointSignatureInfo } from "../EndpointSignatureInfo";
import { SingleEndpointSnippet } from "../snippets/EndpointSnippetsGenerator";
import { getEndpointReturnType } from "../utils/getEndpointReturnType";
import { RawClient } from "./RawClient";

export declare namespace EndpointGenerator {
    export interface Args {
        /** the reference to the client */
        clientReference: string;
        /** the endpoint for the endpoint */
        endpoint: HttpEndpoint;
        /** reference to a variable that is the body */
        bodyReference?: string;
    }
}

export class HttpEndpointGenerator extends AbstractEndpointGenerator {
    public constructor({ context }: { context: SdkGeneratorContext }) {
        super({ context });
    }

    public generate(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient,
            generateRawResponse = false
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
            generateRawResponse?: boolean;
        }
    ) {
        if (generateRawResponse) {
            // Generate raw response methods that return RawResponse<T>
            this.generateRawResponseMethod(cls, {
                serviceId,
                endpoint,
                rawClientReference,
                rawClient
            });
        } else if (this.hasPagination(endpoint)) {
            this.generatePagerMethod(cls, {
                serviceId,
                endpoint,
                rawClientReference,
                rawClient
            });

            if (endpoint.pagination.type !== "custom") {
                this.generateUnpagedMethod(cls, {
                    serviceId,
                    endpoint,
                    rawClientReference,
                    rawClient
                });
            }
        } else {
            this.generateUnpagedMethod(cls, {
                serviceId,
                endpoint,
                rawClientReference,
                rawClient
            });
        }
    }

    private getHttpMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        // if this is a paginated endpoint, don't return a snippet for the internal method
        if (this.hasPagination(endpoint)) {
            return undefined;
        }
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private getHttpPagerMethodSnippet({ endpoint }: { endpoint: HttpEndpoint }): SingleEndpointSnippet | undefined {
        this.assertHasPagination(endpoint);
        const endpointSnippets = this.context.snippetGenerator.getSnippetsForEndpoint(endpoint.id);
        const snippet = endpointSnippets?.userSpecified[0] ?? endpointSnippets?.autogenerated[0];
        return snippet;
    }

    private generateUnpagedMethod(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        const endpointSignatureInfo = this.getUnpagedEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        parameters.push(this.getRequestOptionsParameter({ endpoint }));
        parameters.push(
            this.csharp.parameter({
                type: this.System.Threading.CancellationToken,
                name: this.names.parameters.cancellationToken,
                initializer: "default"
            })
        );
        const return_ = getEndpointReturnType({ context: this.context, endpoint });
        const snippet = this.getHttpMethodSnippet({ endpoint });
        const body = this.csharp.codeblock((writer) => {
            this.writeUnpagedMethodBody(endpointSignatureInfo, writer, rawClient, endpoint, rawClientReference);
        });

        return cls.addMethod({
            name: this.getUnpagedEndpointMethodName(endpoint),
            access: this.hasPagination(endpoint) ? ast.Access.Private : ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });
    }

    private getUnpagedEndpointMethodName(endpoint: HttpEndpoint): string {
        let name = this.context.getEndpointMethodName(endpoint);
        if (this.hasPagination(endpoint)) {
            name = name.replace("Async", "InternalAsync");
        }
        return name;
    }

    private generateRawResponseMethod(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        const endpointSignatureInfo = this.getUnpagedEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        parameters.push(this.getRequestOptionsParameter({ endpoint }));
        parameters.push(
            this.csharp.parameter({
                type: this.System.Threading.CancellationToken,
                name: this.names.parameters.cancellationToken,
                initializer: "default"
            })
        );

        const innerReturnType = getEndpointReturnType({ context: this.context, endpoint });
        const return_ = innerReturnType
            ? this.Types.RawResponse(innerReturnType)
            : this.Types.RawResponse(this.Primitive.object);

        const body = this.csharp.codeblock((writer) => {
            this.writeRawResponseMethodBody(endpointSignatureInfo, writer, rawClient, endpoint, rawClientReference);
        });

        return cls.addMethod({
            name: this.context.getEndpointMethodName(endpoint),
            access: ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ })
        });
    }

    private writeRawResponseMethodBody(
        endpointSignatureInfo: EndpointSignatureInfo,
        writer: Writer,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string
    ) {
        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }
        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryBagReference: queryParameterCodeBlock?.queryParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }

        writer.write(`var ${this.names.variables.response} = `);
        writer.writeNodeStatement(
            rawClient.sendRequestWithRequestWrapper({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );

        // Generate raw response return statements
        writer.writeNode(this.getRawResponseSuccessStatements({ endpoint }));
        writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
    }

    private getRawResponseSuccessStatements({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        const innerReturnType = getEndpointReturnType({ context: this.context, endpoint });

        return this.csharp.codeblock((writer) => {
            writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
            writer.pushScope();

            if (endpoint.response?.body == null) {
                if (endpoint.method === FernIr.HttpMethod.Head) {
                    // HEAD requests return HttpResponseHeaders
                    writer.write("return new ");
                    writer.writeNode(this.Types.RawResponse(this.System.Net.Http.HttpResponseHeaders));
                    writer.writeLine();
                    writer.pushScope();
                    writer.writeLine(`Body = ${this.names.variables.response}.Raw.Headers,`);
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.StatusCode,`);
                    writer.writeLine(`Headers = ${this.names.variables.response}.Raw.Headers`);
                    writer.popScope();
                    writer.writeLine(";");
                } else {
                    // No body, return RawResponse with null body
                    writer.write("return new ");
                    writer.writeNode(this.Types.RawResponse(this.Primitive.object));
                    writer.writeLine();
                    writer.pushScope();
                    writer.writeLine(`Body = null!,`);
                    writer.writeLine(`StatusCode = ${this.names.variables.response}.StatusCode,`);
                    writer.writeLine(`Headers = ${this.names.variables.response}.Raw.Headers`);
                    writer.popScope();
                    writer.writeLine(";");
                }
            } else {
                const body = endpoint.response.body;
                body._visit({
                    json: (reference) => {
                        const astType = this.context.csharpTypeMapper.convert({
                            reference: reference.responseBodyType
                        });
                        writer.writeTextStatement(
                            `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                        );
                        writer.writeLine("try");
                        writer.pushScope();

                        writer.write("var body = ");
                        writer.writeNode(this.Types.JsonUtils);
                        writer.write(".Deserialize<");
                        writer.writeNode(astType);
                        writer.writeLine(`>(${this.names.variables.responseBody})!;`);

                        writer.write("return new ");
                        writer.writeNode(this.Types.RawResponse(astType));
                        writer.writeLine();
                        writer.pushScope();
                        writer.writeLine(`Body = body,`);
                        writer.writeLine(`StatusCode = ${this.names.variables.response}.StatusCode,`);
                        writer.writeLine(`Headers = ${this.names.variables.response}.Raw.Headers`);
                        writer.popScope();
                        writer.writeLine(";");

                        writer.popScope();

                        writer.write("catch (");
                        writer.writeNode(this.System.Text.Json.JsonException);
                        writer.writeLine(" e)");
                        writer.pushScope();

                        writer.write("throw new ");
                        writer.writeNode(this.Types.BaseException);
                        writer.writeTextStatement('("Failed to deserialize response", e)');
                        writer.popScope();
                    },
                    text: () => {
                        writer.writeTextStatement(
                            `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                        );
                        writer.write("return new ");
                        writer.writeNode(this.Types.RawResponse(this.Primitive.string));
                        writer.writeLine();
                        writer.pushScope();
                        writer.writeLine(`Body = ${this.names.variables.responseBody},`);
                        writer.writeLine(`StatusCode = ${this.names.variables.response}.StatusCode,`);
                        writer.writeLine(`Headers = ${this.names.variables.response}.Raw.Headers`);
                        writer.popScope();
                        writer.writeLine(";");
                    },
                    fileDownload: () => {
                        writer.writeTextStatement(
                            `var stream = await ${this.names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                        );
                        writer.write("return new ");
                        writer.writeNode(this.Types.RawResponse(this.System.IO.Stream.asFullyQualified()));
                        writer.writeLine();
                        writer.pushScope();
                        writer.writeLine(`Body = stream,`);
                        writer.writeLine(`StatusCode = ${this.names.variables.response}.StatusCode,`);
                        writer.writeLine(`Headers = ${this.names.variables.response}.Raw.Headers`);
                        writer.popScope();
                        writer.writeLine(";");
                    },
                    streaming: () => {
                        // For streaming responses, we don't support raw response wrapper
                        writer.write("throw new ");
                        writer.writeNode(this.Types.BaseException);
                        writer.writeTextStatement('("Raw response is not supported for streaming endpoints")');
                    },
                    streamParameter: () => {
                        // For streaming responses, we don't support raw response wrapper
                        writer.write("throw new ");
                        writer.writeNode(this.Types.BaseException);
                        writer.writeTextStatement('("Raw response is not supported for streaming endpoints")');
                    },
                    bytes: () => {
                        writer.write("throw new ");
                        writer.writeNode(this.Types.BaseException);
                        writer.writeTextStatement('("Raw response is not supported for bytes endpoints")');
                    },
                    _other: () => {
                        writer.write("throw new ");
                        writer.writeNode(this.Types.BaseException);
                        writer.writeTextStatement('("Raw response is not supported for this endpoint type")');
                    }
                });
            }

            writer.popScope();
        });
    }

    private writeUnpagedMethodBody(
        endpointSignatureInfo: EndpointSignatureInfo,
        writer: Writer,
        rawClient: RawClient,
        endpoint: HttpEndpoint,
        rawClientReference: string
    ) {
        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }
        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryBagReference: queryParameterCodeBlock?.queryParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }

        writer.write(`var ${this.names.variables.response} = `);
        writer.writeNodeStatement(
            rawClient.sendRequestWithRequestWrapper({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const successResponseStatements = this.getEndpointSuccessResponseStatements({ endpoint });
        if (successResponseStatements != null) {
            writer.writeNode(successResponseStatements);
        }
        writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
    }

    private getBaseURLForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        if (endpoint.baseUrl != null && this.context.ir.environments?.environments.type === "multipleBaseUrls") {
            const baseUrl = this.context.ir.environments?.environments.baseUrls.find(
                (baseUrlWithId) => baseUrlWithId.id === endpoint.baseUrl
            );
            if (baseUrl != null) {
                return this.csharp.codeblock(`_client.Options.Environment.${baseUrl.name.pascalCase.safeName}`);
            }
        }
        return this.csharp.codeblock("_client.Options.BaseUrl");
    }

    private getEndpointErrorHandling({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock {
        return this.csharp.codeblock((writer) => {
            writer.pushScope();
            writer.writeTextStatement(
                `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
            );
            if (
                endpoint.errors.length > 0 &&
                this.context.ir.errorDiscriminationStrategy.type === "statusCode" &&
                this.settings.generateErrorTypes
            ) {
                writer.writeLine("try");
                writer.pushScope();
                writer.write("switch (", this.names.variables.response, ".StatusCode)");
                writer.pushScope();

                // ensure that each response code is handled only once
                const handled = new Set<number>();
                for (const error of endpoint.errors) {
                    const errorDeclaration = this.context.ir.errors[error.error.errorId];
                    if (errorDeclaration == null || handled.has(errorDeclaration.statusCode)) {
                        continue;
                    }
                    handled.add(errorDeclaration.statusCode);
                    this.writeErrorCase(error, writer);
                }

                writer.popScope();
                writer.popScope();
                writer.write("catch (", this.System.Text.Json.JsonException, ")");
                writer.pushScope();
                writer.writeLine("// unable to map error response, throwing generic error");
                writer.popScope();
            }
            writer.write(
                "throw new ",
                this.Types.BaseApiException,
                `($"Error with status code {${this.names.variables.response}.StatusCode}", ${this.names.variables.response}.StatusCode, `
            );
            writer.writeTextStatement(`${this.names.variables.responseBody})`);
            writer.popScope();
        });
    }

    private writeErrorCase(error: ResponseError, writer: Writer) {
        const fullError = this.context.ir.errors[error.error.errorId];
        if (fullError == null) {
            throw new Error(`Unexpected no error found for error id: ${error.error.errorId}`);
        }
        writer.writeLine(`case ${fullError.statusCode}:`);
        writer.indent();
        writer.write("throw new ");
        writer.writeNode(this.context.getExceptionClassReference(fullError.name));
        writer.write("(");
        writer.writeNode(this.Types.JsonUtils);
        writer.write(".Deserialize<");
        writer.writeNode(
            fullError.type != null
                ? this.context.csharpTypeMapper.convert({ reference: fullError.type })
                : this.Primitive.object
        );
        writer.writeTextStatement(`>(${this.names.variables.responseBody}))`);
    }

    private getEndpointSuccessResponseStatements({ endpoint }: { endpoint: HttpEndpoint }): ast.CodeBlock | undefined {
        if (endpoint.response?.body == null) {
            return this.csharp.codeblock((writer) => {
                writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                if (endpoint.method === FernIr.HttpMethod.Head) {
                    writer.writeLine("return response.Raw.Headers;");
                } else {
                    writer.writeLine("return;");
                }
                writer.popScope();
            });
        }

        const body = endpoint.response.body;
        const context = this.context;
        const names = this.names;

        function handleStreaming(writer: Writer) {
            return (value: FernIr.StreamingResponse) => {
                function readLineFromResponse() {
                    writer.writeLine(`if (${names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(`string? line`);
                    writer.write(`using var reader = `);
                    writer.write(
                        context.System.IO.StreamReader.new({
                            arguments_: [
                                context.csharp.codeblock(
                                    `await ${names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                                )
                            ]
                        })
                    );
                    writer.writeTextStatement(";");
                    writer.writeLine("while (!string.IsNullOrEmpty(line = await reader.ReadLineAsync()))");
                    writer.pushScope();
                }

                function deserializeJsonChunk(
                    payloadType: ast.Type,
                    jsonUtils: ast.ClassReference,
                    exceptionClass: ast.ClassReference,
                    jsonString: string,
                    yieldResult: boolean
                ) {
                    if (is.OneOf.OneOf(payloadType)) {
                        // we have to tear this apart and figure out which one to deserialize
                        // based on the union type?
                        for (const each of payloadType.generics) {
                            writer.pushScope();
                            writer.write(
                                `if(`,
                                jsonUtils,
                                `.TryDeserialize(`,
                                jsonString,
                                `, out `,
                                each,
                                `? result))`
                            );
                            writer.pushScope();

                            if (yieldResult) {
                                writer.write("yield ");
                            }

                            writer.writeTextStatement(`return result!`);
                            writer.popScope();
                            writer.popScope();
                        }
                        return;
                    }

                    writer.writeStatement(payloadType.asOptional(), `result`);
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("result = ");
                    writer.writeNode(jsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(payloadType);
                    writer.writeTextStatement(`>(${jsonString})`);
                    writer.popScope();
                    writer.writeLine("catch (System.Text.Json.JsonException)");
                    writer.pushScope();
                    writer.writeStatement(
                        "throw new ",
                        exceptionClass,
                        `($"Unable to deserialize JSON response '`,
                        jsonString,
                        `'")`
                    );
                    writer.popScope();
                }

                value._visit({
                    json: (jsonChunk) => {
                        readLineFromResponse();
                        const payloadType = context.csharpTypeMapper.convert({ reference: jsonChunk.payload });
                        deserializeJsonChunk(
                            payloadType,
                            context.generation.Types.JsonUtils,
                            context.generation.Types.BaseException,
                            "line",
                            true
                        );
                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    text: () => {
                        readLineFromResponse();
                        writer.writeLine("if(!string.IsNullOrEmpty(line))");
                        writer.pushScope();
                        writer.writeTextStatement("yield return line");
                        writer.popScope();

                        writer.popScope();
                        writer.writeTextStatement("yield break");
                        writer.popScope();
                    },
                    sse: (sseChunk) => {
                        const payloadType = context.csharpTypeMapper.convert({ reference: sseChunk.payload });
                        writer.writeLine(`if (${names.variables.response}.StatusCode is >= 200 and < 400)`);
                        writer.pushScope();

                        writer.write(`await foreach (var item in `);
                        writer.writeNode(context.System.Net.ServerSentEvents.SseParser);
                        writer.writeLine(
                            `.Create(await ${names.variables.response}.Raw.Content.ReadAsStreamAsync()).EnumerateAsync(cancellationToken))`
                        );
                        writer.pushScope();

                        writer.writeLine("if( !string.IsNullOrEmpty(item.Data))");
                        writer.pushScope();

                        if (sseChunk.terminator) {
                            writer.writeLine(`if( item.Data == "${sseChunk.terminator}")`);
                            writer.pushScope();
                            writer.writeTextStatement("break");
                            writer.popScope();
                        }

                        deserializeJsonChunk(
                            payloadType,
                            context.generation.Types.JsonUtils,
                            context.generation.Types.BaseException,
                            "item.Data",
                            true
                        );

                        writer.popScope();
                        writer.popScope();
                        writer.writeTextStatement("yield break");

                        writer.popScope();
                    },
                    _other: () => {
                        writer.write('/* "Other" Streaming not currently implemented */');
                    }
                });
            };
        }

        return this.csharp.codeblock((writer) => {
            body._visit({
                streamParameter: (ref) => {
                    return handleStreaming(writer)(ref.streamResponse);
                },
                fileDownload: (value) => {
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();
                    writer.writeTextStatement(
                        `return await ${this.names.variables.response}.Raw.Content.ReadAsStreamAsync()`
                    );
                    writer.popScope();
                },
                json: (reference) => {
                    const astType = this.context.csharpTypeMapper.convert({ reference: reference.responseBodyType });
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    // Deserialize the response as json
                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeLine("try");
                    writer.pushScope();

                    writer.write("return ");
                    writer.writeNode(this.Types.JsonUtils);
                    writer.write(".Deserialize<");
                    writer.writeNode(astType);
                    // todo: Maybe remove ! below and handle potential null. Requires introspecting type to know if its
                    // nullable.
                    writer.writeLine(`>(${this.names.variables.responseBody})!;`);
                    writer.popScope();

                    writer.write("catch (");
                    writer.writeNode(this.System.Text.Json.JsonException);
                    writer.writeLine(" e)");
                    writer.pushScope();

                    writer.write("throw new ");
                    writer.writeNode(this.Types.BaseException);
                    writer.writeTextStatement('("Failed to deserialize response", e)');
                    writer.popScope();

                    writer.popScope();

                    writer.writeLine();
                },
                streaming: (ref) => handleStreaming(writer)(ref),
                text: () => {
                    writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                    writer.pushScope();

                    writer.writeTextStatement(
                        `var ${this.names.variables.responseBody} = await ${this.names.variables.response}.Raw.Content.ReadAsStringAsync()`
                    );
                    writer.writeTextStatement(`return ${this.names.variables.responseBody}`);
                    writer.popScope();
                },
                bytes: () => this.context.logger.error("Bytes not supported"),
                _other: () => undefined
            });
        });
    }

    public generatePagerMethod(
        cls: ast.Class,
        {
            serviceId,
            endpoint,
            rawClientReference,
            rawClient
        }: {
            serviceId: ServiceId;
            endpoint: HttpEndpoint;
            rawClientReference: string;
            rawClient: RawClient;
        }
    ) {
        this.assertHasPagination(endpoint);
        const endpointSignatureInfo = this.getEndpointSignatureInfo({ serviceId, endpoint });
        const parameters = [...endpointSignatureInfo.baseParameters];
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        const requestOptionsParam = this.getRequestOptionsParameter({ endpoint });
        parameters.push(requestOptionsParam);
        parameters.push(
            this.csharp.parameter({
                type: this.System.Threading.CancellationToken,
                name: this.names.parameters.cancellationToken,
                initializer: "default"
            })
        );
        const requestOptionsType = requestOptionsParam.type;
        const itemType = this.getPaginationItemType(endpoint);
        const return_ = this.getPagerReturnType(endpoint);
        const snippet = this.getHttpPagerMethodSnippet({ endpoint });
        const body = this.csharp.codeblock((writer) => {
            const requestParameter = endpointSignatureInfo.requestParameter;
            const unpagedEndpointResponseType = getEndpointReturnType({ context: this.context, endpoint });
            if (!unpagedEndpointResponseType) {
                throw new Error("Internal error; a response type is required for pagination endpoints");
            }

            switch (endpoint.pagination.type) {
                case "offset":
                    this.generateOffsetMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint
                    });
                    break;
                case "cursor":
                    this.generateCursorMethodBody({
                        endpointSignatureInfo,
                        pagination: endpoint.pagination,
                        requestParameter,
                        requestOptionsType,
                        unpagedEndpointResponseType,
                        itemType,
                        writer,
                        optionsParamName,
                        endpoint
                    });
                    break;
                case "custom":
                    this.generateCustomPagerMethodBody({
                        serviceId,
                        endpoint,
                        rawClient,
                        rawClientReference,
                        writer
                    });
                    break;
                default:
                    assertNever(endpoint.pagination);
            }
        });
        return cls.addMethod({
            name: this.context.getEndpointMethodName(endpoint),
            access: ast.Access.Public,
            isAsync: true,
            parameters,
            summary: endpoint.docs,
            return_,
            body: this.wrapWithExceptionHandler({ body, returnType: return_ }),
            codeExample: snippet?.endpointCall
        });
    }

    private generateOffsetMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: OffsetPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type;
        unpagedEndpointResponseType: ast.Type;
        itemType: ast.Type;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        if (requestParameter.type.isOptional) {
            writer.writeLine("if (request is not null)");
            writer.pushScope();
        }

        writer.writeLine("request = request with { };");

        if (requestParameter.type.isOptional) {
            writer.popScope();
        }

        const offsetType = this.context.csharpTypeMapper.convert({
            reference: pagination.page.property.valueType
        });
        // use specified type or fallback to object
        const stepType = pagination.step
            ? this.context.csharpTypeMapper.convert({
                  reference: pagination.step?.property.valueType
              })
            : this.Primitive.object;
        const offsetPagerClassReference = this.Types.OffsetPager({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            offsetType,
            stepType,
            itemType
        });

        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: offsetPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    this.csharp.codeblock(requestParameter.name),
                    this.csharp.codeblock(optionsParamName),
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    this.csharp.codeblock(
                        `request => ${this.dotAccess(requestParameter.type, "request", pagination.page)} ?? 0`
                    ),
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, offset) =>");
                        writer.pushScope();

                        if (pagination.page.propertyPath && pagination.page.propertyPath.length > 0) {
                            writer.writeStatement(
                                "request.",
                                this.getDotAccess(unpagedEndpointResponseType, pagination.page, false).code,
                                " ??= new ()"
                            );
                        }

                        writer.writeTextStatement(
                            `${this.dotAccess(requestParameter.type, "request", pagination.page, false)} = offset`
                        );
                        writer.popScope();
                    }),
                    this.csharp.codeblock(
                        pagination.step
                            ? `request => ${this.dotAccess(requestParameter.type, "request", pagination.step)} ?? 0`
                            : "null"
                    ),
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(requestParameter.type, "response", pagination.results)}?.ToList()`
                    ),
                    this.csharp.codeblock(
                        pagination.hasNextPage
                            ? `response => ${this.dotAccess(requestParameter.type, "response", pagination.hasNextPage)}`
                            : "null"
                    ),
                    this.csharp.codeblock(this.names.parameters.cancellationToken)
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    private generateUnpagedEndpointCallback({
        requestParameter,
        endpoint
    }: {
        requestParameter: ast.Parameter | undefined;
        endpoint: HttpEndpoint;
    }): ast.CodeBlock {
        const { pathParameters } = this.getAllPathParameters({
            endpoint,
            requestParameter
        });
        if (pathParameters.length === 0) {
            return this.csharp.codeblock(this.getUnpagedEndpointMethodName(endpoint));
        }
        return this.csharp.codeblock((writer) => {
            writer.write("(request, options, cancellationToken) => ");
            writer.writeNode(
                this.csharp.invokeMethod({
                    method: this.getUnpagedEndpointMethodName(endpoint),
                    arguments_: [
                        ...pathParameters.map((parameter) => this.csharp.codeblock(parameter.name)),
                        this.csharp.codeblock("request"),
                        this.csharp.codeblock("options"),
                        this.csharp.codeblock("cancellationToken")
                    ]
                })
            );
        });
    }

    private generateCursorMethodBody({
        endpointSignatureInfo,
        pagination,
        requestParameter,
        requestOptionsType,
        unpagedEndpointResponseType,
        itemType,
        writer,
        optionsParamName,
        endpoint
    }: {
        endpointSignatureInfo: EndpointSignatureInfo;
        pagination: CursorPagination;
        requestParameter?: ast.Parameter;
        requestOptionsType: ast.Type;
        unpagedEndpointResponseType: ast.Type;
        itemType: ast.Type;
        writer: Writer;
        optionsParamName: string;
        endpoint: HttpEndpoint;
    }) {
        if (!requestParameter) {
            throw new Error("Request parameter is required for pagination");
        }

        writer.writeLine("if (request is not null)");
        writer.pushScope();
        writer.writeLine("request = request with { };");
        writer.popScope();

        const cursorType = this.context.csharpTypeMapper.convert({
            reference: pagination.next.property.valueType
        });
        const cursorPagerClassReference = this.Types.CursorPager({
            requestType: requestParameter.type,
            requestOptionsType,
            responseType: unpagedEndpointResponseType,
            cursorType,
            itemType
        });

        writer.write("var pager = ");
        writer.writeNodeStatement(
            this.csharp.invokeMethod({
                on: cursorPagerClassReference,
                method: "CreateInstanceAsync",
                async: true,
                arguments_: [
                    // TRequest
                    this.csharp.codeblock(requestParameter.name),
                    // TRequestOptions parameter
                    this.csharp.codeblock(optionsParamName),
                    // SendRequest
                    this.generateUnpagedEndpointCallback({
                        requestParameter,
                        endpoint
                    }),
                    // SetCursor
                    this.csharp.codeblock((writer) => {
                        writer.writeLine("(request, cursor) =>");
                        writer.pushScope();
                        if (pagination.page.propertyPath && pagination.page.propertyPath.length > 0) {
                            const { code, enclosingType } = this.getDotAccess(
                                requestParameter.type,
                                pagination.page,
                                false
                            );
                            writer.writeStatement(
                                "request.",
                                code,
                                "??=",
                                this.csharp.instantiateClass({
                                    classReference: enclosingType,
                                    arguments_: [],
                                    // If any fields require initialization (ie, required and no default value),
                                    // we have to provide it at least *some* value so that this code will actually compile
                                    properties: [...enclosingType.scope.fields]
                                        .map((each) => each.field)
                                        .filter(is.NonNullable)
                                        .filter((each) => each.needsIntialization)
                                        .map((each) => ({
                                            name: each.name,
                                            value: each.type.defaultValue
                                        }))
                                })
                            );
                        }
                        writer.writeTextStatement(
                            `${this.dotAccess(requestParameter.type, "request", pagination.page, false)} = cursor`
                        );
                        writer.popScope();
                    }),
                    // GetNextCursor
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(unpagedEndpointResponseType, "response", pagination.next)}`
                    ),
                    // GetItems
                    this.csharp.codeblock(
                        `response => ${this.dotAccess(unpagedEndpointResponseType, "response", pagination.results)}?.ToList()`
                    ),
                    // CancellationToken
                    this.csharp.codeblock(this.names.parameters.cancellationToken)
                ]
            })
        );
        writer.writeTextStatement("return pager");
    }

    public generateCustomPagerMethodBody({
        serviceId,
        endpoint,
        rawClient,
        rawClientReference,
        writer
    }: {
        serviceId: ServiceId;
        endpoint: HttpEndpoint;
        rawClient: RawClient;
        rawClientReference: string;
        writer: Writer;
    }): void {
        const endpointSignatureInfo = this.getEndpointSignatureInfo({ serviceId, endpoint });
        const optionsParamName = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        const itemType = this.getPaginationItemType(endpoint);
        const unpagedEndpointResponseType = getEndpointReturnType({ context: this.context, endpoint });
        if (!unpagedEndpointResponseType) {
            throw new Error("Internal error; a response type is required for pagination endpoints");
        }

        const queryParameterCodeBlock = endpointSignatureInfo.request?.getQueryParameterCodeBlock();
        if (queryParameterCodeBlock != null) {
            queryParameterCodeBlock.code.write(writer);
        }
        const headerParameterCodeBlock = endpointSignatureInfo.request?.getHeaderParameterCodeBlock();
        if (headerParameterCodeBlock != null) {
            headerParameterCodeBlock.code.write(writer);
        }
        const requestBodyCodeBlock = endpointSignatureInfo.request?.getRequestBodyCodeBlock();
        if (requestBodyCodeBlock?.code != null) {
            writer.writeNode(requestBodyCodeBlock.code);
        }

        const apiRequestCodeBlock = rawClient.createHttpRequestWrapper({
            baseUrl: this.getBaseURLForEndpoint({ endpoint }),
            requestType: endpointSignatureInfo.request?.getRequestType(),
            endpoint,
            bodyReference: requestBodyCodeBlock?.requestBodyReference,
            pathParameterReferences: endpointSignatureInfo.pathParameterReferences,
            headerBagReference: headerParameterCodeBlock?.headerParameterBagReference,
            queryBagReference: queryParameterCodeBlock?.queryParameterBagReference,
            endpointRequest: endpointSignatureInfo.request
        });
        if (apiRequestCodeBlock.code) {
            writer.writeNode(apiRequestCodeBlock.code);
        }
        writer.write(`var ${this.names.variables.httpRequest} = `);
        writer.writeNodeStatement(
            rawClient.createHttpRequest({
                request: apiRequestCodeBlock.requestReference,
                clientReference: rawClientReference
            })
        );
        const cancellationTokenName = this.names.parameters.cancellationToken;
        writer.writeNodeStatement(
            this.csharp.codeblock((writer) => {
                writer.write(
                    `var ${this.names.variables.sendRequest} = async (HttpRequestMessage ${this.names.variables.httpRequest}, CancellationToken ${cancellationTokenName}) =>`
                );
                writer.pushScope();

                writer.write(`var ${this.names.variables.response} = `);
                writer.writeNodeStatement(
                    rawClient.sendRequestWithHttpRequest({
                        request: this.csharp.codeblock(this.names.variables.httpRequest),
                        options: this.csharp.codeblock(optionsParamName),
                        clientReference: rawClientReference,
                        cancellationToken: this.csharp.codeblock(cancellationTokenName)
                    })
                );

                writer.writeLine(`if (${this.names.variables.response}.StatusCode is >= 200 and < 400)`);
                writer.pushScope();

                // Deserialize the response as json
                writer.writeTextStatement(`return ${this.names.variables.response}.Raw`);
                writer.popScope();
                writer.writeLine();

                writer.writeNode(this.getEndpointErrorHandling({ endpoint }));
                writer.popScope();
            })
        );

        writer.write("return ");
        writer.writeNodeStatement(
            this.context.invokeCustomPagerFactoryMethod({
                itemType,
                sendRequestMethod: this.csharp.codeblock(this.names.variables.sendRequest),
                initialRequest: this.csharp.codeblock(this.names.variables.httpRequest),
                clientOptions: this.csharp.codeblock(`${rawClientReference}.Options`),
                requestOptions: this.csharp.codeblock(optionsParamName),
                cancellationToken: this.csharp.codeblock(this.names.parameters.cancellationToken)
            })
        );
    }

    private getDotAccess(
        encType: ast.Type,
        { property, propertyPath }: RequestProperty | ResponseProperty,
        allowOptional: boolean = true
    ): { code: string; enclosingType: ast.ClassReference } {
        encType = encType.asNonOptional();
        let enclosingType = is.ClassReference(encType)
            ? encType
            : fail(`Expected ClassReference, got ${encType.fullyQualifiedName}`);

        if (!propertyPath || propertyPath.length === 0) {
            return { code: this.csharp.getPropertyName(enclosingType, property), enclosingType };
        }
        let optional = "";

        return {
            code: propertyPath
                .map((val) => {
                    // get the property name for the current property
                    const propertyName = this.csharp.getPropertyName(enclosingType, val);

                    // get the type of the current property
                    let typeOfValue = this.context.csharpTypeMapper.convert({ reference: val.type });
                    optional = allowOptional && is.Optional(typeOfValue) ? "?" : "";
                    typeOfValue = typeOfValue.asNonOptional();

                    // find the classRef for that type
                    if (is.ClassReference(typeOfValue)) {
                        enclosingType = typeOfValue;
                    }
                    // return the property name
                    return `${propertyName}${optional}`;
                })
                .join("."),
            enclosingType
        };
    }

    private dotAccess(
        encType: ast.Type,
        variableName: string,
        property: RequestProperty | ResponseProperty,
        allowOptional: boolean = true
    ): string {
        encType = encType.asNonOptional();
        let enclosingType = is.ClassReference(encType)
            ? encType
            : fail(`Expected ClassReference, got ${encType.fullyQualifiedName}`);

        if (!property.propertyPath || property.propertyPath.length === 0) {
            return `${variableName}.${this.csharp.getPropertyName(enclosingType, property.property)}`;
        }
        const dotAccess = this.getDotAccess(enclosingType, property, allowOptional);
        return `${variableName}.${dotAccess.code}.${this.csharp.getPropertyName(dotAccess.enclosingType, property.property)}`;
    }

    public override generateEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        requestOptions,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        requestOptions?: ast.CodeBlock;
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        const additionalEndParameters = requestOptions != null ? [requestOptions] : [];
        return this.hasPagination(endpoint)
            ? this.generateHttpPagerEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              })
            : this.generateHttpEndpointSnippet({
                  example,
                  endpoint,
                  clientVariableName,
                  serviceId,
                  additionalEndParameters,
                  getResult,
                  parseDatetimes
              });
    }

    public generateHttpPagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return this.generatePagerEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    public generateHttpEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        serviceId,
        additionalEndParameters,
        getResult,
        parseDatetimes
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
        parseDatetimes: boolean;
    }): ast.MethodInvocation | undefined {
        return super.generateEndpointSnippet({
            example,
            endpoint,
            clientVariableName,
            serviceId,
            additionalEndParameters,
            getResult,
            parseDatetimes
        });
    }

    private generatePagerEndpointSnippet({
        example,
        endpoint,
        clientVariableName,
        parseDatetimes,
        serviceId,
        additionalEndParameters
    }: {
        example: ExampleEndpointCall;
        endpoint: HttpEndpoint;
        clientVariableName: string;
        serviceId: ServiceId;
        parseDatetimes: boolean;
        additionalEndParameters?: ast.CodeBlock[];
        getResult?: boolean;
    }): ast.MethodInvocation | undefined {
        const service = this.context.getHttpService(serviceId) ?? fail(`Service with id ${serviceId} not found`);
        const serviceFilePath = service.name.fernFilepath;
        const args = this.getNonEndpointArguments({ endpoint, example, parseDatetimes });
        const endpointRequestSnippet = this.getEndpointRequestSnippet(example, endpoint, serviceId, parseDatetimes);
        if (endpointRequestSnippet != null) {
            args.push(endpointRequestSnippet);
        }
        const on = this.csharp.codeblock((writer) => {
            writer.write(`${clientVariableName}`);
            for (const path of serviceFilePath.allParts) {
                writer.write(`.${path.pascalCase.safeName}`);
            }
        });
        for (const endParameter of additionalEndParameters ?? []) {
            args.push(endParameter);
        }

        getEndpointReturnType({ context: this.context, endpoint });
        return this.csharp.invokeMethod({
            method: this.context.getEndpointMethodName(endpoint),
            arguments_: args,
            on,
            async: true,
            configureAwait: true,
            generics: []
        });
    }

    private getRequestOptionsParameter({ endpoint }: { endpoint: HttpEndpoint }): ast.Parameter {
        const name = this.getRequestOptionsParamNameForEndpoint({ endpoint });
        if (endpoint.idempotent) {
            return this.csharp.parameter({
                type: this.Types.IdempotentRequestOptions.asOptional(),
                name,
                initializer: "null"
            });
        } else {
            return this.csharp.parameter({
                type: this.Types.RequestOptions.asOptional(),
                name,
                initializer: "null"
            });
        }
    }

    private getRequestOptionsParamNameForEndpoint({ endpoint }: { endpoint: HttpEndpoint }): string {
        if (endpoint.idempotent) {
            return this.names.parameters.idempotentOptions;
        } else {
            return this.names.parameters.requestOptions;
        }
    }
}

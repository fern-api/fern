import { assertNever } from "@fern-api/core-utils";
import {
    AuthScheme,
    ErrorDeclaration,
    ExampleEndpointCall,
    ExampleEndpointErrorResponse,
    ExampleInlinedRequestBody,
    ExampleObjectType,
    ExampleObjectTypeWithTypeId,
    ExampleRequestBody,
    ExampleResponse,
    ExampleTypeReference,
    HttpEndpoint,
    HttpMethod,
    HttpService,
    IntermediateRepresentation,
    Name,
    ObjectPropertyAccess
} from "@fern-fern/ir-sdk/api";
import {
    DependencyManager,
    DependencyType,
    ExportedFilePath,
    getExampleEndpointCalls,
    getExampleEndpointCallsForTests,
    getParameterNameForRootExamplePathParameter,
    getParameterNameForRootPathParameter,
    getTextOfTsNode,
    PackageId,
    Reference
} from "@fern-typescript/commons";
import { GeneratedSdkClientClass, SdkContext } from "@fern-typescript/contexts";
import { OAuthTokenProviderGenerator } from "@fern-typescript/sdk-client-class-generator";
import path from "path";
import { Directory, ts } from "ts-morph";
import { arrayOf, Code, code, literalOf } from "ts-poet";

const DEFAULT_PACKAGE_PATH = "src";

export declare namespace TestGenerator {
    interface Args {
        ir: IntermediateRepresentation;
        dependencyManager: DependencyManager;
        rootDirectory: Directory;
        includeSerdeLayer: boolean;
        writeUnitTests: boolean;
        generateWireTests: boolean;
        useBigInt: boolean;
        retainOriginalCasing: boolean;
        relativePackagePath: string;
        relativeTestPath: string;
        neverThrowErrors: boolean;
        generateReadWriteOnlyTypes: boolean;
        testFramework: "jest" | "vitest";
        useLegacyExports: boolean;
        shouldBundle: boolean;
        wireTestsFallbackToAutoGeneratedErrorExamples: boolean;
    }
}

export class TestGenerator {
    private readonly ir: IntermediateRepresentation;
    private readonly dependencyManager: DependencyManager;
    private readonly rootDirectory: Directory;
    private readonly writeUnitTests: boolean;
    private readonly includeSerdeLayer: boolean;
    private readonly generateWireTests: boolean;
    private readonly useBigInt: boolean;
    private readonly retainOriginalCasing: boolean;
    private readonly relativePackagePath: string;
    private readonly relativeTestPath: string;
    private readonly neverThrowErrors: boolean;
    private readonly generateReadWriteOnlyTypes: boolean;
    private readonly testFramework: "jest" | "vitest";
    private readonly useLegacyExports: boolean;
    private readonly shouldBundle: boolean;
    private readonly wireTestsFallbackToAutoGeneratedErrorExamples: boolean;

    constructor({
        ir,
        dependencyManager,
        rootDirectory,
        includeSerdeLayer,
        writeUnitTests,
        generateWireTests,
        useBigInt,
        retainOriginalCasing,
        relativePackagePath,
        relativeTestPath,
        neverThrowErrors,
        generateReadWriteOnlyTypes,
        testFramework,
        useLegacyExports,
        shouldBundle,
        wireTestsFallbackToAutoGeneratedErrorExamples
    }: TestGenerator.Args) {
        this.ir = ir;
        this.dependencyManager = dependencyManager;
        this.rootDirectory = rootDirectory;
        this.writeUnitTests = writeUnitTests;
        this.generateWireTests = generateWireTests;
        this.includeSerdeLayer = includeSerdeLayer;
        this.useBigInt = useBigInt;
        this.retainOriginalCasing = retainOriginalCasing;
        this.relativePackagePath = relativePackagePath;
        this.relativeTestPath = relativeTestPath;
        this.neverThrowErrors = neverThrowErrors;
        this.generateReadWriteOnlyTypes = generateReadWriteOnlyTypes;
        this.testFramework = testFramework;
        this.useLegacyExports = useLegacyExports;
        this.shouldBundle = shouldBundle;
        this.wireTestsFallbackToAutoGeneratedErrorExamples = wireTestsFallbackToAutoGeneratedErrorExamples;
    }

    private async addJestConfigs(): Promise<void> {
        const setupFilesAfterEnv = [];
        if (this.useBigInt) {
            setupFilesAfterEnv.push(`<rootDir>/${this.relativeTestPath}/bigint.setup.ts`);
        }
        if (this.generateWireTests || this.writeUnitTests) {
            const jestConfig = this.rootDirectory.createSourceFile(
                "jest.config.mjs",
                code`
                /** @type {import('jest').Config} */
                export default {
                    preset: "ts-jest",
                    testEnvironment: "node",
                    projects: [
                        ${
                            this.writeUnitTests
                                ? code`{
                            displayName: "unit",
                            preset: "ts-jest",
                            testEnvironment: "node",
                            moduleNameMapper: {
                                "^(\\.{1,2}/.*)\\.js$": "$1",
                            },
                            roots: ["<rootDir>/${this.relativeTestPath}"],
                            testPathIgnorePatterns: ["/tests/wire/"],
                            setupFilesAfterEnv: ${arrayOf(...setupFilesAfterEnv)},
                        },`
                                : ""
                        }
                        ${
                            this.generateWireTests
                                ? code`{
                            displayName: "wire",
                            preset: "ts-jest",
                            testEnvironment: "node",
                            moduleNameMapper: {
                                "^(\\.{1,2}/.*)\\.js$": "$1",
                            },
                            roots: ["<rootDir>/${this.relativeTestPath}/wire"],
                            setupFilesAfterEnv: ${arrayOf(...setupFilesAfterEnv, `<rootDir>/${this.relativeTestPath}/mock-server/setup.ts`)},
                        }`
                                : ""
                        }
                    ],
                    workerThreads: ${this.useBigInt ? "true" : "false"},
                    passWithNoTests: true,
                };
                `.toString({ dprintOptions: { indentWidth: 4 } })
            );
            await jestConfig.save();
        } else {
            const jestConfig = this.rootDirectory.createSourceFile(
                "jest.config.mjs",
                code`
                /** @type {import('jest').Config} */
                export default {
                    preset: "ts-jest",
                    testEnvironment: "node",
                    moduleNameMapper: {
                        "^(\\.{1,2}/.*)\\.js$": "$1"
                    },
                    roots: ["<rootDir>/${this.relativeTestPath}"],
                    testPathIgnorePatterns: ["/tests/wire/"],
                    setupFilesAfterEnv: ${arrayOf(...setupFilesAfterEnv)},
                    workerThreads: ${this.useBigInt ? "true" : "false"},
                    passWithNoTests: true
                };
                `.toString({ dprintOptions: { indentWidth: 4 } })
            );
            await jestConfig.save();
        }
    }

    private async addVitestConfigs(): Promise<void> {
        const vitestConfig = this.rootDirectory.createSourceFile(
            "vitest.config.ts",
            code`
            import { defineConfig } from "vitest/config";
            export default defineConfig({
                test: {
                    projects: [
                        {
                            test: {
                                globals: true,
                                name: "unit",
                                environment: "node",
                                root: "./${this.relativeTestPath}",
                                include: ["**/*.test.{js,ts,jsx,tsx}"],
                                exclude: ["wire/**"]
                            }
                        },
                        ${
                            this.generateWireTests
                                ? code`{
                                    test: {
                                        globals: true,
                                        name: "wire",
                                        environment: "node",
                                        root: "./${this.relativeTestPath}/wire",
                                        setupFiles: ["../mock-server/setup.ts"]
                                    }
                                },`
                                : ""
                        }
                    ],
                    passWithNoTests: true
                }
            });
            `.toString({ dprintOptions: { indentWidth: 4 } })
        );
        await vitestConfig.save();
    }

    public getTestFile(service: HttpService): ExportedFilePath {
        const folders = service.name.fernFilepath.packagePath.map((folder) => folder.originalName);
        const filename = `${service.name.fernFilepath.file?.camelCase.unsafeName ?? "main"}.test.ts`;

        const filePath = path.join("wire", ...folders, filename);

        return {
            directories: [],
            file: {
                nameOnDisk: filePath
            },
            rootDir: this.relativeTestPath
        };
    }

    private addDependencies(): void {
        switch (this.testFramework) {
            case "jest":
                this.dependencyManager.addDependency("jest", "^29.7.0", {
                    type: DependencyType.DEV
                });
                this.dependencyManager.addDependency("@jest/globals", "^29.7.0", {
                    type: DependencyType.DEV
                });
                this.dependencyManager.addDependency("@types/jest", "^29.5.14", {
                    type: DependencyType.DEV
                });
                this.dependencyManager.addDependency("ts-jest", "^29.3.4", {
                    type: DependencyType.DEV
                });
                this.dependencyManager.addDependency("jest-environment-jsdom", "^29.7.0", {
                    type: DependencyType.DEV
                });
                break;
            case "vitest":
                this.dependencyManager.addDependency("vitest", "^3.2.4", {
                    type: DependencyType.DEV
                });
                break;
        }
        if (this.generateWireTests) {
            this.dependencyManager.addDependency("msw", "2.11.2", {
                type: DependencyType.DEV
            });
        }
    }

    public async addExtras(): Promise<void> {
        switch (this.testFramework) {
            case "jest":
                await this.addJestConfigs();
                break;
            case "vitest":
                await this.addVitestConfigs();
                break;
        }
        this.addDependencies();
    }

    public get scripts(): Record<string, string> {
        switch (this.testFramework) {
            case "jest": {
                const scripts: Record<string, string> = {
                    test: "jest --config jest.config.mjs"
                };
                if (this.writeUnitTests) {
                    scripts["test:unit"] = "jest --selectProjects unit";
                }
                if (this.generateWireTests) {
                    scripts["test:wire"] = "jest --selectProjects wire";
                }
                return scripts;
            }
            case "vitest": {
                const scripts: Record<string, string> = {
                    test: "vitest"
                };
                scripts["test:unit"] = "vitest --project unit";
                if (this.generateWireTests) {
                    scripts["test:wire"] = "vitest --project wire";
                }
                return scripts;
            }
            default:
                return {};
        }
    }

    public get extraFiles(): Record<string, string> {
        const pathToRoot =
            this.relativePackagePath === DEFAULT_PACKAGE_PATH
                ? "../"
                : "../".repeat(this.relativePackagePath.split("/").length + 1);

        const extendsPath =
            this.useLegacyExports || this.shouldBundle
                ? `${pathToRoot}tsconfig.json`
                : `${pathToRoot}tsconfig.base.json`;

        const includePaths = [`${pathToRoot}${this.relativePackagePath}`, `${pathToRoot}${this.relativeTestPath}`];

        return {
            [`${this.relativeTestPath}/tsconfig.json`]: `{
    "extends": "${extendsPath}",
    "compilerOptions": {
        "outDir": null,
        "rootDir": "..",
        "baseUrl": ".."${
            this.testFramework === "vitest"
                ? `,
            "types": ["vitest/globals"]`
                : ""
        }
    },
    "include": ${JSON.stringify(includePaths)},
    "exclude": []
}`,
            [`${this.relativeTestPath}/custom.test.ts`]: `
/**
* This is a custom test file, if you wish to add more tests
* to your SDK.
* Be sure to mark this file in \`.fernignore\`.
*
* If you include example requests/responses in your fern definition,
* you will have tests automatically generated for you.
*/
describe("test", () => {
    it("default", () => {
        expect(true).toBe(true);
    });
});`
        };
    }

    public createWireTestDirectory(): void {
        const wireTestPath = `${this.relativeTestPath}/wire`;
        this.rootDirectory.createDirectory(wireTestPath);
        this.rootDirectory.createSourceFile(`${wireTestPath}/.gitkeep`, "", {
            overwrite: true
        });
    }

    public getMockAuthFilepath(): ExportedFilePath {
        return {
            directories: [
                {
                    nameOnDisk: "wire"
                }
            ],
            file: {
                nameOnDisk: "mockAuth.ts"
            },
            rootDir: this.relativeTestPath
        };
    }

    public shouldBuildMockAuthFile({ context }: { context: SdkContext }): boolean {
        if (!this.generateWireTests) {
            return false;
        }

        if (!this.ir.auth.schemes.find((s) => s.type === "inferred")) {
            return false;
        }

        return true;
    }

    public buildMockAuthFile({ context }: { context: SdkContext }): Code | undefined {
        context.importsManager.addImportFromRoot(
            "mock-server/MockServer",
            {
                namedImports: ["MockServer"]
            },
            this.relativeTestPath
        );
        const authScheme = this.ir.auth.schemes.find((s) => s.type === "inferred");
        if (!authScheme) {
            return undefined;
        }
        const endpointId = authScheme.tokenEndpoint.endpoint.endpointId;
        const serviceId = authScheme.tokenEndpoint.endpoint.serviceId;

        const service = this.ir.services[serviceId];
        if (!service) {
            throw new Error("Service not found");
        }

        const endpoint = service.endpoints.find((e) => e.id === endpointId);
        if (!endpoint) {
            throw new Error("Endpoint not found");
        }

        const successfulExamples = getExampleEndpointCalls(endpoint).filter(
            (example) => example.response.type === "ok"
        );
        const example = successfulExamples[0];
        if (!example) {
            return;
        }

        if (example.response.type !== "ok") {
            context.logger.warn("No successful response found to mock auth in wire tests.");
            return;
        }

        const rawRequestBody = this.getRequestExample(example.request);
        const rawResponseBody = this.getResponseExample(example.response);
        const responseStatusCode = getExampleResponseStatusCode({
            response: example.response,
            ir: this.ir
        });
        const mockBodyMethod = this.getMockBodyMethod(endpoint);

        return code`
export function mockAuth(server: MockServer) {
    ${rawRequestBody ? code`const rawRequestBody = ${rawRequestBody};` : ""}
    ${rawResponseBody ? code`const rawResponseBody = ${rawResponseBody};` : ""}
    server
        .mockEndpoint()
        .${endpoint.method.toLowerCase()}("${example.url}")${example.serviceHeaders.map((h) => {
            return code`.header("${h.name.wireValue}", "${h.value.jsonExample}")
                `;
        })}${example.endpointHeaders.map((h) => {
            return code`.header("${h.name.wireValue}", "${h.value.jsonExample}")
                `;
        })}${
            rawRequestBody
                ? code`.${mockBodyMethod}(rawRequestBody)
            `
                : ""
        }.respondWith()
        .statusCode(${responseStatusCode})${
            rawResponseBody
                ? code`.jsonBody(rawResponseBody)
            `
                : ""
        }.build();
}
`;
    }

    private getAuthClientOptions(context: SdkContext): Record<string, Code> {
        const authOptions: Record<string, Code> = {};
        this.ir.auth.schemes.forEach((schema) => {
            schema._visit({
                bearer: (schema) => {
                    authOptions[schema.token.camelCase.unsafeName] = code`"test"`;
                },
                header: (schema) => {
                    authOptions[schema.name.name.camelCase.unsafeName] = code`"test"`;
                },
                basic: (schema) => {
                    authOptions[schema.username.camelCase.unsafeName] = code`"test"`;
                    authOptions[schema.password.camelCase.unsafeName] = code`"test"`;
                },
                oauth: () => {
                    // noop
                    authOptions[OAuthTokenProviderGenerator.OAUTH_CLIENT_ID_PROPERTY_NAME] = code`"test"`;
                    authOptions[OAuthTokenProviderGenerator.OAUTH_CLIENT_SECRET_PROPERTY_NAME] = code`"test"`;
                },
                inferred: (auth) => {
                    const service = this.ir.services[auth.tokenEndpoint.endpoint.serviceId];
                    if (!service) {
                        throw new Error("Service not found");
                    }
                    const endpoint = service.endpoints.find((e) => e.id === auth.tokenEndpoint.endpoint.endpointId);
                    if (!endpoint) {
                        throw new Error("Endpoint not found");
                    }

                    const successfulExamples = getExampleEndpointCalls(endpoint).filter(
                        (example) => example.response.type === "ok"
                    );
                    const example = successfulExamples[0];
                    if (!example) {
                        return;
                    }

                    if (example.response.type !== "ok") {
                        context.logger.warn("No successful response found to mock auth in wire tests.");
                        return;
                    }

                    const authRequestParameters = this.getAuthRequestExampleOptions({
                        request: example,
                        auth: AuthScheme.inferred(auth),
                        context
                    });
                    Object.assign(authOptions, authRequestParameters);
                },
                _other: () => {
                    // noop
                }
            });
        });
        return authOptions;
    }

    private getAuthRequestExampleOptions({
        request,
        auth,
        context
    }: {
        request: ExampleEndpointCall;
        auth: AuthScheme;
        context: SdkContext;
    }): Record<string, Code> {
        const result: Record<string, Code> = {};

        request.endpointHeaders.forEach((h) => {
            result[h.name.name.camelCase.safeName] = code`${literalOf(h.value.jsonExample)}`;
        });

        request.serviceHeaders.forEach((header) => {
            result[header.name.name.camelCase.safeName] = code`${literalOf(header.value.jsonExample)}`;
        });

        request.queryParameters.forEach((queryParameter) => {
            result[queryParameter.name.name.camelCase.safeName] = code`${literalOf(queryParameter.value.jsonExample)}`;
        });

        request.rootPathParameters.forEach((rootPathParameter) => {
            result[rootPathParameter.name.camelCase.safeName] = code`${literalOf(rootPathParameter.value.jsonExample)}`;
        });

        request.servicePathParameters.forEach((pathParameter) => {
            result[pathParameter.name.camelCase.safeName] = code`${literalOf(pathParameter.value.jsonExample)}`;
        });

        request.endpointPathParameters.forEach((pathParameter) => {
            result[pathParameter.name.camelCase.safeName] = code`${literalOf(pathParameter.value.jsonExample)}`;
        });

        request.request?._visit({
            inlinedRequestBody: (value) => {
                value.properties.forEach((p) => {
                    return (result[p.name.name.camelCase.safeName] = this.createRawJsonExample({
                        example: p.value,
                        isForRequest: true,
                        isForResponse: false
                    }));
                });
            },
            reference: (value) => {
                Object.entries(this.getAuthRequestParameters(value)).forEach(([key, val]) => {
                    result[key] = val;
                });
            },
            _other: () => {
                // noop
            }
        });

        const authProviderParams = new Set<string>(
            context.authProvider.getPropertiesForAuthTokenParams(auth).map((p) => p.name)
        );
        return Object.fromEntries(Object.entries(result).filter(([key]) => authProviderParams.has(key)));
    }

    private getAuthRequestParameters({ shape }: ExampleTypeReference): Record<string, Code> {
        const getAuthRequestParameters = this.getAuthRequestParameters.bind(this);
        const createRawJsonExample = this.createRawJsonExample.bind(this);
        return shape._visit<Record<string, Code>>({
            primitive: () => {
                return {};
            },
            container: (value) => {
                return value._visit({
                    list: () => ({}),
                    map: () => ({}),
                    nullable: (value) => {
                        if (!value.nullable) {
                            return {};
                        }
                        return getAuthRequestParameters(value.nullable);
                    },
                    optional: (value) => {
                        if (!value.optional) {
                            return {};
                        }
                        return getAuthRequestParameters(value.optional);
                    },
                    set: () => ({}),
                    literal: () => ({}),
                    _other: () => ({})
                });
            },
            named: (value) => {
                return value.shape._visit<Record<string, Code>>({
                    alias: (value) => {
                        return getAuthRequestParameters(value.value);
                    },
                    enum: () => ({}),
                    object: (value) => {
                        return Object.fromEntries(
                            value.properties.map((property) => {
                                return [
                                    property.name.name.camelCase.safeName,
                                    createRawJsonExample({
                                        example: property.value,
                                        isForRequest: true,
                                        isForResponse: false
                                    })
                                ];
                            })
                        );
                    },
                    union: () => ({}),
                    undiscriminatedUnion: (value) => {
                        return getAuthRequestParameters(value.singleUnionType);
                    },
                    _other: () => ({})
                });
            },
            unknown: () => ({}),
            _other: () => ({})
        });
    }

    public buildFile(
        serviceName: string,
        service: HttpService,
        packageId: PackageId,
        serviceGenerator: GeneratedSdkClientClass,
        context: SdkContext
    ): Code | undefined {
        context.importsManager.addImportFromRoot(
            "mock-server/MockServerPool",
            {
                namedImports: ["mockServerPool"]
            },
            this.relativeTestPath
        );
        const refToClientType = context.sdkClientClass.getReferenceToClientClass({
            isRoot: true
        });

        const baseOptions: Record<string, Code> = {};

        // Add variables to baseOptions
        this.ir.variables.forEach((variable) => {
            const variableName = getParameterNameForVariable({
                variableName: variable.name,
                retainOriginalCasing: this.retainOriginalCasing
            });
            baseOptions[variableName] = code`${literalOf(variableName)}`;
        });

        this.ir.pathParameters.forEach((pathParameter) => {
            if (pathParameter.variable != null) {
                return;
            }
            baseOptions[
                getParameterNameForRootPathParameter({
                    pathParameter,
                    retainOriginalCasing: this.retainOriginalCasing
                })
            ] = code`${literalOf(pathParameter.name.camelCase.unsafeName)}`;
        });
        Object.assign(baseOptions, this.getAuthClientOptions(context));
        this.ir.headers.forEach((header) => {
            // We don't need to include literal types because they will automatically be included
            if (header.valueType.type === "container" && header.valueType.container.type === "literal") {
                return;
            }
            baseOptions[header.name.name.camelCase.unsafeName] = code`"test"`;
        });
        this.ir.apiVersion?._visit({
            header: (v) => {
                const propName = v.header.name.name.camelCase.unsafeName;
                const defaultValue = v.value.default?.name.wireValue;
                if (defaultValue) {
                    baseOptions[propName] = code`${literalOf(defaultValue)}`;
                    return;
                }
                if (context.type.isOptional(v.header.valueType)) {
                    return;
                }
                if (context.type.isNullable(v.header.valueType)) {
                    baseOptions[propName] = code`null`;
                    return;
                }
                const fallbackValue = v.value.values[0]?.name.wireValue;
                if (fallbackValue) {
                    baseOptions[propName] = code`${literalOf(fallbackValue)}`;
                    return;
                }
            },
            // biome-ignore lint/suspicious/noEmptyBlockStatements: allow
            _other: () => {}
        });

        const tests = service.endpoints
            .filter((e) => this.shouldBuildTest(e))
            .map((endpoint) =>
                this.buildEndpointTests(endpoint, serviceGenerator, context, refToClientType, baseOptions)
            )
            .filter((test) => test != null);

        if (tests.length === 0) {
            return undefined;
        }

        return code`
describe("${serviceName}", () => {
    ${tests}
});
`;
    }

    private buildEndpointTests(
        endpoint: HttpEndpoint,
        serviceGenerator: GeneratedSdkClientClass,
        context: SdkContext,
        importStatement: Reference,
        baseOptions: Record<string, Code>
    ): Code[] {
        let examples = getExampleEndpointCallsForTests({
            endpoint,
            fallbackToAutoGeneratedErrorExamples: this.wireTestsFallbackToAutoGeneratedErrorExamples
        });
        if (this.neverThrowErrors) {
            // remove error examples because we don't have time to implement them properly right now
            examples = examples.filter((example) => example.response.type === "ok");
        }
        if (examples.length === 0) {
            return [];
        }
        const hasMultipleExamples = examples.length > 1;

        return examples
            .flatMap((example, exampleIndex) =>
                this.buildExampleTest({
                    endpoint,
                    example,
                    exampleIndex,
                    hasMultipleExamples,
                    context,
                    serviceGenerator,
                    importStatement,
                    baseOptions
                })
            )
            .filter((test) => test != null) as Code[];
    }

    private buildExampleTest({
        endpoint,
        example,
        exampleIndex,
        hasMultipleExamples,
        serviceGenerator,
        context,
        importStatement,
        baseOptions
    }: {
        endpoint: HttpEndpoint;
        example: ExampleEndpointCall;
        exampleIndex: number;
        hasMultipleExamples: boolean;
        serviceGenerator: GeneratedSdkClientClass;
        context: SdkContext;
        importStatement: Reference;
        baseOptions: Record<string, Code>;
    }): Code | undefined {
        const options: Record<string, Code> = { ...baseOptions };
        const generatedEndpoint = serviceGenerator.getEndpoint({
            endpointId: endpoint.id,
            context
        });
        if (!generatedEndpoint) {
            return;
        }
        const generatedExample = generatedEndpoint.getExample({
            context,
            example,
            opts: {
                isForSnippet: true,
                isForComment: false
            },
            clientReference: ts.factory.createIdentifier("client")
        });

        if (!generatedExample) {
            return;
        }

        const rawRequestBody = this.getRequestExample(example.request);
        const rawResponseBody = this.getResponseExample(example.response);
        const responseStatusCode = getExampleResponseStatusCode({
            response: example.response,
            ir: this.ir
        });
        const mockBodyMethod = this.getMockBodyMethod(endpoint);

        const willThrowError = responseStatusCode >= 400 && this.neverThrowErrors === false;

        const expected = getExpectedResponse({
            response: example.response,
            context,
            neverThrowErrors: this.neverThrowErrors
        });

        const generateEnvironment = () => {
            if (!this.ir.environments) {
                return code`server.baseUrl`;
            }
            return this.ir.environments.environments._visit<Code>({
                singleBaseUrl: () => {
                    return code`server.baseUrl`;
                },
                multipleBaseUrls: (environment) => {
                    return code`${literalOf(
                        Object.fromEntries(
                            environment.baseUrls.map((url) => {
                                return [url.name.camelCase.unsafeName, code`server.baseUrl`];
                            })
                        )
                    )}`;
                },
                _other: () => code`server.baseUrl`
            });
        };
        options["environment"] = generateEnvironment();

        example.rootPathParameters.forEach((pathParameter) => {
            options[
                getParameterNameForRootExamplePathParameter({
                    pathParameter,
                    retainOriginalCasing: this.retainOriginalCasing
                })
            ] = code`${literalOf(pathParameter.value.jsonExample)}`;
        });

        example.endpointPathParameters.forEach((examplePathParameter) => {
            const pathParamDef = endpoint.pathParameters.find(
                (p) => p.name.originalName === examplePathParameter.name.originalName
            );

            if (pathParamDef?.variable != null) {
                const variable = this.ir.variables.find((v) => v.id === pathParamDef.variable);
                if (variable != null) {
                    const variableName = getParameterNameForVariable({
                        variableName: variable.name,
                        retainOriginalCasing: this.retainOriginalCasing
                    });
                    options[variableName] = code`${literalOf(examplePathParameter.value.jsonExample)}`;
                } else {
                    context.logger.warn(
                        `Variable with id "${pathParamDef.variable}" not found for path parameter "${examplePathParameter.name.originalName}" in endpoint ${endpoint.id}`
                    );
                }
            }
        });

        const isHeadersResponse = endpoint.response?.body === undefined && endpoint.method === HttpMethod.Head;

        let mockAuthSnippet: Code | undefined;
        if (this.shouldBuildMockAuthFile({ context }) && endpoint.auth) {
            mockAuthSnippet = code`mockAuth(server);\n`;
            context.importsManager.addImportFromRoot(
                "wire/mockAuth",
                {
                    namedImports: ["mockAuth"]
                },
                this.relativeTestPath
            );
        }

        const expectedName =
            endpoint.pagination !== undefined
                ? context.type.generateGetterForResponsePropertyAsString({
                      property: endpoint.pagination.results,
                      variable: "expected"
                  })
                : "expected";
        const pageName =
            endpoint.pagination !== undefined && endpoint.pagination.type === "custom"
                ? context.type.generateGetterForResponsePropertyAsString({
                      property: endpoint.pagination.results,
                      variable: "page"
                  })
                : "page";
        const nextPageName =
            endpoint.pagination !== undefined && endpoint.pagination.type === "custom"
                ? context.type.generateGetterForResponsePropertyAsString({
                      property: endpoint.pagination.results,
                      variable: "nextPage"
                  })
                : "nextPage";
        const paginationBlock =
            endpoint.pagination !== undefined
                ? code`
                const expected = ${expected}
                const page = ${getTextOfTsNode(generatedExample.endpointInvocation)};
                ${
                    endpoint.pagination.type !== "custom"
                        ? code`
                            expect(${expectedName}).toEqual(${pageName}.data);
                            expect(${pageName}.hasNextPage()).toBe(true);
                            const nextPage = await ${pageName}.getNextPage();
                            expect(${expectedName}).toEqual(${nextPageName}.data);
                        `
                        : code`expect(${expectedName}).toEqual(${pageName});`
                }
                `
                : "";

        let testName = endpoint.name.originalName;
        if (hasMultipleExamples) {
            testName += ` (${exampleIndex + 1})`;
        }

        return code`
    test("${testName}", async () => {
        const server = mockServerPool.createServer();${mockAuthSnippet ? mockAuthSnippet : ""}
        const client = new ${getTextOfTsNode(importStatement.getEntityName())}(${literalOf(options)});
        ${rawRequestBody ? code`const rawRequestBody = ${rawRequestBody};` : ""}
        ${rawResponseBody ? code`const rawResponseBody = ${rawResponseBody};` : ""}
        server
            .mockEndpoint()
            .${endpoint.method.toLowerCase()}("${example.url}")${example.serviceHeaders.map((h) => {
                return code`.header("${h.name.wireValue}", "${h.value.jsonExample}")
                    `;
            })}${example.endpointHeaders.map((h) => {
                return code`.header("${h.name.wireValue}", "${h.value.jsonExample}")
                    `;
            })}${
                rawRequestBody
                    ? code`.${mockBodyMethod}(rawRequestBody)
                `
                    : ""
            }.respondWith()
            .statusCode(${responseStatusCode})${
                rawResponseBody
                    ? code`.jsonBody(rawResponseBody)
                `
                    : ""
            }.build();

        ${
            willThrowError
                ? code`
            await expect(async () => {
                return ${getTextOfTsNode(generatedExample.endpointInvocation)}
            }).rejects.toThrow(${literalOf(expected)});`
                : isHeadersResponse
                  ? code`const headers = ${getTextOfTsNode(generatedExample.endpointInvocation)};
        expect(headers).toBeInstanceOf(Headers);`
                  : code`
                    ${
                        endpoint.pagination !== undefined
                            ? paginationBlock
                            : code`
                            const response = ${getTextOfTsNode(generatedExample.endpointInvocation)};
                            expect(response).toEqual(${expected});
                          `
                    }
                `
        }
    });
          `;
    }

    private getName({ name, context }: { name: Name; context: SdkContext }): string {
        return context.retainOriginalCasing || !context.includeSerdeLayer ? name.originalName : name.camelCase.safeName;
    }

    private getMockBodyMethod(endpoint: HttpEndpoint): string {
        const contentType = endpoint.requestBody?.contentType;
        if (contentType === "application/x-www-form-urlencoded") {
            return "formUrlEncodedBody";
        }
        return "jsonBody";
    }

    private shouldBuildTest(endpoint: HttpEndpoint): boolean {
        if (
            this.ir.auth.schemes.some((scheme) => {
                switch (scheme.type) {
                    case "basic":
                    case "bearer":
                    case "header":
                        return false; // supported
                    case "inferred":
                        return false; // TODO: handle inferred auth scheme
                    case "oauth":
                        return true; // not supported
                    default:
                        assertNever(scheme);
                }
            })
        ) {
            return false;
        }

        const requestType = endpoint.requestBody?.type ?? "undefined";
        switch (requestType) {
            case "bytes":
            case "fileUpload":
                return false; // not supported
            case "inlinedRequestBody":
            case "reference":
            case "undefined":
                break; // supported
            default:
                assertNever(requestType);
        }
        const responseType = endpoint.response?.body?.type ?? "undefined";
        switch (responseType) {
            case "fileDownload":
            case "text":
            case "bytes":
            case "streaming":
            case "streamParameter":
                return false; // not supported
            case "json":
            case "undefined":
                break; // supported
            default:
                assertNever(responseType);
        }
        if (endpoint.idempotent) {
            return false;
        }
        return true;
    }

    getRequestExample(request: ExampleRequestBody | undefined): Code | undefined {
        if (!request) {
            return undefined;
        }
        const requestExample = request._visit({
            inlinedRequestBody: (value) => {
                return code`${literalOf(
                    Object.fromEntries([
                        ...getUnusedPropertiesFromJsonExample(value.jsonExample, value),
                        ...value.properties
                            .map<[string, Code]>((p) => {
                                return [
                                    p.name.wireValue,
                                    this.createRawJsonExample({
                                        example: p.value,
                                        isForRequest: true,
                                        isForResponse: false
                                    })
                                ];
                            })
                            .filter(([, v]) => !isCodeUndefined(v)),
                        ...(value.extraProperties ?? [])
                            .map<[string, Code]>((p) => {
                                return [
                                    p.name.wireValue,
                                    this.createRawJsonExample({
                                        example: p.value,
                                        isForRequest: true,
                                        isForResponse: false
                                    })
                                ];
                            })
                            .filter(([, v]) => !isCodeUndefined(v))
                    ])
                )}`;
            },
            reference: (value) =>
                this.createRawJsonExample({ example: value, isForRequest: true, isForResponse: false }),
            _other: () => code`${literalOf(request.jsonExample)}`
        });
        if (isCodeUndefined(requestExample)) {
            return undefined;
        }
        if (isCodeEmptyObject(requestExample)) {
            // exception in the static example generation where empty objects are omitted for optional containers
            if (
                request.type === "reference" &&
                request.shape.type === "container" &&
                request.shape.container.type === "optional"
            ) {
                return undefined;
            }
        }
        return requestExample;
    }

    getResponseExample(response: ExampleResponse | undefined): Code | undefined {
        if (!response) {
            return undefined;
        }
        const createRawJsonExample = this.createRawJsonExample.bind(this);
        const responseExample = response._visit<Code | undefined>({
            ok: (value) => {
                return value._visit({
                    body: (value) => {
                        if (!value) {
                            return undefined;
                        }
                        return createRawJsonExample({ example: value, isForRequest: false, isForResponse: true });
                    },
                    stream: () => {
                        throw new Error("Stream not supported in wire tests");
                    },
                    sse: () => {
                        throw new Error("SSE not supported in wire tests");
                    },
                    _other: () => {
                        throw new Error("Unsupported response type");
                    }
                });
            },
            error: (value) => {
                if (!value.body) {
                    return undefined;
                }

                return createRawJsonExample({ example: value.body, isForRequest: false, isForResponse: true });
            },
            _other: () => {
                throw new Error("Unsupported response type");
            }
        });
        if (responseExample === undefined) {
            return undefined;
        }
        const rawCode = responseExample.toString().trim();
        if (rawCode === "undefined") {
            return undefined;
        }
        return responseExample;
    }

    createRawJsonExample({
        example,
        isForRequest,
        isForResponse
    }: {
        example: ExampleTypeReference;
        isForRequest: boolean;
        isForResponse: boolean;
    }): Code {
        const { shape, jsonExample } = example;
        const createRawJsonExample = this.createRawJsonExample.bind(this);
        const filterOutReadonlyProps = this.generateReadWriteOnlyTypes && isForRequest === true;
        const filterOutWriteonlyProps = this.generateReadWriteOnlyTypes && isForResponse === true;

        return shape._visit<Code>({
            primitive: (value) => {
                return value._visit<Code>({
                    integer: (value) => code`${literalOf(value)}`,
                    double: (value) => code`${literalOf(value)}`,
                    string: (value) => code`${literalOf(value.original)}`,
                    boolean: (value) => code`${literalOf(value)}`,
                    long: (value) => {
                        if (this.useBigInt) {
                            return code`BigInt(${literalOf(value)})`;
                        }
                        return code`${literalOf(value)}`;
                    },
                    uint: (value) => code`${literalOf(value)}`,
                    uint64: (value) => code`${literalOf(value)}`,
                    float: (value) => code`${literalOf(value)}`,
                    base64: (value) => code`${literalOf(value)}`,
                    bigInteger: (value) => {
                        if (this.useBigInt) {
                            return code`BigInt(${literalOf(value)})`;
                        }
                        return code`${literalOf(value)}`;
                    },
                    datetime: (value) => code`${literalOf(value.raw)}`,
                    date: (value) => code`${literalOf(value)}`,
                    uuid: (value) => code`${literalOf(value)}`,
                    _other: () => code`${literalOf(jsonExample)}`
                });
            },
            container: (value) => {
                return value._visit({
                    list: (value) => {
                        return code`${arrayOf(
                            ...value.list
                                .map((item) => createRawJsonExample({ example: item, isForRequest, isForResponse }))
                                .filter((v) => !isCodeUndefined(v))
                        )}`;
                    },
                    map: (value) => {
                        return code`${literalOf(
                            Object.fromEntries(
                                value.map.map((item) => {
                                    return [
                                        item.key.jsonExample,
                                        createRawJsonExample({ example: item.value, isForRequest, isForResponse })
                                    ];
                                })
                            )
                        )}`;
                    },
                    nullable: (value) => {
                        if (!value.nullable) {
                            return code`null`;
                        }
                        return createRawJsonExample({ example: value.nullable, isForRequest, isForResponse });
                    },
                    optional: (value) => {
                        if (!value.optional) {
                            return code`undefined`;
                        }
                        return createRawJsonExample({ example: value.optional, isForRequest, isForResponse });
                    },
                    set: (value) => {
                        return code`${arrayOf(
                            ...value.set
                                .map((v) => createRawJsonExample({ example: v, isForRequest, isForResponse }))
                                .filter((v) => !isCodeUndefined(v))
                        )}`;
                    },
                    literal: (value) => {
                        return value.literal._visit({
                            integer: (value) => code`${literalOf(value)}`,
                            long: (value) => {
                                if (this.useBigInt) {
                                    return code`BigInt(${literalOf(value)})`;
                                }
                                return code`${literalOf(value)}`;
                            },
                            uint: (value) => code`${literalOf(value)}`,
                            uint64: (value) => code`${literalOf(value)}`,
                            float: (value) => code`${literalOf(value)}`,
                            double: (value) => code`${literalOf(value)}`,
                            boolean: (value) => code`${literalOf(value)}`,
                            string: (value) => code`${literalOf(value.original)}`,
                            date: (value) => code`${literalOf(value)}`,
                            datetime: (value) => code`${literalOf(value.raw)}`,
                            uuid: (value) => code`${literalOf(value)}`,
                            base64: (value) => code`${literalOf(value)}`,
                            bigInteger: (value) => {
                                if (this.useBigInt) {
                                    return code`BigInt(${value})`;
                                }
                                return code`${literalOf(value)}`;
                            },
                            _other: () => code`${literalOf(jsonExample)}`
                        });
                    },
                    _other: () => code`${literalOf(jsonExample)}`
                });
            },
            named: (value) => {
                return value.shape._visit<Code>({
                    alias: (value) => {
                        return createRawJsonExample({ example: value.value, isForRequest, isForResponse });
                    },
                    enum: (value) => {
                        return code`${literalOf(value.value.wireValue)}`;
                    },
                    object: (value) => {
                        return code`${literalOf(
                            Object.fromEntries([
                                ...getUnusedPropertiesFromJsonExample(jsonExample, value),
                                ...value.properties
                                    .filter((p) => {
                                        if (typeof p.propertyAccess === "undefined") {
                                            return true;
                                        }
                                        if (
                                            filterOutReadonlyProps &&
                                            p.propertyAccess === ObjectPropertyAccess.ReadOnly
                                        ) {
                                            return false;
                                        }
                                        if (
                                            filterOutWriteonlyProps &&
                                            p.propertyAccess === ObjectPropertyAccess.WriteOnly
                                        ) {
                                            return false;
                                        }
                                        return true;
                                    })
                                    .map<[string, Code]>((property) => {
                                        return [
                                            property.name.wireValue,
                                            createRawJsonExample({
                                                example: property.value,
                                                isForRequest,
                                                isForResponse
                                            })
                                        ];
                                    })
                                    .filter(([_, value]) => !isCodeUndefined(value)),
                                ...(value.extraProperties ?? [])
                                    .map<[string, Code]>((property) => [
                                        property.name.wireValue,
                                        createRawJsonExample({
                                            example: property.value,
                                            isForRequest,
                                            isForResponse
                                        })
                                    ])
                                    .filter(([_, value]) => !isCodeUndefined(value))
                            ])
                        )}`;
                    },
                    union: (value) => {
                        if (typeof jsonExample !== "object" || jsonExample == null) {
                            // should not happen
                            return code`${literalOf(jsonExample)}`;
                        }
                        const properties: Record<string, unknown> = {};
                        properties[value.discriminant.wireValue] = (jsonExample as Record<string, unknown>)[
                            value.discriminant.wireValue
                        ];
                        Object.assign(
                            properties,
                            Object.fromEntries(
                                (value.baseProperties ?? []).map((property) => {
                                    return [property.name.wireValue, property.value.jsonExample];
                                })
                            )
                        );
                        Object.assign(
                            properties,
                            Object.fromEntries(
                                (value.extendProperties ?? []).map((property) => {
                                    return [property.name.wireValue, property.value.jsonExample];
                                })
                            )
                        );
                        const singleUnionProperties = value.singleUnionType.shape._visit({
                            noProperties: () => jsonExample as object | undefined | null,
                            singleProperty: () => jsonExample as object | undefined | null,
                            samePropertiesAsObject: (memberValue) => {
                                return Object.fromEntries([
                                    ...memberValue.object.properties
                                        .filter((p) => {
                                            if (typeof p.propertyAccess === "undefined") {
                                                return true;
                                            }
                                            if (
                                                filterOutReadonlyProps &&
                                                p.propertyAccess === ObjectPropertyAccess.ReadOnly
                                            ) {
                                                return false;
                                            }
                                            if (
                                                filterOutWriteonlyProps &&
                                                p.propertyAccess === ObjectPropertyAccess.WriteOnly
                                            ) {
                                                return false;
                                            }
                                            return true;
                                        })
                                        .map<[string, Code]>((property) => {
                                            return [
                                                property.name.wireValue,
                                                createRawJsonExample({
                                                    example: property.value,
                                                    isForRequest,
                                                    isForResponse
                                                })
                                            ];
                                        })
                                        .filter(([_, value]) => !isCodeUndefined(value)),
                                    ...(memberValue.object.extraProperties ?? [])
                                        .map<[string, Code]>((property) => [
                                            property.name.wireValue,
                                            createRawJsonExample({
                                                example: property.value,
                                                isForRequest,
                                                isForResponse
                                            })
                                        ])
                                        .filter(([_, value]) => !isCodeUndefined(value))
                                ]);
                            },
                            _other: () => jsonExample as object | undefined | null
                        });
                        if (singleUnionProperties != null) {
                            Object.assign(properties, singleUnionProperties);
                        }

                        // for extra properties
                        const otherProperties = Object.fromEntries(
                            Object.entries(jsonExample).filter(([key]) => !Object.keys(properties).includes(key))
                        );
                        Object.assign(properties, otherProperties);
                        return code`${literalOf(properties)}`;
                    },
                    undiscriminatedUnion: (value) => {
                        return createRawJsonExample({ example: value.singleUnionType, isForRequest, isForResponse });
                    },
                    _other: () => {
                        return code`${literalOf(jsonExample)}`;
                    }
                });
            },
            unknown: () => {
                return code`${literalOf(jsonExample)}`;
            },
            _other: () => {
                return code`${literalOf(jsonExample)}`;
            }
        });
    }
}

function getExampleResponseStatusCode({
    response,
    ir
}: {
    response: ExampleResponse;
    ir: IntermediateRepresentation;
}): number {
    return response._visit({
        ok: () => 200,
        error: (exampleError) => {
            const error = getExampleErrorDeclarationOrThrow({ exampleError, ir });
            return error.statusCode;
        },
        _other: () => {
            throw new Error("Unsupported response type");
        }
    });
}

/**
 * Properties that come from extends and base properties, which aren't included in the example shape, but are in the jsonExample
 */
function getUnusedPropertiesFromJsonExample(
    jsonExample: unknown,
    shape: ExampleObjectType | ExampleObjectTypeWithTypeId | ExampleInlinedRequestBody
): [string, unknown][] {
    const properties = "object" in shape ? shape.object.properties : shape.properties;
    const propertyKeys = new Set(properties.map((p) => p.name.wireValue));
    if (typeof jsonExample === "object" && jsonExample != null) {
        return (
            Object.entries(jsonExample)
                .filter(([key]) => !propertyKeys.has(key))
                // TODO: null could be valid, but IR gives us null for optional and nullable, because there's no way to differentiate in JSON
                // For now, we just filter out nulls
                .filter(([_, value]) => value != null)
        );
    }
    return [];
}

function getExpectedResponse({
    response,
    context,
    neverThrowErrors
}: {
    response: ExampleResponse;
    context: SdkContext;
    neverThrowErrors: boolean;
}): Code {
    return response._visit({
        ok: (response) => {
            const result = response._visit({
                body: (value) => {
                    if (!value) {
                        return code`undefined`;
                    }
                    const example = context.type.getGeneratedExample(value).build(context, {
                        isForSnippet: true,
                        isForResponse: true
                    });
                    return code`${getTextOfTsNode(example)}`;
                },
                stream: () => {
                    throw new Error("Stream not supported in wire tests");
                },
                sse: () => {
                    throw new Error("SSE not supported in wire tests");
                },
                _other: () => {
                    throw new Error("Unsupported response type");
                }
            });
            if (neverThrowErrors) {
                return code`{
                    body: ${result},
                    ok: true,
                    headers: expect.any(Object),
                    rawResponse: expect.any(Object),
                }`;
            }
            return result;
        },
        error: (value) => {
            const errorReference = context.sdkError
                .getReferenceToError(value.error)
                .getTypeNode({ isForSnippet: true, isForResponse: true });

            return code`${getTextOfTsNode(errorReference)}`;
        },
        _other: () => {
            throw new Error("Unsupported response type");
        }
    });
}

function getExampleErrorDeclarationOrThrow({
    exampleError,
    ir
}: {
    exampleError: ExampleEndpointErrorResponse;
    ir: IntermediateRepresentation;
}): ErrorDeclaration {
    const error = ir.errors[exampleError.error.errorId];
    if (!error) {
        throw new Error(`Error with ID ${exampleError.error.errorId} not found in IR`);
    }
    return error;
}

function isCodeUndefined(code: Code): boolean {
    const rawCode = code.toString().trim();
    return rawCode === "undefined";
}

function isCodeEmptyObject(code: Code): boolean {
    const rawCode = code.toString().trim();
    return rawCode === "{}" || rawCode === "{ }";
}

/**
 * Determines the casing of the variable name when used in client constructor options
 */
function getParameterNameForVariable({
    variableName,
    retainOriginalCasing
}: {
    variableName: Name;
    retainOriginalCasing: boolean;
}): string {
    if (retainOriginalCasing) {
        return variableName.originalName;
    }
    return variableName.camelCase.safeName;
}

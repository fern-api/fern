import { ReferenceConfigBuilder } from "@fern-api/base-generator";
import { AbsoluteFilePath } from "@fern-api/fs-utils";
import { FernGeneratorCli } from "@fern-fern/generator-cli-sdk";
import { FernGeneratorExec } from "@fern-fern/generator-exec-sdk";
import * as FernGeneratorExecSerializers from "@fern-fern/generator-exec-sdk/serialization";
import {
    ExampleEndpointCall,
    HttpEndpoint,
    HttpService,
    IntermediateRepresentation,
    Subpackage,
    TypeDeclaration,
    TypeId,
    WebSocketChannel
} from "@fern-fern/ir-sdk/api";
import {
    AsIsManager,
    BundledTypescriptProject,
    CoreUtilitiesManager,
    DependencyManager,
    ExportedDirectory,
    ExportedFilePath,
    ExportsManager,
    getFullPathForEndpoint,
    getTextOfTsNode,
    ImportsManager,
    NpmPackage,
    PackageId,
    PublicExportsManager,
    SimpleTypescriptProject,
    TypescriptProject
} from "@fern-typescript/commons";
import { BaseClientContext, GeneratorContext } from "@fern-typescript/contexts";
import { EndpointErrorUnionGenerator } from "@fern-typescript/endpoint-error-union-generator";
import { EnvironmentsGenerator } from "@fern-typescript/environments-generator";
import { GenericAPISdkErrorGenerator, TimeoutSdkErrorGenerator } from "@fern-typescript/generic-sdk-error-generators";
import { RequestWrapperGenerator } from "@fern-typescript/request-wrapper-generator";
import { ErrorResolver, PackageResolver, TypeResolver } from "@fern-typescript/resolvers";
import {
    AuthProvidersGenerator,
    BaseClientTypeGenerator,
    SdkClientClassGenerator,
    WebsocketClassGenerator
} from "@fern-typescript/sdk-client-class-generator";
import { SdkEndpointTypeSchemasGenerator } from "@fern-typescript/sdk-endpoint-type-schemas-generator";
import { SdkErrorGenerator } from "@fern-typescript/sdk-error-generator";
import { SdkErrorSchemaGenerator } from "@fern-typescript/sdk-error-schema-generator";
import { SdkInlinedRequestBodySchemaGenerator } from "@fern-typescript/sdk-inlined-request-schema-generator";
import { TypeGenerator } from "@fern-typescript/type-generator";
import { TypeReferenceExampleGenerator } from "@fern-typescript/type-reference-example-generator";
import { TypeSchemaGenerator } from "@fern-typescript/type-schema-generator";
import { WebsocketTypeSchemaGenerator } from "@fern-typescript/websocket-type-schema-generator";
import { writeFile } from "fs/promises";
import { Directory, Project, SourceFile, ts } from "ts-morph";
import { BaseClientContextImpl } from "./contexts/base-client/BaseClientContextImpl";
import { SdkContextImpl } from "./contexts/SdkContextImpl";
import { ContributingGenerator } from "./contributing/ContributingGenerator";
import { BaseClientTypeDeclarationReferencer } from "./declaration-referencers/BaseClientTypeDeclarationReferencer";
import { EndpointDeclarationReferencer } from "./declaration-referencers/EndpointDeclarationReferencer";
import { EnvironmentsDeclarationReferencer } from "./declaration-referencers/EnvironmentsDeclarationReferencer";
import { GenericAPISdkErrorDeclarationReferencer } from "./declaration-referencers/GenericAPISdkErrorDeclarationReferencer";
import { JsonDeclarationReferencer } from "./declaration-referencers/JsonDeclarationReferencer";
import { RequestWrapperDeclarationReferencer } from "./declaration-referencers/RequestWrapperDeclarationReferencer";
import { SdkClientClassDeclarationReferencer } from "./declaration-referencers/SdkClientClassDeclarationReferencer";
import { SdkErrorDeclarationReferencer } from "./declaration-referencers/SdkErrorDeclarationReferencer";
import { SdkInlinedRequestBodyDeclarationReferencer } from "./declaration-referencers/SdkInlinedRequestBodyDeclarationReferencer";
import { NonStatusCodeErrorHandlerDeclarationReferencer } from "./declaration-referencers/NonStatusCodeErrorHandlerDeclarationReferencer";
import { TimeoutSdkErrorDeclarationReferencer } from "./declaration-referencers/TimeoutSdkErrorDeclarationReferencer";
import { TypeDeclarationReferencer } from "./declaration-referencers/TypeDeclarationReferencer";
import { VersionDeclarationReferencer } from "./declaration-referencers/VersionDeclarationReferencer";
import { WebsocketSocketDeclarationReferencer } from "./declaration-referencers/WebsocketSocketDeclarationReferencer";
import { WebsocketTypeSchemaDeclarationReferencer } from "./declaration-referencers/WebsocketTypeSchemaDeclarationReferencer";
import { NonStatusCodeErrorHandlerGenerator } from "./non-status-code-error-handler/NonStatusCodeErrorHandlerGenerator";
import { ReadmeConfigBuilder } from "./readme/ReadmeConfigBuilder";
import { TypeScriptGeneratorAgent } from "./TypeScriptGeneratorAgent";
import { TestGenerator } from "./test-generator/TestGenerator";
import { VersionFileGenerator } from "./version/VersionFileGenerator";
import { VersionGenerator } from "./version/VersionGenerator";

const FILE_HEADER = `// This file was auto-generated by Fern from our API Definition.
`;

const WHITELABEL_FILE_HEADER = `/**
 * This file was auto-generated from our API Definition.
 */
`;

export declare namespace SdkGenerator {
    export interface Init {
        namespaceExport: string;
        intermediateRepresentation: IntermediateRepresentation;
        context: GeneratorContext;
        npmPackage: NpmPackage | undefined;
        generateJestTests: boolean;
        rawConfig: FernGeneratorExec.GeneratorConfig;
        config: Config;
    }

    export interface Config {
        runScripts: boolean;
        whitelabel: boolean;
        generateOAuthClients: boolean;
        originalReadmeFilepath: AbsoluteFilePath | undefined;
        snippetFilepath: AbsoluteFilePath | undefined;
        shouldBundle: boolean;
        shouldUseBrandedStringAliases: boolean;
        isPackagePrivate: boolean;
        neverThrowErrors: boolean;
        includeCredentialsOnCrossOriginRequests: boolean;
        outputEsm: boolean;
        outputJsr: boolean;
        allowCustomFetcher: boolean;
        shouldGenerateWebsocketClients: boolean;
        includeUtilsOnUnionMembers: boolean;
        includeOtherInUnionTypes: boolean;
        enableForwardCompatibleEnums: boolean;
        requireDefaultEnvironment: boolean;
        defaultTimeoutInSeconds: number | "infinity" | undefined;
        skipResponseValidation: boolean;
        extraDependencies: Record<string, string>;
        extraDevDependencies: Record<string, string>;
        extraPeerDependencies: Record<string, string>;
        extraPeerDependenciesMeta: Record<string, unknown>;
        treatUnknownAsAny: boolean;
        includeContentHeadersOnFileDownloadResponse: boolean;
        includeSerdeLayer: boolean;
        noOptionalProperties: boolean;
        tolerateRepublish: boolean;
        retainOriginalCasing: boolean;
        parameterNaming: "originalName" | "wireValue" | "camelCase" | "snakeCase" | "default";
        allowExtraFields: boolean;
        writeUnitTests: boolean;
        inlineFileProperties: boolean;
        inlinePathParameters: boolean;
        enableInlineTypes: boolean;
        omitUndefined: boolean;
        executionEnvironment: "local" | "dev" | "prod";
        organization: string;
        apiName: string;
        packageJson: Record<string, unknown> | undefined;
        useBigInt: boolean;
        useLegacyExports: boolean;
        generateWireTests: boolean;
        streamType: "wrapper" | "web";
        fileResponseType: "stream" | "binary-response";
        formDataSupport: "Node16" | "Node18";
        fetchSupport: "node-fetch" | "native";
        packagePath: string | undefined;
        omitFernHeaders: boolean;
        useDefaultRequestParameterValues: boolean;
        packageManager: "pnpm" | "yarn";
        generateReadWriteOnlyTypes: boolean;
        flattenRequestParameters: boolean;
        exportAllRequestsAtRoot: boolean;
        testFramework: "jest" | "vitest";
        consolidateTypeFiles: boolean;
        generateEndpointMetadata: boolean;
        wireTestsFallbackToAutoGeneratedErrorExamples: boolean;
        linter: "biome" | "oxlint" | "none";
        formatter: "prettier" | "biome" | "oxfmt";
        generateSubpackageExports: boolean;
        offsetSemantics: "item-index" | "page-index";
    }
}

export class SdkGenerator {
    private namespaceExport: string;
    private context: GeneratorContext;
    private intermediateRepresentation: IntermediateRepresentation;
    private rawConfig: FernGeneratorExec.GeneratorConfig;
    private config: SdkGenerator.Config;
    private npmPackage: NpmPackage | undefined;
    private generateOAuthClients: boolean;
    private generateJestTests: boolean;
    private shouldGenerateWebsocketClients: boolean;
    private extraFiles: Record<string, string> = {};
    private extraScripts: Record<string, string> = {};

    private endpointSnippets: FernGeneratorExec.Endpoint[] = [];

    private project: Project;
    private snippetProject: Project | undefined;
    private snippetCounter = 0;
    private rootDirectory: Directory;
    private exportsManager: ExportsManager;
    private readonly publicExportsManager: PublicExportsManager;
    private dependencyManager = new DependencyManager();
    private coreUtilitiesManager: CoreUtilitiesManager;
    private typeResolver: TypeResolver;
    private errorResolver: ErrorResolver;
    private packageResolver: PackageResolver;

    private versionDeclarationReferencer: VersionDeclarationReferencer;
    private typeDeclarationReferencer: TypeDeclarationReferencer;
    private typeSchemaDeclarationReferencer: TypeDeclarationReferencer;
    private errorDeclarationReferencer: SdkErrorDeclarationReferencer;
    private sdkErrorSchemaDeclarationReferencer: SdkErrorDeclarationReferencer;
    private sdkClientClassDeclarationReferencer: SdkClientClassDeclarationReferencer;
    private endpointErrorUnionDeclarationReferencer: EndpointDeclarationReferencer;
    private requestWrapperDeclarationReferencer: RequestWrapperDeclarationReferencer;
    private sdkInlinedRequestBodySchemaDeclarationReferencer: SdkInlinedRequestBodyDeclarationReferencer;
    private sdkEndpointSchemaDeclarationReferencer: EndpointDeclarationReferencer;
    private environmentsDeclarationReferencer: EnvironmentsDeclarationReferencer;
    private baseClientTypeDeclarationReferencer: BaseClientTypeDeclarationReferencer;
    private baseClientContext: BaseClientContext;
    private genericAPISdkErrorDeclarationReferencer: GenericAPISdkErrorDeclarationReferencer;
    private timeoutSdkErrorDeclarationReferencer: TimeoutSdkErrorDeclarationReferencer;
    private nonStatusCodeErrorHandlerDeclarationReferencer: NonStatusCodeErrorHandlerDeclarationReferencer;
    private jsonDeclarationReferencer: JsonDeclarationReferencer;

    private versionGenerator: VersionGenerator;
    private typeGenerator: TypeGenerator;
    private typeSchemaGenerator: TypeSchemaGenerator;
    private typeReferenceExampleGenerator: TypeReferenceExampleGenerator;
    private sdkErrorGenerator: SdkErrorGenerator;
    private sdkErrorSchemaGenerator: SdkErrorSchemaGenerator;
    private endpointErrorUnionGenerator: EndpointErrorUnionGenerator;
    private requestWrapperGenerator: RequestWrapperGenerator;
    private sdkInlinedRequestBodySchemaGenerator: SdkInlinedRequestBodySchemaGenerator;
    private websocketTypeSchemaGenerator: WebsocketTypeSchemaGenerator;
    private sdkEndpointTypeSchemasGenerator: SdkEndpointTypeSchemasGenerator;
    private environmentsGenerator: EnvironmentsGenerator;
    private sdkClientClassGenerator: SdkClientClassGenerator;
    private baseClientTypeGenerator: BaseClientTypeGenerator;
    private genericAPISdkErrorGenerator: GenericAPISdkErrorGenerator;
    private timeoutSdkErrorGenerator: TimeoutSdkErrorGenerator;
    private nonStatusCodeErrorHandlerGenerator: NonStatusCodeErrorHandlerGenerator;
    private testGenerator: TestGenerator;
    private websocketGenerator: WebsocketClassGenerator;
    private referenceConfigBuilder: ReferenceConfigBuilder;
    private generatorAgent: TypeScriptGeneratorAgent;
    private readonly asIsManager: AsIsManager;
    private websocketSocketDeclarationReferencer: WebsocketSocketDeclarationReferencer;
    private websocketTypeSchemaDeclarationReferencer: WebsocketTypeSchemaDeclarationReferencer;

    private rootDirectoryPath: string;
    private defaultSrcDirectory: string;
    private defaultTestDirectory: string;

    private relativePackagePath: string;
    private relativeTestPath: string;
    private testDirectory: Directory;
    private packagePathDirectory: Directory;

    constructor({
        namespaceExport,
        intermediateRepresentation,
        context,
        npmPackage,
        rawConfig,
        config,
        generateJestTests
    }: SdkGenerator.Init) {
        this.rootDirectoryPath = "/";
        this.defaultSrcDirectory = "src";
        this.defaultTestDirectory = "tests";

        this.context = context;
        this.namespaceExport = namespaceExport;
        this.intermediateRepresentation = intermediateRepresentation;
        this.config = config;
        this.npmPackage = npmPackage;
        this.rawConfig = rawConfig;
        this.generateJestTests = generateJestTests;
        this.generateOAuthClients =
            this.config.generateOAuthClients &&
            this.intermediateRepresentation.auth.schemes.some((scheme) => scheme.type === "oauth");
        this.shouldGenerateWebsocketClients = this.config.shouldGenerateWebsocketClients;

        this.project = new Project({
            useInMemoryFileSystem: true
        });
        this.rootDirectory = this.project.createDirectory(this.rootDirectoryPath);
        this.relativePackagePath = this.getRelativePackagePath();
        this.relativeTestPath = this.getRelativeTestPath();
        this.testDirectory = this.project.createDirectory(this.getRelativeTestPath());
        this.packagePathDirectory = this.project.createDirectory(this.relativePackagePath);
        this.typeResolver = new TypeResolver(intermediateRepresentation);
        this.errorResolver = new ErrorResolver(intermediateRepresentation);
        this.packageResolver = new PackageResolver(intermediateRepresentation);

        this.exportsManager = new ExportsManager({
            packagePath: this.relativePackagePath
        });
        this.publicExportsManager = new PublicExportsManager();
        this.coreUtilitiesManager = new CoreUtilitiesManager({
            streamType: this.config.streamType,
            formDataSupport: this.config.formDataSupport,
            fetchSupport: this.config.fetchSupport,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath,
            generateEndpointMetadata: this.config.generateEndpointMetadata
        });

        const apiDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "api",
                exportDeclaration: { namespaceExport }
            }
        ];

        const schemaDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "serialization"
            }
        ];

        this.versionDeclarationReferencer = new VersionDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            apiVersion: this.intermediateRepresentation.apiVersion,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath
        });
        this.typeDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            consolidateTypeFiles: config.consolidateTypeFiles
        });
        this.typeSchemaDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.errorDeclarationReferencer = new SdkErrorDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport
        });
        this.sdkErrorSchemaDeclarationReferencer = new SdkErrorDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.sdkClientClassDeclarationReferencer = new SdkClientClassDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });
        this.endpointErrorUnionDeclarationReferencer = new EndpointDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });
        this.requestWrapperDeclarationReferencer = new RequestWrapperDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            packageResolver: this.packageResolver,
            exportAllRequestsAtRoot: config.exportAllRequestsAtRoot
        });
        this.sdkInlinedRequestBodySchemaDeclarationReferencer = new SdkInlinedRequestBodyDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });
        this.sdkEndpointSchemaDeclarationReferencer = new EndpointDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });
        this.environmentsDeclarationReferencer = new EnvironmentsDeclarationReferencer({
            containingDirectory: [],
            namespaceExport,
            npmPackage: this.npmPackage,
            environmentsConfig: intermediateRepresentation.environments ?? undefined,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath
        });
        this.baseClientTypeDeclarationReferencer = new BaseClientTypeDeclarationReferencer({
            containingDirectory: [],
            namespaceExport,
            relativePackagePath: this.relativePackagePath,
            consolidateTypeFiles: config.consolidateTypeFiles,
            generateIdempotentRequestOptions: this.hasIdempotentEndpoints()
        });
        this.baseClientContext = new BaseClientContextImpl({
            intermediateRepresentation,
            allowCustomFetcher: config.allowCustomFetcher,
            generateIdempotentRequestOptions: this.hasIdempotentEndpoints(),
            requireDefaultEnvironment: config.requireDefaultEnvironment,
            retainOriginalCasing: config.retainOriginalCasing,
            parameterNaming: config.parameterNaming,
            baseClientTypeDeclarationReferencer: this.baseClientTypeDeclarationReferencer
        });
        this.genericAPISdkErrorDeclarationReferencer = new GenericAPISdkErrorDeclarationReferencer({
            containingDirectory: [],
            namespaceExport
        });
        this.timeoutSdkErrorDeclarationReferencer = new TimeoutSdkErrorDeclarationReferencer({
            containingDirectory: [],
            namespaceExport
        });
        this.nonStatusCodeErrorHandlerDeclarationReferencer = new NonStatusCodeErrorHandlerDeclarationReferencer({
            containingDirectory: [],
            namespaceExport
        });
        this.jsonDeclarationReferencer = new JsonDeclarationReferencer({
            containingDirectory: [
                {
                    nameOnDisk: "core"
                }
            ],
            namespaceExport: "json"
        });

        this.versionGenerator = new VersionGenerator();
        this.typeGenerator = new TypeGenerator({
            useBrandedStringAliases: config.shouldUseBrandedStringAliases,
            includeUtilsOnUnionMembers: config.includeUtilsOnUnionMembers,
            includeOtherInUnionTypes: config.includeOtherInUnionTypes,
            enableForwardCompatibleEnums: config.enableForwardCompatibleEnums,
            includeSerdeLayer: config.includeSerdeLayer,
            noOptionalProperties: config.noOptionalProperties,
            retainOriginalCasing: config.retainOriginalCasing,
            enableInlineTypes: config.enableInlineTypes,
            generateReadWriteOnlyTypes: config.generateReadWriteOnlyTypes
        });
        this.typeSchemaGenerator = new TypeSchemaGenerator({
            includeUtilsOnUnionMembers: config.includeUtilsOnUnionMembers,
            noOptionalProperties: config.noOptionalProperties
        });
        this.typeReferenceExampleGenerator = new TypeReferenceExampleGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            useBigInt: config.useBigInt
        });
        this.sdkErrorGenerator = new SdkErrorGenerator({
            neverThrowErrors: config.neverThrowErrors
        });
        this.sdkErrorSchemaGenerator = new SdkErrorSchemaGenerator({
            skipValidation: config.skipResponseValidation,
            includeSerdeLayer: config.includeSerdeLayer
        });
        this.endpointErrorUnionGenerator = new EndpointErrorUnionGenerator({
            errorResolver: this.errorResolver,
            intermediateRepresentation,
            includeSerdeLayer: config.includeSerdeLayer,
            retainOriginalCasing: config.retainOriginalCasing,
            noOptionalProperties: config.noOptionalProperties,
            enableInlineTypes: config.enableInlineTypes,
            generateReadWriteOnlyTypes: config.generateReadWriteOnlyTypes
        });
        this.sdkEndpointTypeSchemasGenerator = new SdkEndpointTypeSchemasGenerator({
            errorResolver: this.errorResolver,
            intermediateRepresentation,
            shouldGenerateErrors: config.neverThrowErrors,
            skipResponseValidation: config.skipResponseValidation,
            includeSerdeLayer: config.includeSerdeLayer,
            allowExtraFields: config.allowExtraFields,
            omitUndefined: config.omitUndefined
        });
        this.requestWrapperGenerator = new RequestWrapperGenerator();
        this.environmentsGenerator = new EnvironmentsGenerator();
        this.sdkClientClassGenerator = new SdkClientClassGenerator({
            intermediateRepresentation,
            errorResolver: this.errorResolver,
            packageResolver: this.packageResolver,
            neverThrowErrors: config.neverThrowErrors,
            includeCredentialsOnCrossOriginRequests: config.includeCredentialsOnCrossOriginRequests,
            allowCustomFetcher: config.allowCustomFetcher,
            shouldGenerateWebsocketClients: this.shouldGenerateWebsocketClients,
            requireDefaultEnvironment: config.requireDefaultEnvironment,
            defaultTimeoutInSeconds: config.defaultTimeoutInSeconds,
            npmPackage,
            includeContentHeadersOnFileDownloadResponse: config.includeContentHeadersOnFileDownloadResponse,
            includeSerdeLayer: config.includeSerdeLayer,
            retainOriginalCasing: config.retainOriginalCasing,
            inlineFileProperties: config.inlineFileProperties,
            omitUndefined: config.omitUndefined,
            allowExtraFields: config.allowExtraFields,
            streamType: config.streamType,
            fileResponseType: config.fileResponseType,
            exportsManager: this.exportsManager,
            formDataSupport: config.formDataSupport,
            useDefaultRequestParameterValues: config.useDefaultRequestParameterValues,
            generateEndpointMetadata: config.generateEndpointMetadata,
            parameterNaming: config.parameterNaming,
            offsetSemantics: config.offsetSemantics
        });
        this.baseClientTypeGenerator = new BaseClientTypeGenerator({
            ir: intermediateRepresentation,
            generateIdempotentRequestOptions: this.hasIdempotentEndpoints(),
            omitFernHeaders: config.omitFernHeaders
        });
        this.websocketGenerator = new WebsocketClassGenerator({
            intermediateRepresentation,
            retainOriginalCasing: config.retainOriginalCasing,
            omitUndefined: config.omitUndefined,
            skipResponseValidation: config.skipResponseValidation
        });
        this.genericAPISdkErrorGenerator = new GenericAPISdkErrorGenerator();
        this.timeoutSdkErrorGenerator = new TimeoutSdkErrorGenerator();
        this.nonStatusCodeErrorHandlerGenerator = new NonStatusCodeErrorHandlerGenerator();
        this.sdkInlinedRequestBodySchemaGenerator = new SdkInlinedRequestBodySchemaGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            allowExtraFields: config.allowExtraFields,
            omitUndefined: config.omitUndefined
        });
        this.websocketTypeSchemaGenerator = new WebsocketTypeSchemaGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            omitUndefined: config.omitUndefined,
            skipResponseValidation: config.skipResponseValidation
        });
        this.testGenerator = new TestGenerator({
            ir: intermediateRepresentation,
            dependencyManager: this.dependencyManager,
            rootDirectory: this.rootDirectory,
            writeUnitTests: this.config.writeUnitTests,
            includeSerdeLayer: config.includeSerdeLayer,
            generateWireTests: config.generateWireTests,
            useBigInt: config.useBigInt,
            retainOriginalCasing: config.retainOriginalCasing,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath,
            neverThrowErrors: config.neverThrowErrors,
            generateReadWriteOnlyTypes: config.generateReadWriteOnlyTypes,
            testFramework: config.testFramework,
            useLegacyExports: config.useLegacyExports,
            shouldBundle: config.shouldBundle,
            wireTestsFallbackToAutoGeneratedErrorExamples: config.wireTestsFallbackToAutoGeneratedErrorExamples,
            parameterNaming: config.parameterNaming
        });
        this.referenceConfigBuilder = new ReferenceConfigBuilder();
        this.generatorAgent = new TypeScriptGeneratorAgent({
            logger: this.context.logger,
            config: this.rawConfig,
            readmeConfigBuilder: new ReadmeConfigBuilder({
                endpointSnippets: this.endpointSnippets,
                fileResponseType: this.config.fileResponseType,
                fetchSupport: this.config.fetchSupport,
                generateSubpackageExports: this.config.generateSubpackageExports
            }),
            ir: intermediateRepresentation
        });

        this.asIsManager = new AsIsManager({
            useBigInt: config.useBigInt,
            generateWireTests: config.generateWireTests,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath,
            generatorType: "sdk",
            formatter: config.formatter,
            linter: config.linter
        });

        this.websocketTypeSchemaDeclarationReferencer = new WebsocketTypeSchemaDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });

        this.websocketSocketDeclarationReferencer = new WebsocketSocketDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
            packageResolver: this.packageResolver
        });
    }

    public async generate(): Promise<TypescriptProject> {
        this.context.logger.debug("Copying as-is files");
        await this.copyAsIsFiles();
        this.generateTypeDeclarations();
        this.context.logger.debug("Generated types");
        this.generateErrorDeclarations();
        this.context.logger.debug("Generated errors");
        this.generateHandleNonStatusCodeError();
        this.context.logger.debug("Generated handleNonStatusCodeError");
        if (this.shouldGenerateWebsocketClients) {
            if (this.config.includeSerdeLayer) {
                this.generateUnionedResponseSchemas();
                this.context.logger.debug("Generated unioned response schemas");
            }
            this.generateWebsocketSockets();
            this.context.logger.debug("Generated websocket clients");
        }
        this.generateBaseClientTypes();
        this.context.logger.debug("Generated base client types");
        this.generateServiceDeclarations();
        this.context.logger.debug("Generated services");
        if (this.config.generateSubpackageExports) {
            this.generateSubpackageExports();
            this.context.logger.debug("Generated subpackage exports");
        }
        this.generateEnvironments();
        this.context.logger.debug("Generated environments");
        this.generateRequestWrappers();
        this.context.logger.debug("Generated request wrappers");
        this.generateVersion();
        this.context.logger.debug("Generated version");
        this.context.logger.debug("Generating auth providers");
        this.generateAuthProviders();
        this.context.logger.debug("Generated auth providers");

        if (this.config.neverThrowErrors) {
            this.generateEndpointErrorUnion();
        }
        if (!this.config.neverThrowErrors || this.generateOAuthClients) {
            this.generateGenericAPISdkError();
            this.generateTimeoutSdkError();
            if (this.config.includeSerdeLayer) {
                this.generateSdkErrorSchemas();
            }
        }

        let exportSerde: boolean = false;
        if (this.config.includeSerdeLayer) {
            this.generateTypeSchemas();
            this.generateEndpointTypeSchemas();
            this.generateInlinedRequestBodySchemas();
            const serializationDirectory = this.rootDirectory.getDirectory("src/serialization");
            if (serializationDirectory != null && serializationDirectory?.getDescendantSourceFiles().length > 0) {
                exportSerde = true;
                this.exportsManager.addExportsForDirectories([
                    { nameOnDisk: "serialization", exportDeclaration: { namespaceExport: "serialization" } }
                ]);
                this.context.logger.debug("Generated serde layer.");
            }
        }

        if (this.npmPackage?.version != null) {
            const versionFileGenerator = new VersionFileGenerator({
                version: this.npmPackage.version,
                packagePathDirectory: this.packagePathDirectory
            });
            versionFileGenerator.generate();
        }

        this.coreUtilitiesManager.finalize(this.exportsManager, this.dependencyManager);
        this.exportsManager.writeExportsToProject(this.rootDirectory);
        this.context.logger.debug("Generated exports");

        if (this.generateJestTests && this.config.writeUnitTests) {
            this.generateTestFiles();
        }
        await this.testGenerator.addExtras();
        this.extraScripts = {
            ...this.extraScripts,
            ...this.testGenerator.scripts
        };
        this.extraFiles = {
            ...this.extraFiles,
            ...this.testGenerator.extraFiles
        };

        if (this.config.snippetFilepath != null) {
            this.generateSnippets();
            const snippets: FernGeneratorExec.Snippets = {
                endpoints: this.endpointSnippets,
                types: {}
            };
            await writeFile(
                this.config.snippetFilepath,
                JSON.stringify(await FernGeneratorExecSerializers.Snippets.jsonOrThrow(snippets), undefined, 4)
            );
            this.context.logger.debug("Generated snippets");

            try {
                await this.generateReadme();
            } catch (e) {
                this.context.logger.warn("Failed to generate README.md, this is OK");
            }

            try {
                await this.generateReference();
            } catch (e) {
                this.context.logger.warn("Failed to generate reference.md, this is OK");
            }

            if (!this.config.whitelabel) {
                try {
                    await this.generateContributing();
                } catch (e) {
                    this.context.logger.warn("Failed to generate CONTRIBUTING.md, this is OK");
                }
            }
        }

        const subpackageExportPaths = this.config.generateSubpackageExports ? this.getSubpackageExportPaths() : [];

        return this.config.shouldBundle
            ? new BundledTypescriptProject({
                  npmPackage: this.npmPackage,
                  dependencies: this.dependencyManager.getDependencies(),
                  tsMorphProject: this.project,
                  extraDependencies: this.config.extraDependencies,
                  extraDevDependencies: this.config.extraDevDependencies,
                  extraPeerDependencies: this.config.extraPeerDependencies,
                  extraPeerDependenciesMeta: this.config.extraPeerDependenciesMeta,
                  extraFiles: this.extraFiles,
                  extraScripts: this.extraScripts,
                  extraConfigs: this.config.packageJson,
                  outputJsr: this.config.outputJsr,
                  runScripts: this.config.runScripts,
                  exportSerde,
                  packagePath: this.relativePackagePath,
                  testPath: this.getRelativeTestPath(),
                  packageManager: this.config.packageManager,
                  linter: this.config.linter,
                  formatter: this.config.formatter,
                  generateSubpackageExports: this.config.generateSubpackageExports,
                  subpackageExportPaths
              })
            : new SimpleTypescriptProject({
                  npmPackage: this.npmPackage,
                  dependencies: this.dependencyManager.getDependencies(),
                  tsMorphProject: this.project,
                  outputEsm: this.config.outputEsm,
                  outputJsr: this.config.outputJsr,
                  extraDependencies: this.config.extraDependencies,
                  extraDevDependencies: this.config.extraDevDependencies,
                  extraPeerDependencies: this.config.extraPeerDependencies,
                  extraPeerDependenciesMeta: this.config.extraPeerDependenciesMeta,
                  extraFiles: this.extraFiles,
                  extraScripts: this.extraScripts,
                  resolutions: {},
                  extraConfigs: this.config.packageJson,
                  runScripts: this.config.runScripts,
                  exportSerde,
                  useLegacyExports: this.config.useLegacyExports,
                  packagePath: this.relativePackagePath,
                  testPath: this.getRelativeTestPath(),
                  packageManager: this.config.packageManager,
                  linter: this.config.linter,
                  formatter: this.config.formatter,
                  generateSubpackageExports: this.config.generateSubpackageExports,
                  subpackageExportPaths
              });
    }

    private hasIdempotentEndpoints(): boolean {
        return Object.values(this.intermediateRepresentation.services)
            .flatMap((s) => s.endpoints)
            .some((endpoint) => endpoint.idempotent);
    }

    private async copyAsIsFiles() {
        await this.asIsManager.addToTsProject({ project: this.project });
    }

    private getTypesToGenerate(): Record<TypeId, TypeDeclaration> {
        if (this.config.enableInlineTypes) {
            return Object.fromEntries(
                Object.entries(this.intermediateRepresentation.types).filter(
                    ([_, typeDeclaration]) => !typeDeclaration.inline
                )
            );
        }
        return this.intermediateRepresentation.types;
    }

    public async copyCoreUtilities({
        pathToSrc,
        pathToRoot
    }: {
        pathToSrc: AbsoluteFilePath;
        pathToRoot: AbsoluteFilePath;
    }): Promise<void> {
        await this.coreUtilitiesManager.copyCoreUtilities({ pathToSrc, pathToRoot });
    }

    public async generatePublicExports({ pathToSrc }: { pathToSrc: AbsoluteFilePath }): Promise<void> {
        await this.publicExportsManager.generatePublicExportsFiles({
            pathToSrc
        });
        this.context.logger.debug("Generated public exports");
    }

    private generateTypeDeclarations() {
        if (this.config.consolidateTypeFiles) {
            return this.generateConsolidatedTypeDeclarations();
        }
        for (const typeDeclaration of Object.values(this.getTypesToGenerate())) {
            this.withSourceFile({
                filepath: this.typeDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.type.getGeneratedType(typeDeclaration.name).writeToFile(context);
                }
            });
        }
    }

    private generateConsolidatedTypeDeclarations() {
        const typesByFile = new Map<string, TypeDeclaration[]>();

        for (const typeDeclaration of Object.values(this.getTypesToGenerate())) {
            const filepath = this.typeDeclarationReferencer.getExportedFilepath(typeDeclaration.name);
            const filepathKey = JSON.stringify(filepath);

            const types = typesByFile.get(filepathKey) ?? [];
            types.push(typeDeclaration);
            typesByFile.set(filepathKey, types);
        }

        for (const [filepathKey, typeDeclarations] of typesByFile.entries()) {
            this.withSourceFile({
                filepath: JSON.parse(filepathKey),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    for (const typeDeclaration of typeDeclarations) {
                        const currentStatementCount = context.sourceFile.getStatements().length;
                        context.type.getGeneratedType(typeDeclaration.name).writeToFile(context);
                        context.sourceFile.insertStatements(currentStatementCount, (writer) => writer.newLine());
                    }
                }
            });
        }
    }

    private generateTypeSchemas(): { generated: boolean } {
        let generated = false;
        for (const typeDeclaration of Object.values(this.getTypesToGenerate())) {
            this.withSourceFile({
                filepath: this.typeSchemaDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    if (!generated) {
                        generated = true;
                    }
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.typeSchema.getGeneratedTypeSchema(typeDeclaration.name).writeToFile(context);
                }
            });
        }
        return { generated };
    }

    private generateWebsocketSockets() {
        this.forPackageChannel((channel, packageId) => {
            if (!packageId.isRoot) {
                const subpackageId = packageId.subpackageId;
                this.withSourceFile({
                    filepath: this.websocketSocketDeclarationReferencer.getExportedFilepath(subpackageId),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateSdkContext({ sourceFile, importsManager });
                        context.websocket
                            .getGeneratedWebsocketSocketClass(packageId, subpackageId, channel)
                            ?.writeToFile(context);
                    }
                });
            }
        });
    }

    private generateErrorDeclarations() {
        for (const errorDeclaration of Object.values(this.intermediateRepresentation.errors)) {
            this.withSourceFile({
                filepath: this.errorDeclarationReferencer.getExportedFilepath(errorDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.sdkError.getGeneratedSdkError(errorDeclaration.name)?.writeToFile(context);
                }
            });
        }
    }

    private generateHandleNonStatusCodeError() {
        if (this.config.neverThrowErrors) {
            return;
        }
        this.withSourceFile({
            filepath: this.nonStatusCodeErrorHandlerDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                this.nonStatusCodeErrorHandlerGenerator
                    .generateNonStatusCodeErrorHandler()
                    .writeToFile(context);
            }
        });
    }

    private generateSdkErrorSchemas() {
        for (const errorDeclaration of Object.values(this.intermediateRepresentation.errors)) {
            this.withSourceFile({
                filepath: this.sdkErrorSchemaDeclarationReferencer.getExportedFilepath(errorDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.sdkErrorSchema.getGeneratedSdkErrorSchema(errorDeclaration.name)?.writeToFile(context);
                }
            });
        }
    }

    private generateEndpointErrorUnion() {
        this.forEachService((service, packageId) => {
            for (const endpoint of service.endpoints) {
                this.withSourceFile({
                    filepath: this.endpointErrorUnionDeclarationReferencer.getExportedFilepath({
                        packageId,
                        endpoint
                    }),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateSdkContext({ sourceFile, importsManager });
                        context.endpointErrorUnion
                            .getGeneratedEndpointErrorUnion(packageId, endpoint.name)
                            .writeToFile(context);
                    }
                });
            }
        });
    }

    private generateEndpointTypeSchemas(): { generated: boolean } {
        let generated = false;
        this.forEachService((service, packageId) => {
            for (const endpoint of service.endpoints) {
                this.withSourceFile({
                    filepath: this.sdkEndpointSchemaDeclarationReferencer.getExportedFilepath({
                        packageId,
                        endpoint
                    }),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateSdkContext({ sourceFile, importsManager });
                        context.sdkEndpointTypeSchemas
                            .getGeneratedEndpointTypeSchemas(packageId, endpoint.name)
                            .writeToFile(context);
                        if (!generated) {
                            generated = true;
                        }
                    }
                });
            }
        });
        return { generated };
    }

    private generateRequestWrappers() {
        if (this.config.exportAllRequestsAtRoot) {
            this.generateAggregatedRequestWrappers();
        } else {
            this.generateIndividualRequestWrappers();
        }
    }

    private generateIndividualRequestWrappers() {
        this.forEachService((service, packageId) => {
            for (const endpoint of service.endpoints) {
                if (endpoint.sdkRequest?.shape.type === "wrapper") {
                    this.withSourceFile({
                        filepath: this.requestWrapperDeclarationReferencer.getExportedFilepath({
                            packageId,
                            endpoint
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = this.generateSdkContext({ sourceFile, importsManager });
                            context.requestWrapper
                                .getGeneratedRequestWrapper(packageId, endpoint.name)
                                .writeToFile(context);
                        },
                        addExportTypeModifier: true
                    });
                }
            }
        });
    }

    private generateAggregatedRequestWrappers() {
        const requestWrappers: Array<{ packageId: PackageId; endpoint: HttpEndpoint }> = [];
        this.forEachService((service, packageId) => {
            for (const endpoint of service.endpoints) {
                if (endpoint.sdkRequest?.shape.type === "wrapper") {
                    requestWrappers.push({ packageId, endpoint });
                }
            }
        });
        if (requestWrappers.length === 0) {
            return;
        }

        this.withSourceFile({
            filepath: this.requestWrapperDeclarationReferencer.getAggregatedRequestsFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                for (const { packageId, endpoint } of requestWrappers) {
                    context.requestWrapper.getGeneratedRequestWrapper(packageId, endpoint.name).writeToFile(context);
                }
            },
            addExportTypeModifier: true
        });
    }

    private generateUnionedResponseSchemas(): { generated: boolean } {
        let generated = false;
        if (!this.config.includeSerdeLayer) {
            return { generated };
        }
        this.forPackageChannel((channel, packageId) => {
            const receiveMessages = channel.messages
                .filter((message) => message.origin === "server")
                .map((message) => message.body)
                .filter((message) => message.type === "reference");
            this.withSourceFile({
                filepath: this.websocketTypeSchemaDeclarationReferencer.getExportedFilepath({
                    packageId,
                    channel
                }),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.websocketTypeSchema
                        .getGeneratedWebsocketResponseTypeSchema(packageId, channel, receiveMessages)
                        .writeToFile(context);
                    if (!generated) {
                        generated = true;
                    }
                }
            });
        });
        return { generated };
    }

    private generateInlinedRequestBodySchemas(): { generated: boolean } {
        let generated = false;
        this.forEachService((service, packageId) => {
            for (const endpoint of service.endpoints) {
                if (endpoint.requestBody?.type === "inlinedRequestBody") {
                    this.withSourceFile({
                        filepath: this.sdkInlinedRequestBodySchemaDeclarationReferencer.getExportedFilepath({
                            packageId,
                            endpoint
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = this.generateSdkContext({ sourceFile, importsManager });
                            context.sdkInlinedRequestBodySchema
                                .getGeneratedInlinedRequestBodySchema(packageId, endpoint.name)
                                .writeToFile(context);
                            if (!generated) {
                                generated = true;
                            }
                        }
                    });
                }
            }
        });
        return { generated };
    }

    private generateBaseClientTypes() {
        this.context.logger.debug("Generating base client types...");
        this.withSourceFile({
            filepath: this.baseClientTypeDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                this.baseClientTypeGenerator.writeToFile(context);
            }
        });
    }

    private generateServiceDeclarations() {
        this.context.logger.debug("Generating service declarations...");
        for (const packageId of this.getAllPackageIds()) {
            const package_ = this.packageResolver.resolvePackage(packageId);
            if (!package_.hasEndpointsInTree && (!this.shouldGenerateWebsocketClients || package_.websocket == null)) {
                continue;
            }
            this.withSourceFile({
                filepath: this.sdkClientClassDeclarationReferencer.getExportedFilepath(packageId),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    context.sdkClientClass.getGeneratedSdkClientClass(packageId).writeToFile(context);
                }
            });
        }
    }

    private generateTestFiles() {
        this.context.logger.debug("Generating test files...");
        if (this.config.generateWireTests) {
            // make sure folder is always created, even if no wire tests are generated
            this.testGenerator.createWireTestDirectory();
            this.withSourceFile({
                filepath: this.testGenerator.getMockAuthFilepath(),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    const file = this.testGenerator.buildMockAuthFile({ context });
                    if (file) {
                        sourceFile.replaceWithText(file.toString({ dprintOptions: { indentWidth: 4 } }));
                    }
                },
                packagePath: this.getRelativeTestPath()
            });
        }
        this.forEachService((service, packageId) => {
            if (service.endpoints.length === 0) {
                return;
            }

            this.withSourceFile({
                filepath: this.testGenerator.getTestFile(service),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    const file = this.testGenerator.buildFile(
                        this.sdkClientClassDeclarationReferencer.getExportedName(packageId),
                        service,
                        packageId,
                        context.sdkClientClass.getGeneratedSdkClientClass(packageId),
                        context
                    );
                    if (file) {
                        sourceFile.replaceWithText(file.toString({ dprintOptions: { indentWidth: 4 } }));
                    }
                },
                packagePath: this.getRelativeTestPath()
            });
        });
    }

    private async generateReadme(): Promise<void> {
        if (this.endpointSnippets.length === 0) {
            this.context.logger.debug("No snippets were produced; skipping README.md generation.");
            return;
        }
        await this.withRawFile({
            filepath: this.generatorAgent.getExportedReadmeFilePath(),
            run: async ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                const readmeContent = await this.generatorAgent.generateReadme({
                    context,
                    endpointSnippets: this.endpointSnippets
                });
                sourceFile.replaceWithText(readmeContent);
            },
            packagePath: "/"
        });
    }

    private async generateReference(): Promise<void> {
        if (this.referenceConfigBuilder.isEmpty()) {
            return;
        }
        await this.withRawFile({
            filepath: this.generatorAgent.getExportedReferenceFilePath(),
            run: async ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                const referenceContent = await this.generatorAgent.generateReference(this.referenceConfigBuilder);
                sourceFile.replaceWithText(referenceContent);
            },
            packagePath: "/"
        });
    }

    private async generateContributing(): Promise<void> {
        await this.withRawFile({
            filepath: this.generatorAgent.getExportedContributingFilePath(),
            run: async ({ sourceFile, importsManager }) => {
                const contributingGenerator = new ContributingGenerator({
                    packageManager: this.config.packageManager
                });
                const contributingContent = contributingGenerator.generate();
                sourceFile.replaceWithText(contributingContent);
            },
            packagePath: "/"
        });
    }

    private runWithSnippet({
        sourceFile,
        importsManager,
        rootPackage,
        packageId,
        endpoint,
        example,
        includeImports
    }: {
        sourceFile: SourceFile;
        importsManager: ImportsManager;
        rootPackage: PackageId;
        packageId: PackageId;
        endpoint: HttpEndpoint;
        example: ExampleEndpointCall;
        includeImports: boolean;
    }): ts.Node[] | undefined {
        const context = this.generateSdkContext({ sourceFile, importsManager }, { isForSnippet: true });
        const clientInstantiation = context.sdkClientClass
            .getGeneratedSdkClientClass(rootPackage)
            .instantiateAsRoot({ context, npmPackage: this.npmPackage });
        const clientAssignment = ts.factory.createVariableStatement(
            undefined,
            ts.factory.createVariableDeclarationList(
                [
                    ts.factory.createVariableDeclaration(
                        context.sdkInstanceReferenceForSnippet,
                        undefined,
                        undefined,
                        clientInstantiation
                    )
                ],
                ts.NodeFlags.Const
            )
        );
        const clientClass = context.sdkClientClass.getGeneratedSdkClientClass(packageId);
        const endpointSample = clientClass.invokeEndpoint({
            context,
            endpointId: endpoint.id,
            example,
            clientReference: context.sdkInstanceReferenceForSnippet
        });
        const maybeLeveragedInvocation = clientClass.maybeLeverageInvocation({
            context,
            endpointId: endpoint.id,
            example,
            clientReference: context.sdkInstanceReferenceForSnippet
        });

        if (endpointSample == null) {
            return undefined;
        }

        const snippet = maybeLeveragedInvocation ?? [
            ts.factory.createExpressionStatement(endpointSample.endpointInvocation)
        ];

        if (includeImports) {
            return [...endpointSample.imports, clientAssignment, ...snippet];
        }
        return snippet;
    }

    private generateSnippets() {
        const rootPackage: PackageId = { isRoot: true };
        this.forEachService((service, packageId) => {
            if (service.endpoints.length === 0) {
                return;
            }
            let serviceReference = this.referenceConfigBuilder.addSection({
                title:
                    service.displayName ??
                    service.name.fernFilepath.allParts.map((part) => part.pascalCase.unsafeName).join(" ")
            });

            const exportedFilepath = this.sdkClientClassDeclarationReferencer.getExportedFilepath(packageId);
            exportedFilepath.rootDir = this.relativePackagePath;
            const serviceFilepath = this.exportsManager.convertExportedFilePathToFilePath(exportedFilepath);

            for (const endpoint of service.endpoints) {
                if (packageId.isRoot) {
                    serviceReference = this.referenceConfigBuilder.addRootSection();
                }

                let examplesForEndpoint: ExampleEndpointCall[] = [];
                for (const userDefinedExample of endpoint.userSpecifiedExamples) {
                    if (userDefinedExample.example != null) {
                        examplesForEndpoint.push(userDefinedExample.example);
                    }
                }
                if (examplesForEndpoint.length === 0) {
                    // use a single autogenerated example if no user provided examples
                    const maybeAutogeneratedExample = endpoint.autogeneratedExamples[0]?.example;
                    examplesForEndpoint = maybeAutogeneratedExample != null ? [maybeAutogeneratedExample] : [];
                }

                for (const [index, example] of examplesForEndpoint.entries()) {
                    const snippet = this.withSnippet({
                        run: ({ sourceFile, importsManager }): ts.Node[] | undefined => {
                            return this.runWithSnippet({
                                sourceFile,
                                importsManager,
                                rootPackage,
                                packageId,
                                endpoint,
                                example,
                                includeImports: true
                            });
                        },
                        includeImports: true
                    });

                    if (snippet != null) {
                        const endpointSnippet: FernGeneratorExec.Endpoint = {
                            id: {
                                path: FernGeneratorExec.EndpointPath(getFullPathForEndpoint(endpoint)),
                                method: endpoint.method,
                                identifierOverride: endpoint.id
                            },
                            snippet: FernGeneratorExec.EndpointSnippet.typescript({
                                client: snippet
                            })
                        };
                        if (example.name?.originalName != null) {
                            endpointSnippet.exampleIdentifier = example.name?.originalName;
                        }

                        this.endpointSnippets.push(endpointSnippet);
                    }

                    if (index === 0 && serviceReference != null) {
                        // We only include a reference section for the first example.
                        let returnType = undefined;
                        let endpointClientAccess: ts.Expression | undefined = undefined;
                        const parameters: FernGeneratorCli.ParameterReference[] = [];
                        const referenceSnippet = this.withSnippet({
                            run: ({ sourceFile, importsManager }): ts.Node[] | undefined => {
                                const context = this.generateSdkContext(
                                    { sourceFile, importsManager },
                                    { isForSnippet: true }
                                );
                                const clientClass = context.sdkClientClass.getGeneratedSdkClientClass(packageId);
                                const endpointDetailed = clientClass.getEndpoint({
                                    context,
                                    endpointId: endpoint.id
                                });
                                const returnTypeNode = endpointDetailed?.getSignature(context).returnTypeWithoutPromise;
                                returnType =
                                    returnTypeNode !== undefined ? getTextOfTsNode(returnTypeNode) : returnTypeNode;
                                parameters.push(
                                    ...(endpointDetailed?.getSignature(context).parameters.map((param) => {
                                        return {
                                            name: param.name,
                                            description: param.docs,
                                            type: param.type?.toString() ?? "unknown",
                                            required: param.hasQuestionToken != null ? !param.hasQuestionToken : true
                                        };
                                    }) ?? [])
                                );

                                endpointClientAccess = clientClass.accessFromRootClient({
                                    referenceToRootClient: context.sdkInstanceReferenceForSnippet
                                });

                                return this.runWithSnippet({
                                    sourceFile,
                                    importsManager,
                                    rootPackage,
                                    packageId,
                                    endpoint,
                                    example,
                                    includeImports: false
                                });
                            },
                            includeImports: false
                        });

                        let statement = undefined;
                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                        if (endpointClientAccess !== undefined) {
                            statement = getTextOfTsNode(endpointClientAccess) + ".";
                        }

                        if (referenceSnippet != null && statement != null) {
                            serviceReference.addEndpoint({
                                title: {
                                    snippetParts: [
                                        {
                                            text: statement
                                        },
                                        {
                                            text: this.getEndpointFunctionName(endpoint),
                                            location: {
                                                path: serviceFilepath
                                            }
                                        },
                                        {
                                            text: this.getReferenceEndpointInvocationParameters({
                                                parameters
                                            })
                                        }
                                    ],
                                    returnValue:
                                        returnType != null
                                            ? {
                                                  text: returnType
                                              }
                                            : undefined
                                },
                                description: endpoint.docs,
                                snippet: referenceSnippet,
                                parameters
                            });
                        }
                    }
                }
            }
        });
    }

    private getEndpointFunctionName(endpoint: HttpEndpoint): string {
        return endpoint.name.camelCase.unsafeName;
    }

    private getReferenceEndpointInvocationParameters({
        parameters
    }: {
        parameters: FernGeneratorCli.ParameterReference[];
    }): string {
        return `(${parameters
            .filter((param) => param.name !== "requestOptions")
            .map((param) => (param.name === "request" ? "{ ...params }" : param.name))
            .join(", ")})`;
    }

    private generateAuthProviders(): void {
        const isAnyAuth = this.intermediateRepresentation.auth.requirement === "ANY";

        if (isAnyAuth) {
            // For ANY auth, we need to generate all individual auth providers first,
            // then generate the AnyAuthProvider that aggregates them
            for (const authScheme of this.intermediateRepresentation.auth.schemes) {
                const authProvidersGenerator = new AuthProvidersGenerator({
                    ir: this.intermediateRepresentation,
                    authScheme,
                    neverThrowErrors: this.config.neverThrowErrors,
                    includeSerdeLayer: this.config.includeSerdeLayer
                });
                if (!authProvidersGenerator.shouldWriteFile()) {
                    continue;
                }
                this.withSourceFile({
                    filepath: authProvidersGenerator.getFilePath(),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateSdkContext({ sourceFile, importsManager });
                        authProvidersGenerator.writeToFile(context);
                    }
                });
            }

            // Now generate the AnyAuthProvider that aggregates all the individual providers
            const anyAuthProvidersGenerator = new AuthProvidersGenerator({
                ir: this.intermediateRepresentation,
                authScheme: { type: "any" },
                neverThrowErrors: this.config.neverThrowErrors,
                includeSerdeLayer: this.config.includeSerdeLayer
            });
            this.withSourceFile({
                filepath: anyAuthProvidersGenerator.getFilePath(),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateSdkContext({ sourceFile, importsManager });
                    anyAuthProvidersGenerator.writeToFile(context);
                }
            });
        } else {
            // For non-ANY auth, generate auth providers as before
            for (const authScheme of this.intermediateRepresentation.auth.schemes) {
                const authProvidersGenerator = new AuthProvidersGenerator({
                    ir: this.intermediateRepresentation,
                    authScheme,
                    neverThrowErrors: this.config.neverThrowErrors,
                    includeSerdeLayer: this.config.includeSerdeLayer
                });
                if (!authProvidersGenerator.shouldWriteFile()) {
                    continue;
                }
                this.withSourceFile({
                    filepath: authProvidersGenerator.getFilePath(),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateSdkContext({ sourceFile, importsManager });
                        authProvidersGenerator.writeToFile(context);
                    }
                });
            }
        }
    }

    private generateVersion(): void {
        if (this.intermediateRepresentation.apiVersion == null) {
            return;
        }
        this.withSourceFile({
            filepath: this.versionDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                const generatedVersion = context.versionContext.getGeneratedVersion();
                if (generatedVersion != null) {
                    generatedVersion.writeToFile(context);
                }
            },
            addExportTypeModifier: true
        });
    }

    private generateEnvironments(): void {
        this.withSourceFile({
            filepath: this.environmentsDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                context.environments.getGeneratedEnvironments().writeToFile(context);
            }
        });
    }

    private generateGenericAPISdkError(): void {
        this.withSourceFile({
            filepath: this.genericAPISdkErrorDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                this.genericAPISdkErrorGenerator
                    .generateGenericAPISdkError({
                        errorClassName: this.genericAPISdkErrorDeclarationReferencer.getExportedName()
                    })
                    .writeToFile(context);
            }
        });
    }

    private generateTimeoutSdkError(): void {
        this.withSourceFile({
            filepath: this.timeoutSdkErrorDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateSdkContext({ sourceFile, importsManager });
                this.timeoutSdkErrorGenerator
                    .generateTimeoutSdkError({
                        errorClassName: this.timeoutSdkErrorDeclarationReferencer.getExportedName()
                    })
                    .writeToFile(context);
            }
        });
    }

    private withSnippet({
        run,
        includeImports = false
    }: {
        run: (args: { sourceFile: SourceFile; importsManager: ImportsManager }) => ts.Node[] | undefined;
        includeImports: boolean;
    }): string | undefined {
        const useOldBehavior = process.env.FERN_SNIPPET_PROJECT_PER_SNIPPET === "1";

        if (useOldBehavior) {
            const project = new Project({
                useInMemoryFileSystem: true
            });
            const sourceFile = project.createSourceFile("snippet");
            const importsManager = new ImportsManager({
                packagePath: this.relativePackagePath
            });
            const statements = run({ sourceFile, importsManager });
            if (statements != null) {
                sourceFile.addStatements(statements.map((expression) => getTextOfTsNode(expression)));
                if (includeImports) {
                    importsManager.writeImportsToSourceFile(sourceFile);
                }
                return sourceFile.getText();
            }
            return undefined;
        }

        if (this.snippetProject == null) {
            this.snippetProject = new Project({
                useInMemoryFileSystem: true
            });
        }

        const sourceFile = this.snippetProject.createSourceFile(`snippet-${this.snippetCounter++}.ts`, undefined, {
            overwrite: false
        });
        const importsManager = new ImportsManager({
            packagePath: this.relativePackagePath
        });
        const statements = run({ sourceFile, importsManager });
        if (statements != null) {
            sourceFile.addStatements(statements.map((expression) => getTextOfTsNode(expression)));
            if (includeImports) {
                importsManager.writeImportsToSourceFile(sourceFile);
            }
            const text = sourceFile.getText();
            sourceFile.delete();
            return text;
        }
        // Clean up the source file even if no statements were generated
        sourceFile.delete();
        return undefined;
    }

    private withSourceFile({
        run,
        filepath,
        addExportTypeModifier,
        overwrite,
        packagePath = this.relativePackagePath
    }: {
        run: (args: { sourceFile: SourceFile; importsManager: ImportsManager }) => void;
        filepath: ExportedFilePath;
        addExportTypeModifier?: boolean;
        overwrite?: boolean;
        packagePath?: string;
    }) {
        filepath.rootDir = packagePath;
        const filepathStr = this.exportsManager.convertExportedFilePathToFilePath(filepath);
        this.context.logger.debug(`Generating ${filepathStr}`);

        const sourceFile = this.rootDirectory.createSourceFile(filepathStr, undefined, { overwrite: true });
        const importsManager = new ImportsManager({
            packagePath: this.relativePackagePath
        });

        run({ sourceFile, importsManager });

        if (sourceFile.getStatements().length === 0) {
            sourceFile.delete();
            this.context.logger.debug(`Skipping ${filepathStr} (no content)`);
        } else {
            importsManager.writeImportsToSourceFile(sourceFile);
            this.exportsManager.addExportsForFilepath(filepath, addExportTypeModifier);

            // this needs to be last.
            // https://github.com/dsherret/ts-morph/issues/189#issuecomment-414174283
            sourceFile.insertText(0, (writer) => {
                if (this.config.whitelabel) {
                    writer.writeLine(WHITELABEL_FILE_HEADER);
                } else {
                    writer.writeLine(FILE_HEADER);
                }
            });

            this.context.logger.debug(`Generated ${filepathStr}`);
        }
    }

    private async withRawFile({
        run,
        filepath,
        overwrite,
        packagePath = this.relativePackagePath
    }: {
        run: (args: { sourceFile: SourceFile; importsManager: ImportsManager }) => Promise<void>;
        filepath: ExportedFilePath;
        overwrite?: boolean;
        packagePath?: string;
    }) {
        filepath.rootDir = packagePath;
        const filepathStr = this.exportsManager.convertExportedFilePathToFilePath(filepath);
        this.context.logger.debug(`Generating ${filepathStr}`);
        await run({
            sourceFile: this.rootDirectory.createSourceFile(filepathStr, undefined, { overwrite: true }),
            importsManager: new ImportsManager({
                packagePath: this.relativePackagePath
            })
        });
        this.context.logger.debug(`Generated ${filepathStr}`);
    }

    private getAllPackageIds(): PackageId[] {
        return [
            { isRoot: true },
            ...Object.keys(this.intermediateRepresentation.subpackages).map(
                (subpackageId): PackageId => ({ isRoot: false, subpackageId })
            )
        ];
    }

    private forPackageChannel(run: (channel: WebSocketChannel, packageId: PackageId) => void): void {
        for (const packageId of this.getAllPackageIds()) {
            const channel = this.packageResolver.getChannelDeclaration(packageId);
            if (channel != null) {
                run(channel, packageId);
            }
        }
    }
    private forEachService(run: (service: HttpService, packageId: PackageId) => void): void {
        for (const packageId of this.getAllPackageIds()) {
            const service = this.packageResolver.getServiceDeclaration(packageId);
            if (service != null) {
                run(service, packageId);
            }
        }
    }

    private generateSdkContext(
        {
            sourceFile,
            importsManager
        }: {
            sourceFile: SourceFile;
            importsManager: ImportsManager;
        },
        { isForSnippet }: { isForSnippet?: boolean } = {}
    ): SdkContextImpl {
        return new SdkContextImpl({
            logger: this.context.logger,
            version: this.context.version,
            config: this.rawConfig,
            ir: this.intermediateRepresentation,
            npmPackage: this.npmPackage,
            isForSnippet: isForSnippet ?? false,
            intermediateRepresentation: this.intermediateRepresentation,
            sourceFile,
            coreUtilitiesManager: this.coreUtilitiesManager,
            dependencyManager: this.dependencyManager,
            fernConstants: this.intermediateRepresentation.constants,
            importsManager,
            exportsManager: this.exportsManager,
            versionGenerator: this.versionGenerator,
            versionDeclarationReferencer: this.versionDeclarationReferencer,
            jsonDeclarationReferencer: this.jsonDeclarationReferencer,
            typeResolver: this.typeResolver,
            typeDeclarationReferencer: this.typeDeclarationReferencer,
            typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
            typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
            errorDeclarationReferencer: this.errorDeclarationReferencer,
            sdkErrorSchemaDeclarationReferencer: this.sdkErrorSchemaDeclarationReferencer,
            endpointErrorUnionDeclarationReferencer: this.endpointErrorUnionDeclarationReferencer,
            sdkEndpointSchemaDeclarationReferencer: this.sdkEndpointSchemaDeclarationReferencer,
            endpointErrorUnionGenerator: this.endpointErrorUnionGenerator,
            requestWrapperDeclarationReferencer: this.requestWrapperDeclarationReferencer,
            requestWrapperGenerator: this.requestWrapperGenerator,
            sdkInlinedRequestBodySchemaDeclarationReferencer: this.sdkInlinedRequestBodySchemaDeclarationReferencer,
            sdkInlinedRequestBodySchemaGenerator: this.sdkInlinedRequestBodySchemaGenerator,
            websocketTypeSchemaGenerator: this.websocketTypeSchemaGenerator,
            websocketTypeSchemaDeclarationReferencer: this.websocketTypeSchemaDeclarationReferencer,
            websocketSocketDeclarationReferencer: this.websocketSocketDeclarationReferencer,
            websocketGenerator: this.websocketGenerator,
            typeGenerator: this.typeGenerator,
            sdkErrorGenerator: this.sdkErrorGenerator,
            errorResolver: this.errorResolver,
            packageResolver: this.packageResolver,
            sdkEndpointTypeSchemasGenerator: this.sdkEndpointTypeSchemasGenerator,
            typeSchemaGenerator: this.typeSchemaGenerator,
            sdkErrorSchemaGenerator: this.sdkErrorSchemaGenerator,
            environmentsGenerator: this.environmentsGenerator,
            environmentsDeclarationReferencer: this.environmentsDeclarationReferencer,
            baseClientTypeDeclarationReferencer: this.baseClientTypeDeclarationReferencer,
            sdkClientClassDeclarationReferencer: this.sdkClientClassDeclarationReferencer,
            sdkClientClassGenerator: this.sdkClientClassGenerator,
            baseClientContext: this.baseClientContext,
            genericAPISdkErrorDeclarationReferencer: this.genericAPISdkErrorDeclarationReferencer,
            genericAPISdkErrorGenerator: this.genericAPISdkErrorGenerator,
            timeoutSdkErrorDeclarationReferencer: this.timeoutSdkErrorDeclarationReferencer,
            timeoutSdkErrorGenerator: this.timeoutSdkErrorGenerator,
            nonStatusCodeErrorHandlerDeclarationReferencer: this.nonStatusCodeErrorHandlerDeclarationReferencer,
            nonStatusCodeErrorHandlerGenerator: this.nonStatusCodeErrorHandlerGenerator,
            treatUnknownAsAny: this.config.treatUnknownAsAny,
            includeSerdeLayer: this.config.includeSerdeLayer,
            retainOriginalCasing: this.config.retainOriginalCasing,
            inlineFileProperties: this.config.inlineFileProperties,
            inlinePathParameters: this.config.inlinePathParameters,
            enableInlineTypes: this.config.enableInlineTypes,
            generateOAuthClients: this.generateOAuthClients,
            omitUndefined: this.config.omitUndefined,
            useBigInt: this.config.useBigInt,
            neverThrowErrors: this.config.neverThrowErrors,
            allowExtraFields: this.config.allowExtraFields,
            relativePackagePath: this.relativePackagePath,
            relativeTestPath: this.relativeTestPath,
            formDataSupport: this.config.formDataSupport,
            useDefaultRequestParameterValues: this.config.useDefaultRequestParameterValues,
            generateReadWriteOnlyTypes: this.config.generateReadWriteOnlyTypes,
            flattenRequestParameters: this.config.flattenRequestParameters,
            parameterNaming: this.config.parameterNaming
        });
    }

    private getRelativePackagePath(): string {
        if (!this.config.packagePath) {
            return this.defaultSrcDirectory;
        }

        let packagePath = this.config.packagePath;

        if (packagePath.startsWith("/")) {
            packagePath = packagePath.slice(1);
        }

        if (packagePath.endsWith("/")) {
            packagePath = packagePath.slice(0, -1);
        }

        return packagePath;
    }

    private getRelativeTestPath(): string {
        const packagePath = this.getRelativePackagePath();

        if (packagePath === this.defaultSrcDirectory) {
            return this.defaultTestDirectory;
        }

        return packagePath + "/" + this.defaultTestDirectory;
    }

    private getSubpackageExportPaths(): Array<{ key: string; relPath: string }> {
        const paths: Array<{ key: string; relPath: string }> = [];

        for (const packageId of this.getAllPackageIds()) {
            if (packageId.isRoot) {
                continue;
            }

            const package_ = this.packageResolver.resolvePackage(packageId);

            const hasClient =
                package_.hasEndpointsInTree || (this.shouldGenerateWebsocketClients && package_.websocket != null);

            if (!hasClient && package_.subpackages.length === 0) {
                continue;
            }

            const segments = package_.fernFilepath.packagePath.map((name) => name.camelCase.safeName);
            const subpackage = package_ as Subpackage;
            if (subpackage.name != null) {
                const packageName = subpackage.name.camelCase.safeName;
                if (segments.length === 0 || segments[segments.length - 1] !== packageName) {
                    segments.push(packageName);
                }
            }
            const fernPackageKey = segments.join("/");

            const clientFilepath = this.sdkClientClassDeclarationReferencer.getExportedFilepath(packageId);
            const fullPath = this.exportsManager.convertExportedFilePathToFilePath(clientFilepath);
            const relativePath = fullPath
                .replace(/^\//, "")
                .replace(/^src\//, "")
                .replace(/\/client\/Client\.ts$/, "");

            paths.push({ key: fernPackageKey, relPath: relativePath });
        }

        return paths;
    }

    private generateSubpackageExports() {
        this.context.logger.debug("Generating subpackage exports...");
        for (const packageId of this.getAllPackageIds()) {
            if (packageId.isRoot) {
                continue;
            }

            const package_ = this.packageResolver.resolvePackage(packageId);

            const hasClient =
                package_.hasEndpointsInTree || (this.shouldGenerateWebsocketClients && package_.websocket != null);

            const clientFilepath = this.sdkClientClassDeclarationReferencer.getExportedFilepath(packageId);
            const clientClassName = this.sdkClientClassDeclarationReferencer.getExportedName(packageId);
            const exportsFilepath: ExportedFilePath = {
                directories: clientFilepath.directories.slice(0, -1), // Remove the "client" directory
                file: {
                    nameOnDisk: "exports.ts"
                }
            };

            this.withSourceFile({
                filepath: exportsFilepath,
                run: ({ sourceFile }) => {
                    if (hasClient) {
                        sourceFile.addExportDeclaration({
                            moduleSpecifier: "./client/Client.js",
                            namedExports: [clientClassName]
                        });

                        sourceFile.addExportDeclaration({
                            moduleSpecifier: "./client/index.js"
                        });
                    } else {
                        sourceFile.addExportDeclaration({
                            moduleSpecifier: "./index.js"
                        });
                    }

                    if (package_.subpackages.length > 0) {
                        sourceFile.addExportDeclaration({
                            moduleSpecifier: "./resources/index.js"
                        });
                    }
                }
            });
        }
    }
}

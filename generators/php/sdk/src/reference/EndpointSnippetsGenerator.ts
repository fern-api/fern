import { DynamicSnippetsGenerator } from "@fern-api/php-dynamic-snippets";

import { dynamic, ExampleEndpointCall, HttpEndpoint } from "@fern-fern/ir-sdk/api";

import { SdkGeneratorContext } from "../SdkGeneratorContext";
import { convertDynamicEndpointSnippetRequest } from "../utils/convertEndpointSnippetRequest";
import { convertIr } from "../utils/convertIr";

export interface EndpointSnippets {
    autogenerated: SingleEndpointSnippet[];
    userSpecified: SingleEndpointSnippet[];
}

export interface SingleEndpointSnippet {
    exampleIdentifier: string | undefined;
    endpointCall: string;
}

export class EndpointSnippetsGenerator {
    public static CLIENT_VARIABLE_NAME = "$client";

    private readonly context: SdkGeneratorContext;
    private readonly snippetsCache: Map<string, EndpointSnippets> = new Map();

    constructor({ context }: { context: SdkGeneratorContext }) {
        this.context = context;
    }

    public async populateSnippetsCache(): Promise<void> {
        const endpointSnippetsById = new Map<string, EndpointSnippets>();
        const dynamicIr = this.context.ir.dynamic;

        if (!dynamicIr) {
            this.context.logger.warn("Cannot populate snippets cache without dynamic IR");
            return;
        }

        const convertedIr = convertIr(dynamicIr);
        const dynamicSnippetsGenerator = new DynamicSnippetsGenerator({
            ir: convertedIr,
            config: this.context.config
        });

        for (const [endpointId, dynamicEndpoint] of Object.entries(dynamicIr.endpoints)) {
            const irEndpoint = this.getIrEndpointById(endpointId);
            if (!irEndpoint) {
                this.context.logger.debug(`Could not find IR endpoint for ${endpointId}`);
                continue;
            }

            this.context.logger.debug(
                `Processing endpoint ${endpointId} with ${dynamicEndpoint.examples?.length || 0} examples`
            );

            const allExamples = dynamicEndpoint.examples || [];

            if (allExamples.length === 0) {
                continue;
            }

            const snippets = await Promise.all(
                allExamples.map(async (example) => {
                    try {
                        const snippet = await this.generateSingleEndpointSnippetFromDynamic({
                            endpoint: irEndpoint,
                            example,
                            dynamicSnippetsGenerator
                        });
                        return { snippet, isUserSpecified: false };
                    } catch (error) {
                        return { snippet: null, isUserSpecified: false };
                    }
                })
            );

            const autogenerated = snippets
                .filter(({ snippet, isUserSpecified }) => snippet != null && !isUserSpecified)
                .map(({ snippet }) => snippet as SingleEndpointSnippet);

            const userSpecified = snippets
                .filter(({ snippet, isUserSpecified }) => snippet != null && isUserSpecified)
                .map(({ snippet }) => snippet as SingleEndpointSnippet);

            if (autogenerated.length > 0 || userSpecified.length > 0) {
                this.context.logger.debug(
                    `Generated ${autogenerated.length} autogenerated and ${userSpecified.length} user-specified snippets for endpoint ${endpointId}`
                );
                endpointSnippetsById.set(endpointId, { autogenerated, userSpecified });
            } else {
                this.context.logger.debug(`No snippets generated for endpoint ${endpointId}`);
            }
        }

        endpointSnippetsById.forEach((value, key) => {
            this.snippetsCache.set(key, value);
        });
    }

    public getSnippetsForEndpoint(endpointId: string): EndpointSnippets | undefined {
        return this.snippetsCache.get(endpointId);
    }

    public getSingleEndpointSnippet({
        endpoint,
        example
    }: {
        endpoint: HttpEndpoint;
        example: ExampleEndpointCall;
    }): SingleEndpointSnippet | undefined {
        const snippets = this.getSnippetsForEndpoint(endpoint.id);

        if (snippets) {
            const exampleId = example.id;
            const snippet =
                snippets.userSpecified.find((s) => s.exampleIdentifier === exampleId) ??
                snippets.autogenerated.find((s) => s.exampleIdentifier === exampleId);
            if (snippet) {
                return snippet;
            }

            const exampleName = example.name?.originalName;
            const nameMatchedSnippet =
                snippets.userSpecified.find((s) => s.exampleIdentifier === exampleName) ??
                snippets.autogenerated.find((s) => s.exampleIdentifier === exampleName);
            if (nameMatchedSnippet) {
                return nameMatchedSnippet;
            }

            const fallbackSnippet = snippets.userSpecified[0] ?? snippets.autogenerated[0];
            if (fallbackSnippet) {
                return fallbackSnippet;
            }
        }
        return undefined;
    }

    private async generateSingleEndpointSnippetFromDynamic({
        endpoint,
        example,
        dynamicSnippetsGenerator
    }: {
        endpoint: HttpEndpoint;
        example: dynamic.EndpointSnippetRequest;
        dynamicSnippetsGenerator: DynamicSnippetsGenerator;
    }): Promise<SingleEndpointSnippet | null> {
        try {
            const snippetRequest = convertDynamicEndpointSnippetRequest(example);
            const generatedSnippet = await dynamicSnippetsGenerator.generate(snippetRequest);

            if (!generatedSnippet.snippet) {
                this.context.logger.warn(`Empty snippet returned for endpoint ${endpoint.id}`);
                return null;
            }

            return {
                exampleIdentifier: (example as dynamic.EndpointExample).id,
                endpointCall: this.extractMethodCall(generatedSnippet.snippet)
            };
        } catch (error) {
            return null;
        }
    }

    private extractMethodCall(fullSnippet: string): string {
        const lines = fullSnippet.split("\n");
        let methodCallLines: string[] = [];
        let inMethodCall = false;
        let parenCount = 0;

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (trimmedLine.startsWith("$client->") && !inMethodCall) {
                inMethodCall = true;
                methodCallLines = [];
            }

            if (inMethodCall) {
                methodCallLines.push(line);

                for (const char of line) {
                    if (char === "(") {
                        parenCount++;
                    }
                    if (char === ")") {
                        parenCount--;
                    }
                }

                if (line.includes(";") && parenCount === 0) {
                    break;
                }
            }
        }

        if (methodCallLines.length === 0) {
            this.context.logger.debug("Could not extract method call from snippet, using full snippet");
            return fullSnippet;
        }

        let result = methodCallLines.join("\n");

        const nonEmptyLines = result.split("\n").filter((line) => line.trim().length > 0);
        if (nonEmptyLines.length > 0) {
            const minIndent = Math.min(...nonEmptyLines.map((line) => line.length - line.trimStart().length));
            result = result
                .split("\n")
                .map((line) => (line.length > minIndent ? line.substring(minIndent) : line))
                .join("\n");
        }

        return result.trim();
    }

    private getIrEndpointById(endpointId: string): HttpEndpoint | undefined {
        for (const service of Object.values(this.context.ir.services)) {
            const endpoint = service.endpoints.find((ep) => ep.id === endpointId);
            if (endpoint) {
                return endpoint;
            }
        }
        return undefined;
    }
}

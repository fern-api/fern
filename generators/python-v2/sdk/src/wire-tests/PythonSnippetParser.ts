import { python } from "@fern-api/python-ast";

/**
 * Utility class for parsing Python code snippets generated by the dynamic snippets generator.
 * This extracts key components like imports, client construction, and method calls for wire tests.
 */
export class PythonSnippetParser {
    /**
     * Parse import statements from a Python snippet
     */
    public static parseImportsFromSnippet(snippet: string): python.Reference[] {
        const imports: python.Reference[] = [];
        const lines = snippet.split("\n");

        for (const line of lines) {
            const trimmedLine = line.trim();

            // Handle "import module" statements
            const importMatch = trimmedLine.match(/^import\s+([\w.]+)(?:\s+as\s+(\w+))?$/);
            if (importMatch && importMatch[1]) {
                const moduleName = importMatch[1];
                const alias = importMatch[2];
                imports.push(
                    python.reference({
                        name: alias || moduleName,
                        modulePath: moduleName.split(".")
                    })
                );
                continue;
            }

            // Handle "from module import name" statements
            const fromImportMatch = trimmedLine.match(/^from\s+([\w.]+)\s+import\s+([\w,\s]+)$/);
            if (fromImportMatch && fromImportMatch[1] && fromImportMatch[2]) {
                const moduleName = fromImportMatch[1];
                const importNames = fromImportMatch[2].split(",").map((name) => name.trim());

                for (const importName of importNames) {
                    // Handle "name as alias" pattern
                    const aliasMatch = importName.match(/^(\w+)(?:\s+as\s+(\w+))?$/);
                    if (aliasMatch && aliasMatch[1]) {
                        const name = aliasMatch[1];
                        const alias = aliasMatch[2];
                        imports.push(
                            python.reference({
                                name: alias || name,
                                modulePath: [...moduleName.split("."), name]
                            })
                        );
                    }
                }
            }
        }

        return imports;
    }

    /**
     * Extract client constructor code from a Python snippet
     */
    public static parseClientConstructor(snippet: string): string {
        const lines = snippet.split("\n");

        // Find the line that creates the client (typically "client = ...")
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i]?.trim() ?? "";
            if (line.startsWith("client = ")) {
                // Find the end of the client constructor (handle multi-line)
                let constructor = line;
                let j = i + 1;

                // Check if this line ends with an open parenthesis, indicating multi-line
                let openParens = (line.match(/\(/g) || []).length;
                let closeParens = (line.match(/\)/g) || []).length;

                while (j < lines.length && openParens > closeParens) {
                    const nextLine = lines[j]?.trim() ?? "";
                    constructor += "\n" + nextLine;
                    openParens += (nextLine.match(/\(/g) || []).length;
                    closeParens += (nextLine.match(/\)/g) || []).length;
                    j++;
                }

                return constructor;
            }
        }

        return "";
    }

    /**
     * Extract client method call from a Python snippet
     */
    public static parseClientCallFromSnippet(snippet: string): string {
        const lines = snippet.split("\n");

        // Find lines that start with "client." or contain "client."
        let callStartIndex = -1;
        for (let i = 0; i < lines.length; i++) {
            const trimmedLine = lines[i]?.trim() ?? "";
            if (trimmedLine.startsWith("client.") || trimmedLine.includes(" = client.")) {
                callStartIndex = i;
                break;
            }
        }

        if (callStartIndex === -1) {
            return "";
        }

        // Track parentheses to find the end of the method call
        let clientCall = lines[callStartIndex] ?? "";
        let openParens = (clientCall.match(/\(/g) || []).length;
        let closeParens = (clientCall.match(/\)/g) || []).length;

        let j = callStartIndex + 1;
        while (j < lines.length && openParens > closeParens) {
            const nextLine = lines[j] ?? "";
            clientCall += "\n" + nextLine;
            openParens += (nextLine.match(/\(/g) || []).length;
            closeParens += (nextLine.match(/\)/g) || []).length;
            j++;
        }

        return clientCall;
    }

    /**
     * Extract request body instantiation from a Python snippet
     */
    public static parseRequestBodyInstantiation(snippet: string): string {
        const lines = snippet.split("\n");

        // Look for request/body object creation patterns
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i]?.trim() ?? "";

            // Common patterns: "request = ...", "body = ...", "data = ..."
            if (line.match(/^(request|body|data|payload)\s*=/)) {
                let instantiation = line;
                let openBraces = (line.match(/\{/g) || []).length;
                let closeBraces = (line.match(/\}/g) || []).length;
                let openParens = (line.match(/\(/g) || []).length;
                let closeParens = (line.match(/\)/g) || []).length;

                let j = i + 1;
                // Continue reading lines until braces/parens are balanced
                while (j < lines.length && (openBraces > closeBraces || openParens > closeParens)) {
                    const nextLine = lines[j] ?? "";
                    instantiation += "\n" + nextLine;
                    openBraces += (nextLine.match(/\{/g) || []).length;
                    closeBraces += (nextLine.match(/\}/g) || []).length;
                    openParens += (nextLine.match(/\(/g) || []).length;
                    closeParens += (nextLine.match(/\)/g) || []).length;
                    j++;
                }

                return instantiation;
            }
        }

        return "";
    }

    /**
     * Extract the test function name from a Python snippet
     */
    public static parseTestFunctionNameFromSnippet(snippet: string): string {
        const lines = snippet.split("\n");

        // Find the line that starts with "def test_"
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith("def test_")) {
                const match = trimmedLine.match(/^def (test_.*?)(?:\s*\(|:)/);
                if (match && match[1]) {
                    return match[1];
                }
            }
        }

        return "";
    }

    /**
     * Clean up indentation and formatting of extracted code blocks
     */
    public static cleanCodeBlock(codeBlock: string): string {
        if (!codeBlock) return "";

        const lines = codeBlock.split("\n");

        // Find minimum indentation (excluding empty lines)
        let minIndent = Infinity;
        for (const line of lines) {
            if (line.trim() === "") continue;
            const leadingSpaces = line.match(/^(\s*)/)?.[1]?.length ?? 0;
            minIndent = Math.min(minIndent, leadingSpaces);
        }

        // Remove common indentation
        if (minIndent > 0 && minIndent !== Infinity) {
            return lines.map((line) => (line.trim() === "" ? "" : line.slice(minIndent))).join("\n");
        }

        return codeBlock;
    }

    /**
     * Extract variable assignments from snippet (e.g., "user_id = 123")
     */
    public static parseVariableAssignments(snippet: string): Record<string, string> {
        const assignments: Record<string, string> = {};
        const lines = snippet.split("\n");

        for (const line of lines) {
            const trimmedLine = line.trim();
            // Match simple assignments like "variable = value"
            const assignmentMatch = trimmedLine.match(/^(\w+)\s*=\s*(.+)$/);
            if (assignmentMatch && assignmentMatch[1] && assignmentMatch[2]) {
                const varName = assignmentMatch[1];
                const varValue = assignmentMatch[2];

                // Skip if it's a client assignment or complex expression
                if (varName !== "client" && !varValue.includes("client.") && !varValue.includes("(")) {
                    assignments[varName] = varValue;
                }
            }
        }

        return assignments;
    }
}

import { FernGeneratorExec } from "@fern-api/browser-compatible-base-generator";
import { FernIr } from "@fern-api/dynamic-ir-sdk";
import { RelativeFilePath } from "@fern-api/fs-utils";
import { WireMockMapping } from "@fern-api/mock-utils";
import { python } from "@fern-api/python-ast";
import { WriteablePythonFile } from "@fern-api/python-base";
import { DynamicSnippetsGenerator } from "@fern-api/python-dynamic-snippets";
import {
    dynamic,
    ExampleEndpointCall,
    HttpEndpoint,
    HttpService,
    IntermediateRepresentation
} from "@fern-fern/ir-sdk/api";
import { SdkGeneratorContext } from "../SdkGeneratorContext";
import { WireTestSetupGenerator } from "./WireTestSetupGenerator";

/**
 * Local interface for wire test examples.
 * Contains only the fields needed for wire test generation, avoiding coupling to dynamic.EndpointExample.
 */
interface WireTestExample {
    name?: string;
    pathParameters: Record<string, unknown>;
    queryParameters: Record<string, unknown>;
    headers: Record<string, unknown>;
    requestBody?: unknown;
}

/**
 * Generates WireMock-based integration tests for Python SDK.
 *
 * This is a skeleton implementation that sets up the infrastructure for wire tests
 * but does not implement the actual Python test code generation.
 */
export class WireTestGenerator {
    private readonly context: SdkGeneratorContext;
    private dynamicIr: dynamic.DynamicIntermediateRepresentation;
    private wireMockConfigContent: Record<string, WireMockMapping>;
    private snippetGenerator: DynamicSnippetsGenerator;
    private readonly packagePathPrefix: string;

    constructor(context: SdkGeneratorContext, ir: IntermediateRepresentation) {
        this.context = context;
        const dynamicIr = ir.dynamic;
        if (!dynamicIr) {
            throw new Error("Cannot generate wire tests without dynamic IR");
        }
        this.dynamicIr = dynamicIr;
        this.wireMockConfigContent = this.getWireMockConfigContent();
        // package_path is already normalized by the schema (leading/trailing slashes stripped)
        this.packagePathPrefix = context.customConfig.package_path ?? "";

        // TODO(tjdbdc): Really need a migration framework for dynamic IR
        this.snippetGenerator = new DynamicSnippetsGenerator({
            ir: this.dynamicIr,
            config: {
                organization: context.config.organization,
                workspaceName: context.config.workspaceName,
                customConfig: context.customConfig
            } as FernGeneratorExec.GeneratorConfig
        });
    }

    /**
     * Builds a path with the package path prefix if set.
     */
    private withPackagePrefix(relativePath: string): string {
        return this.packagePathPrefix ? `${this.packagePathPrefix}/${relativePath}` : relativePath;
    }

    // =============================================================================
    // PUBLIC API
    // =============================================================================

    public async generate(): Promise<void> {
        const endpointsByService = this.groupEndpointsByService();

        this.context.logger.debug(
            `Wire tests: ${endpointsByService.size} services, ${Object.keys(this.dynamicIr.endpoints).length} dynamic endpoints`
        );

        let totalEndpointsWithExamples = 0;

        for (const [serviceName, endpoints] of endpointsByService.entries()) {
            // Filter to endpoints that have static IR examples
            // We MUST use static IR examples to match WireMock mappings (which are generated from static IR)
            const endpointsWithExamples = endpoints.filter((endpoint) => {
                const staticExample = this.getStaticIrExample(endpoint);
                return staticExample !== undefined;
            });

            totalEndpointsWithExamples += endpointsWithExamples.length;

            if (endpointsWithExamples.length === 0) {
                continue;
            }

            const serviceTestFile = await this.generateServiceTestFile(serviceName, endpointsWithExamples);
            if (serviceTestFile) {
                this.context.project.addSourceFiles(serviceTestFile);
            }
        }

        this.context.logger.debug(`Wire tests: ${totalEndpointsWithExamples} endpoints with static IR examples`);

        // Generate docker-compose.test.yml and wiremock-mappings.json for WireMock
        new WireTestSetupGenerator(this.context, this.context.ir, this.packagePathPrefix).generate();
    }

    /**
     * Gets the first available example from the static IR for an endpoint.
     * Prefers user-specified examples over autogenerated ones.
     */
    private getStaticIrExample(endpoint: HttpEndpoint): ExampleEndpointCall | undefined {
        // First try user-specified examples
        for (const userExample of endpoint.userSpecifiedExamples) {
            if (userExample.example) {
                return userExample.example;
            }
        }
        // Fall back to autogenerated examples
        for (const autoExample of endpoint.autogeneratedExamples) {
            if (autoExample.example) {
                return autoExample.example;
            }
        }
        return undefined;
    }

    /**
     * Converts a static IR example to a wire test example format.
     */
    private convertStaticExampleToWireTest(
        endpoint: HttpEndpoint,
        staticExample: ExampleEndpointCall
    ): WireTestExample {
        // Extract path parameters
        const pathParameters: Record<string, unknown> = {};
        for (const param of [
            ...(staticExample.rootPathParameters ?? []),
            ...(staticExample.servicePathParameters ?? []),
            ...(staticExample.endpointPathParameters ?? [])
        ]) {
            pathParameters[param.name.originalName] = param.value.jsonExample;
        }

        // Extract query parameters
        const queryParameters: Record<string, unknown> = {};
        for (const param of staticExample.queryParameters ?? []) {
            queryParameters[param.name.wireValue] = param.value.jsonExample;
        }

        // Extract headers
        const headers: Record<string, unknown> = {};
        for (const header of [...(staticExample.serviceHeaders ?? []), ...(staticExample.endpointHeaders ?? [])]) {
            headers[header.name.wireValue] = header.value.jsonExample;
        }

        // Extract request body
        let requestBody: unknown = undefined;
        if (staticExample.request) {
            if ("jsonExample" in staticExample.request && staticExample.request.jsonExample !== undefined) {
                requestBody = staticExample.request.jsonExample;
            }
        }

        return {
            name: staticExample.name?.originalName,
            pathParameters,
            queryParameters,
            headers,
            requestBody
        };
    }

    // =============================================================================
    // FILE GENERATION
    // =============================================================================

    private async generateServiceTestFile(
        serviceName: string,
        endpoints: HttpEndpoint[]
    ): Promise<WriteablePythonFile | null> {
        const endpointTestCases: Array<{
            endpoint: HttpEndpoint;
            example: WireTestExample;
            service: HttpService;
            exampleIndex: number;
        }> = [];

        for (const endpoint of endpoints) {
            // Find the service that owns this endpoint
            const service = Object.values(this.context.ir.services).find((s) =>
                s.endpoints.some((e) => e.id === endpoint.id)
            );
            if (!service) {
                continue;
            }

            // Always use static IR examples to match WireMock mappings
            // WireMock mappings are generated from static IR examples, so we must use the same examples
            const staticExample = this.getStaticIrExample(endpoint);
            if (staticExample) {
                const wireTestExample = this.convertStaticExampleToWireTest(endpoint, staticExample);
                endpointTestCases.push({ endpoint, example: wireTestExample, service, exampleIndex: 0 });
            }
        }

        if (endpointTestCases.length === 0) {
            return null;
        }

        this.context.logger.info(
            `Generating test file for service ${serviceName} with ${endpointTestCases.length} test cases`
        );

        const pythonFile = this.buildTestFile(serviceName, endpointTestCases);

        return new WriteablePythonFile({
            filename: `test_${serviceName}`,
            directory: RelativeFilePath.of(this.withPackagePrefix("tests/wire")),
            contents: pythonFile
        });
    }

    // =============================================================================
    // FILE BUILDING
    // =============================================================================

    private buildTestFile(
        serviceName: string,
        testCases: Array<{
            endpoint: HttpEndpoint;
            example: WireTestExample;
            service: HttpService;
            exampleIndex: number;
        }>
    ): python.PythonFile {
        const statements: python.AstNode[] = [];

        // Add raw imports that the AST doesn't support (simple "import X" statements)
        statements.push(python.codeBlock("import pytest"));
        statements.push(python.codeBlock("from datetime import datetime, date"));
        statements.push(python.codeBlock("from uuid import UUID"));

        // Add an import registration statement (for "from X import Y" style imports)
        statements.push(this.createImportRegistration());

        // Add test functions for each endpoint
        for (const { endpoint, example, service, exampleIndex } of testCases) {
            const testFunction = this.generateEndpointTestFunction(
                serviceName,
                endpoint,
                example,
                service,
                exampleIndex
            );
            if (testFunction) {
                statements.push(testFunction);
            }
        }

        const pathSegments = this.withPackagePrefix(`tests/wire/test_${serviceName}`).split("/");
        return python.file({
            path: pathSegments,
            statements
        });
    }

    /**
     * Creates a special node that registers imports without rendering anything.
     * This is a workaround for using codeBlock while still getting automatic "from X import Y" imports.
     */
    private createImportRegistration(): python.AstNode {
        // Create an empty code block
        const node = python.codeBlock("");

        // Import get_client and verify_request_count from .conftest (relative import within tests/wire package)
        node.addReference(python.reference({ name: "get_client", modulePath: [".conftest"] }));
        node.addReference(python.reference({ name: "verify_request_count", modulePath: [".conftest"] }));

        return node;
    }

    // =============================================================================
    // TEST FUNCTION GENERATION
    // =============================================================================

    private generateEndpointTestFunction(
        serviceName: string,
        endpoint: HttpEndpoint,
        example: WireTestExample,
        service: HttpService,
        exampleIndex: number
    ): python.Method | null {
        try {
            const testName = this.getTestFunctionName(serviceName, endpoint);
            const basePath = this.buildBasePath(endpoint);
            const queryParamsCode = this.buildQueryParamsCode(endpoint);

            // Build deterministic test ID based on fully qualified path
            const testId = this.buildDeterministicTestId(service, endpoint, exampleIndex);

            const statements: python.AstNode[] = [];

            // Use deterministic test ID for concurrency safety
            statements.push(python.codeBlock(`test_id = "${testId}"`));

            // Create client using the get_client helper from conftest.py
            // This ensures all required auth parameters are supplied with fake values
            statements.push(python.codeBlock(`client = get_client(test_id)`));

            // Generate the API call AST directly
            const apiCallAst = this.generateApiCallAst(endpoint, example);
            statements.push(apiCallAst);

            // Verify request count using test ID for filtering
            statements.push(
                python.codeBlock(
                    `verify_request_count(test_id, "${endpoint.method}", "${basePath}", ${queryParamsCode}, 1)`
                )
            );

            const method = python.method({
                name: testName,
                return_: python.Type.none(),
                docstring: `Test ${endpoint.name.originalName} endpoint with WireMock`
            });

            statements.forEach((stmt) => method.addStatement(stmt));
            return method;
        } catch (error) {
            this.context.logger.warn(`Failed to generate test function for endpoint ${endpoint.id}: ${error}`);
            return null;
        }
    }

    /**
     * Builds a deterministic test ID based on the fully qualified service path.
     * Format: service.sub_service.endpoint_name.example_index
     * This ensures test IDs are unique per test and deterministic across regenerations.
     */
    private buildDeterministicTestId(service: HttpService, endpoint: HttpEndpoint, exampleIndex: number): string {
        const servicePathParts = service.name.fernFilepath.allParts.map((part) => part.snakeCase.safeName);
        const endpointName = endpoint.name.snakeCase.safeName;

        const segments: string[] = [];
        if (servicePathParts.length > 0) {
            segments.push(servicePathParts.join("."));
        }
        segments.push(endpointName);
        segments.push(String(exampleIndex));

        // Example: "endpoints.primitive.get_and_return_string.0"
        return segments.join(".");
    }

    // =============================================================================
    // API CALL GENERATION
    // =============================================================================

    /**
     * Builds the path template for an endpoint in the format expected by the snippet generator.
     * Example: "/users/{userId}/posts/{postId}"
     */
    private buildPathTemplate(endpoint: HttpEndpoint): string {
        let path = endpoint.fullPath.head;
        for (const part of endpoint.fullPath.parts) {
            path += `{${part.pathParameter}}${part.tail}`;
        }
        // Ensure the path starts with a leading slash to match dynamic IR format
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        return path;
    }

    private generateApiCallAst(endpoint: HttpEndpoint, example: WireTestExample): python.AstNode {
        try {
            // Build the snippet request
            const snippetRequest: FernIr.dynamic.EndpointSnippetRequest = {
                endpoint: {
                    method: endpoint.method,
                    path: this.buildPathTemplate(endpoint)
                },
                baseURL: "http://localhost:8080",
                pathParameters: example.pathParameters,
                queryParameters: example.queryParameters,
                headers: example.headers,
                requestBody: example.requestBody
            };

            // Generate just the method call AST using DynamicSnippetsGenerator
            return this.snippetGenerator.generateMethodCallSnippetAst(snippetRequest);
        } catch (error) {
            // Fallback: log error and generate a placeholder
            this.context.logger.error(
                `Failed to generate API call for endpoint ${endpoint.name.originalName}: ${error}`
            );
            throw error;
        }
    }

    /**
     * Escapes a string for use in Python code.
     * Handles newlines, tabs, carriage returns, backslashes, and quotes.
     */
    private escapeStringForPython(value: string): string {
        return value
            .replace(/\\/g, "\\\\") // Escape backslashes first
            .replace(/\n/g, "\\n") // Escape newlines
            .replace(/\r/g, "\\r") // Escape carriage returns
            .replace(/\t/g, "\\t") // Escape tabs
            .replace(/"/g, '\\"'); // Escape double quotes
    }

    // =============================================================================
    // PATH AND QUERY PARAMETER HELPERS
    // =============================================================================

    private buildQueryParamsCode(endpoint: HttpEndpoint): string {
        const dynamicEndpoint = this.dynamicIr.endpoints[endpoint.id];
        if (!dynamicEndpoint?.examples?.[0]?.queryParameters) {
            return "None";
        }

        const queryParams = dynamicEndpoint.examples[0].queryParameters;
        const entries: string[] = [];

        for (const [key, value] of Object.entries(queryParams)) {
            if (value != null) {
                entries.push(`"${this.escapeStringForPython(key)}": "${this.escapeStringForPython(String(value))}"`);
            }
        }

        if (entries.length === 0) {
            return "None";
        }

        return `{${entries.join(", ")}}`;
    }

    // =============================================================================
    // UTILITY METHODS
    // =============================================================================

    private getTestFunctionName(serviceName: string, endpoint: HttpEndpoint): string {
        const endpointName = endpoint.name.snakeCase.safeName;
        return `test_${serviceName}_${endpointName}`;
    }

    private getClientModulePath(): string[] {
        // The client is imported from the root package module
        // e.g., "from seed import SeedExhaustive" -> modulePath is ["seed"]
        return [this.context.config.organization];
    }

    private getClientClassName(): string {
        // The client class name follows the pattern: OrganizationWorkspace
        // For seed_exhaustive, it would be SeedExhaustive
        const orgName = this.context.config.organization;
        const workspaceName = this.context.config.workspaceName;

        // Convert to PascalCase
        const toPascalCase = (str: string) => {
            return str
                .split(/[-_]/)
                .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
                .join("");
        };

        return toPascalCase(orgName) + toPascalCase(workspaceName);
    }

    // =============================================================================
    // =============================================================================

    private wiremockMappingKey({
        requestMethod,
        requestUrlPathTemplate
    }: {
        requestMethod: string;
        requestUrlPathTemplate: string;
    }): string {
        return `${requestMethod} - ${requestUrlPathTemplate}`;
    }

    private getWireMockConfigContent(): Record<string, WireMockMapping> {
        const out: Record<string, WireMockMapping> = {};
        const wiremockStubMapping = WireTestSetupGenerator.getWiremockConfigContent(this.context.ir);
        for (const mapping of wiremockStubMapping.mappings) {
            const key = this.wiremockMappingKey({
                requestMethod: mapping.request.method,
                requestUrlPathTemplate: mapping.request.urlPathTemplate
            });
            out[key] = mapping;
        }
        return out;
    }

    // =============================================================================
    // =============================================================================

    private buildBasePath(endpoint: HttpEndpoint): string {
        let basePath = endpoint.fullPath.head;
        for (const part of endpoint.fullPath.parts || []) {
            basePath += `{${part.pathParameter}}${part.tail}`;
        }
        if (!basePath.startsWith("/")) {
            basePath = "/" + basePath;
        }

        // Substitute path parameters with actual values from WireMock mapping
        const mappingKey = this.wiremockMappingKey({
            requestMethod: endpoint.method,
            requestUrlPathTemplate: basePath
        });

        const wiremockMapping = this.wireMockConfigContent[mappingKey];
        if (wiremockMapping && wiremockMapping.request.pathParameters) {
            Object.entries(wiremockMapping.request.pathParameters).forEach(([paramName, paramValue]) => {
                const pathParam = paramValue as { equalTo: string };
                basePath = basePath.replace(`{${paramName}}`, pathParam.equalTo);
            });
        }

        return basePath;
    }

    // =============================================================================
    // =============================================================================

    private groupEndpointsByService(): Map<string, HttpEndpoint[]> {
        const endpointsByService = new Map<string, HttpEndpoint[]>();

        for (const service of Object.values(this.context.ir.services)) {
            const serviceName = this.getFormattedServiceName(service);
            const endpoints = service.endpoints;

            if (endpoints.length > 0) {
                endpointsByService.set(serviceName, endpoints);
            }
        }

        return endpointsByService;
    }

    private getFormattedServiceName(service: HttpService): string {
        return service.name.fernFilepath.allParts.map((part) => part.camelCase.unsafeName).join("_");
    }
}

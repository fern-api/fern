import { RustFile } from "@fern-api/rust-base";
import { AliasGenerator } from "./alias";
import { EnumGenerator } from "./enum";
import { InlinedRequestBodyGenerator } from "./inlined-request-body";
import { ModelGeneratorContext } from "./ModelGeneratorContext";
import { StructGenerator } from "./object";
import { QueryParameterRequestGenerator } from "./query-request";
import { UndiscriminatedUnionGenerator, UnionGenerator } from "./union";

export function generateModels({ context }: { context: ModelGeneratorContext }): RustFile[] {
    const files: RustFile[] = [];

    for (const [_typeId, typeDeclaration] of Object.entries(context.ir.types)) {
        const file = typeDeclaration.shape._visit<RustFile | undefined>({
            alias: (aliasTypeDeclaration) => {
                return new AliasGenerator(typeDeclaration, aliasTypeDeclaration, context).generate();
            },
            enum: (enumTypeDeclaration) => {
                return new EnumGenerator(typeDeclaration, enumTypeDeclaration, context).generate();
            },
            object: (objectTypeDeclaration) => {
                return new StructGenerator(typeDeclaration, objectTypeDeclaration, context).generate();
            },
            union: (unionTypeDeclaration) => {
                return new UnionGenerator(typeDeclaration, unionTypeDeclaration, context).generate();
            },
            undiscriminatedUnion: (undiscriminatedUnionTypeDeclaration) => {
                return new UndiscriminatedUnionGenerator(
                    typeDeclaration,
                    undiscriminatedUnionTypeDeclaration,
                    context
                ).generate();
            },
            _other: () => {
                // Unknown type shape, skip for now
                return undefined;
            }
        });

        if (file != null) {
            files.push(file);
        }
    }

    // Generate inlined request body types from services
    const inlinedRequestBodyGenerator = new InlinedRequestBodyGenerator(context);
    files.push(...inlinedRequestBodyGenerator.generateFiles());

    // Generate query parameter request structs for query-only endpoints
    const queryRequestGenerator = new QueryParameterRequestGenerator(context);
    files.push(...queryRequestGenerator.generateFiles());

    // Deduplicate files by filename to prevent file collisions
    // This is a safety net - ideally generators shouldn't create duplicates
    const seenFilenames = new Map<string, string>();
    const deduplicatedFiles: RustFile[] = [];

    for (const file of files) {
        const fullPath = `${file.directory}/${file.filename}`;

        if (seenFilenames.has(fullPath)) {
            const firstSource = seenFilenames.get(fullPath);
            context.logger.error(
                `DUPLICATE FILE DETECTED: ${fullPath}\n` +
                `  First generated by: ${firstSource}\n` +
                `  Duplicate attempt: (current iteration)\n` +
                `  This indicates a bug in the generator - the same file should not be generated twice!`
            );
            continue;
        }

        // Track which generator created this file for debugging
        const source = fullPath.includes("inline_") ? "InlinedRequestBodyGenerator" :
                      fullPath.includes("query") ? "QueryParameterRequestGenerator" :
                      "IRTypeGenerator";
        seenFilenames.set(fullPath, source);
        deduplicatedFiles.push(file);
    }

    if (seenFilenames.size < files.length) {
        const duplicateCount = files.length - seenFilenames.size;
        context.logger.warn(
            `Removed ${duplicateCount} duplicate file(s) to prevent corruption. ` +
            `This is a generator bug that should be fixed!`
        );
    }

    return deduplicatedFiles;
}

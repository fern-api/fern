import { AbstractProject } from "@fern-api/base-generator";
import { join, RelativeFilePath } from "@fern-api/fs-utils";
import { BaseRustCustomConfigSchema } from "@fern-api/rust-codegen";
import { mkdir } from "fs/promises";
import { AbstractRustGeneratorContext } from "../context/AbstractRustGeneratorContext";
import { RustFile } from "./RustFile";
import { RustFilenameRegistry } from "./RustFilenameRegistry";

const SRC_DIRECTORY_NAME = "src";

export interface RustProjectConfig {
    context: AbstractRustGeneratorContext<BaseRustCustomConfigSchema>;
    crateName: string;
    crateVersion: string;
    clientClassName: string;
}

export class RustProject extends AbstractProject<AbstractRustGeneratorContext<BaseRustCustomConfigSchema>> {
    private crateName: string;
    private crateVersion: string;
    private clientClassName: string;
    private sourceFiles: RustFile[] = [];
    public readonly filenameRegistry: RustFilenameRegistry;

    public constructor({ context, crateName, crateVersion, clientClassName }: RustProjectConfig) {
        super(context);
        this.crateName = crateName;
        this.crateVersion = crateVersion;
        this.clientClassName = clientClassName;
        this.filenameRegistry = RustFilenameRegistry.create();
    }

    public get sourceFileDirectory(): RelativeFilePath {
        return RelativeFilePath.of(SRC_DIRECTORY_NAME);
    }

    public addSourceFiles(...files: RustFile[]): void {
        this.sourceFiles.push(...files);
    }

    public async persist(): Promise<void> {
        // Create source directory
        const absolutePathToSrcDirectory = join(this.absolutePathToOutputDirectory, this.sourceFileDirectory);
        this.context.logger.debug(`mkdir ${absolutePathToSrcDirectory}`);
        await mkdir(absolutePathToSrcDirectory, { recursive: true });

        // Write all template files (both source and project-level)
        await this.persistStaticSourceFiles();

        // Write all dynamic source files
        await Promise.all(this.sourceFiles.map((file) => file.write(this.absolutePathToOutputDirectory)));

        // Write raw files
        await this.writeRawFiles();
    }

    private async persistStaticSourceFiles(): Promise<void> {
        const { context, absolutePathToOutputDirectory } = this;
        await Promise.all(
            context.getCoreAsIsFiles().map(async (def) => {
                let fileContents = await def.loadContents();

                // Replace template variables
                fileContents = this.replaceTemplateVariables(fileContents);

                const rustFile = new RustFile({
                    filename: def.filename,
                    directory: def.directory,
                    fileContents
                });
                await rustFile.write(absolutePathToOutputDirectory);
            })
        );
    }

    private replaceTemplateVariables(content: string): string {
        content = content.replace(/\{\{CLIENT_NAME\}\}/g, this.clientClassName);

        content = content.replace(/\{\{PACKAGE_NAME\}\}/g, this.crateName);
        content = content.replace(/\{\{PACKAGE_VERSION\}\}/g, this.crateVersion);

        content = content.replace(
            /\{\{PACKAGE_DESCRIPTION\}\}/g,
            this.context.customConfig.packageDescription || `Rust SDK for ${this.crateName} generated by Fern`
        );
        content = content.replace(/\{\{PACKAGE_LICENSE\}\}/g, this.context.customConfig.packageLicense || "MIT");
        content = content.replace(
            /\{\{PACKAGE_REPOSITORY\}\}/g,
            this.context.customConfig.packageRepository || "https://github.com/fern-api/fern"
        );
        content = content.replace(
            /\{\{PACKAGE_DOCUMENTATION\}\}/g,
            this.context.customConfig.packageDocumentation || `https://docs.rs/${this.crateName}`
        );

        const tomlSections = this.context.dependencyManager.toTomlSections();
        content = content.replace(/\{\{EXTRA_DEPENDENCIES\}\}/g, tomlSections.dependencies);
        content = content.replace(/\{\{EXTRA_DEV_DEPENDENCIES\}\}/g, tomlSections.devDependencies);

        if (tomlSections.features) {
            content = content.replace(/\{\{FEATURES\}\}/g, `\n[features]\n${tomlSections.features}`);
        } else {
            content = content.replace(/\{\{FEATURES\}\}/g, "");
        }

        content = content.replace(/\{\{PUBLISH_WORKFLOW\}\}/g, this.generatePublishWorkflow());

        // Conditionally include chrono exports in prelude
        if (this.context.usesDateTime()) {
            content = content.replace(
                /\{\{CHRONO_EXPORTS\}\}/g,
                "\npub use chrono::{DateTime, NaiveDate, NaiveDateTime, Utc};"
            );
        } else {
            content = content.replace(/\{\{CHRONO_EXPORTS\}\}/g, "");
        }

        // Conditionally include uuid exports in prelude
        if (this.context.usesUuid()) {
            content = content.replace(/\{\{UUID_EXPORTS\}\}/g, "\npub use uuid::Uuid;");
        } else {
            content = content.replace(/\{\{UUID_EXPORTS\}\}/g, "");
        }

        return content;
    }

    private generateExtraDependencies(): string {
        const extraDeps = this.context.customConfig.extraDependencies || {};
        if (Object.keys(extraDeps).length === 0) {
            return "";
        }

        let result = "";
        for (const [name, config] of Object.entries(extraDeps)) {
            if (typeof config === "string") {
                result += `${name} = "${config}"\n`;
            } else {
                result += `${name} = ${this.objectToToml(config)}\n`;
            }
        }
        return result;
    }

    private generateExtraDevDependencies(): string {
        const extraDevDeps = this.context.customConfig.extraDevDependencies || {};
        if (Object.keys(extraDevDeps).length === 0) {
            return "";
        }

        let result = "";
        for (const [name, version] of Object.entries(extraDevDeps)) {
            result += `${name} = "${version}"\n`;
        }
        return result;
    }

    private generatePublishWorkflow(): string {
        // Only include publish workflow when publishConfig is set
        if (this.context.publishConfig == null) {
            return "";
        }

        return `
  publish:
    needs: [check, compile, test]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Publish
        env:
          CARGO_REGISTRY_TOKEN: \${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: cargo publish`;
    }

    private objectToToml(obj: unknown): string {
        if (typeof obj === "string") {
            return `"${obj}"`;
        }
        if (Array.isArray(obj)) {
            return `[${obj.map((item) => `"${item}"`).join(", ")}]`;
        }
        if (typeof obj === "object" && obj !== null) {
            const pairs = Object.entries(obj).map(([key, value]) => {
                if (typeof value === "string") {
                    return `${key} = "${value}"`;
                } else if (Array.isArray(value)) {
                    return `${key} = [${value.map((item) => `"${item}"`).join(", ")}]`;
                } else {
                    return `${key} = ${this.objectToToml(value)}`;
                }
            });
            return `{ ${pairs.join(", ")} }`;
        }
        return String(obj);
    }
}

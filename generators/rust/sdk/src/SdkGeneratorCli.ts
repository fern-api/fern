import { GeneratorNotificationService } from "@fern-api/base-generator";
import { AbstractRustGeneratorCli } from "@fern-api/rust-base";
import { FernGeneratorExec } from "@fern-fern/generator-exec-sdk";
import { IntermediateRepresentation } from "@fern-fern/ir-sdk/api";
import { RelativeFilePath } from "@fern-api/fs-utils";
import { SdkCustomConfigSchema } from "./SdkCustomConfig";
import { SdkGeneratorContext } from "./SdkGeneratorContext";

export class SdkGeneratorCli extends AbstractRustGeneratorCli<SdkCustomConfigSchema, SdkGeneratorContext> {
    protected constructContext({
        ir,
        customConfig,
        generatorConfig,
        generatorNotificationService
    }: {
        ir: IntermediateRepresentation;
        customConfig: SdkCustomConfigSchema;
        generatorConfig: FernGeneratorExec.GeneratorConfig;
        generatorNotificationService: GeneratorNotificationService;
    }): SdkGeneratorContext {
        return new SdkGeneratorContext(ir, generatorConfig, customConfig, generatorNotificationService);
    }

    protected parseCustomConfigOrThrow(customConfig: unknown): SdkCustomConfigSchema {
        const parsed = customConfig != null ? SdkCustomConfigSchema.parse(customConfig) : undefined;
        if (parsed != null) {
            return parsed;
        }
        return SdkCustomConfigSchema.parse({});
    }

    protected publishPackage(context: SdkGeneratorContext): Promise<void> {
        return this.generate(context);
    }

    protected async writeForGithub(context: SdkGeneratorContext): Promise<void> {
        await this.generate(context);
        if (context.isSelfHosted()) {
            await this.generateGitHub({ context });
        }
    }

    protected async writeForDownload(context: SdkGeneratorContext): Promise<void> {
        return await this.generate(context);
    }

    protected async generate(context: SdkGeneratorContext): Promise<void> {
        // Generate lib.rs
        const libContent = this.generateLibRs(context);
        context.project.addSourceFile(RelativeFilePath.of("src/lib.rs"), libContent);

        // Generate client.rs
        const clientContent = this.generateClientRs(context);
        context.project.addSourceFile(RelativeFilePath.of("src/client.rs"), clientContent);

        // Generate error.rs
        const errorContent = this.generateErrorRs();
        context.project.addSourceFile(RelativeFilePath.of("src/error.rs"), errorContent);

        // Generate types if they exist
        if (Object.keys(context.ir.types).length > 0) {
            const typesContent = this.generateTypesRs(context);
            context.project.addSourceFile(RelativeFilePath.of("src/types.rs"), typesContent);
        }

        // Generate services
        for (const [serviceId, service] of Object.entries(context.ir.services)) {
            const serviceName = service.name.fernFilepath.allParts.join("_").toLowerCase();
            const serviceContent = this.generateServiceRs(context, service);
            context.project.addSourceFile(RelativeFilePath.of(`src/${serviceName}.rs`), serviceContent);
        }

        await context.project.persist();
    }

    private generateLibRs(context: SdkGeneratorContext): string {
        const hasTypes = Object.keys(context.ir.types).length > 0;
        const services = Object.values(context.ir.services);
        
        let modules = `pub mod client;
pub mod error;`;
        
        if (hasTypes) {
            modules += `\npub mod types;`;
        }
        
        for (const service of services) {
            const serviceName = service.name.fernFilepath.allParts.join("_").toLowerCase();
            modules += `\npub mod ${serviceName};`;
        }
        
        return `//! ${context.ir.apiName.pascalCase.safeName} SDK
//!
//! Generated by Fern

${modules}

pub use client::${context.getClientName()};
pub use error::Error;
${hasTypes ? '\npub use types::*;' : ''}
`;
    }

    private generateClientRs(context: SdkGeneratorContext): string {
        const clientName = context.getClientName();
        return `use crate::error::Error;
use reqwest::{Client, RequestBuilder};
use serde::{Deserialize, Serialize};

pub struct ${clientName} {
    client: Client,
    base_url: String,
}

impl ${clientName} {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self {
            client: Client::new(),
            base_url: base_url.into(),
        }
    }

    pub fn with_client(client: Client, base_url: impl Into<String>) -> Self {
        Self {
            client,
            base_url: base_url.into(),
        }
    }

    // TODO: Add API methods here
}
`;
    }

    private generateErrorRs(): string {
        return `use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("HTTP error: {0}")]
    Http(#[from] reqwest::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("API error: {message}")]
    Api { message: String },
}
`;
    }

    private async generateGitHub({ context }: { context: SdkGeneratorContext }): Promise<void> {
        await context.generatorAgent.pushToGitHub({ context });
    }

    private generateTypesRs(context: SdkGeneratorContext): string {
        let content = `use serde::{Deserialize, Serialize};

`;
        
        // Generate type aliases
        for (const [typeId, type] of Object.entries(context.ir.types)) {
            const typeName = type.name.name.pascalCase.safeName;
            
            if (type.shape.type === "alias") {
                // For now, just create a simple type alias
                content += `pub type ${typeName} = String; // TODO: Implement proper type\n\n`;
            } else if (type.shape.type === "enum") {
                content += `#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ${typeName} {
`;
                for (const value of type.shape.values) {
                    content += `    ${value.name.name.pascalCase.safeName},\n`;
                }
                content += `}\n\n`;
            } else if (type.shape.type === "object") {
                content += `#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ${typeName} {
`;
                for (const property of type.shape.properties) {
                    const fieldName = property.name.name.snakeCase.safeName;
                    content += `    pub ${fieldName}: String, // TODO: Implement proper type\n`;
                }
                content += `}\n\n`;
            }
        }
        
        return content;
    }

    private generateServiceRs(context: SdkGeneratorContext, service: any): string {
        const clientName = context.getClientName();
        const serviceName = service.displayName || service.name.fernFilepath.allParts.join("_");
        
        return `use crate::client::${clientName};
use crate::error::Error;

impl ${clientName} {
    // ${serviceName} methods
    
    // TODO: Generate actual service methods based on endpoints
}
`;
    }
} 
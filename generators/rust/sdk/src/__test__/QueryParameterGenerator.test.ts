import { describe, it, expect } from "vitest";
import { IntermediateRepresentation, HttpEndpoint, QueryParameter } from "@fern-fern/ir-sdk/api";
import { SubClientGenerator } from "../generators/SubClientGenerator";
import { SdkGeneratorContext } from "../SdkGeneratorContext";
import * as FernIr from "@fern-fern/ir-sdk/api";

// Mock function to create basic IR structure
function createMockIR(services: Record<string, unknown> = {}): IntermediateRepresentation {
    return {
        apiName: {
            originalName: "TestAPI",
            camelCase: { unsafeName: "testApi", safeName: "testApi" },
            snakeCase: { unsafeName: "test_api", safeName: "test_api" },
            screamingSnakeCase: { unsafeName: "TEST_API", safeName: "TEST_API" },
            pascalCase: { unsafeName: "TestAPI", safeName: "TestAPI" }
        },
        apiVersion: "1.0.0",
        errors: {},
        types: {},
        services
    } as unknown as IntermediateRepresentation;
}

// Mock function to create query parameter
function createQueryParameter(name: string, wireValue: string): QueryParameter {
    return {
        name: {
            name: {
                originalName: name,
                camelCase: {
                    unsafeName: name.toLowerCase(),
                    safeName: name.toLowerCase()
                },
                snakeCase: {
                    unsafeName: name.toLowerCase(),
                    safeName: name.toLowerCase()
                },
                screamingSnakeCase: {
                    unsafeName: name.toUpperCase(),
                    safeName: name.toUpperCase()
                },
                pascalCase: { unsafeName: name, safeName: name }
            },
            wireValue
        },
        valueType: FernIr.TypeReference.primitive({
            v1: FernIr.PrimitiveTypeV1.String,
            v2: undefined
        }),
        allowMultiple: false,
        docs: undefined,
        availability: undefined
    } as QueryParameter;
}

// Mock function to create HTTP endpoint with query parameters
function createHttpEndpoint(name: string, queryParams: QueryParameter[] = []): HttpEndpoint {
    return {
        id: name,
        name: {
            originalName: name,
            camelCase: {
                unsafeName: name.toLowerCase(),
                safeName: name.toLowerCase()
            },
            snakeCase: {
                unsafeName: name.toLowerCase(),
                safeName: name.toLowerCase()
            },
            screamingSnakeCase: {
                unsafeName: name.toUpperCase(),
                safeName: name.toUpperCase()
            },
            pascalCase: { unsafeName: name, safeName: name }
        },
        displayName: undefined,
        method: "GET",
        baseUrl: undefined,
        v2BaseUrls: undefined,
        basePath: undefined,
        path: {
            head: "/api/test",
            parts: []
        },
        fullPath: {
            head: "/api/test",
            parts: []
        },
        pathParameters: [],
        allPathParameters: [],
        queryParameters: queryParams,
        headers: [],
        requestBody: undefined,
        sdkRequest: undefined,
        response: undefined,
        errors: [],
        auth: false,
        idempotent: false,
        availability: undefined,
        docs: undefined,
        v2RequestBodies: undefined,
        v2Responses: undefined,
        audiences: undefined,
        userSpecifiedExamples: [],
        autogeneratedExamples: [],
        pagination: undefined,
        v2Examples: undefined,
        transport: undefined,
        source: undefined
    } as HttpEndpoint;
}

// Mock function to create context
function createMockContext(ir: IntermediateRepresentation): SdkGeneratorContext {
    return {
        ir,
        getClientName: () => "TestClient",
        customConfig: { generateExamples: false },
        getHttpServiceOrThrow: () => ({ endpoints: [] }) as unknown as FernIr.HttpService
    } as unknown as SdkGeneratorContext;
}

function createMockSubpackage(): FernIr.Subpackage {
    return {
        name: {
            originalName: "TestSubpackage",
            camelCase: { unsafeName: "testSubpackage", safeName: "testSubpackage" },
            snakeCase: { unsafeName: "test_subpackage", safeName: "test_subpackage" },
            screamingSnakeCase: {
                unsafeName: "TEST_SUBPACKAGE",
                safeName: "TEST_SUBPACKAGE"
            },
            pascalCase: { unsafeName: "TestSubpackage", safeName: "TestSubpackage" }
        },
        displayName: undefined,
        fernFilepath: {
            allParts: [],
            packagePath: [],
            file: { contents: [], extension: "fern" }
        },
        service: undefined,
        types: [],
        errors: [],
        webhooks: undefined,
        websocket: undefined,
        subpackages: [],
        hasEndpointsInTree: false,
        navigationConfig: undefined,
        docs: undefined,
        availability: undefined
    } as unknown as FernIr.Subpackage;
}

describe("QueryParameterGenerator", () => {
    it("should generate method without query parameters correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const endpoint = createHttpEndpoint("getTest");

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        // await expect(fullMethod).toMatchFileSnapshot("snapshots/method-without-query-params.rs");
    });

    it("should generate method with single query parameter correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const queryParam = createQueryParameter("limit", "limit");
        const endpoint = createHttpEndpoint("getTest", [queryParam]);

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        await expect(fullMethod).toMatchFileSnapshot("snapshots/method-with-single-query-param.rs");
    });

    it("should generate method with multiple query parameters correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const queryParam1 = createQueryParameter("limit", "limit");
        const queryParam2 = createQueryParameter("offset", "offset");
        const endpoint = createHttpEndpoint("getTest", [queryParam1, queryParam2]);

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        await expect(fullMethod).toMatchFileSnapshot("snapshots/method-with-multiple-query-params.rs");
    });
});

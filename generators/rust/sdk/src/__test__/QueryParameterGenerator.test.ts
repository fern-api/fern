import * as FernIr from "@fern-fern/ir-sdk/api";
import { HttpEndpoint, IntermediateRepresentation, QueryParameter } from "@fern-fern/ir-sdk/api";
import { describe, expect, it } from "vitest";
import { SubClientGenerator } from "../generators/SubClientGenerator";
import { SdkGeneratorContext } from "../SdkGeneratorContext";

// Mock function to create basic IR structure
function createMockIR(services: Record<string, unknown> = {}): IntermediateRepresentation {
    return {
        apiName: {
            originalName: "TestAPI",
            camelCase: { unsafeName: "testApi", safeName: "testApi" },
            snakeCase: { unsafeName: "test_api", safeName: "test_api" },
            screamingSnakeCase: { unsafeName: "TEST_API", safeName: "TEST_API" },
            pascalCase: { unsafeName: "TestAPI", safeName: "TestAPI" }
        },
        apiVersion: "1.0.0",
        errors: {},
        types: {},
        services
    } as unknown as IntermediateRepresentation;
}

// Mock function to create query parameter
function createQueryParameter(name: string, wireValue: string): QueryParameter {
    return {
        name: {
            name: {
                originalName: name,
                camelCase: {
                    unsafeName: name.toLowerCase(),
                    safeName: name.toLowerCase()
                },
                snakeCase: {
                    unsafeName: name.toLowerCase(),
                    safeName: name.toLowerCase()
                },
                screamingSnakeCase: {
                    unsafeName: name.toUpperCase(),
                    safeName: name.toUpperCase()
                },
                pascalCase: { unsafeName: name, safeName: name }
            },
            wireValue
        },
        valueType: FernIr.TypeReference.primitive({
            v1: FernIr.PrimitiveTypeV1.String,
            v2: undefined
        }),
        allowMultiple: false,
        docs: undefined,
        availability: undefined
    } as QueryParameter;
}

// Mock function to create HTTP endpoint with query parameters
function createHttpEndpoint(name: string, queryParams: QueryParameter[] = []): HttpEndpoint {
    return {
        id: name,
        name: {
            originalName: name,
            camelCase: {
                unsafeName: name.toLowerCase(),
                safeName: name.toLowerCase()
            },
            snakeCase: {
                unsafeName: name.toLowerCase(),
                safeName: name.toLowerCase()
            },
            screamingSnakeCase: {
                unsafeName: name.toUpperCase(),
                safeName: name.toUpperCase()
            },
            pascalCase: { unsafeName: name, safeName: name }
        },
        displayName: undefined,
        method: "GET",
        baseUrl: undefined,
        v2BaseUrls: undefined,
        basePath: undefined,
        path: {
            head: "/api/test",
            parts: []
        },
        fullPath: {
            head: "/api/test",
            parts: []
        },
        pathParameters: [],
        allPathParameters: [],
        queryParameters: queryParams,
        headers: [],
        requestBody: undefined,
        sdkRequest: undefined,
        response: undefined,
        errors: [],
        auth: false,
        idempotent: false,
        availability: undefined,
        docs: undefined,
        v2RequestBodies: undefined,
        v2Responses: undefined,
        audiences: undefined,
        userSpecifiedExamples: [],
        autogeneratedExamples: [],
        pagination: undefined,
        v2Examples: undefined,
        transport: undefined,
        source: undefined,
        security: undefined,
        retries: undefined
    } as HttpEndpoint;
}

// Mock function to create context
function createMockContext(ir: IntermediateRepresentation): SdkGeneratorContext {
    return {
        ir,
        getClientName: () => "TestClient",
        customConfig: { generateExamples: false },
        getHttpServiceOrThrow: () => ({ endpoints: [] }) as unknown as FernIr.HttpService,
        getSubpackageOrThrow: (subpackageId: string) => ir.subpackages[subpackageId as keyof typeof ir.subpackages],
        getSubpackagesOrThrow: (packageOrSubpackage: { subpackages?: string[] }) => {
            return (
                packageOrSubpackage.subpackages?.map((subpackageId: string) => [
                    subpackageId,
                    ir.subpackages[subpackageId as keyof typeof ir.subpackages]
                ]) || []
            );
        },
        getUniqueFilenameForSubpackage: (subpackage: {
            fernFilepath: { allParts: Array<{ snakeCase: { safeName: string } }> };
        }) => {
            const pathParts = subpackage.fernFilepath.allParts.map((part) => part.snakeCase.safeName);
            return `${pathParts.join("_")}.rs`;
        },
        getUniqueClientNameForSubpackage: (subpackage: {
            fernFilepath: { allParts: Array<{ pascalCase: { safeName: string } }> };
        }) => {
            const pathParts = subpackage.fernFilepath.allParts.map((part) => part.pascalCase.safeName);
            return pathParts.join("") + "Client";
        },
        getDirectoryForFernFilepath: (fernFilepath: { allParts: Array<{ snakeCase: { safeName: string } }> }) => {
            return fernFilepath.allParts.map((part) => part.snakeCase.safeName).join("/");
        },
        getQueryRequestTypeName: (endpoint: HttpEndpoint) => {
            const methodName = endpoint.name.pascalCase.safeName;
            return `${methodName}QueryRequest`;
        },
        getModuleNameForQueryRequest: (queryRequestTypeName: string) => {
            return queryRequestTypeName
                .replace(/([A-Z])/g, "_$1")
                .toLowerCase()
                .replace(/^_/, "");
        },
        escapeRustKeyword: (name: string) => {
            // Simple implementation for testing - just returns the name as-is
            // In production, this would escape Rust keywords with r# prefix
            const RUST_KEYWORDS = new Set([
                "as",
                "break",
                "const",
                "continue",
                "crate",
                "else",
                "enum",
                "extern",
                "false",
                "fn",
                "for",
                "if",
                "impl",
                "in",
                "let",
                "loop",
                "match",
                "mod",
                "move",
                "mut",
                "pub",
                "ref",
                "return",
                "self",
                "Self",
                "static",
                "struct",
                "super",
                "trait",
                "true",
                "type",
                "unsafe",
                "use",
                "where",
                "while",
                "async",
                "await",
                "dyn",
                "abstract",
                "become",
                "box",
                "do",
                "final",
                "macro",
                "override",
                "priv",
                "typeof",
                "unsized",
                "virtual",
                "yield",
                "try"
            ]);
            return RUST_KEYWORDS.has(name) ? `r#${name}` : name;
        }
    } as unknown as SdkGeneratorContext;
}

function createMockSubpackage(): FernIr.Subpackage {
    return {
        name: {
            originalName: "TestSubpackage",
            camelCase: { unsafeName: "testSubpackage", safeName: "testSubpackage" },
            snakeCase: { unsafeName: "test_subpackage", safeName: "test_subpackage" },
            screamingSnakeCase: {
                unsafeName: "TEST_SUBPACKAGE",
                safeName: "TEST_SUBPACKAGE"
            },
            pascalCase: { unsafeName: "TestSubpackage", safeName: "TestSubpackage" }
        },
        displayName: undefined,
        fernFilepath: {
            allParts: [],
            packagePath: [],
            file: { contents: [], extension: "fern" }
        },
        service: undefined,
        types: [],
        errors: [],
        webhooks: undefined,
        websocket: undefined,
        subpackages: [],
        hasEndpointsInTree: false,
        navigationConfig: undefined,
        docs: undefined,
        availability: undefined
    } as unknown as FernIr.Subpackage;
}

describe("QueryParameterGenerator", () => {
    it("should generate method without query parameters correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const endpoint = createHttpEndpoint("getTest");

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        await expect(fullMethod).toMatchFileSnapshot("snapshots/method-without-query-params.rs");
    });

    it("should generate method with single query parameter correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const queryParam = createQueryParameter("limit", "limit");
        const endpoint = createHttpEndpoint("getTest", [queryParam]);

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        await expect(fullMethod).toMatchFileSnapshot("snapshots/method-with-single-query-param.rs");
    });

    it("should generate method with multiple query parameters correctly", async () => {
        const ir = createMockIR();
        const context = createMockContext(ir);
        const mockSubpackage = createMockSubpackage();
        const generator = new SubClientGenerator(context, mockSubpackage);

        const queryParam1 = createQueryParameter("limit", "limit");
        const queryParam2 = createQueryParameter("offset", "offset");
        const endpoint = createHttpEndpoint("getTest", [queryParam1, queryParam2]);

        // Access private method for testing
        const method = (
            generator as unknown as {
                generateHttpMethod: (endpoint: HttpEndpoint) => {
                    name: string;
                    parameters: string[];
                    returnType: string;
                    body: string;
                };
            }
        ).generateHttpMethod(endpoint);

        // Format the method body for snapshot comparison
        const methodSignature = `pub async fn ${method.name}(${method.parameters.join(", ")}) -> ${method.returnType}`;
        const methodBody = method.body;
        const fullMethod = `${methodSignature} {\n    ${methodBody}\n}`;

        await expect(fullMethod).toMatchFileSnapshot("snapshots/method-with-multiple-query-params.rs");
    });
});

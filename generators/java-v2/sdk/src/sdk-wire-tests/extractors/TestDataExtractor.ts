import {
    ExampleEndpointCall,
    ExampleRequestBody,
    ExampleResponse,
    ExampleTypeReference,
    HttpEndpoint,
    TypeDeclaration
} from "@fern-fern/ir-sdk/api";
import { SdkGeneratorContext } from "../../SdkGeneratorContext";

/**
 * Extracts test data directly from the static IR for wire test validation.
 * This class is responsible for extracting request and response data from examples,
 * separate from the code snippet generation. It is used to generate test data for wire tests.
 */
export class WireTestDataExtractor {
    constructor(private readonly context: SdkGeneratorContext) {}

    public getTestExamples(endpoint: HttpEndpoint): WireTestExample[] {
        const examples: WireTestExample[] = [];

        for (const userExample of endpoint.userSpecifiedExamples) {
            if (userExample.example) {
                const extracted = this.extractTestExample(userExample.example, endpoint);
                if (extracted) {
                    examples.push(extracted);
                }
            }
        }

        if (examples.length === 0) {
            for (const autoExample of endpoint.autogeneratedExamples) {
                if (autoExample.example) {
                    const extracted = this.extractTestExample(autoExample.example, endpoint);
                    if (extracted) {
                        examples.push(extracted);
                    }
                }
            }
        }

        return examples;
    }

    private extractTestExample(example: ExampleEndpointCall, endpoint: HttpEndpoint): WireTestExample | undefined {
        const requestBody = this.extractRequestBody(example.request, endpoint);

        return {
            id: example.id || `${endpoint.id}-example`,
            name: example.name?.originalName,
            request: {
                body: requestBody,
                headers: this.extractHeaders(example),
                queryParams: this.extractQueryParams(example),
                pathParams: this.extractPathParams(example)
            },
            response: {
                statusCode: this.getResponseStatusCode(example.response),
                body: this.extractResponseBody(example.response)
            }
        };
    }

    private extractRequestBody(request: ExampleRequestBody | undefined, endpoint: HttpEndpoint): unknown | undefined {
        if (!request) {
            return undefined;
        }

        let rawBody: unknown | undefined;

        if ("jsonExample" in request && request.jsonExample !== undefined) {
            rawBody = request.jsonExample;

            // Check if this is an empty object for an optional request body
            if (this.isEmptyObjectForOptionalRequest(rawBody, endpoint)) {
                return undefined;
            }
        } else {
            // Fallback for inlined request bodies that may not have a direct jsonExample
            rawBody = request._visit({
                inlinedRequestBody: (value) => {
                    const result: Record<string, unknown> = {};
                    value.properties.forEach((p) => {
                        result[p.name.wireValue] = this.createRawJsonExample(p.value);
                    });
                    return result;
                },
                reference: (value) => {
                    return this.createRawJsonExample(value);
                },
                _other: () => {
                    return undefined;
                }
            });
        }

        return this.pruneUnionBaseProperties(rawBody, endpoint);
    }

    /**
     * Checks if the body is an empty object ({}) for an optional request body type.
     * Empty objects for optional request bodies should be treated as undefined to skip validation.
     */
    private isEmptyObjectForOptionalRequest(body: unknown, endpoint: HttpEndpoint): boolean {
        if (typeof body !== "object" || body === null || Array.isArray(body)) {
            return false;
        }

        const bodyKeys = Object.keys(body);
        if (bodyKeys.length !== 0) {
            return false;
        }

        const requestBody = endpoint.requestBody;
        if (!requestBody || requestBody.type !== "reference") {
            return false;
        }

        const typeRef = requestBody.requestBodyType;
        if (typeRef.type !== "container") {
            return false;
        }

        return typeRef.container.type === "optional";
    }

    /**
     * Prunes base properties from union types in the request body.
     * The Java generator does not support base properties on unions, so we need to
     * remove them from expected JSON to match the actual SDK output.
     */
    private pruneUnionBaseProperties(body: unknown, endpoint: HttpEndpoint): unknown {
        if (!body || typeof body !== "object") {
            return body;
        }

        const requestBody = endpoint.requestBody;
        if (!requestBody) {
            return body;
        }

        if (requestBody.type === "reference") {
            const typeReference = requestBody.requestBodyType;

            if (typeReference.type === "named") {
                const typeId = typeReference.typeId;
                const typeDecl = this.context.ir.types[typeId];

                if (typeDecl && typeDecl.shape.type === "union") {
                    return this.pruneBasePropertiesFromUnion(body, typeDecl);
                }
            } else if (typeReference.type === "container" && typeReference.container.type === "list") {
                const listItemType = typeReference.container.list;

                if (listItemType.type === "named") {
                    const typeId = listItemType.typeId;
                    const typeDecl = this.context.ir.types[typeId];

                    if (typeDecl && typeDecl.shape.type === "union") {
                        return this.pruneBasePropertiesFromUnion(body, typeDecl);
                    }
                }
            }
        }

        return body;
    }

    /**
     * Removes base properties from a union type's JSON representation.
     * Also handles arrays of unions (e.g., list<BigUnion>).
     */
    private pruneBasePropertiesFromUnion(body: unknown, typeDecl: TypeDeclaration): unknown {
        if (!body) {
            return body;
        }

        if (Array.isArray(body)) {
            return body.map((item) => this.pruneBasePropertiesFromUnion(item, typeDecl));
        }

        if (typeof body !== "object" || body === null) {
            return body;
        }

        const unionShape = typeDecl.shape;
        if (unionShape.type !== "union") {
            return body;
        }

        const basePropertyWireNames = new Set<string>();
        unionShape.baseProperties.forEach((prop) => {
            basePropertyWireNames.add(prop.name.wireValue);
        });

        const prunedBody: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(body as Record<string, unknown>)) {
            if (!basePropertyWireNames.has(key)) {
                prunedBody[key] = value;
            }
        }

        return prunedBody;
    }

    private extractResponseBody(response: ExampleResponse | undefined): unknown | undefined {
        if (!response) {
            return undefined;
        }

        return response._visit({
            ok: (value) => {
                return value._visit({
                    body: (body) => {
                        if (!body) {
                            return undefined;
                        }
                        return this.createRawJsonExample(body);
                    },
                    stream: () => undefined,
                    sse: () => undefined,
                    _other: () => undefined
                });
            },
            error: (value) => {
                if (!value.body) {
                    return undefined;
                }
                return this.createRawJsonExample(value.body);
            },
            _other: () => undefined
        });
    }

    private getResponseStatusCode(response: ExampleResponse | undefined): number {
        if (!response) {
            return 200;
        }

        return response._visit({
            ok: () => 200,
            error: (exampleError) => {
                const error = this.context.ir.errors[exampleError.error.errorId];
                return error?.statusCode ?? 500;
            },
            _other: () => 200
        });
    }

    private extractHeaders(example: ExampleEndpointCall): Record<string, string> {
        const headers: Record<string, string> = {};

        [...(example.serviceHeaders ?? []), ...(example.endpointHeaders ?? [])].forEach((header) => {
            headers[header.name.wireValue] = String(header.value.jsonExample);
        });

        return headers;
    }

    private extractQueryParams(example: ExampleEndpointCall): Record<string, string> {
        const params: Record<string, string> = {};

        (example.queryParameters ?? []).forEach((param) => {
            params[param.name.wireValue] = String(param.value.jsonExample);
        });

        return params;
    }

    private extractPathParams(example: ExampleEndpointCall): Record<string, string> {
        const params: Record<string, string> = {};

        [
            ...(example.rootPathParameters ?? []),
            ...(example.servicePathParameters ?? []),
            ...(example.endpointPathParameters ?? [])
        ].forEach((param) => {
            params[param.name.originalName] = String(param.value.jsonExample);
        });

        return params;
    }

    private createRawJsonExample(typeRef: ExampleTypeReference): unknown {
        return typeRef.jsonExample;
    }
}

export interface WireTestExample {
    id: string;
    name?: string;
    request: {
        body?: unknown;
        headers: Record<string, string>;
        queryParams: Record<string, string>;
        pathParams: Record<string, string>;
    };
    response: {
        statusCode: number;
        body?: unknown;
    };
}

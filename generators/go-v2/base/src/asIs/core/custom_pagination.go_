package core

import (
	"context"
)

// CustomPager is a generic pager for custom pagination endpoints.
// It provides bidirectional navigation through pages of results.
type CustomPager[T any] struct {
	current  *T
	hasNext  func(*T) bool
	hasPrev  func(*T) bool
	getNext  func(context.Context, *T) (*T, error)
	getPrev  func(context.Context, *T) (*T, error)
}

// NewCustomPager creates a new custom pager with the given initial response
// and navigation functions.
func NewCustomPager[T any](
	initial *T,
	hasNext func(*T) bool,
	hasPrev func(*T) bool,
	getNext func(context.Context, *T) (*T, error),
	getPrev func(context.Context, *T) (*T, error),
) *CustomPager[T] {
	return &CustomPager[T]{
		current: initial,
		hasNext: hasNext,
		hasPrev: hasPrev,
		getNext: getNext,
		getPrev: getPrev,
	}
}

// HasNextPage returns true if there is a next page available.
func (p *CustomPager[T]) HasNextPage() bool {
	if p.current == nil || p.hasNext == nil {
		return false
	}
	return p.hasNext(p.current)
}

// GetNextPage fetches the next page of results.
func (p *CustomPager[T]) GetNextPage(ctx context.Context) (*T, error) {
	if p.getNext == nil {
		return nil, ErrNoPages
	}
	next, err := p.getNext(ctx, p.current)
	if err != nil {
		return nil, err
	}
	p.current = next
	return next, nil
}

// HasPrevPage returns true if there is a previous page available.
func (p *CustomPager[T]) HasPrevPage() bool {
	if p.current == nil || p.hasPrev == nil {
		return false
	}
	return p.hasPrev(p.current)
}

// GetPrevPage fetches the previous page of results.
func (p *CustomPager[T]) GetPrevPage(ctx context.Context) (*T, error) {
	if p.getPrev == nil {
		return nil, ErrNoPages
	}
	prev, err := p.getPrev(ctx, p.current)
	if err != nil {
		return nil, err
	}
	p.current = prev
	return prev, nil
}

// Current returns the current page response.
func (p *CustomPager[T]) Current() *T {
	return p.current
}

// Iter returns a channel-based iterator for iterating through pages.
// This works with all Go versions and can be used with range loops.
// The iterator will yield the current page and continue fetching next pages
// until no more pages are available or the context is cancelled.
func (p *CustomPager[T]) Iter(ctx context.Context) <-chan *T {
	ch := make(chan *T)
	go func() {
		defer close(ch)
		current := p.current
		for current != nil {
			select {
			case <-ctx.Done():
				return
			case ch <- current:
			}
			if !p.HasNextPage() {
				return
			}
			next, err := p.GetNextPage(ctx)
			if err != nil {
				return
			}
			current = next
		}
	}()
	return ch
}

// Seq returns a range-over-func iterator for Go 1.23+ compatibility.
// This allows using the pager with range loops: for page := range pager.Seq(ctx) { ... }
// The iterator will yield the current page and continue fetching next pages
// until no more pages are available or the context is cancelled.
func (p *CustomPager[T]) Seq(ctx context.Context) func(yield func(*T) bool) {
	return func(yield func(*T) bool) {
		current := p.current
		for current != nil {
			select {
			case <-ctx.Done():
				return
			default:
			}
			if !yield(current) {
				return
			}
			if !p.HasNextPage() {
				return
			}
			next, err := p.GetNextPage(ctx)
			if err != nil {
				return
			}
			current = next
		}
	}
}

// ForEach iterates through all pages and calls the provided function for each page.
// If the function returns false, iteration stops early.
func (p *CustomPager[T]) ForEach(ctx context.Context, fn func(*T) bool) {
	current := p.current
	for current != nil {
		select {
		case <-ctx.Done():
			return
		default:
		}
		if !fn(current) {
			return
		}
		if !p.HasNextPage() {
			return
		}
		next, err := p.GetNextPage(ctx)
		if err != nil {
			return
		}
		current = next
	}
}

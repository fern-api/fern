import { DynamicSnippetsGenerator } from "@fern-api/go-dynamic-snippets";

import { dynamic, ExampleEndpointCall, HttpEndpoint } from "@fern-fern/ir-sdk/api";

import { SdkGeneratorContext } from "../SdkGeneratorContext";
import { convertDynamicEndpointSnippetRequest } from "../utils/convertEndpointSnippetRequest";
import { convertIr } from "../utils/convertIr";

export interface EndpointSnippets {
    autogenerated: SingleEndpointSnippet[];
    userSpecified: SingleEndpointSnippet[];
}

export interface SingleEndpointSnippet {
    exampleIdentifier: string | undefined;
    endpointCall: string;
}

export class EndpointSnippetsGenerator {
    public static CLIENT_VARIABLE_NAME = "client";

    private readonly context: SdkGeneratorContext;
    private readonly snippetsCache: Map<string, EndpointSnippets> = new Map();

    constructor({ context }: { context: SdkGeneratorContext }) {
        this.context = context;
    }

    public async populateSnippetsCache(): Promise<void> {
        const endpointSnippetsById = new Map<string, EndpointSnippets>();
        const dynamicIr = this.context.ir.dynamic;

        if (!dynamicIr) {
            this.context.logger.warn("Cannot populate snippets cache without dynamic IR");
            return;
        }

        const convertedIr = convertIr(dynamicIr);
        const dynamicSnippetsGenerator = new DynamicSnippetsGenerator({
            ir: convertedIr,
            config: this.context.config
        });

        // Process all endpoints and their examples
        for (const [endpointId, dynamicEndpoint] of Object.entries(dynamicIr.endpoints)) {
            const irEndpoint = this.getIrEndpointById(endpointId);
            if (!irEndpoint) {
                this.context.logger.debug(`Could not find IR endpoint for ${endpointId}`);
                continue;
            }

            this.context.logger.debug(
                `Processing endpoint ${endpointId} with ${dynamicEndpoint.examples?.length || 0} examples`
            );

            const allExamples = dynamicEndpoint.examples || [];

            if (allExamples.length === 0) {
                continue;
            }

            const snippets = await Promise.all(
                allExamples.map(async (example) => {
                    try {
                        const snippet = await this.generateSingleEndpointSnippetFromDynamic({
                            endpoint: irEndpoint,
                            example,
                            dynamicSnippetsGenerator
                        });
                        return { snippet, isUserSpecified: false }; // Dynamic examples don't distinguish user vs auto
                    } catch (error) {
                        return { snippet: null, isUserSpecified: false };
                    }
                })
            );

            const autogenerated = snippets
                .filter(({ snippet, isUserSpecified }) => snippet != null && !isUserSpecified)
                .map(({ snippet }) => snippet as SingleEndpointSnippet);

            const userSpecified = snippets
                .filter(({ snippet, isUserSpecified }) => snippet != null && isUserSpecified)
                .map(({ snippet }) => snippet as SingleEndpointSnippet);

            if (autogenerated.length > 0 || userSpecified.length > 0) {
                this.context.logger.debug(
                    `Generated ${autogenerated.length} autogenerated and ${userSpecified.length} user-specified snippets for endpoint ${endpointId}`
                );
                endpointSnippetsById.set(endpointId, { autogenerated, userSpecified });
            } else {
                this.context.logger.debug(`No snippets generated for endpoint ${endpointId}`);
            }
        }

        // Store in cache
        endpointSnippetsById.forEach((value, key) => {
            this.snippetsCache.set(key, value);
        });
    }

    public getSnippetsForEndpoint(endpointId: string): EndpointSnippets | undefined {
        return this.snippetsCache.get(endpointId);
    }

    public getSingleEndpointSnippet({
        endpoint,
        example
    }: {
        endpoint: HttpEndpoint;
        example: ExampleEndpointCall;
    }): SingleEndpointSnippet | undefined {
        const snippets = this.getSnippetsForEndpoint(endpoint.id);

        if (snippets) {
            // First try to find by example ID (canonical identifier)
            const exampleId = example.id;
            const snippet =
                snippets.userSpecified.find((s) => s.exampleIdentifier === exampleId) ??
                snippets.autogenerated.find((s) => s.exampleIdentifier === exampleId);
            if (snippet) {
                return snippet;
            }

            // Fallback: try to find by example name
            const exampleName = example.name?.originalName;
            const nameMatchedSnippet =
                snippets.userSpecified.find((s) => s.exampleIdentifier === exampleName) ??
                snippets.autogenerated.find((s) => s.exampleIdentifier === exampleName);
            if (nameMatchedSnippet) {
                return nameMatchedSnippet;
            }

            // If no exact match, return the first available snippet
            const fallbackSnippet = snippets.userSpecified[0] ?? snippets.autogenerated[0];
            if (fallbackSnippet) {
                return fallbackSnippet;
            }
        }
        return undefined;
    }

    private async generateSingleEndpointSnippetFromDynamic({
        endpoint,
        example,
        dynamicSnippetsGenerator
    }: {
        endpoint: HttpEndpoint;
        example: dynamic.EndpointSnippetRequest;
        dynamicSnippetsGenerator: DynamicSnippetsGenerator;
    }): Promise<SingleEndpointSnippet | null> {
        try {
            this.context.logger.debug(
                `Generated snippet request for endpoint ${endpoint.id}: ${JSON.stringify(example, null, 2)}`
            );

            // Convert to the expected format for the generator
            const snippetRequest = convertDynamicEndpointSnippetRequest(example);
            const generatedSnippet = await dynamicSnippetsGenerator.generate(snippetRequest);

            this.context.logger.debug(
                `Generated snippet response for endpoint ${endpoint.id}: ${JSON.stringify(generatedSnippet, null, 2)}`
            );

            if (!generatedSnippet.snippet) {
                this.context.logger.warn(`Empty snippet returned for endpoint ${endpoint.id}`);
                return null;
            }

            return {
                exampleIdentifier: (example as dynamic.EndpointExample).id, // Use unique example ID for dynamic examples
                endpointCall: this.extractMethodCall(generatedSnippet.snippet)
            };
        } catch (error) {
            return null;
        }
    }

    private extractMethodCall(fullSnippet: string): string {
        // Extract just the method call from the full Golang snippet
        // Look for the pattern: client.service().method(...);

        const lines = fullSnippet.split("\n");
        let methodCallLines: string[] = [];
        let inMethodCall = false;
        let braceCount = 0;

        for (const line of lines) {
            const trimmedLine = line.trim();

            // Start collecting when we see a client method call
            if (trimmedLine.startsWith("client.") && !inMethodCall) {
                inMethodCall = true;
                methodCallLines = [];
            }

            if (inMethodCall) {
                methodCallLines.push(line);

                // Count braces to determine when the method call ends
                for (const char of line) {
                    if (char === "(") {
                        braceCount++;
                    }
                    if (char === ")") {
                        braceCount--;
                    }
                }

                // If we hit a semicolon and braces are balanced, we're done
                if (line.includes(";") && braceCount === 0) {
                    break;
                }
            }
        }

        if (methodCallLines.length === 0) {
            // Fallback: return the full snippet if we can't parse it
            this.context.logger.debug("Could not extract method call from snippet, using full snippet");
            return fullSnippet;
        }

        // Clean up the extracted lines
        let result = methodCallLines.join("\n");

        // Remove any leading whitespace while preserving relative indentation
        const nonEmptyLines = result.split("\n").filter((line) => line.trim().length > 0);
        if (nonEmptyLines.length > 0) {
            const minIndent = Math.min(...nonEmptyLines.map((line) => line.length - line.trimStart().length));
            result = result
                .split("\n")
                .map((line) => (line.length > minIndent ? line.substring(minIndent) : line))
                .join("\n");
        }

        const extracted = result.trim();
        this.context.logger.debug(`Extracted method call: ${extracted}`);
        return extracted;
    }

    private getIrEndpointById(endpointId: string): HttpEndpoint | undefined {
        // Search through all services to find the endpoint
        for (const service of Object.values(this.context.ir.services)) {
            const endpoint = service.endpoints.find((ep) => ep.id === endpointId);
            if (endpoint) {
                return endpoint;
            }
        }
        return undefined;
    }
}

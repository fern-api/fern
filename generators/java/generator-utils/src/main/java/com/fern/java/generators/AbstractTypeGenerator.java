package com.fern.java.generators;

import com.fern.ir.model.commons.Name;
import com.fern.ir.model.commons.SafeAndUnsafeString;
import com.fern.ir.model.types.DeclaredTypeName;
import com.fern.ir.model.types.TypeDeclaration;
import com.fern.java.AbstractGeneratorContext;
import com.fern.java.output.GeneratedJavaFile;
import com.google.common.collect.ImmutableSet;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import javax.lang.model.element.Modifier;

public abstract class AbstractTypeGenerator extends AbstractFileGenerator {
    protected Set<String> reservedTypeNames;
    protected boolean isTopLevelClass;

    public AbstractTypeGenerator(
            ClassName className,
            AbstractGeneratorContext<?, ?> generatorContext,
            Set<String> reservedTypeNames,
            boolean isTopLevelClass) {
        super(className, generatorContext);
        this.reservedTypeNames = reservedTypeNames;
        this.isTopLevelClass = isTopLevelClass;
    }

    public abstract List<TypeDeclaration> getInlineTypeDeclarations();

    protected abstract TypeSpec getTypeSpecWithoutInlineTypes();

    public TypeSpec getTypeSpec() {
        TypeSpec typeSpec = getTypeSpecWithoutInlineTypes();
        if (generatorContext.getCustomConfig().enableInlineTypes()) {
            List<TypeSpec> inlineTypeSpecs = getInlineTypeSpecs();
            typeSpec = typeSpec.toBuilder().addTypes(inlineTypeSpecs).build();
            if (!isTopLevelClass) {
                typeSpec = typeSpec.toBuilder().addModifiers(Modifier.STATIC).build();
            }
        }
        return typeSpec;
    }

    protected List<TypeSpec> getInlineTypeSpecs() {
        if (!generatorContext.getCustomConfig().enableInlineTypes()) {
            return List.of();
        }

        List<TypeDeclaration> declarations = getInlineTypeDeclarations();
        List<TypeSpec> result = new ArrayList<>();
        for (TypeDeclaration declaration : declarations) {
            String name = declaration.getName().getName().getPascalCase().getSafeName();
            Optional<AbstractTypeGenerator> generator = declaration
                    .getShape()
                    .visit(new SingleTypeGenerator(
                            generatorContext,
                            declaration.getName(),
                            className.nestedClass(name),
                            TypesGenerator.getGeneratedInterfaces(generatorContext),
                            false,
                            ImmutableSet.<String>builder()
                                    .addAll(reservedTypeNames)
                                    .add(name)
                                    .build(),
                            false));
            if (generator.isPresent()) {
                TypeSpec typeSpec = generator.get().getTypeSpec();
                result.add(typeSpec);
            }
        }

        return result;
    }

    @Override
    public GeneratedJavaFile generateFile() {
        return GeneratedJavaFile.builder()
                .className(className)
                .javaFile(
                        JavaFile.builder(className.packageName(), getTypeSpec()).build())
                .build();
    }

    public static TypeDeclaration overrideTypeDeclarationName(TypeDeclaration rawTypeDeclaration, String newName) {
        return TypeDeclaration.builder()
                .name(DeclaredTypeName.builder()
                        .typeId(rawTypeDeclaration.getName().getTypeId())
                        .fernFilepath(rawTypeDeclaration.getName().getFernFilepath())
                        .name(Name.builder()
                                .originalName(newName)
                                .camelCase(safeAndUnsafe(newName))
                                .pascalCase(safeAndUnsafe(newName))
                                .snakeCase(safeAndUnsafe(newName))
                                .screamingSnakeCase(safeAndUnsafe(newName))
                                .build())
                        .build())
                .shape(rawTypeDeclaration.getShape())
                .availability(rawTypeDeclaration.getAvailability())
                .docs(rawTypeDeclaration.getDocs())
                .autogeneratedExamples(rawTypeDeclaration.getAutogeneratedExamples())
                .userProvidedExamples(rawTypeDeclaration.getUserProvidedExamples())
                .referencedTypes(rawTypeDeclaration.getReferencedTypes())
                .encoding(rawTypeDeclaration.getEncoding())
                .source(rawTypeDeclaration.getSource())
                .inline(rawTypeDeclaration.getInline())
                .build();
    }

    private static SafeAndUnsafeString safeAndUnsafe(String newName) {
        return SafeAndUnsafeString.builder()
                .unsafeName(newName)
                .safeName(newName)
                .build();
    }
}

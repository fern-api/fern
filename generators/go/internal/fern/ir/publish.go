// Code generated by Fern. DO NOT EDIT.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

var (
	directPublishFieldTarget = big.NewInt(1 << 0)
)

type DirectPublish struct {
	Target *PublishTarget `json:"target" url:"target"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DirectPublish) GetTarget() *PublishTarget {
	if d == nil {
		return nil
	}
	return d.Target
}

func (d *DirectPublish) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DirectPublish) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DirectPublish) SetTarget(target *PublishTarget) {
	d.Target = target
	d.require(directPublishFieldTarget)
}

func (d *DirectPublish) UnmarshalJSON(data []byte) error {
	type unmarshaler DirectPublish
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DirectPublish(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DirectPublish) MarshalJSON() ([]byte, error) {
	type embed DirectPublish
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DirectPublish) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	filesystemFieldGenerateFullProject = big.NewInt(1 << 0)
	filesystemFieldPublishTarget       = big.NewInt(1 << 1)
)

type Filesystem struct {
	// If true, will generate the entire project (pyproject.toml, package.json, etc)
	GenerateFullProject bool           `json:"generateFullProject" url:"generateFullProject"`
	PublishTarget       *PublishTarget `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (f *Filesystem) GetGenerateFullProject() bool {
	if f == nil {
		return false
	}
	return f.GenerateFullProject
}

func (f *Filesystem) GetPublishTarget() *PublishTarget {
	if f == nil {
		return nil
	}
	return f.PublishTarget
}

func (f *Filesystem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Filesystem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetGenerateFullProject sets the GenerateFullProject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Filesystem) SetGenerateFullProject(generateFullProject bool) {
	f.GenerateFullProject = generateFullProject
	f.require(filesystemFieldGenerateFullProject)
}

// SetPublishTarget sets the PublishTarget field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Filesystem) SetPublishTarget(publishTarget *PublishTarget) {
	f.PublishTarget = publishTarget
	f.require(filesystemFieldPublishTarget)
}

func (f *Filesystem) UnmarshalJSON(data []byte) error {
	type unmarshaler Filesystem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Filesystem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *Filesystem) MarshalJSON() ([]byte, error) {
	type embed Filesystem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Filesystem) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	githubPublishFieldOwner  = big.NewInt(1 << 0)
	githubPublishFieldRepo   = big.NewInt(1 << 1)
	githubPublishFieldUri    = big.NewInt(1 << 2)
	githubPublishFieldToken  = big.NewInt(1 << 3)
	githubPublishFieldMode   = big.NewInt(1 << 4)
	githubPublishFieldTarget = big.NewInt(1 << 5)
)

type GithubPublish struct {
	Owner  string         `json:"owner" url:"owner"`
	Repo   string         `json:"repo" url:"repo"`
	Uri    *string        `json:"uri,omitempty" url:"uri,omitempty"`
	Token  *string        `json:"token,omitempty" url:"token,omitempty"`
	Mode   *string        `json:"mode,omitempty" url:"mode,omitempty"`
	Target *PublishTarget `json:"target" url:"target"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GithubPublish) GetOwner() string {
	if g == nil {
		return ""
	}
	return g.Owner
}

func (g *GithubPublish) GetRepo() string {
	if g == nil {
		return ""
	}
	return g.Repo
}

func (g *GithubPublish) GetUri() *string {
	if g == nil {
		return nil
	}
	return g.Uri
}

func (g *GithubPublish) GetToken() *string {
	if g == nil {
		return nil
	}
	return g.Token
}

func (g *GithubPublish) GetTarget() *PublishTarget {
	if g == nil {
		return nil
	}
	return g.Target
}

func (g *GithubPublish) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubPublish) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetOwner sets the Owner field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetOwner(owner string) {
	g.Owner = owner
	g.require(githubPublishFieldOwner)
}

// SetRepo sets the Repo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetRepo(repo string) {
	g.Repo = repo
	g.require(githubPublishFieldRepo)
}

// SetUri sets the Uri field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetUri(uri *string) {
	g.Uri = uri
	g.require(githubPublishFieldUri)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetToken(token *string) {
	g.Token = token
	g.require(githubPublishFieldToken)
}

// SetMode sets the Mode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetMode(mode *string) {
	g.Mode = mode
	g.require(githubPublishFieldMode)
}

// SetTarget sets the Target field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubPublish) SetTarget(target *PublishTarget) {
	g.Target = target
	g.require(githubPublishFieldTarget)
}

func (g *GithubPublish) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubPublish
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubPublish(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GithubPublish) MarshalJSON() ([]byte, error) {
	type embed GithubPublish
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GithubPublish) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	mavenPublishTargetFieldCoordinate                  = big.NewInt(1 << 0)
	mavenPublishTargetFieldVersion                     = big.NewInt(1 << 1)
	mavenPublishTargetFieldUsernameEnvironmentVariable = big.NewInt(1 << 2)
	mavenPublishTargetFieldPasswordEnvironmentVariable = big.NewInt(1 << 3)
	mavenPublishTargetFieldMavenUrlEnvironmentVariable = big.NewInt(1 << 4)
)

type MavenPublishTarget struct {
	Coordinate                  *string `json:"coordinate,omitempty" url:"coordinate,omitempty"`
	Version                     *string `json:"version,omitempty" url:"version,omitempty"`
	UsernameEnvironmentVariable string  `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable string  `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	MavenUrlEnvironmentVariable string  `json:"mavenUrlEnvironmentVariable" url:"mavenUrlEnvironmentVariable"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenPublishTarget) GetCoordinate() *string {
	if m == nil {
		return nil
	}
	return m.Coordinate
}

func (m *MavenPublishTarget) GetVersion() *string {
	if m == nil {
		return nil
	}
	return m.Version
}

func (m *MavenPublishTarget) GetUsernameEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.UsernameEnvironmentVariable
}

func (m *MavenPublishTarget) GetPasswordEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenPublishTarget) GetMavenUrlEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.MavenUrlEnvironmentVariable
}

func (m *MavenPublishTarget) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishTarget) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetCoordinate sets the Coordinate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishTarget) SetCoordinate(coordinate *string) {
	m.Coordinate = coordinate
	m.require(mavenPublishTargetFieldCoordinate)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishTarget) SetVersion(version *string) {
	m.Version = version
	m.require(mavenPublishTargetFieldVersion)
}

// SetUsernameEnvironmentVariable sets the UsernameEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishTarget) SetUsernameEnvironmentVariable(usernameEnvironmentVariable string) {
	m.UsernameEnvironmentVariable = usernameEnvironmentVariable
	m.require(mavenPublishTargetFieldUsernameEnvironmentVariable)
}

// SetPasswordEnvironmentVariable sets the PasswordEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishTarget) SetPasswordEnvironmentVariable(passwordEnvironmentVariable string) {
	m.PasswordEnvironmentVariable = passwordEnvironmentVariable
	m.require(mavenPublishTargetFieldPasswordEnvironmentVariable)
}

// SetMavenUrlEnvironmentVariable sets the MavenUrlEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishTarget) SetMavenUrlEnvironmentVariable(mavenUrlEnvironmentVariable string) {
	m.MavenUrlEnvironmentVariable = mavenUrlEnvironmentVariable
	m.require(mavenPublishTargetFieldMavenUrlEnvironmentVariable)
}

func (m *MavenPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenPublishTarget) MarshalJSON() ([]byte, error) {
	type embed MavenPublishTarget
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenPublishTarget) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	npmPublishTargetFieldVersion                  = big.NewInt(1 << 0)
	npmPublishTargetFieldPackageName              = big.NewInt(1 << 1)
	npmPublishTargetFieldTokenEnvironmentVariable = big.NewInt(1 << 2)
)

type NpmPublishTarget struct {
	Version                  *string `json:"version,omitempty" url:"version,omitempty"`
	PackageName              *string `json:"packageName,omitempty" url:"packageName,omitempty"`
	TokenEnvironmentVariable string  `json:"tokenEnvironmentVariable" url:"tokenEnvironmentVariable"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NpmPublishTarget) GetVersion() *string {
	if n == nil {
		return nil
	}
	return n.Version
}

func (n *NpmPublishTarget) GetPackageName() *string {
	if n == nil {
		return nil
	}
	return n.PackageName
}

func (n *NpmPublishTarget) GetTokenEnvironmentVariable() string {
	if n == nil {
		return ""
	}
	return n.TokenEnvironmentVariable
}

func (n *NpmPublishTarget) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishTarget) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishTarget) SetVersion(version *string) {
	n.Version = version
	n.require(npmPublishTargetFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishTarget) SetPackageName(packageName *string) {
	n.PackageName = packageName
	n.require(npmPublishTargetFieldPackageName)
}

// SetTokenEnvironmentVariable sets the TokenEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishTarget) SetTokenEnvironmentVariable(tokenEnvironmentVariable string) {
	n.TokenEnvironmentVariable = tokenEnvironmentVariable
	n.require(npmPublishTargetFieldTokenEnvironmentVariable)
}

func (n *NpmPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmPublishTarget) MarshalJSON() ([]byte, error) {
	type embed NpmPublishTarget
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmPublishTarget) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	postmanPublishTargetFieldApiKey       = big.NewInt(1 << 0)
	postmanPublishTargetFieldWorkspaceId  = big.NewInt(1 << 1)
	postmanPublishTargetFieldCollectionId = big.NewInt(1 << 2)
)

type PostmanPublishTarget struct {
	ApiKey       string  `json:"apiKey" url:"apiKey"`
	WorkspaceId  string  `json:"workspaceId" url:"workspaceId"`
	CollectionId *string `json:"collectionId,omitempty" url:"collectionId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PostmanPublishTarget) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PostmanPublishTarget) GetWorkspaceId() string {
	if p == nil {
		return ""
	}
	return p.WorkspaceId
}

func (p *PostmanPublishTarget) GetCollectionId() *string {
	if p == nil {
		return nil
	}
	return p.CollectionId
}

func (p *PostmanPublishTarget) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanPublishTarget) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetApiKey sets the ApiKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanPublishTarget) SetApiKey(apiKey string) {
	p.ApiKey = apiKey
	p.require(postmanPublishTargetFieldApiKey)
}

// SetWorkspaceId sets the WorkspaceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanPublishTarget) SetWorkspaceId(workspaceId string) {
	p.WorkspaceId = workspaceId
	p.require(postmanPublishTargetFieldWorkspaceId)
}

// SetCollectionId sets the CollectionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanPublishTarget) SetCollectionId(collectionId *string) {
	p.CollectionId = collectionId
	p.require(postmanPublishTargetFieldCollectionId)
}

func (p *PostmanPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanPublishTarget) MarshalJSON() ([]byte, error) {
	type embed PostmanPublishTarget
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PostmanPublishTarget) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PublishTarget struct {
	Type    string
	Postman *PostmanPublishTarget
	Npm     *NpmPublishTarget
	Maven   *MavenPublishTarget
	Pypi    *PypiPublishTarget
}

func (p *PublishTarget) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishTarget) GetPostman() *PostmanPublishTarget {
	if p == nil {
		return nil
	}
	return p.Postman
}

func (p *PublishTarget) GetNpm() *NpmPublishTarget {
	if p == nil {
		return nil
	}
	return p.Npm
}

func (p *PublishTarget) GetMaven() *MavenPublishTarget {
	if p == nil {
		return nil
	}
	return p.Maven
}

func (p *PublishTarget) GetPypi() *PypiPublishTarget {
	if p == nil {
		return nil
	}
	return p.Pypi
}

func (p *PublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "postman":
		value := new(PostmanPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Postman = value
	case "npm":
		value := new(NpmPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "maven":
		value := new(MavenPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "pypi":
		value := new(PypiPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Pypi = value
	}
	return nil
}

func (p PublishTarget) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(p.Postman, "type", "postman")
	}
	if p.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(p.Npm, "type", "npm")
	}
	if p.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(p.Maven, "type", "maven")
	}
	if p.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(p.Pypi, "type", "pypi")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishTargetVisitor interface {
	VisitPostman(*PostmanPublishTarget) error
	VisitNpm(*NpmPublishTarget) error
	VisitMaven(*MavenPublishTarget) error
	VisitPypi(*PypiPublishTarget) error
}

func (p *PublishTarget) Accept(visitor PublishTargetVisitor) error {
	if p.Postman != nil {
		return visitor.VisitPostman(p.Postman)
	}
	if p.Npm != nil {
		return visitor.VisitNpm(p.Npm)
	}
	if p.Maven != nil {
		return visitor.VisitMaven(p.Maven)
	}
	if p.Pypi != nil {
		return visitor.VisitPypi(p.Pypi)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishTarget) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Postman != nil {
		fields = append(fields, "postman")
	}
	if p.Npm != nil {
		fields = append(fields, "npm")
	}
	if p.Maven != nil {
		fields = append(fields, "maven")
	}
	if p.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PublishingConfig struct {
	Type string
	// Publish via syncing to a GitHub repo and triggering GitHub workflows
	Github *GithubPublish
	// Publish directly from the generator
	Direct *DirectPublish
	// Do not publish anywhere but deposit files in the local filesystem
	Filesystem *Filesystem
}

func (p *PublishingConfig) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishingConfig) GetGithub() *GithubPublish {
	if p == nil {
		return nil
	}
	return p.Github
}

func (p *PublishingConfig) GetDirect() *DirectPublish {
	if p == nil {
		return nil
	}
	return p.Direct
}

func (p *PublishingConfig) GetFilesystem() *Filesystem {
	if p == nil {
		return nil
	}
	return p.Filesystem
}

func (p *PublishingConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "github":
		value := new(GithubPublish)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Github = value
	case "direct":
		value := new(DirectPublish)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Direct = value
	case "filesystem":
		value := new(Filesystem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Filesystem = value
	}
	return nil
}

func (p PublishingConfig) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Github != nil {
		return internal.MarshalJSONWithExtraProperty(p.Github, "type", "github")
	}
	if p.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(p.Direct, "type", "direct")
	}
	if p.Filesystem != nil {
		return internal.MarshalJSONWithExtraProperty(p.Filesystem, "type", "filesystem")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishingConfigVisitor interface {
	VisitGithub(*GithubPublish) error
	VisitDirect(*DirectPublish) error
	VisitFilesystem(*Filesystem) error
}

func (p *PublishingConfig) Accept(visitor PublishingConfigVisitor) error {
	if p.Github != nil {
		return visitor.VisitGithub(p.Github)
	}
	if p.Direct != nil {
		return visitor.VisitDirect(p.Direct)
	}
	if p.Filesystem != nil {
		return visitor.VisitFilesystem(p.Filesystem)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishingConfig) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Github != nil {
		fields = append(fields, "github")
	}
	if p.Direct != nil {
		fields = append(fields, "direct")
	}
	if p.Filesystem != nil {
		fields = append(fields, "filesystem")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

var (
	pypiPublishTargetFieldVersion     = big.NewInt(1 << 0)
	pypiPublishTargetFieldPackageName = big.NewInt(1 << 1)
)

type PypiPublishTarget struct {
	Version     *string `json:"version,omitempty" url:"version,omitempty"`
	PackageName *string `json:"packageName,omitempty" url:"packageName,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PypiPublishTarget) GetVersion() *string {
	if p == nil {
		return nil
	}
	return p.Version
}

func (p *PypiPublishTarget) GetPackageName() *string {
	if p == nil {
		return nil
	}
	return p.PackageName
}

func (p *PypiPublishTarget) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishTarget) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiPublishTarget) SetVersion(version *string) {
	p.Version = version
	p.require(pypiPublishTargetFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiPublishTarget) SetPackageName(packageName *string) {
	p.PackageName = packageName
	p.require(pypiPublishTargetFieldPackageName)
}

func (p *PypiPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiPublishTarget) MarshalJSON() ([]byte, error) {
	type embed PypiPublishTarget
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PypiPublishTarget) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

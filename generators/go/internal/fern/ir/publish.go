// Code generated by Fern. DO NOT EDIT.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type DirectPublish struct {
	Target *PublishTarget `json:"target" url:"target"`

	extraProperties map[string]interface{}
}

func (d *DirectPublish) GetTarget() *PublishTarget {
	if d == nil {
		return nil
	}
	return d.Target
}

func (d *DirectPublish) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DirectPublish) UnmarshalJSON(data []byte) error {
	type unmarshaler DirectPublish
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DirectPublish(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DirectPublish) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type Filesystem struct {
	// If true, will generate the entire project (pyproject.toml, package.json, etc)
	GenerateFullProject bool           `json:"generateFullProject" url:"generateFullProject"`
	PublishTarget       *PublishTarget `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`

	extraProperties map[string]interface{}
}

func (f *Filesystem) GetGenerateFullProject() bool {
	if f == nil {
		return false
	}
	return f.GenerateFullProject
}

func (f *Filesystem) GetPublishTarget() *PublishTarget {
	if f == nil {
		return nil
	}
	return f.PublishTarget
}

func (f *Filesystem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Filesystem) UnmarshalJSON(data []byte) error {
	type unmarshaler Filesystem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Filesystem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *Filesystem) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GithubPublish struct {
	Owner  string         `json:"owner" url:"owner"`
	Repo   string         `json:"repo" url:"repo"`
	Uri    *string        `json:"uri,omitempty" url:"uri,omitempty"`
	Token  *string        `json:"token,omitempty" url:"token,omitempty"`
	Target *PublishTarget `json:"target" url:"target"`

	extraProperties map[string]interface{}
}

func (g *GithubPublish) GetOwner() string {
	if g == nil {
		return ""
	}
	return g.Owner
}

func (g *GithubPublish) GetRepo() string {
	if g == nil {
		return ""
	}
	return g.Repo
}

func (g *GithubPublish) GetUri() *string {
	if g == nil {
		return nil
	}
	return g.Uri
}

func (g *GithubPublish) GetToken() *string {
	if g == nil {
		return nil
	}
	return g.Token
}

func (g *GithubPublish) GetTarget() *PublishTarget {
	if g == nil {
		return nil
	}
	return g.Target
}

func (g *GithubPublish) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubPublish) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubPublish
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubPublish(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GithubPublish) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type MavenPublishTarget struct {
	Coordinate                  *string `json:"coordinate,omitempty" url:"coordinate,omitempty"`
	Version                     *string `json:"version,omitempty" url:"version,omitempty"`
	UsernameEnvironmentVariable string  `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable string  `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	MavenUrlEnvironmentVariable string  `json:"mavenUrlEnvironmentVariable" url:"mavenUrlEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (m *MavenPublishTarget) GetCoordinate() *string {
	if m == nil {
		return nil
	}
	return m.Coordinate
}

func (m *MavenPublishTarget) GetVersion() *string {
	if m == nil {
		return nil
	}
	return m.Version
}

func (m *MavenPublishTarget) GetUsernameEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.UsernameEnvironmentVariable
}

func (m *MavenPublishTarget) GetPasswordEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenPublishTarget) GetMavenUrlEnvironmentVariable() string {
	if m == nil {
		return ""
	}
	return m.MavenUrlEnvironmentVariable
}

func (m *MavenPublishTarget) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenPublishTarget) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmPublishTarget struct {
	Version                  *string `json:"version,omitempty" url:"version,omitempty"`
	PackageName              *string `json:"packageName,omitempty" url:"packageName,omitempty"`
	TokenEnvironmentVariable string  `json:"tokenEnvironmentVariable" url:"tokenEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (n *NpmPublishTarget) GetVersion() *string {
	if n == nil {
		return nil
	}
	return n.Version
}

func (n *NpmPublishTarget) GetPackageName() *string {
	if n == nil {
		return nil
	}
	return n.PackageName
}

func (n *NpmPublishTarget) GetTokenEnvironmentVariable() string {
	if n == nil {
		return ""
	}
	return n.TokenEnvironmentVariable
}

func (n *NpmPublishTarget) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmPublishTarget) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PostmanPublishTarget struct {
	ApiKey       string  `json:"apiKey" url:"apiKey"`
	WorkspaceId  string  `json:"workspaceId" url:"workspaceId"`
	CollectionId *string `json:"collectionId,omitempty" url:"collectionId,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PostmanPublishTarget) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PostmanPublishTarget) GetWorkspaceId() string {
	if p == nil {
		return ""
	}
	return p.WorkspaceId
}

func (p *PostmanPublishTarget) GetCollectionId() *string {
	if p == nil {
		return nil
	}
	return p.CollectionId
}

func (p *PostmanPublishTarget) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanPublishTarget) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PublishTarget struct {
	Type    string
	Postman *PostmanPublishTarget
	Npm     *NpmPublishTarget
	Maven   *MavenPublishTarget
	Pypi    *PypiPublishTarget
}

func (p *PublishTarget) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishTarget) GetPostman() *PostmanPublishTarget {
	if p == nil {
		return nil
	}
	return p.Postman
}

func (p *PublishTarget) GetNpm() *NpmPublishTarget {
	if p == nil {
		return nil
	}
	return p.Npm
}

func (p *PublishTarget) GetMaven() *MavenPublishTarget {
	if p == nil {
		return nil
	}
	return p.Maven
}

func (p *PublishTarget) GetPypi() *PypiPublishTarget {
	if p == nil {
		return nil
	}
	return p.Pypi
}

func (p *PublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "postman":
		value := new(PostmanPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Postman = value
	case "npm":
		value := new(NpmPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "maven":
		value := new(MavenPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "pypi":
		value := new(PypiPublishTarget)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Pypi = value
	}
	return nil
}

func (p PublishTarget) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(p.Postman, "type", "postman")
	}
	if p.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(p.Npm, "type", "npm")
	}
	if p.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(p.Maven, "type", "maven")
	}
	if p.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(p.Pypi, "type", "pypi")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishTargetVisitor interface {
	VisitPostman(*PostmanPublishTarget) error
	VisitNpm(*NpmPublishTarget) error
	VisitMaven(*MavenPublishTarget) error
	VisitPypi(*PypiPublishTarget) error
}

func (p *PublishTarget) Accept(visitor PublishTargetVisitor) error {
	if p.Postman != nil {
		return visitor.VisitPostman(p.Postman)
	}
	if p.Npm != nil {
		return visitor.VisitNpm(p.Npm)
	}
	if p.Maven != nil {
		return visitor.VisitMaven(p.Maven)
	}
	if p.Pypi != nil {
		return visitor.VisitPypi(p.Pypi)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishTarget) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Postman != nil {
		fields = append(fields, "postman")
	}
	if p.Npm != nil {
		fields = append(fields, "npm")
	}
	if p.Maven != nil {
		fields = append(fields, "maven")
	}
	if p.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PublishingConfig struct {
	Type string
	// Publish via syncing to a GitHub repo and triggering GitHub workflows
	Github *GithubPublish
	// Publish directly from the generator
	Direct *DirectPublish
	// Do not publish anywhere but deposit files in the local filesystem
	Filesystem *Filesystem
}

func (p *PublishingConfig) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishingConfig) GetGithub() *GithubPublish {
	if p == nil {
		return nil
	}
	return p.Github
}

func (p *PublishingConfig) GetDirect() *DirectPublish {
	if p == nil {
		return nil
	}
	return p.Direct
}

func (p *PublishingConfig) GetFilesystem() *Filesystem {
	if p == nil {
		return nil
	}
	return p.Filesystem
}

func (p *PublishingConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "github":
		value := new(GithubPublish)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Github = value
	case "direct":
		value := new(DirectPublish)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Direct = value
	case "filesystem":
		value := new(Filesystem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Filesystem = value
	}
	return nil
}

func (p PublishingConfig) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Github != nil {
		return internal.MarshalJSONWithExtraProperty(p.Github, "type", "github")
	}
	if p.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(p.Direct, "type", "direct")
	}
	if p.Filesystem != nil {
		return internal.MarshalJSONWithExtraProperty(p.Filesystem, "type", "filesystem")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishingConfigVisitor interface {
	VisitGithub(*GithubPublish) error
	VisitDirect(*DirectPublish) error
	VisitFilesystem(*Filesystem) error
}

func (p *PublishingConfig) Accept(visitor PublishingConfigVisitor) error {
	if p.Github != nil {
		return visitor.VisitGithub(p.Github)
	}
	if p.Direct != nil {
		return visitor.VisitDirect(p.Direct)
	}
	if p.Filesystem != nil {
		return visitor.VisitFilesystem(p.Filesystem)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishingConfig) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Github != nil {
		fields = append(fields, "github")
	}
	if p.Direct != nil {
		fields = append(fields, "direct")
	}
	if p.Filesystem != nil {
		fields = append(fields, "filesystem")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PypiPublishTarget struct {
	Version     *string `json:"version,omitempty" url:"version,omitempty"`
	PackageName *string `json:"packageName,omitempty" url:"packageName,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiPublishTarget) GetVersion() *string {
	if p == nil {
		return nil
	}
	return p.Version
}

func (p *PypiPublishTarget) GetPackageName() *string {
	if p == nil {
		return nil
	}
	return p.PackageName
}

func (p *PypiPublishTarget) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiPublishTarget) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

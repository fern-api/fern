// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type CsharpProtobufFileOptions struct {
	// Populated by the `csharp_namespace` file option, e.g.
	//
	// ```protobuf
	// option csharp_namespace = Grpc.Health.V1;
	// ```
	//
	// This is used to determine what import path is required to reference the
	// associated type(s).
	Namespace string `json:"namespace" url:"namespace"`

	extraProperties map[string]interface{}
}

func (c *CsharpProtobufFileOptions) GetNamespace() string {
	if c == nil {
		return ""
	}
	return c.Namespace
}

func (c *CsharpProtobufFileOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CsharpProtobufFileOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CsharpProtobufFileOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CsharpProtobufFileOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CsharpProtobufFileOptions) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ProtobufFile struct {
	// The `.proto` source path, relative to the Protobuf root directory.
	// This is how the file is referenced in `import` statements.
	Filepath string `json:"filepath" url:"filepath"`
	// The `.proto` package name. If not specified, a package name was not declared.
	PackageName *string `json:"packageName,omitempty" url:"packageName,omitempty"`
	// Specifies a variety of language-specific options.
	Options *ProtobufFileOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
}

func (p *ProtobufFile) GetFilepath() string {
	if p == nil {
		return ""
	}
	return p.Filepath
}

func (p *ProtobufFile) GetPackageName() *string {
	if p == nil {
		return nil
	}
	return p.PackageName
}

func (p *ProtobufFile) GetOptions() *ProtobufFileOptions {
	if p == nil {
		return nil
	}
	return p.Options
}

func (p *ProtobufFile) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtobufFile) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtobufFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtobufFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtobufFile) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProtobufFileOptions struct {
	Csharp *CsharpProtobufFileOptions `json:"csharp,omitempty" url:"csharp,omitempty"`

	extraProperties map[string]interface{}
}

func (p *ProtobufFileOptions) GetCsharp() *CsharpProtobufFileOptions {
	if p == nil {
		return nil
	}
	return p.Csharp
}

func (p *ProtobufFileOptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtobufFileOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtobufFileOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtobufFileOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtobufFileOptions) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Defines the information related to a Protobuf service declaration. This is
// primarily meant to be used to instantiate the internal gRPC client used by
// the SDK.
//
// For example, consider the following C# snippet which instantiates a
// `UserService` gRPC client:
//
// ```csharp
// using User.Grpc;
//
// public class RawGrpcClient
//
//	{
//	    public UserService.UserServiceClient UserServiceClient;
//
//	    public RawGrpcClient(...)
//	    {
//	        GrpcChannel channel = GrpcChannel.ForAddress(...);
//	        UserServiceClient = new UserService.UserServiceClient(channel);
//	    }
//	}
//
// ```
type ProtobufService struct {
	// The `.proto` source file that defines this service.
	File *ProtobufFile `json:"file,omitempty" url:"file,omitempty"`
	// The name of the service defined in the `.proto` file (e.g. UserService).
	Name *Name `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (p *ProtobufService) GetFile() *ProtobufFile {
	if p == nil {
		return nil
	}
	return p.File
}

func (p *ProtobufService) GetName() *Name {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *ProtobufService) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtobufService) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtobufService
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtobufService(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtobufService) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A Protobuf type declaration.
type ProtobufType struct {
	Type        string
	WellKnown   *WellKnownProtobufType
	UserDefined *UserDefinedProtobufType
}

func NewProtobufTypeFromWellKnown(value *WellKnownProtobufType) *ProtobufType {
	return &ProtobufType{Type: "wellKnown", WellKnown: value}
}

func NewProtobufTypeFromUserDefined(value *UserDefinedProtobufType) *ProtobufType {
	return &ProtobufType{Type: "userDefined", UserDefined: value}
}

func (p *ProtobufType) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *ProtobufType) GetWellKnown() *WellKnownProtobufType {
	if p == nil {
		return nil
	}
	return p.WellKnown
}

func (p *ProtobufType) GetUserDefined() *UserDefinedProtobufType {
	if p == nil {
		return nil
	}
	return p.UserDefined
}

func (p *ProtobufType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "wellKnown":
		var valueUnmarshaler struct {
			WellKnown *WellKnownProtobufType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.WellKnown = valueUnmarshaler.WellKnown
	case "userDefined":
		value := new(UserDefinedProtobufType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.UserDefined = value
	}
	return nil
}

func (p ProtobufType) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "wellKnown":
		var marshaler = struct {
			Type      string                 `json:"type"`
			WellKnown *WellKnownProtobufType `json:"value,omitempty"`
		}{
			Type:      "wellKnown",
			WellKnown: p.WellKnown,
		}
		return json.Marshal(marshaler)
	case "userDefined":
		return internal.MarshalJSONWithExtraProperty(p.UserDefined, "type", "userDefined")
	}
}

type ProtobufTypeVisitor interface {
	VisitWellKnown(*WellKnownProtobufType) error
	VisitUserDefined(*UserDefinedProtobufType) error
}

func (p *ProtobufType) Accept(visitor ProtobufTypeVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "wellKnown":
		return visitor.VisitWellKnown(p.WellKnown)
	case "userDefined":
		return visitor.VisitUserDefined(p.UserDefined)
	}
}

func (p *ProtobufType) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.WellKnown != nil {
		fields = append(fields, "wellKnown")
	}
	if p.UserDefined != nil {
		fields = append(fields, "userDefined")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Defines the information related to the original `.proto` source file
// that defines this type. This is primarily meant to be used to generate
// Protobuf mapper methods, which are used in gRPC-compatbile SDKs.
//
// For example, consider the following Go snippet which requires the
// `go_package` setting:
//
// ```go
// import "github.com/acme/acme-go/proto"
//
//	type GetUserRequest struct {
//	  Username string
//	  Email    string
//	}
//
//	func (u *GetUserRequest) ToProto() *proto.GetUserRequest {
//	  if u == nil {
//	    return nil
//	  }
//	  return &proto.GetUserRequest{
//	    Username u.Username,
//	    Email:   u.Email,
//	  }
//	}
//
// ```
type UserDefinedProtobufType struct {
	// The `.proto` source file that defines this type.
	File *ProtobufFile `json:"file,omitempty" url:"file,omitempty"`
	// This name is _usually_ equivalent to the associated DeclaredTypeName's name.
	// However, its repeated here just in case the naming convention differs, which
	// is most relevant for APIs that specify `smart-casing`.
	Name *Name `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UserDefinedProtobufType) GetFile() *ProtobufFile {
	if u == nil {
		return nil
	}
	return u.File
}

func (u *UserDefinedProtobufType) GetName() *Name {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UserDefinedProtobufType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserDefinedProtobufType) UnmarshalJSON(data []byte) error {
	type unmarshaler UserDefinedProtobufType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserDefinedProtobufType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserDefinedProtobufType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The set of well-known types supported by Protobuf. These types are often included
// in the target runtime library, so they usually require special handling.
//
// The full list of well-known types can be found at https://protobuf.dev/reference/protobuf/google.protobuf
type WellKnownProtobufType struct {
	Type             string
	Any              interface{}
	Api              interface{}
	BoolValue        interface{}
	BytesValue       interface{}
	DoubleValue      interface{}
	Duration         interface{}
	Empty            interface{}
	Enum             interface{}
	EnumValue        interface{}
	Field            interface{}
	FieldCardinality interface{}
	FieldKind        interface{}
	FieldMask        interface{}
	FloatValue       interface{}
	Int32Value       interface{}
	Int64Value       interface{}
	ListValue        interface{}
	Method           interface{}
	Mixin            interface{}
	NullValue        interface{}
	Option           interface{}
	SourceContext    interface{}
	StringValue      interface{}
	Struct           interface{}
	Syntax           interface{}
	Timestamp        interface{}
	Type_            interface{}
	Uint32Value      interface{}
	Uint64Value      interface{}
	Value            interface{}
}

func NewWellKnownProtobufTypeFromAny(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "any", Any: value}
}

func NewWellKnownProtobufTypeFromApi(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "api", Api: value}
}

func NewWellKnownProtobufTypeFromBoolValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "boolValue", BoolValue: value}
}

func NewWellKnownProtobufTypeFromBytesValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "bytesValue", BytesValue: value}
}

func NewWellKnownProtobufTypeFromDoubleValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "doubleValue", DoubleValue: value}
}

func NewWellKnownProtobufTypeFromDuration(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "duration", Duration: value}
}

func NewWellKnownProtobufTypeFromEmpty(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "empty", Empty: value}
}

func NewWellKnownProtobufTypeFromEnum(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "enum", Enum: value}
}

func NewWellKnownProtobufTypeFromEnumValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "enumValue", EnumValue: value}
}

func NewWellKnownProtobufTypeFromField(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "field", Field: value}
}

func NewWellKnownProtobufTypeFromFieldCardinality(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "fieldCardinality", FieldCardinality: value}
}

func NewWellKnownProtobufTypeFromFieldKind(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "fieldKind", FieldKind: value}
}

func NewWellKnownProtobufTypeFromFieldMask(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "fieldMask", FieldMask: value}
}

func NewWellKnownProtobufTypeFromFloatValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "floatValue", FloatValue: value}
}

func NewWellKnownProtobufTypeFromInt32Value(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "int32Value", Int32Value: value}
}

func NewWellKnownProtobufTypeFromInt64Value(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "int64Value", Int64Value: value}
}

func NewWellKnownProtobufTypeFromListValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "listValue", ListValue: value}
}

func NewWellKnownProtobufTypeFromMethod(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "method", Method: value}
}

func NewWellKnownProtobufTypeFromMixin(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "mixin", Mixin: value}
}

func NewWellKnownProtobufTypeFromNullValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "nullValue", NullValue: value}
}

func NewWellKnownProtobufTypeFromOption(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "option", Option: value}
}

func NewWellKnownProtobufTypeFromSourceContext(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "sourceContext", SourceContext: value}
}

func NewWellKnownProtobufTypeFromStringValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "stringValue", StringValue: value}
}

func NewWellKnownProtobufTypeFromStruct(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "struct", Struct: value}
}

func NewWellKnownProtobufTypeFromSyntax(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "syntax", Syntax: value}
}

func NewWellKnownProtobufTypeFromTimestamp(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "timestamp", Timestamp: value}
}

func NewWellKnownProtobufTypeFromType(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "type", Type_: value}
}

func NewWellKnownProtobufTypeFromUint32Value(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "uint32Value", Uint32Value: value}
}

func NewWellKnownProtobufTypeFromUint64Value(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "uint64Value", Uint64Value: value}
}

func NewWellKnownProtobufTypeFromValue(value interface{}) *WellKnownProtobufType {
	return &WellKnownProtobufType{Type: "value", Value: value}
}

func (w *WellKnownProtobufType) GetType() string {
	if w == nil {
		return ""
	}
	return w.Type
}

func (w *WellKnownProtobufType) GetAny() interface{} {
	if w == nil {
		return nil
	}
	return w.Any
}

func (w *WellKnownProtobufType) GetApi() interface{} {
	if w == nil {
		return nil
	}
	return w.Api
}

func (w *WellKnownProtobufType) GetBoolValue() interface{} {
	if w == nil {
		return nil
	}
	return w.BoolValue
}

func (w *WellKnownProtobufType) GetBytesValue() interface{} {
	if w == nil {
		return nil
	}
	return w.BytesValue
}

func (w *WellKnownProtobufType) GetDoubleValue() interface{} {
	if w == nil {
		return nil
	}
	return w.DoubleValue
}

func (w *WellKnownProtobufType) GetDuration() interface{} {
	if w == nil {
		return nil
	}
	return w.Duration
}

func (w *WellKnownProtobufType) GetEmpty() interface{} {
	if w == nil {
		return nil
	}
	return w.Empty
}

func (w *WellKnownProtobufType) GetEnum() interface{} {
	if w == nil {
		return nil
	}
	return w.Enum
}

func (w *WellKnownProtobufType) GetEnumValue() interface{} {
	if w == nil {
		return nil
	}
	return w.EnumValue
}

func (w *WellKnownProtobufType) GetField() interface{} {
	if w == nil {
		return nil
	}
	return w.Field
}

func (w *WellKnownProtobufType) GetFieldCardinality() interface{} {
	if w == nil {
		return nil
	}
	return w.FieldCardinality
}

func (w *WellKnownProtobufType) GetFieldKind() interface{} {
	if w == nil {
		return nil
	}
	return w.FieldKind
}

func (w *WellKnownProtobufType) GetFieldMask() interface{} {
	if w == nil {
		return nil
	}
	return w.FieldMask
}

func (w *WellKnownProtobufType) GetFloatValue() interface{} {
	if w == nil {
		return nil
	}
	return w.FloatValue
}

func (w *WellKnownProtobufType) GetInt32Value() interface{} {
	if w == nil {
		return nil
	}
	return w.Int32Value
}

func (w *WellKnownProtobufType) GetInt64Value() interface{} {
	if w == nil {
		return nil
	}
	return w.Int64Value
}

func (w *WellKnownProtobufType) GetListValue() interface{} {
	if w == nil {
		return nil
	}
	return w.ListValue
}

func (w *WellKnownProtobufType) GetMethod() interface{} {
	if w == nil {
		return nil
	}
	return w.Method
}

func (w *WellKnownProtobufType) GetMixin() interface{} {
	if w == nil {
		return nil
	}
	return w.Mixin
}

func (w *WellKnownProtobufType) GetNullValue() interface{} {
	if w == nil {
		return nil
	}
	return w.NullValue
}

func (w *WellKnownProtobufType) GetOption() interface{} {
	if w == nil {
		return nil
	}
	return w.Option
}

func (w *WellKnownProtobufType) GetSourceContext() interface{} {
	if w == nil {
		return nil
	}
	return w.SourceContext
}

func (w *WellKnownProtobufType) GetStringValue() interface{} {
	if w == nil {
		return nil
	}
	return w.StringValue
}

func (w *WellKnownProtobufType) GetStruct() interface{} {
	if w == nil {
		return nil
	}
	return w.Struct
}

func (w *WellKnownProtobufType) GetSyntax() interface{} {
	if w == nil {
		return nil
	}
	return w.Syntax
}

func (w *WellKnownProtobufType) GetTimestamp() interface{} {
	if w == nil {
		return nil
	}
	return w.Timestamp
}

func (w *WellKnownProtobufType) GetType_() interface{} {
	if w == nil {
		return nil
	}
	return w.Type
}

func (w *WellKnownProtobufType) GetUint32Value() interface{} {
	if w == nil {
		return nil
	}
	return w.Uint32Value
}

func (w *WellKnownProtobufType) GetUint64Value() interface{} {
	if w == nil {
		return nil
	}
	return w.Uint64Value
}

func (w *WellKnownProtobufType) GetValue() interface{} {
	if w == nil {
		return nil
	}
	return w.Value
}

func (w *WellKnownProtobufType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", w)
	}
	switch unmarshaler.Type {
	case "any":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Any = value
	case "api":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Api = value
	case "boolValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.BoolValue = value
	case "bytesValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.BytesValue = value
	case "doubleValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.DoubleValue = value
	case "duration":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Duration = value
	case "empty":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Empty = value
	case "enum":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Enum = value
	case "enumValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.EnumValue = value
	case "field":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Field = value
	case "fieldCardinality":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.FieldCardinality = value
	case "fieldKind":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.FieldKind = value
	case "fieldMask":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.FieldMask = value
	case "floatValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.FloatValue = value
	case "int32Value":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Int32Value = value
	case "int64Value":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Int64Value = value
	case "listValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.ListValue = value
	case "method":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Method = value
	case "mixin":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Mixin = value
	case "nullValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.NullValue = value
	case "option":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Option = value
	case "sourceContext":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.SourceContext = value
	case "stringValue":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.StringValue = value
	case "struct":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Struct = value
	case "syntax":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Syntax = value
	case "timestamp":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Timestamp = value
	case "type":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Type_ = value
	case "uint32Value":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Uint32Value = value
	case "uint64Value":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Uint64Value = value
	case "value":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Value = value
	}
	return nil
}

func (w WellKnownProtobufType) MarshalJSON() ([]byte, error) {
	if err := w.validate(); err != nil {
		return nil, err
	}
	switch w.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "any":
		var marshaler = struct {
			Type string      `json:"type"`
			Any  interface{} `json:"any,omitempty"`
		}{
			Type: "any",
			Any:  w.Any,
		}
		return json.Marshal(marshaler)
	case "api":
		var marshaler = struct {
			Type string      `json:"type"`
			Api  interface{} `json:"api,omitempty"`
		}{
			Type: "api",
			Api:  w.Api,
		}
		return json.Marshal(marshaler)
	case "boolValue":
		var marshaler = struct {
			Type      string      `json:"type"`
			BoolValue interface{} `json:"boolValue,omitempty"`
		}{
			Type:      "boolValue",
			BoolValue: w.BoolValue,
		}
		return json.Marshal(marshaler)
	case "bytesValue":
		var marshaler = struct {
			Type       string      `json:"type"`
			BytesValue interface{} `json:"bytesValue,omitempty"`
		}{
			Type:       "bytesValue",
			BytesValue: w.BytesValue,
		}
		return json.Marshal(marshaler)
	case "doubleValue":
		var marshaler = struct {
			Type        string      `json:"type"`
			DoubleValue interface{} `json:"doubleValue,omitempty"`
		}{
			Type:        "doubleValue",
			DoubleValue: w.DoubleValue,
		}
		return json.Marshal(marshaler)
	case "duration":
		var marshaler = struct {
			Type     string      `json:"type"`
			Duration interface{} `json:"duration,omitempty"`
		}{
			Type:     "duration",
			Duration: w.Duration,
		}
		return json.Marshal(marshaler)
	case "empty":
		var marshaler = struct {
			Type  string      `json:"type"`
			Empty interface{} `json:"empty,omitempty"`
		}{
			Type:  "empty",
			Empty: w.Empty,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string      `json:"type"`
			Enum interface{} `json:"enum,omitempty"`
		}{
			Type: "enum",
			Enum: w.Enum,
		}
		return json.Marshal(marshaler)
	case "enumValue":
		var marshaler = struct {
			Type      string      `json:"type"`
			EnumValue interface{} `json:"enumValue,omitempty"`
		}{
			Type:      "enumValue",
			EnumValue: w.EnumValue,
		}
		return json.Marshal(marshaler)
	case "field":
		var marshaler = struct {
			Type  string      `json:"type"`
			Field interface{} `json:"field,omitempty"`
		}{
			Type:  "field",
			Field: w.Field,
		}
		return json.Marshal(marshaler)
	case "fieldCardinality":
		var marshaler = struct {
			Type             string      `json:"type"`
			FieldCardinality interface{} `json:"fieldCardinality,omitempty"`
		}{
			Type:             "fieldCardinality",
			FieldCardinality: w.FieldCardinality,
		}
		return json.Marshal(marshaler)
	case "fieldKind":
		var marshaler = struct {
			Type      string      `json:"type"`
			FieldKind interface{} `json:"fieldKind,omitempty"`
		}{
			Type:      "fieldKind",
			FieldKind: w.FieldKind,
		}
		return json.Marshal(marshaler)
	case "fieldMask":
		var marshaler = struct {
			Type      string      `json:"type"`
			FieldMask interface{} `json:"fieldMask,omitempty"`
		}{
			Type:      "fieldMask",
			FieldMask: w.FieldMask,
		}
		return json.Marshal(marshaler)
	case "floatValue":
		var marshaler = struct {
			Type       string      `json:"type"`
			FloatValue interface{} `json:"floatValue,omitempty"`
		}{
			Type:       "floatValue",
			FloatValue: w.FloatValue,
		}
		return json.Marshal(marshaler)
	case "int32Value":
		var marshaler = struct {
			Type       string      `json:"type"`
			Int32Value interface{} `json:"int32Value,omitempty"`
		}{
			Type:       "int32Value",
			Int32Value: w.Int32Value,
		}
		return json.Marshal(marshaler)
	case "int64Value":
		var marshaler = struct {
			Type       string      `json:"type"`
			Int64Value interface{} `json:"int64Value,omitempty"`
		}{
			Type:       "int64Value",
			Int64Value: w.Int64Value,
		}
		return json.Marshal(marshaler)
	case "listValue":
		var marshaler = struct {
			Type      string      `json:"type"`
			ListValue interface{} `json:"listValue,omitempty"`
		}{
			Type:      "listValue",
			ListValue: w.ListValue,
		}
		return json.Marshal(marshaler)
	case "method":
		var marshaler = struct {
			Type   string      `json:"type"`
			Method interface{} `json:"method,omitempty"`
		}{
			Type:   "method",
			Method: w.Method,
		}
		return json.Marshal(marshaler)
	case "mixin":
		var marshaler = struct {
			Type  string      `json:"type"`
			Mixin interface{} `json:"mixin,omitempty"`
		}{
			Type:  "mixin",
			Mixin: w.Mixin,
		}
		return json.Marshal(marshaler)
	case "nullValue":
		var marshaler = struct {
			Type      string      `json:"type"`
			NullValue interface{} `json:"nullValue,omitempty"`
		}{
			Type:      "nullValue",
			NullValue: w.NullValue,
		}
		return json.Marshal(marshaler)
	case "option":
		var marshaler = struct {
			Type   string      `json:"type"`
			Option interface{} `json:"option,omitempty"`
		}{
			Type:   "option",
			Option: w.Option,
		}
		return json.Marshal(marshaler)
	case "sourceContext":
		var marshaler = struct {
			Type          string      `json:"type"`
			SourceContext interface{} `json:"sourceContext,omitempty"`
		}{
			Type:          "sourceContext",
			SourceContext: w.SourceContext,
		}
		return json.Marshal(marshaler)
	case "stringValue":
		var marshaler = struct {
			Type        string      `json:"type"`
			StringValue interface{} `json:"stringValue,omitempty"`
		}{
			Type:        "stringValue",
			StringValue: w.StringValue,
		}
		return json.Marshal(marshaler)
	case "struct":
		var marshaler = struct {
			Type   string      `json:"type"`
			Struct interface{} `json:"struct,omitempty"`
		}{
			Type:   "struct",
			Struct: w.Struct,
		}
		return json.Marshal(marshaler)
	case "syntax":
		var marshaler = struct {
			Type   string      `json:"type"`
			Syntax interface{} `json:"syntax,omitempty"`
		}{
			Type:   "syntax",
			Syntax: w.Syntax,
		}
		return json.Marshal(marshaler)
	case "timestamp":
		var marshaler = struct {
			Type      string      `json:"type"`
			Timestamp interface{} `json:"timestamp,omitempty"`
		}{
			Type:      "timestamp",
			Timestamp: w.Timestamp,
		}
		return json.Marshal(marshaler)
	case "type":
		var marshaler = struct {
			Type  string      `json:"type"`
			Type_ interface{} `json:"type,omitempty"`
		}{
			Type:  "type",
			Type_: w.Type_,
		}
		return json.Marshal(marshaler)
	case "uint32Value":
		var marshaler = struct {
			Type        string      `json:"type"`
			Uint32Value interface{} `json:"uint32Value,omitempty"`
		}{
			Type:        "uint32Value",
			Uint32Value: w.Uint32Value,
		}
		return json.Marshal(marshaler)
	case "uint64Value":
		var marshaler = struct {
			Type        string      `json:"type"`
			Uint64Value interface{} `json:"uint64Value,omitempty"`
		}{
			Type:        "uint64Value",
			Uint64Value: w.Uint64Value,
		}
		return json.Marshal(marshaler)
	case "value":
		var marshaler = struct {
			Type  string      `json:"type"`
			Value interface{} `json:"value,omitempty"`
		}{
			Type:  "value",
			Value: w.Value,
		}
		return json.Marshal(marshaler)
	}
}

type WellKnownProtobufTypeVisitor interface {
	VisitAny(interface{}) error
	VisitApi(interface{}) error
	VisitBoolValue(interface{}) error
	VisitBytesValue(interface{}) error
	VisitDoubleValue(interface{}) error
	VisitDuration(interface{}) error
	VisitEmpty(interface{}) error
	VisitEnum(interface{}) error
	VisitEnumValue(interface{}) error
	VisitField(interface{}) error
	VisitFieldCardinality(interface{}) error
	VisitFieldKind(interface{}) error
	VisitFieldMask(interface{}) error
	VisitFloatValue(interface{}) error
	VisitInt32Value(interface{}) error
	VisitInt64Value(interface{}) error
	VisitListValue(interface{}) error
	VisitMethod(interface{}) error
	VisitMixin(interface{}) error
	VisitNullValue(interface{}) error
	VisitOption(interface{}) error
	VisitSourceContext(interface{}) error
	VisitStringValue(interface{}) error
	VisitStruct(interface{}) error
	VisitSyntax(interface{}) error
	VisitTimestamp(interface{}) error
	VisitType(interface{}) error
	VisitUint32Value(interface{}) error
	VisitUint64Value(interface{}) error
	VisitValue(interface{}) error
}

func (w *WellKnownProtobufType) Accept(visitor WellKnownProtobufTypeVisitor) error {
	switch w.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "any":
		return visitor.VisitAny(w.Any)
	case "api":
		return visitor.VisitApi(w.Api)
	case "boolValue":
		return visitor.VisitBoolValue(w.BoolValue)
	case "bytesValue":
		return visitor.VisitBytesValue(w.BytesValue)
	case "doubleValue":
		return visitor.VisitDoubleValue(w.DoubleValue)
	case "duration":
		return visitor.VisitDuration(w.Duration)
	case "empty":
		return visitor.VisitEmpty(w.Empty)
	case "enum":
		return visitor.VisitEnum(w.Enum)
	case "enumValue":
		return visitor.VisitEnumValue(w.EnumValue)
	case "field":
		return visitor.VisitField(w.Field)
	case "fieldCardinality":
		return visitor.VisitFieldCardinality(w.FieldCardinality)
	case "fieldKind":
		return visitor.VisitFieldKind(w.FieldKind)
	case "fieldMask":
		return visitor.VisitFieldMask(w.FieldMask)
	case "floatValue":
		return visitor.VisitFloatValue(w.FloatValue)
	case "int32Value":
		return visitor.VisitInt32Value(w.Int32Value)
	case "int64Value":
		return visitor.VisitInt64Value(w.Int64Value)
	case "listValue":
		return visitor.VisitListValue(w.ListValue)
	case "method":
		return visitor.VisitMethod(w.Method)
	case "mixin":
		return visitor.VisitMixin(w.Mixin)
	case "nullValue":
		return visitor.VisitNullValue(w.NullValue)
	case "option":
		return visitor.VisitOption(w.Option)
	case "sourceContext":
		return visitor.VisitSourceContext(w.SourceContext)
	case "stringValue":
		return visitor.VisitStringValue(w.StringValue)
	case "struct":
		return visitor.VisitStruct(w.Struct)
	case "syntax":
		return visitor.VisitSyntax(w.Syntax)
	case "timestamp":
		return visitor.VisitTimestamp(w.Timestamp)
	case "type":
		return visitor.VisitType(w.Type)
	case "uint32Value":
		return visitor.VisitUint32Value(w.Uint32Value)
	case "uint64Value":
		return visitor.VisitUint64Value(w.Uint64Value)
	case "value":
		return visitor.VisitValue(w.Value)
	}
}

func (w *WellKnownProtobufType) validate() error {
	if w == nil {
		return fmt.Errorf("type %T is nil", w)
	}
	var fields []string
	if w.Any != nil {
		fields = append(fields, "any")
	}
	if w.Api != nil {
		fields = append(fields, "api")
	}
	if w.BoolValue != nil {
		fields = append(fields, "boolValue")
	}
	if w.BytesValue != nil {
		fields = append(fields, "bytesValue")
	}
	if w.DoubleValue != nil {
		fields = append(fields, "doubleValue")
	}
	if w.Duration != nil {
		fields = append(fields, "duration")
	}
	if w.Empty != nil {
		fields = append(fields, "empty")
	}
	if w.Enum != nil {
		fields = append(fields, "enum")
	}
	if w.EnumValue != nil {
		fields = append(fields, "enumValue")
	}
	if w.Field != nil {
		fields = append(fields, "field")
	}
	if w.FieldCardinality != nil {
		fields = append(fields, "fieldCardinality")
	}
	if w.FieldKind != nil {
		fields = append(fields, "fieldKind")
	}
	if w.FieldMask != nil {
		fields = append(fields, "fieldMask")
	}
	if w.FloatValue != nil {
		fields = append(fields, "floatValue")
	}
	if w.Int32Value != nil {
		fields = append(fields, "int32Value")
	}
	if w.Int64Value != nil {
		fields = append(fields, "int64Value")
	}
	if w.ListValue != nil {
		fields = append(fields, "listValue")
	}
	if w.Method != nil {
		fields = append(fields, "method")
	}
	if w.Mixin != nil {
		fields = append(fields, "mixin")
	}
	if w.NullValue != nil {
		fields = append(fields, "nullValue")
	}
	if w.Option != nil {
		fields = append(fields, "option")
	}
	if w.SourceContext != nil {
		fields = append(fields, "sourceContext")
	}
	if w.StringValue != nil {
		fields = append(fields, "stringValue")
	}
	if w.Struct != nil {
		fields = append(fields, "struct")
	}
	if w.Syntax != nil {
		fields = append(fields, "syntax")
	}
	if w.Timestamp != nil {
		fields = append(fields, "timestamp")
	}
	if w.Type_ != nil {
		fields = append(fields, "type")
	}
	if w.Uint32Value != nil {
		fields = append(fields, "uint32Value")
	}
	if w.Uint64Value != nil {
		fields = append(fields, "uint64Value")
	}
	if w.Value != nil {
		fields = append(fields, "value")
	}
	if len(fields) == 0 {
		if w.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", w, w.Type)
		}
		return fmt.Errorf("type %T is empty", w)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", w, fields)
	}
	if w.Type != "" {
		field := fields[0]
		if w.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				w,
				w.Type,
				w,
			)
		}
	}
	return nil
}

// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type AutogeneratedEndpointExample struct {
	Example *ExampleEndpointCall `json:"example,omitempty" url:"example,omitempty"`

	extraProperties map[string]interface{}
}

func (a *AutogeneratedEndpointExample) GetExample() *ExampleEndpointCall {
	if a == nil {
		return nil
	}
	return a.Example
}

func (a *AutogeneratedEndpointExample) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutogeneratedEndpointExample) UnmarshalJSON(data []byte) error {
	type unmarshaler AutogeneratedEndpointExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutogeneratedEndpointExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AutogeneratedEndpointExample) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BytesRequest struct {
	Docs        *string `json:"docs,omitempty" url:"docs,omitempty"`
	IsOptional  bool    `json:"isOptional" url:"isOptional"`
	ContentType *string `json:"contentType,omitempty" url:"contentType,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BytesRequest) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BytesRequest) GetIsOptional() bool {
	if b == nil {
		return false
	}
	return b.IsOptional
}

func (b *BytesRequest) GetContentType() *string {
	if b == nil {
		return nil
	}
	return b.ContentType
}

func (b *BytesRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BytesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BytesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BytesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BytesRequest) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BytesResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BytesResponse) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BytesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BytesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BytesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BytesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BytesResponse) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// If set, the endpoint will be generated with auto-pagination features.
//
// The page must be defined as a property defined on the request, whereas
// the next page and results are resolved from properties defined on the
// response.
type CursorPagination struct {
	Page    *RequestProperty  `json:"page,omitempty" url:"page,omitempty"`
	Next    *ResponseProperty `json:"next,omitempty" url:"next,omitempty"`
	Results *ResponseProperty `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
}

func (c *CursorPagination) GetPage() *RequestProperty {
	if c == nil {
		return nil
	}
	return c.Page
}

func (c *CursorPagination) GetNext() *ResponseProperty {
	if c == nil {
		return nil
	}
	return c.Next
}

func (c *CursorPagination) GetResults() *ResponseProperty {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CursorPagination) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CursorPagination) UnmarshalJSON(data []byte) error {
	type unmarshaler CursorPagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CursorPagination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CursorPagination) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Pagination where the SDK author is responsible for implementing the pagination
// logic in the SDK.
type CustomPagination struct {
	// The response property is used to determine the results response type
	// generated in the endpoint.
	Results *ResponseProperty `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
}

func (c *CustomPagination) GetResults() *ResponseProperty {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CustomPagination) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPagination) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPagination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CustomPagination) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeclaredServiceName struct {
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredServiceName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredServiceName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredServiceName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredServiceName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredServiceName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredServiceName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointName = *Name

type ExampleCodeSample struct {
	Type     string
	Language *ExampleCodeSampleLanguage
	Sdk      *ExampleCodeSampleSdk
}

func NewExampleCodeSampleFromLanguage(value *ExampleCodeSampleLanguage) *ExampleCodeSample {
	return &ExampleCodeSample{Type: "language", Language: value}
}

func NewExampleCodeSampleFromSdk(value *ExampleCodeSampleSdk) *ExampleCodeSample {
	return &ExampleCodeSample{Type: "sdk", Sdk: value}
}

func (e *ExampleCodeSample) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleCodeSample) GetLanguage() *ExampleCodeSampleLanguage {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ExampleCodeSample) GetSdk() *ExampleCodeSampleSdk {
	if e == nil {
		return nil
	}
	return e.Sdk
}

func (e *ExampleCodeSample) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "language":
		value := new(ExampleCodeSampleLanguage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Language = value
	case "sdk":
		value := new(ExampleCodeSampleSdk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Sdk = value
	}
	return nil
}

func (e ExampleCodeSample) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "language":
		return internal.MarshalJSONWithExtraProperty(e.Language, "type", "language")
	case "sdk":
		return internal.MarshalJSONWithExtraProperty(e.Sdk, "type", "sdk")
	}
}

type ExampleCodeSampleVisitor interface {
	VisitLanguage(*ExampleCodeSampleLanguage) error
	VisitSdk(*ExampleCodeSampleSdk) error
}

func (e *ExampleCodeSample) Accept(visitor ExampleCodeSampleVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "language":
		return visitor.VisitLanguage(e.Language)
	case "sdk":
		return visitor.VisitSdk(e.Sdk)
	}
}

func (e *ExampleCodeSample) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Language != nil {
		fields = append(fields, "language")
	}
	if e.Sdk != nil {
		fields = append(fields, "sdk")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

// This is intended to co-exist with the auto-generated code samples.
type ExampleCodeSampleLanguage struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
	// Override the example name.
	Name     *Name  `json:"name,omitempty" url:"name,omitempty"`
	Language string `json:"language" url:"language"`
	Code     string `json:"code" url:"code"`
	// The command to install the dependencies for the code sample.
	// For example, `npm install` or `pip install -r requirements.txt`.
	Install *string `json:"install,omitempty" url:"install,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleCodeSampleLanguage) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleCodeSampleLanguage) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleCodeSampleLanguage) GetLanguage() string {
	if e == nil {
		return ""
	}
	return e.Language
}

func (e *ExampleCodeSampleLanguage) GetCode() string {
	if e == nil {
		return ""
	}
	return e.Code
}

func (e *ExampleCodeSampleLanguage) GetInstall() *string {
	if e == nil {
		return nil
	}
	return e.Install
}

func (e *ExampleCodeSampleLanguage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleCodeSampleLanguage) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleCodeSampleLanguage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleCodeSampleLanguage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleCodeSampleLanguage) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This will be used to replace the auto-generated code samples.
type ExampleCodeSampleSdk struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
	// Override the example name.
	Name *Name                `json:"name,omitempty" url:"name,omitempty"`
	Sdk  SupportedSdkLanguage `json:"sdk" url:"sdk"`
	Code string               `json:"code" url:"code"`

	extraProperties map[string]interface{}
}

func (e *ExampleCodeSampleSdk) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleCodeSampleSdk) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleCodeSampleSdk) GetSdk() SupportedSdkLanguage {
	if e == nil {
		return ""
	}
	return e.Sdk
}

func (e *ExampleCodeSampleSdk) GetCode() string {
	if e == nil {
		return ""
	}
	return e.Code
}

func (e *ExampleCodeSampleSdk) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleCodeSampleSdk) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleCodeSampleSdk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleCodeSampleSdk(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleCodeSampleSdk) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointCall struct {
	Docs                   *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Id                     *string                  `json:"id,omitempty" url:"id,omitempty"`
	Name                   *Name                    `json:"name,omitempty" url:"name,omitempty"`
	Url                    string                   `json:"url" url:"url"`
	RootPathParameters     []*ExamplePathParameter  `json:"rootPathParameters,omitempty" url:"rootPathParameters,omitempty"`
	ServicePathParameters  []*ExamplePathParameter  `json:"servicePathParameters,omitempty" url:"servicePathParameters,omitempty"`
	EndpointPathParameters []*ExamplePathParameter  `json:"endpointPathParameters,omitempty" url:"endpointPathParameters,omitempty"`
	ServiceHeaders         []*ExampleHeader         `json:"serviceHeaders,omitempty" url:"serviceHeaders,omitempty"`
	EndpointHeaders        []*ExampleHeader         `json:"endpointHeaders,omitempty" url:"endpointHeaders,omitempty"`
	QueryParameters        []*ExampleQueryParameter `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Request                *ExampleRequestBody      `json:"request,omitempty" url:"request,omitempty"`
	Response               *ExampleResponse         `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEndpointCall) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleEndpointCall) GetId() *string {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *ExampleEndpointCall) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleEndpointCall) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *ExampleEndpointCall) GetRootPathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.RootPathParameters
}

func (e *ExampleEndpointCall) GetServicePathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.ServicePathParameters
}

func (e *ExampleEndpointCall) GetEndpointPathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.EndpointPathParameters
}

func (e *ExampleEndpointCall) GetServiceHeaders() []*ExampleHeader {
	if e == nil {
		return nil
	}
	return e.ServiceHeaders
}

func (e *ExampleEndpointCall) GetEndpointHeaders() []*ExampleHeader {
	if e == nil {
		return nil
	}
	return e.EndpointHeaders
}

func (e *ExampleEndpointCall) GetQueryParameters() []*ExampleQueryParameter {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *ExampleEndpointCall) GetRequest() *ExampleRequestBody {
	if e == nil {
		return nil
	}
	return e.Request
}

func (e *ExampleEndpointCall) GetResponse() *ExampleResponse {
	if e == nil {
		return nil
	}
	return e.Response
}

func (e *ExampleEndpointCall) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEndpointCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEndpointCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEndpointCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEndpointCall) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointErrorResponse struct {
	Error *DeclaredErrorName    `json:"error,omitempty" url:"error,omitempty"`
	Body  *ExampleTypeReference `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEndpointErrorResponse) GetError() *DeclaredErrorName {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExampleEndpointErrorResponse) GetBody() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Body
}

func (e *ExampleEndpointErrorResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEndpointErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEndpointErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEndpointErrorResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEndpointErrorResponse) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointSuccessResponse struct {
	Type   string
	Body   *ExampleTypeReference
	Stream []*ExampleTypeReference
	Sse    []*ExampleServerSideEvent
}

func NewExampleEndpointSuccessResponseFromBody(value *ExampleTypeReference) *ExampleEndpointSuccessResponse {
	return &ExampleEndpointSuccessResponse{Type: "body", Body: value}
}

func NewExampleEndpointSuccessResponseFromStream(value []*ExampleTypeReference) *ExampleEndpointSuccessResponse {
	return &ExampleEndpointSuccessResponse{Type: "stream", Stream: value}
}

func NewExampleEndpointSuccessResponseFromSse(value []*ExampleServerSideEvent) *ExampleEndpointSuccessResponse {
	return &ExampleEndpointSuccessResponse{Type: "sse", Sse: value}
}

func (e *ExampleEndpointSuccessResponse) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleEndpointSuccessResponse) GetBody() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Body
}

func (e *ExampleEndpointSuccessResponse) GetStream() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Stream
}

func (e *ExampleEndpointSuccessResponse) GetSse() []*ExampleServerSideEvent {
	if e == nil {
		return nil
	}
	return e.Sse
}

func (e *ExampleEndpointSuccessResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "body":
		var valueUnmarshaler struct {
			Body *ExampleTypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Body = valueUnmarshaler.Body
	case "stream":
		var valueUnmarshaler struct {
			Stream []*ExampleTypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Stream = valueUnmarshaler.Stream
	case "sse":
		var valueUnmarshaler struct {
			Sse []*ExampleServerSideEvent `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Sse = valueUnmarshaler.Sse
	}
	return nil
}

func (e ExampleEndpointSuccessResponse) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "body":
		var marshaler = struct {
			Type string                `json:"type"`
			Body *ExampleTypeReference `json:"value,omitempty"`
		}{
			Type: "body",
			Body: e.Body,
		}
		return json.Marshal(marshaler)
	case "stream":
		var marshaler = struct {
			Type   string                  `json:"type"`
			Stream []*ExampleTypeReference `json:"value,omitempty"`
		}{
			Type:   "stream",
			Stream: e.Stream,
		}
		return json.Marshal(marshaler)
	case "sse":
		var marshaler = struct {
			Type string                    `json:"type"`
			Sse  []*ExampleServerSideEvent `json:"value,omitempty"`
		}{
			Type: "sse",
			Sse:  e.Sse,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleEndpointSuccessResponseVisitor interface {
	VisitBody(*ExampleTypeReference) error
	VisitStream([]*ExampleTypeReference) error
	VisitSse([]*ExampleServerSideEvent) error
}

func (e *ExampleEndpointSuccessResponse) Accept(visitor ExampleEndpointSuccessResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "body":
		return visitor.VisitBody(e.Body)
	case "stream":
		return visitor.VisitStream(e.Stream)
	case "sse":
		return visitor.VisitSse(e.Sse)
	}
}

func (e *ExampleEndpointSuccessResponse) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Body != nil {
		fields = append(fields, "body")
	}
	if e.Stream != nil {
		fields = append(fields, "stream")
	}
	if e.Sse != nil {
		fields = append(fields, "sse")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleHeader struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleHeader) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleHeader) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleHeader) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleHeader(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleHeader) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBody struct {
	JsonExample interface{}                          `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Properties  []*ExampleInlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleInlinedRequestBody) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleInlinedRequestBody) GetProperties() []*ExampleInlinedRequestBodyProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleInlinedRequestBody) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleInlinedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleInlinedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleInlinedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleInlinedRequestBody) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBodyProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleInlinedRequestBodyProperty) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleInlinedRequestBodyProperty) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleInlinedRequestBodyProperty) GetOriginalTypeDeclaration() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.OriginalTypeDeclaration
}

func (e *ExampleInlinedRequestBodyProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleInlinedRequestBodyProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleInlinedRequestBodyProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleInlinedRequestBodyProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleInlinedRequestBodyProperty) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePathParameter struct {
	Name  *Name                 `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExamplePathParameter) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExamplePathParameter) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExamplePathParameter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExamplePathParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ExamplePathParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExamplePathParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExamplePathParameter) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleQueryParameter struct {
	Name  *NameAndWireValue           `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference       `json:"value,omitempty" url:"value,omitempty"`
	Shape *ExampleQueryParameterShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleQueryParameter) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleQueryParameter) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleQueryParameter) GetShape() *ExampleQueryParameterShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleQueryParameter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleQueryParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleQueryParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleQueryParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleQueryParameter) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleQueryParameterShape struct {
	Type           string
	Single         interface{}
	Exploded       interface{}
	CommaSeparated interface{}
}

func NewExampleQueryParameterShapeFromSingle(value interface{}) *ExampleQueryParameterShape {
	return &ExampleQueryParameterShape{Type: "single", Single: value}
}

func NewExampleQueryParameterShapeFromExploded(value interface{}) *ExampleQueryParameterShape {
	return &ExampleQueryParameterShape{Type: "exploded", Exploded: value}
}

func NewExampleQueryParameterShapeFromCommaSeparated(value interface{}) *ExampleQueryParameterShape {
	return &ExampleQueryParameterShape{Type: "commaSeparated", CommaSeparated: value}
}

func (e *ExampleQueryParameterShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleQueryParameterShape) GetSingle() interface{} {
	if e == nil {
		return nil
	}
	return e.Single
}

func (e *ExampleQueryParameterShape) GetExploded() interface{} {
	if e == nil {
		return nil
	}
	return e.Exploded
}

func (e *ExampleQueryParameterShape) GetCommaSeparated() interface{} {
	if e == nil {
		return nil
	}
	return e.CommaSeparated
}

func (e *ExampleQueryParameterShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "single":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Single = value
	case "exploded":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Exploded = value
	case "commaSeparated":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommaSeparated = value
	}
	return nil
}

func (e ExampleQueryParameterShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "single":
		var marshaler = struct {
			Type   string      `json:"type"`
			Single interface{} `json:"single,omitempty"`
		}{
			Type:   "single",
			Single: e.Single,
		}
		return json.Marshal(marshaler)
	case "exploded":
		var marshaler = struct {
			Type     string      `json:"type"`
			Exploded interface{} `json:"exploded,omitempty"`
		}{
			Type:     "exploded",
			Exploded: e.Exploded,
		}
		return json.Marshal(marshaler)
	case "commaSeparated":
		var marshaler = struct {
			Type           string      `json:"type"`
			CommaSeparated interface{} `json:"commaSeparated,omitempty"`
		}{
			Type:           "commaSeparated",
			CommaSeparated: e.CommaSeparated,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleQueryParameterShapeVisitor interface {
	VisitSingle(interface{}) error
	VisitExploded(interface{}) error
	VisitCommaSeparated(interface{}) error
}

func (e *ExampleQueryParameterShape) Accept(visitor ExampleQueryParameterShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "single":
		return visitor.VisitSingle(e.Single)
	case "exploded":
		return visitor.VisitExploded(e.Exploded)
	case "commaSeparated":
		return visitor.VisitCommaSeparated(e.CommaSeparated)
	}
}

func (e *ExampleQueryParameterShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Single != nil {
		fields = append(fields, "single")
	}
	if e.Exploded != nil {
		fields = append(fields, "exploded")
	}
	if e.CommaSeparated != nil {
		fields = append(fields, "commaSeparated")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleRequestBody struct {
	Type               string
	InlinedRequestBody *ExampleInlinedRequestBody
	Reference          *ExampleTypeReference
}

func NewExampleRequestBodyFromInlinedRequestBody(value *ExampleInlinedRequestBody) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewExampleRequestBodyFromReference(value *ExampleTypeReference) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "reference", Reference: value}
}

func (e *ExampleRequestBody) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleRequestBody) GetInlinedRequestBody() *ExampleInlinedRequestBody {
	if e == nil {
		return nil
	}
	return e.InlinedRequestBody
}

func (e *ExampleRequestBody) GetReference() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Reference
}

func (e *ExampleRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedRequestBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleRequestBody) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return internal.MarshalJSONWithExtraProperty(e.InlinedRequestBody, "type", "inlinedRequestBody")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(e.Reference, "type", "reference")
	}
}

type ExampleRequestBodyVisitor interface {
	VisitInlinedRequestBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleRequestBody) Accept(visitor ExampleRequestBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(e.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

func (e *ExampleRequestBody) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.InlinedRequestBody != nil {
		fields = append(fields, "inlinedRequestBody")
	}
	if e.Reference != nil {
		fields = append(fields, "reference")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleResponse struct {
	Type  string
	Ok    *ExampleEndpointSuccessResponse
	Error *ExampleEndpointErrorResponse
}

func NewExampleResponseFromOk(value *ExampleEndpointSuccessResponse) *ExampleResponse {
	return &ExampleResponse{Type: "ok", Ok: value}
}

func NewExampleResponseFromError(value *ExampleEndpointErrorResponse) *ExampleResponse {
	return &ExampleResponse{Type: "error", Error: value}
}

func (e *ExampleResponse) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleResponse) GetOk() *ExampleEndpointSuccessResponse {
	if e == nil {
		return nil
	}
	return e.Ok
}

func (e *ExampleResponse) GetError() *ExampleEndpointErrorResponse {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExampleResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "ok":
		var valueUnmarshaler struct {
			Ok *ExampleEndpointSuccessResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Ok = valueUnmarshaler.Ok
	case "error":
		value := new(ExampleEndpointErrorResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExampleResponse) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		var marshaler = struct {
			Type string                          `json:"type"`
			Ok   *ExampleEndpointSuccessResponse `json:"value,omitempty"`
		}{
			Type: "ok",
			Ok:   e.Ok,
		}
		return json.Marshal(marshaler)
	case "error":
		return internal.MarshalJSONWithExtraProperty(e.Error, "type", "error")
	}
}

type ExampleResponseVisitor interface {
	VisitOk(*ExampleEndpointSuccessResponse) error
	VisitError(*ExampleEndpointErrorResponse) error
}

func (e *ExampleResponse) Accept(visitor ExampleResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return visitor.VisitOk(e.Ok)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

func (e *ExampleResponse) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Ok != nil {
		fields = append(fields, "ok")
	}
	if e.Error != nil {
		fields = append(fields, "error")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleServerSideEvent struct {
	Event string                `json:"event" url:"event"`
	Data  *ExampleTypeReference `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleServerSideEvent) GetEvent() string {
	if e == nil {
		return ""
	}
	return e.Event
}

func (e *ExampleServerSideEvent) GetData() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *ExampleServerSideEvent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleServerSideEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleServerSideEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleServerSideEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleServerSideEvent) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FileDownloadResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileDownloadResponse) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FileDownloadResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileDownloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileDownloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileDownloadResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileDownloadResponse) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileProperty struct {
	Type      string
	File      *FilePropertySingle
	FileArray *FilePropertyArray
}

func NewFilePropertyFromFile(value *FilePropertySingle) *FileProperty {
	return &FileProperty{Type: "file", File: value}
}

func NewFilePropertyFromFileArray(value *FilePropertyArray) *FileProperty {
	return &FileProperty{Type: "fileArray", FileArray: value}
}

func (f *FileProperty) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FileProperty) GetFile() *FilePropertySingle {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FileProperty) GetFileArray() *FilePropertyArray {
	if f == nil {
		return nil
	}
	return f.FileArray
}

func (f *FileProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		value := new(FilePropertySingle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "fileArray":
		value := new(FilePropertyArray)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.FileArray = value
	}
	return nil
}

func (f FileProperty) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return internal.MarshalJSONWithExtraProperty(f.File, "type", "file")
	case "fileArray":
		return internal.MarshalJSONWithExtraProperty(f.FileArray, "type", "fileArray")
	}
}

type FilePropertyVisitor interface {
	VisitFile(*FilePropertySingle) error
	VisitFileArray(*FilePropertyArray) error
}

func (f *FileProperty) Accept(visitor FilePropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "fileArray":
		return visitor.VisitFileArray(f.FileArray)
	}
}

func (f *FileProperty) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.File != nil {
		fields = append(fields, "file")
	}
	if f.FileArray != nil {
		fields = append(fields, "fileArray")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type FilePropertyArray struct {
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Key         *NameAndWireValue `json:"key,omitempty" url:"key,omitempty"`
	IsOptional  bool              `json:"isOptional" url:"isOptional"`
	ContentType *string           `json:"contentType,omitempty" url:"contentType,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FilePropertyArray) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FilePropertyArray) GetKey() *NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.Key
}

func (f *FilePropertyArray) GetIsOptional() bool {
	if f == nil {
		return false
	}
	return f.IsOptional
}

func (f *FilePropertyArray) GetContentType() *string {
	if f == nil {
		return nil
	}
	return f.ContentType
}

func (f *FilePropertyArray) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilePropertyArray) UnmarshalJSON(data []byte) error {
	type unmarshaler FilePropertyArray
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilePropertyArray(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FilePropertyArray) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FilePropertySingle struct {
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Key         *NameAndWireValue `json:"key,omitempty" url:"key,omitempty"`
	IsOptional  bool              `json:"isOptional" url:"isOptional"`
	ContentType *string           `json:"contentType,omitempty" url:"contentType,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FilePropertySingle) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FilePropertySingle) GetKey() *NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.Key
}

func (f *FilePropertySingle) GetIsOptional() bool {
	if f == nil {
		return false
	}
	return f.IsOptional
}

func (f *FilePropertySingle) GetContentType() *string {
	if f == nil {
		return nil
	}
	return f.ContentType
}

func (f *FilePropertySingle) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilePropertySingle) UnmarshalJSON(data []byte) error {
	type unmarshaler FilePropertySingle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilePropertySingle(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FilePropertySingle) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadBodyProperty struct {
	Docs         *string                         `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability                   `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue               `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference                  `json:"valueType,omitempty" url:"valueType,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty" url:"contentType,omitempty"`
	Style        *FileUploadBodyPropertyEncoding `json:"style,omitempty" url:"style,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileUploadBodyProperty) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FileUploadBodyProperty) GetAvailability() *Availability {
	if f == nil {
		return nil
	}
	return f.Availability
}

func (f *FileUploadBodyProperty) GetName() *NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FileUploadBodyProperty) GetValueType() *TypeReference {
	if f == nil {
		return nil
	}
	return f.ValueType
}

func (f *FileUploadBodyProperty) GetContentType() *string {
	if f == nil {
		return nil
	}
	return f.ContentType
}

func (f *FileUploadBodyProperty) GetStyle() *FileUploadBodyPropertyEncoding {
	if f == nil {
		return nil
	}
	return f.Style
}

func (f *FileUploadBodyProperty) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadBodyProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadBodyProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadBodyProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileUploadBodyProperty) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadBodyPropertyEncoding string

const (
	FileUploadBodyPropertyEncodingExploded FileUploadBodyPropertyEncoding = "exploded"
	FileUploadBodyPropertyEncodingJson     FileUploadBodyPropertyEncoding = "json"
	FileUploadBodyPropertyEncodingForm     FileUploadBodyPropertyEncoding = "form"
)

func NewFileUploadBodyPropertyEncodingFromString(s string) (FileUploadBodyPropertyEncoding, error) {
	switch s {
	case "exploded":
		return FileUploadBodyPropertyEncodingExploded, nil
	case "json":
		return FileUploadBodyPropertyEncodingJson, nil
	case "form":
		return FileUploadBodyPropertyEncodingForm, nil
	}
	var t FileUploadBodyPropertyEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileUploadBodyPropertyEncoding) Ptr() *FileUploadBodyPropertyEncoding {
	return &f
}

type FileUploadRequest struct {
	Docs       *string                      `json:"docs,omitempty" url:"docs,omitempty"`
	Name       *Name                        `json:"name,omitempty" url:"name,omitempty"`
	Properties []*FileUploadRequestProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileUploadRequest) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FileUploadRequest) GetName() *Name {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FileUploadRequest) GetProperties() []*FileUploadRequestProperty {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FileUploadRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileUploadRequest) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestProperty struct {
	Type         string
	File         *FileProperty
	BodyProperty *FileUploadBodyProperty
}

func NewFileUploadRequestPropertyFromFile(value *FileProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "file", File: value}
}

func NewFileUploadRequestPropertyFromBodyProperty(value *FileUploadBodyProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestProperty) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FileUploadRequestProperty) GetFile() *FileProperty {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FileUploadRequestProperty) GetBodyProperty() *FileUploadBodyProperty {
	if f == nil {
		return nil
	}
	return f.BodyProperty
}

func (f *FileUploadRequestProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		var valueUnmarshaler struct {
			File *FileProperty `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.File = valueUnmarshaler.File
	case "bodyProperty":
		value := new(FileUploadBodyProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestProperty) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		var marshaler = struct {
			Type string        `json:"type"`
			File *FileProperty `json:"value,omitempty"`
		}{
			Type: "file",
			File: f.File,
		}
		return json.Marshal(marshaler)
	case "bodyProperty":
		return internal.MarshalJSONWithExtraProperty(f.BodyProperty, "type", "bodyProperty")
	}
}

type FileUploadRequestPropertyVisitor interface {
	VisitFile(*FileProperty) error
	VisitBodyProperty(*FileUploadBodyProperty) error
}

func (f *FileUploadRequestProperty) Accept(visitor FileUploadRequestPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

func (f *FileUploadRequestProperty) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.File != nil {
		fields = append(fields, "file")
	}
	if f.BodyProperty != nil {
		fields = append(fields, "bodyProperty")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type GrpcTransport struct {
	Service *ProtobufService `json:"service,omitempty" url:"service,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GrpcTransport) GetService() *ProtobufService {
	if g == nil {
		return nil
	}
	return g.Service
}

func (g *GrpcTransport) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GrpcTransport) UnmarshalJSON(data []byte) error {
	type unmarshaler GrpcTransport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GrpcTransport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GrpcTransport) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HttpEndpoint struct {
	Docs         *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability         `json:"availability,omitempty" url:"availability,omitempty"`
	Id           EndpointId            `json:"id" url:"id"`
	Name         EndpointName          `json:"name,omitempty" url:"name,omitempty"`
	DisplayName  *string               `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method       HttpMethod            `json:"method" url:"method"`
	Headers      []*HttpHeader         `json:"headers,omitempty" url:"headers,omitempty"`
	BaseUrl      *EnvironmentBaseUrlId `json:"baseUrl,omitempty" url:"baseUrl,omitempty"`
	// Overrides the service and endpoint level base paths
	BasePath              *HttpPath                       `json:"basePath,omitempty" url:"basePath,omitempty"`
	Path                  *HttpPath                       `json:"path,omitempty" url:"path,omitempty"`
	FullPath              *HttpPath                       `json:"fullPath,omitempty" url:"fullPath,omitempty"`
	PathParameters        []*PathParameter                `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	AllPathParameters     []*PathParameter                `json:"allPathParameters,omitempty" url:"allPathParameters,omitempty"`
	QueryParameters       []*QueryParameter               `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	RequestBody           *HttpRequestBody                `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	SdkRequest            *SdkRequest                     `json:"sdkRequest,omitempty" url:"sdkRequest,omitempty"`
	Response              *HttpResponse                   `json:"response,omitempty" url:"response,omitempty"`
	Errors                ResponseErrors                  `json:"errors,omitempty" url:"errors,omitempty"`
	Auth                  bool                            `json:"auth" url:"auth"`
	Idempotent            bool                            `json:"idempotent" url:"idempotent"`
	Pagination            *Pagination                     `json:"pagination,omitempty" url:"pagination,omitempty"`
	UserSpecifiedExamples []*UserSpecifiedEndpointExample `json:"userSpecifiedExamples,omitempty" url:"userSpecifiedExamples,omitempty"`
	AutogeneratedExamples []*AutogeneratedEndpointExample `json:"autogeneratedExamples,omitempty" url:"autogeneratedExamples,omitempty"`
	Transport             *Transport                      `json:"transport,omitempty" url:"transport,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpEndpoint) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpEndpoint) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpEndpoint) GetId() EndpointId {
	if h == nil {
		return ""
	}
	return h.Id
}

func (h *HttpEndpoint) GetName() EndpointName {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpEndpoint) GetDisplayName() *string {
	if h == nil {
		return nil
	}
	return h.DisplayName
}

func (h *HttpEndpoint) GetMethod() HttpMethod {
	if h == nil {
		return ""
	}
	return h.Method
}

func (h *HttpEndpoint) GetHeaders() []*HttpHeader {
	if h == nil {
		return nil
	}
	return h.Headers
}

func (h *HttpEndpoint) GetBaseUrl() *EnvironmentBaseUrlId {
	if h == nil {
		return nil
	}
	return h.BaseUrl
}

func (h *HttpEndpoint) GetBasePath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.BasePath
}

func (h *HttpEndpoint) GetPath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.Path
}

func (h *HttpEndpoint) GetFullPath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.FullPath
}

func (h *HttpEndpoint) GetPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.PathParameters
}

func (h *HttpEndpoint) GetAllPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.AllPathParameters
}

func (h *HttpEndpoint) GetQueryParameters() []*QueryParameter {
	if h == nil {
		return nil
	}
	return h.QueryParameters
}

func (h *HttpEndpoint) GetRequestBody() *HttpRequestBody {
	if h == nil {
		return nil
	}
	return h.RequestBody
}

func (h *HttpEndpoint) GetSdkRequest() *SdkRequest {
	if h == nil {
		return nil
	}
	return h.SdkRequest
}

func (h *HttpEndpoint) GetResponse() *HttpResponse {
	if h == nil {
		return nil
	}
	return h.Response
}

func (h *HttpEndpoint) GetErrors() ResponseErrors {
	if h == nil {
		return nil
	}
	return h.Errors
}

func (h *HttpEndpoint) GetAuth() bool {
	if h == nil {
		return false
	}
	return h.Auth
}

func (h *HttpEndpoint) GetIdempotent() bool {
	if h == nil {
		return false
	}
	return h.Idempotent
}

func (h *HttpEndpoint) GetPagination() *Pagination {
	if h == nil {
		return nil
	}
	return h.Pagination
}

func (h *HttpEndpoint) GetUserSpecifiedExamples() []*UserSpecifiedEndpointExample {
	if h == nil {
		return nil
	}
	return h.UserSpecifiedExamples
}

func (h *HttpEndpoint) GetAutogeneratedExamples() []*AutogeneratedEndpointExample {
	if h == nil {
		return nil
	}
	return h.AutogeneratedExamples
}

func (h *HttpEndpoint) GetTransport() *Transport {
	if h == nil {
		return nil
	}
	return h.Transport
}

func (h *HttpEndpoint) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpEndpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpEndpoint) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpHeader struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	Env          *string           `json:"env,omitempty" url:"env,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpHeader) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpHeader) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpHeader) GetName() *NameAndWireValue {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpHeader) GetValueType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.ValueType
}

func (h *HttpHeader) GetEnv() *string {
	if h == nil {
		return nil
	}
	return h.Env
}

func (h *HttpHeader) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpHeader(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpHeader) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpPath struct {
	Head  string          `json:"head" url:"head"`
	Parts []*HttpPathPart `json:"parts,omitempty" url:"parts,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpPath) GetHead() string {
	if h == nil {
		return ""
	}
	return h.Head
}

func (h *HttpPath) GetParts() []*HttpPathPart {
	if h == nil {
		return nil
	}
	return h.Parts
}

func (h *HttpPath) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpPath) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpPath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpPath(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpPath) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpPathPart struct {
	PathParameter string `json:"pathParameter" url:"pathParameter"`
	Tail          string `json:"tail" url:"tail"`

	extraProperties map[string]interface{}
}

func (h *HttpPathPart) GetPathParameter() string {
	if h == nil {
		return ""
	}
	return h.PathParameter
}

func (h *HttpPathPart) GetTail() string {
	if h == nil {
		return ""
	}
	return h.Tail
}

func (h *HttpPathPart) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpPathPart) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpPathPart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpPathPart(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpPathPart) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpRequestBody struct {
	Type               string
	InlinedRequestBody *InlinedRequestBody
	Reference          *HttpRequestBodyReference
	FileUpload         *FileUploadRequest
	Bytes              *BytesRequest
}

func NewHttpRequestBodyFromInlinedRequestBody(value *InlinedRequestBody) *HttpRequestBody {
	return &HttpRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewHttpRequestBodyFromReference(value *HttpRequestBodyReference) *HttpRequestBody {
	return &HttpRequestBody{Type: "reference", Reference: value}
}

func NewHttpRequestBodyFromFileUpload(value *FileUploadRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "fileUpload", FileUpload: value}
}

func NewHttpRequestBodyFromBytes(value *BytesRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "bytes", Bytes: value}
}

func (h *HttpRequestBody) GetType() string {
	if h == nil {
		return ""
	}
	return h.Type
}

func (h *HttpRequestBody) GetInlinedRequestBody() *InlinedRequestBody {
	if h == nil {
		return nil
	}
	return h.InlinedRequestBody
}

func (h *HttpRequestBody) GetReference() *HttpRequestBodyReference {
	if h == nil {
		return nil
	}
	return h.Reference
}

func (h *HttpRequestBody) GetFileUpload() *FileUploadRequest {
	if h == nil {
		return nil
	}
	return h.FileUpload
}

func (h *HttpRequestBody) GetBytes() *BytesRequest {
	if h == nil {
		return nil
	}
	return h.Bytes
}

func (h *HttpRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", h)
	}
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(InlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.InlinedRequestBody = value
	case "reference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Reference = value
	case "fileUpload":
		value := new(FileUploadRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileUpload = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Bytes = value
	}
	return nil
}

func (h HttpRequestBody) MarshalJSON() ([]byte, error) {
	if err := h.validate(); err != nil {
		return nil, err
	}
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return internal.MarshalJSONWithExtraProperty(h.InlinedRequestBody, "type", "inlinedRequestBody")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(h.Reference, "type", "reference")
	case "fileUpload":
		return internal.MarshalJSONWithExtraProperty(h.FileUpload, "type", "fileUpload")
	case "bytes":
		return internal.MarshalJSONWithExtraProperty(h.Bytes, "type", "bytes")
	}
}

type HttpRequestBodyVisitor interface {
	VisitInlinedRequestBody(*InlinedRequestBody) error
	VisitReference(*HttpRequestBodyReference) error
	VisitFileUpload(*FileUploadRequest) error
	VisitBytes(*BytesRequest) error
}

func (h *HttpRequestBody) Accept(visitor HttpRequestBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(h.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(h.Reference)
	case "fileUpload":
		return visitor.VisitFileUpload(h.FileUpload)
	case "bytes":
		return visitor.VisitBytes(h.Bytes)
	}
}

func (h *HttpRequestBody) validate() error {
	if h == nil {
		return fmt.Errorf("type %T is nil", h)
	}
	var fields []string
	if h.InlinedRequestBody != nil {
		fields = append(fields, "inlinedRequestBody")
	}
	if h.Reference != nil {
		fields = append(fields, "reference")
	}
	if h.FileUpload != nil {
		fields = append(fields, "fileUpload")
	}
	if h.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if len(fields) == 0 {
		if h.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", h, h.Type)
		}
		return fmt.Errorf("type %T is empty", h)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", h, fields)
	}
	if h.Type != "" {
		field := fields[0]
		if h.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				h,
				h.Type,
				h,
			)
		}
	}
	return nil
}

type HttpRequestBodyReference struct {
	Docs            *string        `json:"docs,omitempty" url:"docs,omitempty"`
	RequestBodyType *TypeReference `json:"requestBodyType,omitempty" url:"requestBodyType,omitempty"`
	ContentType     *string        `json:"contentType,omitempty" url:"contentType,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpRequestBodyReference) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpRequestBodyReference) GetRequestBodyType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.RequestBodyType
}

func (h *HttpRequestBodyReference) GetContentType() *string {
	if h == nil {
		return nil
	}
	return h.ContentType
}

func (h *HttpRequestBodyReference) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpRequestBodyReference) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpRequestBodyReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpRequestBodyReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpRequestBodyReference) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpResponse struct {
	StatusCode *int              `json:"status-code,omitempty" url:"status-code,omitempty"`
	Body       *HttpResponseBody `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpResponse) GetStatusCode() *int {
	if h == nil {
		return nil
	}
	return h.StatusCode
}

func (h *HttpResponse) GetBody() *HttpResponseBody {
	if h == nil {
		return nil
	}
	return h.Body
}

func (h *HttpResponse) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpResponse) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpResponseBody struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
	Text         *TextResponse
	Bytes        *BytesResponse
	Streaming    *StreamingResponse
	// If there is a parameter that controls whether the response is streaming or not. Note
	// that if this is the response then `sdkRequest.streamParameter` will always be populated.
	StreamParameter *StreamParameterResponse
}

func NewHttpResponseBodyFromJson(value *JsonResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "json", Json: value}
}

func NewHttpResponseBodyFromFileDownload(value *FileDownloadResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "fileDownload", FileDownload: value}
}

func NewHttpResponseBodyFromText(value *TextResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "text", Text: value}
}

func NewHttpResponseBodyFromBytes(value *BytesResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "bytes", Bytes: value}
}

func NewHttpResponseBodyFromStreaming(value *StreamingResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "streaming", Streaming: value}
}

func NewHttpResponseBodyFromStreamParameter(value *StreamParameterResponse) *HttpResponseBody {
	return &HttpResponseBody{Type: "streamParameter", StreamParameter: value}
}

func (h *HttpResponseBody) GetType() string {
	if h == nil {
		return ""
	}
	return h.Type
}

func (h *HttpResponseBody) GetJson() *JsonResponse {
	if h == nil {
		return nil
	}
	return h.Json
}

func (h *HttpResponseBody) GetFileDownload() *FileDownloadResponse {
	if h == nil {
		return nil
	}
	return h.FileDownload
}

func (h *HttpResponseBody) GetText() *TextResponse {
	if h == nil {
		return nil
	}
	return h.Text
}

func (h *HttpResponseBody) GetBytes() *BytesResponse {
	if h == nil {
		return nil
	}
	return h.Bytes
}

func (h *HttpResponseBody) GetStreaming() *StreamingResponse {
	if h == nil {
		return nil
	}
	return h.Streaming
}

func (h *HttpResponseBody) GetStreamParameter() *StreamParameterResponse {
	if h == nil {
		return nil
	}
	return h.StreamParameter
}

func (h *HttpResponseBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", h)
	}
	switch unmarshaler.Type {
	case "json":
		var valueUnmarshaler struct {
			Json *JsonResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.Json = valueUnmarshaler.Json
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	case "text":
		value := new(TextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Text = value
	case "bytes":
		value := new(BytesResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Bytes = value
	case "streaming":
		var valueUnmarshaler struct {
			Streaming *StreamingResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.Streaming = valueUnmarshaler.Streaming
	case "streamParameter":
		value := new(StreamParameterResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.StreamParameter = value
	}
	return nil
}

func (h HttpResponseBody) MarshalJSON() ([]byte, error) {
	if err := h.validate(); err != nil {
		return nil, err
	}
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		var marshaler = struct {
			Type string        `json:"type"`
			Json *JsonResponse `json:"value,omitempty"`
		}{
			Type: "json",
			Json: h.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		return internal.MarshalJSONWithExtraProperty(h.FileDownload, "type", "fileDownload")
	case "text":
		return internal.MarshalJSONWithExtraProperty(h.Text, "type", "text")
	case "bytes":
		return internal.MarshalJSONWithExtraProperty(h.Bytes, "type", "bytes")
	case "streaming":
		var marshaler = struct {
			Type      string             `json:"type"`
			Streaming *StreamingResponse `json:"value,omitempty"`
		}{
			Type:      "streaming",
			Streaming: h.Streaming,
		}
		return json.Marshal(marshaler)
	case "streamParameter":
		return internal.MarshalJSONWithExtraProperty(h.StreamParameter, "type", "streamParameter")
	}
}

type HttpResponseBodyVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
	VisitText(*TextResponse) error
	VisitBytes(*BytesResponse) error
	VisitStreaming(*StreamingResponse) error
	VisitStreamParameter(*StreamParameterResponse) error
}

func (h *HttpResponseBody) Accept(visitor HttpResponseBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return visitor.VisitJson(h.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(h.FileDownload)
	case "text":
		return visitor.VisitText(h.Text)
	case "bytes":
		return visitor.VisitBytes(h.Bytes)
	case "streaming":
		return visitor.VisitStreaming(h.Streaming)
	case "streamParameter":
		return visitor.VisitStreamParameter(h.StreamParameter)
	}
}

func (h *HttpResponseBody) validate() error {
	if h == nil {
		return fmt.Errorf("type %T is nil", h)
	}
	var fields []string
	if h.Json != nil {
		fields = append(fields, "json")
	}
	if h.FileDownload != nil {
		fields = append(fields, "fileDownload")
	}
	if h.Text != nil {
		fields = append(fields, "text")
	}
	if h.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if h.Streaming != nil {
		fields = append(fields, "streaming")
	}
	if h.StreamParameter != nil {
		fields = append(fields, "streamParameter")
	}
	if len(fields) == 0 {
		if h.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", h, h.Type)
		}
		return fmt.Errorf("type %T is empty", h)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", h, fields)
	}
	if h.Type != "" {
		field := fields[0]
		if h.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				h,
				h.Type,
				h,
			)
		}
	}
	return nil
}

type HttpService struct {
	Availability   *Availability        `json:"availability,omitempty" url:"availability,omitempty"`
	Name           *DeclaredServiceName `json:"name,omitempty" url:"name,omitempty"`
	DisplayName    *string              `json:"displayName,omitempty" url:"displayName,omitempty"`
	BasePath       *HttpPath            `json:"basePath,omitempty" url:"basePath,omitempty"`
	Endpoints      []*HttpEndpoint      `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	Headers        []*HttpHeader        `json:"headers,omitempty" url:"headers,omitempty"`
	PathParameters []*PathParameter     `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	Encoding       *Encoding            `json:"encoding,omitempty" url:"encoding,omitempty"`
	Transport      *Transport           `json:"transport,omitempty" url:"transport,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpService) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpService) GetName() *DeclaredServiceName {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpService) GetDisplayName() *string {
	if h == nil {
		return nil
	}
	return h.DisplayName
}

func (h *HttpService) GetBasePath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.BasePath
}

func (h *HttpService) GetEndpoints() []*HttpEndpoint {
	if h == nil {
		return nil
	}
	return h.Endpoints
}

func (h *HttpService) GetHeaders() []*HttpHeader {
	if h == nil {
		return nil
	}
	return h.Headers
}

func (h *HttpService) GetPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.PathParameters
}

func (h *HttpService) GetEncoding() *Encoding {
	if h == nil {
		return nil
	}
	return h.Encoding
}

func (h *HttpService) GetTransport() *Transport {
	if h == nil {
		return nil
	}
	return h.Transport
}

func (h *HttpService) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpService) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpService
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpService(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpService) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InlinedRequestBody struct {
	Docs       *string                       `json:"docs,omitempty" url:"docs,omitempty"`
	Name       *Name                         `json:"name,omitempty" url:"name,omitempty"`
	Extends    []*DeclaredTypeName           `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*InlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`
	// A list of properties that all the parents of this request have.
	ExtendedProperties []*ObjectProperty `json:"extendedProperties,omitempty" url:"extendedProperties,omitempty"`
	ContentType        *string           `json:"contentType,omitempty" url:"contentType,omitempty"`
	// Whether to allow extra properties on the request.
	ExtraProperties bool `json:"extra-properties" url:"extra-properties"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestBody) GetDocs() *string {
	if i == nil {
		return nil
	}
	return i.Docs
}

func (i *InlinedRequestBody) GetName() *Name {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedRequestBody) GetExtends() []*DeclaredTypeName {
	if i == nil {
		return nil
	}
	return i.Extends
}

func (i *InlinedRequestBody) GetProperties() []*InlinedRequestBodyProperty {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedRequestBody) GetExtendedProperties() []*ObjectProperty {
	if i == nil {
		return nil
	}
	return i.ExtendedProperties
}

func (i *InlinedRequestBody) GetContentType() *string {
	if i == nil {
		return nil
	}
	return i.ContentType
}

func (i *InlinedRequestBody) GetExtraProperties() bool {
	if i == nil {
		return false
	}
	return i.ExtraProperties
}

func (i *InlinedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestBody) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBodyProperty struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestBodyProperty) GetDocs() *string {
	if i == nil {
		return nil
	}
	return i.Docs
}

func (i *InlinedRequestBodyProperty) GetAvailability() *Availability {
	if i == nil {
		return nil
	}
	return i.Availability
}

func (i *InlinedRequestBodyProperty) GetName() *NameAndWireValue {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedRequestBodyProperty) GetValueType() *TypeReference {
	if i == nil {
		return nil
	}
	return i.ValueType
}

func (i *InlinedRequestBodyProperty) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequestBodyProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestBodyProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestBodyProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestBodyProperty) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonResponse struct {
	Type                     string
	Response                 *JsonResponseBody
	NestedPropertyAsResponse *JsonResponseBodyWithProperty
}

func NewJsonResponseFromResponse(value *JsonResponseBody) *JsonResponse {
	return &JsonResponse{Type: "response", Response: value}
}

func NewJsonResponseFromNestedPropertyAsResponse(value *JsonResponseBodyWithProperty) *JsonResponse {
	return &JsonResponse{Type: "nestedPropertyAsResponse", NestedPropertyAsResponse: value}
}

func (j *JsonResponse) GetType() string {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonResponse) GetResponse() *JsonResponseBody {
	if j == nil {
		return nil
	}
	return j.Response
}

func (j *JsonResponse) GetNestedPropertyAsResponse() *JsonResponseBodyWithProperty {
	if j == nil {
		return nil
	}
	return j.NestedPropertyAsResponse
}

func (j *JsonResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "response":
		value := new(JsonResponseBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Response = value
	case "nestedPropertyAsResponse":
		value := new(JsonResponseBodyWithProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.NestedPropertyAsResponse = value
	}
	return nil
}

func (j JsonResponse) MarshalJSON() ([]byte, error) {
	if err := j.validate(); err != nil {
		return nil, err
	}
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		return internal.MarshalJSONWithExtraProperty(j.Response, "type", "response")
	case "nestedPropertyAsResponse":
		return internal.MarshalJSONWithExtraProperty(j.NestedPropertyAsResponse, "type", "nestedPropertyAsResponse")
	}
}

type JsonResponseVisitor interface {
	VisitResponse(*JsonResponseBody) error
	VisitNestedPropertyAsResponse(*JsonResponseBodyWithProperty) error
}

func (j *JsonResponse) Accept(visitor JsonResponseVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		return visitor.VisitResponse(j.Response)
	case "nestedPropertyAsResponse":
		return visitor.VisitNestedPropertyAsResponse(j.NestedPropertyAsResponse)
	}
}

func (j *JsonResponse) validate() error {
	if j == nil {
		return fmt.Errorf("type %T is nil", j)
	}
	var fields []string
	if j.Response != nil {
		fields = append(fields, "response")
	}
	if j.NestedPropertyAsResponse != nil {
		fields = append(fields, "nestedPropertyAsResponse")
	}
	if len(fields) == 0 {
		if j.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", j, j.Type)
		}
		return fmt.Errorf("type %T is empty", j)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", j, fields)
	}
	if j.Type != "" {
		field := fields[0]
		if j.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				j,
				j.Type,
				j,
			)
		}
	}
	return nil
}

type JsonResponseBody struct {
	Docs             *string        `json:"docs,omitempty" url:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty" url:"responseBodyType,omitempty"`

	extraProperties map[string]interface{}
}

func (j *JsonResponseBody) GetDocs() *string {
	if j == nil {
		return nil
	}
	return j.Docs
}

func (j *JsonResponseBody) GetResponseBodyType() *TypeReference {
	if j == nil {
		return nil
	}
	return j.ResponseBodyType
}

func (j *JsonResponseBody) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonResponseBody) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonResponseBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonResponseBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonResponseBody) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JsonResponseBodyWithProperty struct {
	Docs             *string        `json:"docs,omitempty" url:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty" url:"responseBodyType,omitempty"`
	// If set, the SDK will return this property from
	// the response, rather than the response itself.
	//
	// This is particularly useful for JSON API structures
	// (e.g. configure 'data' to return 'response.data').
	ResponseProperty *ObjectProperty `json:"responseProperty,omitempty" url:"responseProperty,omitempty"`

	extraProperties map[string]interface{}
}

func (j *JsonResponseBodyWithProperty) GetDocs() *string {
	if j == nil {
		return nil
	}
	return j.Docs
}

func (j *JsonResponseBodyWithProperty) GetResponseBodyType() *TypeReference {
	if j == nil {
		return nil
	}
	return j.ResponseBodyType
}

func (j *JsonResponseBodyWithProperty) GetResponseProperty() *ObjectProperty {
	if j == nil {
		return nil
	}
	return j.ResponseProperty
}

func (j *JsonResponseBodyWithProperty) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonResponseBodyWithProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonResponseBodyWithProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonResponseBodyWithProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonResponseBodyWithProperty) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JsonStreamChunk struct {
	Docs       *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Payload    *TypeReference `json:"payload,omitempty" url:"payload,omitempty"`
	Terminator *string        `json:"terminator,omitempty" url:"terminator,omitempty"`

	extraProperties map[string]interface{}
}

func (j *JsonStreamChunk) GetDocs() *string {
	if j == nil {
		return nil
	}
	return j.Docs
}

func (j *JsonStreamChunk) GetPayload() *TypeReference {
	if j == nil {
		return nil
	}
	return j.Payload
}

func (j *JsonStreamChunk) GetTerminator() *string {
	if j == nil {
		return nil
	}
	return j.Terminator
}

func (j *JsonStreamChunk) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonStreamChunk) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonStreamChunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonStreamChunk(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonStreamChunk) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type NonStreamHttpResponseBody struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
	Text         *TextResponse
	Bytes        *BytesResponse
}

func NewNonStreamHttpResponseBodyFromJson(value *JsonResponse) *NonStreamHttpResponseBody {
	return &NonStreamHttpResponseBody{Type: "json", Json: value}
}

func NewNonStreamHttpResponseBodyFromFileDownload(value *FileDownloadResponse) *NonStreamHttpResponseBody {
	return &NonStreamHttpResponseBody{Type: "fileDownload", FileDownload: value}
}

func NewNonStreamHttpResponseBodyFromText(value *TextResponse) *NonStreamHttpResponseBody {
	return &NonStreamHttpResponseBody{Type: "text", Text: value}
}

func NewNonStreamHttpResponseBodyFromBytes(value *BytesResponse) *NonStreamHttpResponseBody {
	return &NonStreamHttpResponseBody{Type: "bytes", Bytes: value}
}

func (n *NonStreamHttpResponseBody) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NonStreamHttpResponseBody) GetJson() *JsonResponse {
	if n == nil {
		return nil
	}
	return n.Json
}

func (n *NonStreamHttpResponseBody) GetFileDownload() *FileDownloadResponse {
	if n == nil {
		return nil
	}
	return n.FileDownload
}

func (n *NonStreamHttpResponseBody) GetText() *TextResponse {
	if n == nil {
		return nil
	}
	return n.Text
}

func (n *NonStreamHttpResponseBody) GetBytes() *BytesResponse {
	if n == nil {
		return nil
	}
	return n.Bytes
}

func (n *NonStreamHttpResponseBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "json":
		var valueUnmarshaler struct {
			Json *JsonResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.Json = valueUnmarshaler.Json
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.FileDownload = value
	case "text":
		value := new(TextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Text = value
	case "bytes":
		value := new(BytesResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Bytes = value
	}
	return nil
}

func (n NonStreamHttpResponseBody) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	switch n.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "json":
		var marshaler = struct {
			Type string        `json:"type"`
			Json *JsonResponse `json:"value,omitempty"`
		}{
			Type: "json",
			Json: n.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		return internal.MarshalJSONWithExtraProperty(n.FileDownload, "type", "fileDownload")
	case "text":
		return internal.MarshalJSONWithExtraProperty(n.Text, "type", "text")
	case "bytes":
		return internal.MarshalJSONWithExtraProperty(n.Bytes, "type", "bytes")
	}
}

type NonStreamHttpResponseBodyVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
	VisitText(*TextResponse) error
	VisitBytes(*BytesResponse) error
}

func (n *NonStreamHttpResponseBody) Accept(visitor NonStreamHttpResponseBodyVisitor) error {
	switch n.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "json":
		return visitor.VisitJson(n.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(n.FileDownload)
	case "text":
		return visitor.VisitText(n.Text)
	case "bytes":
		return visitor.VisitBytes(n.Bytes)
	}
}

func (n *NonStreamHttpResponseBody) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Json != nil {
		fields = append(fields, "json")
	}
	if n.FileDownload != nil {
		fields = append(fields, "fileDownload")
	}
	if n.Text != nil {
		fields = append(fields, "text")
	}
	if n.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

// The page must be defined as a query parameter included in the request,
// whereas the results are resolved from properties defined on the response.
//
// The page index is auto-incremented between every additional page request.
type OffsetPagination struct {
	Page    *RequestProperty  `json:"page,omitempty" url:"page,omitempty"`
	Results *ResponseProperty `json:"results,omitempty" url:"results,omitempty"`
	// A response property that indicates whether there is a next page or not.
	HasNextPage *ResponseProperty `json:"hasNextPage,omitempty" url:"hasNextPage,omitempty"`
	// The step size used to increment the page offset between every new page.
	Step *RequestProperty `json:"step,omitempty" url:"step,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OffsetPagination) GetPage() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *OffsetPagination) GetResults() *ResponseProperty {
	if o == nil {
		return nil
	}
	return o.Results
}

func (o *OffsetPagination) GetHasNextPage() *ResponseProperty {
	if o == nil {
		return nil
	}
	return o.HasNextPage
}

func (o *OffsetPagination) GetStep() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.Step
}

func (o *OffsetPagination) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OffsetPagination) UnmarshalJSON(data []byte) error {
	type unmarshaler OffsetPagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OffsetPagination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OffsetPagination) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// If set, the endpoint will be generated with auto-pagination features.
type Pagination struct {
	Type   string
	Cursor *CursorPagination
	Offset *OffsetPagination
	Custom *CustomPagination
}

func NewPaginationFromCursor(value *CursorPagination) *Pagination {
	return &Pagination{Type: "cursor", Cursor: value}
}

func NewPaginationFromOffset(value *OffsetPagination) *Pagination {
	return &Pagination{Type: "offset", Offset: value}
}

func NewPaginationFromCustom(value *CustomPagination) *Pagination {
	return &Pagination{Type: "custom", Custom: value}
}

func (p *Pagination) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *Pagination) GetCursor() *CursorPagination {
	if p == nil {
		return nil
	}
	return p.Cursor
}

func (p *Pagination) GetOffset() *OffsetPagination {
	if p == nil {
		return nil
	}
	return p.Offset
}

func (p *Pagination) GetCustom() *CustomPagination {
	if p == nil {
		return nil
	}
	return p.Custom
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "cursor":
		value := new(CursorPagination)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Cursor = value
	case "offset":
		value := new(OffsetPagination)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Offset = value
	case "custom":
		value := new(CustomPagination)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	}
	return nil
}

func (p Pagination) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "cursor":
		return internal.MarshalJSONWithExtraProperty(p.Cursor, "type", "cursor")
	case "offset":
		return internal.MarshalJSONWithExtraProperty(p.Offset, "type", "offset")
	case "custom":
		return internal.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
}

type PaginationVisitor interface {
	VisitCursor(*CursorPagination) error
	VisitOffset(*OffsetPagination) error
	VisitCustom(*CustomPagination) error
}

func (p *Pagination) Accept(visitor PaginationVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "cursor":
		return visitor.VisitCursor(p.Cursor)
	case "offset":
		return visitor.VisitOffset(p.Offset)
	case "custom":
		return visitor.VisitCustom(p.Custom)
	}
}

func (p *Pagination) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Cursor != nil {
		fields = append(fields, "cursor")
	}
	if p.Offset != nil {
		fields = append(fields, "offset")
	}
	if p.Custom != nil {
		fields = append(fields, "custom")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PathParameter struct {
	Docs      *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *Name                 `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`
	Location  PathParameterLocation `json:"location" url:"location"`
	Variable  *VariableId           `json:"variable,omitempty" url:"variable,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PathParameter) GetDocs() *string {
	if p == nil {
		return nil
	}
	return p.Docs
}

func (p *PathParameter) GetName() *Name {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PathParameter) GetValueType() *TypeReference {
	if p == nil {
		return nil
	}
	return p.ValueType
}

func (p *PathParameter) GetLocation() PathParameterLocation {
	if p == nil {
		return ""
	}
	return p.Location
}

func (p *PathParameter) GetVariable() *VariableId {
	if p == nil {
		return nil
	}
	return p.Variable
}

func (p *PathParameter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PathParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler PathParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PathParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PathParameter) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PathParameterLocation string

const (
	PathParameterLocationRoot     PathParameterLocation = "ROOT"
	PathParameterLocationService  PathParameterLocation = "SERVICE"
	PathParameterLocationEndpoint PathParameterLocation = "ENDPOINT"
)

func NewPathParameterLocationFromString(s string) (PathParameterLocation, error) {
	switch s {
	case "ROOT":
		return PathParameterLocationRoot, nil
	case "SERVICE":
		return PathParameterLocationService, nil
	case "ENDPOINT":
		return PathParameterLocationEndpoint, nil
	}
	var t PathParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PathParameterLocation) Ptr() *PathParameterLocation {
	return &p
}

type QueryParameter struct {
	Docs          *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability  *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name          *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType     *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	AllowMultiple bool              `json:"allowMultiple" url:"allowMultiple"`

	extraProperties map[string]interface{}
}

func (q *QueryParameter) GetDocs() *string {
	if q == nil {
		return nil
	}
	return q.Docs
}

func (q *QueryParameter) GetAvailability() *Availability {
	if q == nil {
		return nil
	}
	return q.Availability
}

func (q *QueryParameter) GetName() *NameAndWireValue {
	if q == nil {
		return nil
	}
	return q.Name
}

func (q *QueryParameter) GetValueType() *TypeReference {
	if q == nil {
		return nil
	}
	return q.ValueType
}

func (q *QueryParameter) GetAllowMultiple() bool {
	if q == nil {
		return false
	}
	return q.AllowMultiple
}

func (q *QueryParameter) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	return nil
}

func (q *QueryParameter) String() string {
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// A property associated with an endpoint's request.
type RequestProperty struct {
	// If empty, the property is defined at the top-level.
	// Otherwise, the property is defined on the nested object identified
	// by the path.
	PropertyPath []*Name               `json:"propertyPath,omitempty" url:"propertyPath,omitempty"`
	Property     *RequestPropertyValue `json:"property,omitempty" url:"property,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RequestProperty) GetPropertyPath() []*Name {
	if r == nil {
		return nil
	}
	return r.PropertyPath
}

func (r *RequestProperty) GetProperty() *RequestPropertyValue {
	if r == nil {
		return nil
	}
	return r.Property
}

func (r *RequestProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RequestProperty) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RequestPropertyValue struct {
	Type  string
	Query *QueryParameter
	Body  *ObjectProperty
}

func NewRequestPropertyValueFromQuery(value *QueryParameter) *RequestPropertyValue {
	return &RequestPropertyValue{Type: "query", Query: value}
}

func NewRequestPropertyValueFromBody(value *ObjectProperty) *RequestPropertyValue {
	return &RequestPropertyValue{Type: "body", Body: value}
}

func (r *RequestPropertyValue) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RequestPropertyValue) GetQuery() *QueryParameter {
	if r == nil {
		return nil
	}
	return r.Query
}

func (r *RequestPropertyValue) GetBody() *ObjectProperty {
	if r == nil {
		return nil
	}
	return r.Body
}

func (r *RequestPropertyValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "query":
		value := new(QueryParameter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Query = value
	case "body":
		value := new(ObjectProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Body = value
	}
	return nil
}

func (r RequestPropertyValue) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "query":
		return internal.MarshalJSONWithExtraProperty(r.Query, "type", "query")
	case "body":
		return internal.MarshalJSONWithExtraProperty(r.Body, "type", "body")
	}
}

type RequestPropertyValueVisitor interface {
	VisitQuery(*QueryParameter) error
	VisitBody(*ObjectProperty) error
}

func (r *RequestPropertyValue) Accept(visitor RequestPropertyValueVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "query":
		return visitor.VisitQuery(r.Query)
	case "body":
		return visitor.VisitBody(r.Body)
	}
}

func (r *RequestPropertyValue) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Query != nil {
		fields = append(fields, "query")
	}
	if r.Body != nil {
		fields = append(fields, "body")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

type ResponseError struct {
	Docs  *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Error *DeclaredErrorName `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
}

func (r *ResponseError) GetDocs() *string {
	if r == nil {
		return nil
	}
	return r.Docs
}

func (r *ResponseError) GetError() *DeclaredErrorName {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *ResponseError) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseError) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResponseError) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseErrors = []*ResponseError

// A property associated with a paginated endpoint's request or response.
type ResponseProperty struct {
	// If empty, the property is defined at the top-level.
	// Otherwise, the property is defined on the nested object identified
	// by the path.
	PropertyPath []*Name         `json:"propertyPath,omitempty" url:"propertyPath,omitempty"`
	Property     *ObjectProperty `json:"property,omitempty" url:"property,omitempty"`

	extraProperties map[string]interface{}
}

func (r *ResponseProperty) GetPropertyPath() []*Name {
	if r == nil {
		return nil
	}
	return r.PropertyPath
}

func (r *ResponseProperty) GetProperty() *ObjectProperty {
	if r == nil {
		return nil
	}
	return r.Property
}

func (r *ResponseProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResponseProperty) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SdkRequest struct {
	// The request property that controls whether or not the response is streamed.
	StreamParameter      *RequestProperty `json:"streamParameter,omitempty" url:"streamParameter,omitempty"`
	RequestParameterName *Name            `json:"requestParameterName,omitempty" url:"requestParameterName,omitempty"`
	Shape                *SdkRequestShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkRequest) GetStreamParameter() *RequestProperty {
	if s == nil {
		return nil
	}
	return s.StreamParameter
}

func (s *SdkRequest) GetRequestParameterName() *Name {
	if s == nil {
		return nil
	}
	return s.RequestParameterName
}

func (s *SdkRequest) GetShape() *SdkRequestShape {
	if s == nil {
		return nil
	}
	return s.Shape
}

func (s *SdkRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkRequest) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SdkRequestBodyType struct {
	Type          string
	TypeReference *HttpRequestBodyReference
	Bytes         *BytesRequest
}

func NewSdkRequestBodyTypeFromTypeReference(value *HttpRequestBodyReference) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "typeReference", TypeReference: value}
}

func NewSdkRequestBodyTypeFromBytes(value *BytesRequest) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "bytes", Bytes: value}
}

func (s *SdkRequestBodyType) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SdkRequestBodyType) GetTypeReference() *HttpRequestBodyReference {
	if s == nil {
		return nil
	}
	return s.TypeReference
}

func (s *SdkRequestBodyType) GetBytes() *BytesRequest {
	if s == nil {
		return nil
	}
	return s.Bytes
}

func (s *SdkRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "typeReference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TypeReference = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Bytes = value
	}
	return nil
}

func (s SdkRequestBodyType) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		return internal.MarshalJSONWithExtraProperty(s.TypeReference, "type", "typeReference")
	case "bytes":
		return internal.MarshalJSONWithExtraProperty(s.Bytes, "type", "bytes")
	}
}

type SdkRequestBodyTypeVisitor interface {
	VisitTypeReference(*HttpRequestBodyReference) error
	VisitBytes(*BytesRequest) error
}

func (s *SdkRequestBodyType) Accept(visitor SdkRequestBodyTypeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		return visitor.VisitTypeReference(s.TypeReference)
	case "bytes":
		return visitor.VisitBytes(s.Bytes)
	}
}

func (s *SdkRequestBodyType) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.TypeReference != nil {
		fields = append(fields, "typeReference")
	}
	if s.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SdkRequestShape struct {
	Type            string
	JustRequestBody *SdkRequestBodyType
	Wrapper         *SdkRequestWrapper
}

func NewSdkRequestShapeFromJustRequestBody(value *SdkRequestBodyType) *SdkRequestShape {
	return &SdkRequestShape{Type: "justRequestBody", JustRequestBody: value}
}

func NewSdkRequestShapeFromWrapper(value *SdkRequestWrapper) *SdkRequestShape {
	return &SdkRequestShape{Type: "wrapper", Wrapper: value}
}

func (s *SdkRequestShape) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SdkRequestShape) GetJustRequestBody() *SdkRequestBodyType {
	if s == nil {
		return nil
	}
	return s.JustRequestBody
}

func (s *SdkRequestShape) GetWrapper() *SdkRequestWrapper {
	if s == nil {
		return nil
	}
	return s.Wrapper
}

func (s *SdkRequestShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "justRequestBody":
		var valueUnmarshaler struct {
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.JustRequestBody = valueUnmarshaler.JustRequestBody
	case "wrapper":
		value := new(SdkRequestWrapper)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Wrapper = value
	}
	return nil
}

func (s SdkRequestShape) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		var marshaler = struct {
			Type            string              `json:"type"`
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}{
			Type:            "justRequestBody",
			JustRequestBody: s.JustRequestBody,
		}
		return json.Marshal(marshaler)
	case "wrapper":
		return internal.MarshalJSONWithExtraProperty(s.Wrapper, "type", "wrapper")
	}
}

type SdkRequestShapeVisitor interface {
	VisitJustRequestBody(*SdkRequestBodyType) error
	VisitWrapper(*SdkRequestWrapper) error
}

func (s *SdkRequestShape) Accept(visitor SdkRequestShapeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return visitor.VisitJustRequestBody(s.JustRequestBody)
	case "wrapper":
		return visitor.VisitWrapper(s.Wrapper)
	}
}

func (s *SdkRequestShape) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.JustRequestBody != nil {
		fields = append(fields, "justRequestBody")
	}
	if s.Wrapper != nil {
		fields = append(fields, "wrapper")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SdkRequestWrapper struct {
	WrapperName           *Name `json:"wrapperName,omitempty" url:"wrapperName,omitempty"`
	BodyKey               *Name `json:"bodyKey,omitempty" url:"bodyKey,omitempty"`
	IncludePathParameters *bool `json:"includePathParameters,omitempty" url:"includePathParameters,omitempty"`
	OnlyPathParameters    *bool `json:"onlyPathParameters,omitempty" url:"onlyPathParameters,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkRequestWrapper) GetWrapperName() *Name {
	if s == nil {
		return nil
	}
	return s.WrapperName
}

func (s *SdkRequestWrapper) GetBodyKey() *Name {
	if s == nil {
		return nil
	}
	return s.BodyKey
}

func (s *SdkRequestWrapper) GetIncludePathParameters() *bool {
	if s == nil {
		return nil
	}
	return s.IncludePathParameters
}

func (s *SdkRequestWrapper) GetOnlyPathParameters() *bool {
	if s == nil {
		return nil
	}
	return s.OnlyPathParameters
}

func (s *SdkRequestWrapper) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkRequestWrapper) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkRequestWrapper
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkRequestWrapper(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkRequestWrapper) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SseStreamChunk struct {
	Docs       *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Payload    *TypeReference `json:"payload,omitempty" url:"payload,omitempty"`
	Terminator *string        `json:"terminator,omitempty" url:"terminator,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SseStreamChunk) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SseStreamChunk) GetPayload() *TypeReference {
	if s == nil {
		return nil
	}
	return s.Payload
}

func (s *SseStreamChunk) GetTerminator() *string {
	if s == nil {
		return nil
	}
	return s.Terminator
}

func (s *SseStreamChunk) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SseStreamChunk) UnmarshalJSON(data []byte) error {
	type unmarshaler SseStreamChunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SseStreamChunk(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SseStreamChunk) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamParameterResponse struct {
	NonStreamResponse *NonStreamHttpResponseBody `json:"nonStreamResponse,omitempty" url:"nonStreamResponse,omitempty"`
	StreamResponse    *StreamingResponse         `json:"streamResponse,omitempty" url:"streamResponse,omitempty"`

	extraProperties map[string]interface{}
}

func (s *StreamParameterResponse) GetNonStreamResponse() *NonStreamHttpResponseBody {
	if s == nil {
		return nil
	}
	return s.NonStreamResponse
}

func (s *StreamParameterResponse) GetStreamResponse() *StreamingResponse {
	if s == nil {
		return nil
	}
	return s.StreamResponse
}

func (s *StreamParameterResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StreamParameterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamParameterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamParameterResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StreamParameterResponse) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamingResponse struct {
	Type string
	Json *JsonStreamChunk
	Text *TextStreamChunk
	Sse  *SseStreamChunk
}

func NewStreamingResponseFromJson(value *JsonStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "json", Json: value}
}

func NewStreamingResponseFromText(value *TextStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "text", Text: value}
}

func NewStreamingResponseFromSse(value *SseStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "sse", Sse: value}
}

func (s *StreamingResponse) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *StreamingResponse) GetJson() *JsonStreamChunk {
	if s == nil {
		return nil
	}
	return s.Json
}

func (s *StreamingResponse) GetText() *TextStreamChunk {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *StreamingResponse) GetSse() *SseStreamChunk {
	if s == nil {
		return nil
	}
	return s.Sse
}

func (s *StreamingResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "json":
		value := new(JsonStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Json = value
	case "text":
		value := new(TextStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	case "sse":
		value := new(SseStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Sse = value
	}
	return nil
}

func (s StreamingResponse) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return internal.MarshalJSONWithExtraProperty(s.Json, "type", "json")
	case "text":
		return internal.MarshalJSONWithExtraProperty(s.Text, "type", "text")
	case "sse":
		return internal.MarshalJSONWithExtraProperty(s.Sse, "type", "sse")
	}
}

type StreamingResponseVisitor interface {
	VisitJson(*JsonStreamChunk) error
	VisitText(*TextStreamChunk) error
	VisitSse(*SseStreamChunk) error
}

func (s *StreamingResponse) Accept(visitor StreamingResponseVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return visitor.VisitJson(s.Json)
	case "text":
		return visitor.VisitText(s.Text)
	case "sse":
		return visitor.VisitSse(s.Sse)
	}
}

func (s *StreamingResponse) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Json != nil {
		fields = append(fields, "json")
	}
	if s.Text != nil {
		fields = append(fields, "text")
	}
	if s.Sse != nil {
		fields = append(fields, "sse")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SupportedSdkLanguage string

const (
	SupportedSdkLanguageCurl       SupportedSdkLanguage = "curl"
	SupportedSdkLanguagePython     SupportedSdkLanguage = "python"
	SupportedSdkLanguageJavascript SupportedSdkLanguage = "javascript"
	SupportedSdkLanguageTypescript SupportedSdkLanguage = "typescript"
	SupportedSdkLanguageGo         SupportedSdkLanguage = "go"
	SupportedSdkLanguageRuby       SupportedSdkLanguage = "ruby"
	SupportedSdkLanguageCsharp     SupportedSdkLanguage = "csharp"
	SupportedSdkLanguageJava       SupportedSdkLanguage = "java"
)

func NewSupportedSdkLanguageFromString(s string) (SupportedSdkLanguage, error) {
	switch s {
	case "curl":
		return SupportedSdkLanguageCurl, nil
	case "python":
		return SupportedSdkLanguagePython, nil
	case "javascript":
		return SupportedSdkLanguageJavascript, nil
	case "typescript":
		return SupportedSdkLanguageTypescript, nil
	case "go":
		return SupportedSdkLanguageGo, nil
	case "ruby":
		return SupportedSdkLanguageRuby, nil
	case "csharp":
		return SupportedSdkLanguageCsharp, nil
	case "java":
		return SupportedSdkLanguageJava, nil
	}
	var t SupportedSdkLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SupportedSdkLanguage) Ptr() *SupportedSdkLanguage {
	return &s
}

type TextResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (t *TextResponse) GetDocs() *string {
	if t == nil {
		return nil
	}
	return t.Docs
}

func (t *TextResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TextResponse) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextStreamChunk struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (t *TextStreamChunk) GetDocs() *string {
	if t == nil {
		return nil
	}
	return t.Docs
}

func (t *TextStreamChunk) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextStreamChunk) UnmarshalJSON(data []byte) error {
	type unmarshaler TextStreamChunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TextStreamChunk(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TextStreamChunk) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Transport struct {
	Type string
	Http interface{}
	Grpc *GrpcTransport
}

func NewTransportFromHttp(value interface{}) *Transport {
	return &Transport{Type: "http", Http: value}
}

func NewTransportFromGrpc(value *GrpcTransport) *Transport {
	return &Transport{Type: "grpc", Grpc: value}
}

func (t *Transport) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Transport) GetHttp() interface{} {
	if t == nil {
		return nil
	}
	return t.Http
}

func (t *Transport) GetGrpc() *GrpcTransport {
	if t == nil {
		return nil
	}
	return t.Grpc
}

func (t *Transport) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "http":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Http = value
	case "grpc":
		value := new(GrpcTransport)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Grpc = value
	}
	return nil
}

func (t Transport) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "http":
		var marshaler = struct {
			Type string      `json:"type"`
			Http interface{} `json:"http,omitempty"`
		}{
			Type: "http",
			Http: t.Http,
		}
		return json.Marshal(marshaler)
	case "grpc":
		return internal.MarshalJSONWithExtraProperty(t.Grpc, "type", "grpc")
	}
}

type TransportVisitor interface {
	VisitHttp(interface{}) error
	VisitGrpc(*GrpcTransport) error
}

func (t *Transport) Accept(visitor TransportVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "http":
		return visitor.VisitHttp(t.Http)
	case "grpc":
		return visitor.VisitGrpc(t.Grpc)
	}
}

func (t *Transport) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Http != nil {
		fields = append(fields, "http")
	}
	if t.Grpc != nil {
		fields = append(fields, "grpc")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type UserSpecifiedEndpointExample struct {
	// Manually written code samples specified by the user
	CodeSamples []*ExampleCodeSample `json:"codeSamples,omitempty" url:"codeSamples,omitempty"`
	// Manually written example specified by the user
	Example *ExampleEndpointCall `json:"example,omitempty" url:"example,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UserSpecifiedEndpointExample) GetCodeSamples() []*ExampleCodeSample {
	if u == nil {
		return nil
	}
	return u.CodeSamples
}

func (u *UserSpecifiedEndpointExample) GetExample() *ExampleEndpointCall {
	if u == nil {
		return nil
	}
	return u.Example
}

func (u *UserSpecifiedEndpointExample) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSpecifiedEndpointExample) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSpecifiedEndpointExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSpecifiedEndpointExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserSpecifiedEndpointExample) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Code generated by Fern. DO NOT EDIT.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	common "github.com/fern-api/fern-go/internal/fern/ir/common"
	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

var (
	availabilityFieldStatus  = big.NewInt(1 << 0)
	availabilityFieldMessage = big.NewInt(1 << 1)
)

type Availability struct {
	Status  AvailabilityStatus `json:"status" url:"status"`
	Message *string            `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (a *Availability) GetStatus() AvailabilityStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *Availability) GetMessage() *string {
	if a == nil {
		return nil
	}
	return a.Message
}

func (a *Availability) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Availability) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Availability) SetStatus(status AvailabilityStatus) {
	a.Status = status
	a.require(availabilityFieldStatus)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Availability) SetMessage(message *string) {
	a.Message = message
	a.require(availabilityFieldMessage)
}

func (a *Availability) UnmarshalJSON(data []byte) error {
	type unmarshaler Availability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Availability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *Availability) MarshalJSON() ([]byte, error) {
	type embed Availability
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Availability) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

var (
	declarationFieldDocs         = big.NewInt(1 << 0)
	declarationFieldAvailability = big.NewInt(1 << 1)
)

type Declaration struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetDocs() *string {
	if d == nil {
		return nil
	}
	return d.Docs
}

func (d *Declaration) GetAvailability() *Availability {
	if d == nil {
		return nil
	}
	return d.Availability
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Declaration) SetDocs(docs *string) {
	d.Docs = docs
	d.require(declarationFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Declaration) SetAvailability(availability *Availability) {
	d.Availability = availability
	d.require(declarationFieldAvailability)
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Declaration) MarshalJSON() ([]byte, error) {
	type embed Declaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Declaration) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisplayName = string

var (
	endpointReferenceFieldEndpointId   = big.NewInt(1 << 0)
	endpointReferenceFieldServiceId    = big.NewInt(1 << 1)
	endpointReferenceFieldSubpackageId = big.NewInt(1 << 2)
)

type EndpointReference struct {
	EndpointId common.EndpointId `json:"endpointId" url:"endpointId"`
	ServiceId  ServiceId         `json:"serviceId" url:"serviceId"`
	// The subpackage that defines the endpoint. If empty, the endpoint is
	// defined in the root package.
	SubpackageId *SubpackageId `json:"subpackageId,omitempty" url:"subpackageId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EndpointReference) GetEndpointId() common.EndpointId {
	if e == nil {
		return ""
	}
	return e.EndpointId
}

func (e *EndpointReference) GetServiceId() ServiceId {
	if e == nil {
		return ""
	}
	return e.ServiceId
}

func (e *EndpointReference) GetSubpackageId() *SubpackageId {
	if e == nil {
		return nil
	}
	return e.SubpackageId
}

func (e *EndpointReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointReference) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEndpointId sets the EndpointId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointReference) SetEndpointId(endpointId common.EndpointId) {
	e.EndpointId = endpointId
	e.require(endpointReferenceFieldEndpointId)
}

// SetServiceId sets the ServiceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointReference) SetServiceId(serviceId ServiceId) {
	e.ServiceId = serviceId
	e.require(endpointReferenceFieldServiceId)
}

// SetSubpackageId sets the SubpackageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointReference) SetSubpackageId(subpackageId *SubpackageId) {
	e.SubpackageId = subpackageId
	e.require(endpointReferenceFieldSubpackageId)
}

func (e *EndpointReference) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointReference) MarshalJSON() ([]byte, error) {
	type embed EndpointReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EndpointReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorId = string

// Defines the original string, and its escaped-equivalent (depending on the target programming language).
// This is particularly relevant to example string literals.
//
// For example, in Python we escape strings that contain single or double quotes by using triple quotes,
// in Go we use backticks, etc.
var (
	escapedStringFieldOriginal = big.NewInt(1 << 0)
)

type EscapedString struct {
	Original string `json:"original" url:"original"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EscapedString) GetOriginal() string {
	if e == nil {
		return ""
	}
	return e.Original
}

func (e *EscapedString) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EscapedString) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetOriginal sets the Original field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EscapedString) SetOriginal(original string) {
	e.Original = original
	e.require(escapedStringFieldOriginal)
}

func (e *EscapedString) UnmarshalJSON(data []byte) error {
	type unmarshaler EscapedString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EscapedString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EscapedString) MarshalJSON() ([]byte, error) {
	type embed EscapedString
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EscapedString) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FeatureId = string

type ServiceId = string

type SubpackageId = string

type WebSocketChannelId = string

type WebhookGroupId = string

type WebhookId = string

var (
	withContentTypeFieldContentType = big.NewInt(1 << 0)
)

type WithContentType struct {
	ContentType *string `json:"contentType,omitempty" url:"contentType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithContentType) GetContentType() *string {
	if w == nil {
		return nil
	}
	return w.ContentType
}

func (w *WithContentType) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithContentType) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetContentType sets the ContentType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithContentType) SetContentType(contentType *string) {
	w.ContentType = contentType
	w.require(withContentTypeFieldContentType)
}

func (w *WithContentType) UnmarshalJSON(data []byte) error {
	type unmarshaler WithContentType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithContentType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithContentType) MarshalJSON() ([]byte, error) {
	type embed WithContentType
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithContentType) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

var (
	withDocsAndAvailabilityFieldDocs         = big.NewInt(1 << 0)
	withDocsAndAvailabilityFieldAvailability = big.NewInt(1 << 1)
)

type WithDocsAndAvailability struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithDocsAndAvailability) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WithDocsAndAvailability) GetAvailability() *Availability {
	if w == nil {
		return nil
	}
	return w.Availability
}

func (w *WithDocsAndAvailability) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithDocsAndAvailability) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithDocsAndAvailability) SetDocs(docs *string) {
	w.Docs = docs
	w.require(withDocsAndAvailabilityFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithDocsAndAvailability) SetAvailability(availability *Availability) {
	w.Availability = availability
	w.require(withDocsAndAvailabilityFieldAvailability)
}

func (w *WithDocsAndAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler WithDocsAndAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithDocsAndAvailability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithDocsAndAvailability) MarshalJSON() ([]byte, error) {
	type embed WithDocsAndAvailability
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithDocsAndAvailability) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

var (
	withJsonExampleFieldJsonExample = big.NewInt(1 << 0)
)

type WithJsonExample struct {
	JsonExample interface{} `json:"jsonExample" url:"jsonExample"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithJsonExample) GetJsonExample() interface{} {
	if w == nil {
		return nil
	}
	return w.JsonExample
}

func (w *WithJsonExample) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithJsonExample) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetJsonExample sets the JsonExample field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithJsonExample) SetJsonExample(jsonExample interface{}) {
	w.JsonExample = jsonExample
	w.require(withJsonExampleFieldJsonExample)
}

func (w *WithJsonExample) UnmarshalJSON(data []byte) error {
	type unmarshaler WithJsonExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithJsonExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithJsonExample) MarshalJSON() ([]byte, error) {
	type embed WithJsonExample
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithJsonExample) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

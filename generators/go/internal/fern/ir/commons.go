// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type Availability struct {
	Status  AvailabilityStatus `json:"status" url:"status"`
	Message *string            `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
}

func (a *Availability) GetStatus() AvailabilityStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *Availability) GetMessage() *string {
	if a == nil {
		return nil
	}
	return a.Message
}

func (a *Availability) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Availability) UnmarshalJSON(data []byte) error {
	type unmarshaler Availability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Availability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *Availability) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

type Declaration struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetDocs() *string {
	if d == nil {
		return nil
	}
	return d.Docs
}

func (d *Declaration) GetAvailability() *Availability {
	if d == nil {
		return nil
	}
	return d.Availability
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Declaration) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointReference struct {
	EndpointId EndpointId `json:"endpointId" url:"endpointId"`
	ServiceId  ServiceId  `json:"serviceId" url:"serviceId"`
	// The subpackage that defines the endpoint. If empty, the endpoint is
	// defined in the root package.
	SubpackageId *SubpackageId `json:"subpackageId,omitempty" url:"subpackageId,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EndpointReference) GetEndpointId() EndpointId {
	if e == nil {
		return ""
	}
	return e.EndpointId
}

func (e *EndpointReference) GetServiceId() ServiceId {
	if e == nil {
		return ""
	}
	return e.ServiceId
}

func (e *EndpointReference) GetSubpackageId() *SubpackageId {
	if e == nil {
		return nil
	}
	return e.SubpackageId
}

func (e *EndpointReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointReference) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorId = string

// Defines the original string, and its escaped-equivalent (depending on the target programming language).
// This is particularly relevant to example string literals.
//
// For example, in Python we escape strings that contain single or double quotes by using triple quotes,
// in Go we use backticks, etc.
type EscapedString struct {
	Original string `json:"original" url:"original"`

	extraProperties map[string]interface{}
}

func (e *EscapedString) GetOriginal() string {
	if e == nil {
		return ""
	}
	return e.Original
}

func (e *EscapedString) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EscapedString) UnmarshalJSON(data []byte) error {
	type unmarshaler EscapedString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EscapedString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EscapedString) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FeatureId = string

type ServiceId = string

type SubpackageId = string

type WebSocketChannelId = string

type WebhookGroupId = string

type WebhookId = string

type WithDocsAndAvailability struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WithDocsAndAvailability) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WithDocsAndAvailability) GetAvailability() *Availability {
	if w == nil {
		return nil
	}
	return w.Availability
}

func (w *WithDocsAndAvailability) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithDocsAndAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler WithDocsAndAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithDocsAndAvailability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithDocsAndAvailability) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WithJsonExample struct {
	JsonExample interface{} `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WithJsonExample) GetJsonExample() interface{} {
	if w == nil {
		return nil
	}
	return w.JsonExample
}

func (w *WithJsonExample) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithJsonExample) UnmarshalJSON(data []byte) error {
	type unmarshaler WithJsonExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithJsonExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithJsonExample) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	common "sdk/common"
	internal "sdk/internal"
)

type ApiDefinitionSource struct {
	Type    string
	Proto   *ProtoSource
	Openapi interface{}
}

func NewApiDefinitionSourceFromProto(value *ProtoSource) *ApiDefinitionSource {
	return &ApiDefinitionSource{Type: "proto", Proto: value}
}

func NewApiDefinitionSourceFromOpenapi(value interface{}) *ApiDefinitionSource {
	return &ApiDefinitionSource{Type: "openapi", Openapi: value}
}

func (a *ApiDefinitionSource) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ApiDefinitionSource) GetProto() *ProtoSource {
	if a == nil {
		return nil
	}
	return a.Proto
}

func (a *ApiDefinitionSource) GetOpenapi() interface{} {
	if a == nil {
		return nil
	}
	return a.Openapi
}

func (a *ApiDefinitionSource) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "proto":
		value := new(ProtoSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Proto = value
	case "openapi":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Openapi = value
	}
	return nil
}

func (a ApiDefinitionSource) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "proto":
		return internal.MarshalJSONWithExtraProperty(a.Proto, "type", "proto")
	case "openapi":
		var marshaler = struct {
			Type    string      `json:"type"`
			Openapi interface{} `json:"openapi,omitempty"`
		}{
			Type:    "openapi",
			Openapi: a.Openapi,
		}
		return json.Marshal(marshaler)
	}
}

type ApiDefinitionSourceVisitor interface {
	VisitProto(*ProtoSource) error
	VisitOpenapi(interface{}) error
}

func (a *ApiDefinitionSource) Accept(visitor ApiDefinitionSourceVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "proto":
		return visitor.VisitProto(a.Proto)
	case "openapi":
		return visitor.VisitOpenapi(a.Openapi)
	}
}

func (a *ApiDefinitionSource) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Proto != nil {
		fields = append(fields, "proto")
	}
	if a.Openapi != nil {
		fields = append(fields, "openapi")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// Uniquely identifies a specific API definition source. This allows us to clearly identify
// what source a given type, endpoint, etc was derived from.
type ApiDefinitionSourceId = string

// The available set of versions for the API. This is used to generate a special
// enum that can be used to specify the version of the API to use.
type ApiVersionScheme struct {
	Type   string
	Header *HeaderApiVersionScheme
}

func NewApiVersionSchemeFromHeader(value *HeaderApiVersionScheme) *ApiVersionScheme {
	return &ApiVersionScheme{Type: "header", Header: value}
}

func (a *ApiVersionScheme) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ApiVersionScheme) GetHeader() *HeaderApiVersionScheme {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *ApiVersionScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "header":
		value := new(HeaderApiVersionScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a ApiVersionScheme) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "header":
		return internal.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
}

type ApiVersionSchemeVisitor interface {
	VisitHeader(*HeaderApiVersionScheme) error
}

func (a *ApiVersionScheme) Accept(visitor ApiVersionSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

func (a *ApiVersionScheme) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type ErrorDiscriminationByPropertyStrategy struct {
	Discriminant    *common.NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	ContentProperty *common.NameAndWireValue `json:"contentProperty,omitempty" url:"contentProperty,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ErrorDiscriminationByPropertyStrategy) GetDiscriminant() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Discriminant
}

func (e *ErrorDiscriminationByPropertyStrategy) GetContentProperty() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.ContentProperty
}

func (e *ErrorDiscriminationByPropertyStrategy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorDiscriminationByPropertyStrategy) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorDiscriminationByPropertyStrategy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorDiscriminationByPropertyStrategy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ErrorDiscriminationByPropertyStrategy) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDiscriminationStrategy struct {
	Type       string
	StatusCode interface{}
	Property   *ErrorDiscriminationByPropertyStrategy
}

func NewErrorDiscriminationStrategyFromStatusCode(value interface{}) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "statusCode", StatusCode: value}
}

func NewErrorDiscriminationStrategyFromProperty(value *ErrorDiscriminationByPropertyStrategy) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "property", Property: value}
}

func (e *ErrorDiscriminationStrategy) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ErrorDiscriminationStrategy) GetStatusCode() interface{} {
	if e == nil {
		return nil
	}
	return e.StatusCode
}

func (e *ErrorDiscriminationStrategy) GetProperty() *ErrorDiscriminationByPropertyStrategy {
	if e == nil {
		return nil
	}
	return e.Property
}

func (e *ErrorDiscriminationStrategy) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	case "property":
		value := new(ErrorDiscriminationByPropertyStrategy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	}
	return nil
}

func (e ErrorDiscriminationStrategy) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	case "property":
		return internal.MarshalJSONWithExtraProperty(e.Property, "type", "property")
	}
}

type ErrorDiscriminationStrategyVisitor interface {
	VisitStatusCode(interface{}) error
	VisitProperty(*ErrorDiscriminationByPropertyStrategy) error
}

func (e *ErrorDiscriminationStrategy) Accept(visitor ErrorDiscriminationStrategyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	case "property":
		return visitor.VisitProperty(e.Property)
	}
}

func (e *ErrorDiscriminationStrategy) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.StatusCode != nil {
		fields = append(fields, "statusCode")
	}
	if e.Property != nil {
		fields = append(fields, "property")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

// The version information is sent as an HTTP header (e.g. X-API-Version) on every request.
//
// If the enum does _not_ define a default value, the version should be treated like
// a required global header parameter. The version header should also support any
// environment variable scanning specified by the header.
type HeaderApiVersionScheme struct {
	Header *HttpHeader          `json:"header,omitempty" url:"header,omitempty"`
	Value  *EnumTypeDeclaration `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HeaderApiVersionScheme) GetHeader() *HttpHeader {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HeaderApiVersionScheme) GetValue() *EnumTypeDeclaration {
	if h == nil {
		return nil
	}
	return h.Value
}

func (h *HeaderApiVersionScheme) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderApiVersionScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderApiVersionScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderApiVersionScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderApiVersionScheme) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Complete representation of the API schema
type IntermediateRepresentation struct {
	// The unique identifier for the API definition used within FDR. This is retrieved once a definition has been registered.
	FdrApiDefinitionId *string           `json:"fdrApiDefinitionId,omitempty" url:"fdrApiDefinitionId,omitempty"`
	ApiVersion         *ApiVersionScheme `json:"apiVersion,omitempty" url:"apiVersion,omitempty"`
	// This is the human readable unique id for the API.
	ApiName        *common.Name `json:"apiName,omitempty" url:"apiName,omitempty"`
	ApiDisplayName *string      `json:"apiDisplayName,omitempty" url:"apiDisplayName,omitempty"`
	ApiDocs        *string      `json:"apiDocs,omitempty" url:"apiDocs,omitempty"`
	Auth           *ApiAuth     `json:"auth,omitempty" url:"auth,omitempty"`
	// API Wide headers that are sent on every request
	Headers []*HttpHeader `json:"headers,omitempty" url:"headers,omitempty"`
	// Headers that are sent for idempotent endpoints
	IdempotencyHeaders []*HttpHeader `json:"idempotencyHeaders,omitempty" url:"idempotencyHeaders,omitempty"`
	// The types described by this API
	Types map[common.TypeId]*TypeDeclaration `json:"types,omitempty" url:"types,omitempty"`
	// The services exposed by this API
	Services map[ServiceId]*HttpService `json:"services,omitempty" url:"services,omitempty"`
	// The webhooks sent by this API
	WebhookGroups map[WebhookGroupId]WebhookGroup `json:"webhookGroups,omitempty" url:"webhookGroups,omitempty"`
	// The websocket channels served by this API
	WebsocketChannels           map[WebSocketChannelId]*WebSocketChannel   `json:"websocketChannels,omitempty" url:"websocketChannels,omitempty"`
	Errors                      map[ErrorId]*ErrorDeclaration              `json:"errors,omitempty" url:"errors,omitempty"`
	Subpackages                 map[SubpackageId]*Subpackage               `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	RootPackage                 *Package                                   `json:"rootPackage,omitempty" url:"rootPackage,omitempty"`
	Constants                   *Constants                                 `json:"constants,omitempty" url:"constants,omitempty"`
	Environments                *common.EnvironmentsConfig                 `json:"environments,omitempty" url:"environments,omitempty"`
	BasePath                    *HttpPath                                  `json:"basePath,omitempty" url:"basePath,omitempty"`
	PathParameters              []*PathParameter                           `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	ErrorDiscriminationStrategy *ErrorDiscriminationStrategy               `json:"errorDiscriminationStrategy,omitempty" url:"errorDiscriminationStrategy,omitempty"`
	SdkConfig                   *SdkConfig                                 `json:"sdkConfig,omitempty" url:"sdkConfig,omitempty"`
	Variables                   []*VariableDeclaration                     `json:"variables,omitempty" url:"variables,omitempty"`
	ServiceTypeReferenceInfo    *ServiceTypeReferenceInfo                  `json:"serviceTypeReferenceInfo,omitempty" url:"serviceTypeReferenceInfo,omitempty"`
	ReadmeConfig                *ReadmeConfig                              `json:"readmeConfig,omitempty" url:"readmeConfig,omitempty"`
	SourceConfig                *SourceConfig                              `json:"sourceConfig,omitempty" url:"sourceConfig,omitempty"`
	PublishConfig               *PublishingConfig                          `json:"publishConfig,omitempty" url:"publishConfig,omitempty"`
	Dynamic                     *dynamic.DynamicIntermediateRepresentation `json:"dynamic,omitempty" url:"dynamic,omitempty"`

	extraProperties map[string]interface{}
}

func (i *IntermediateRepresentation) GetFdrApiDefinitionId() *string {
	if i == nil {
		return nil
	}
	return i.FdrApiDefinitionId
}

func (i *IntermediateRepresentation) GetApiVersion() *ApiVersionScheme {
	if i == nil {
		return nil
	}
	return i.ApiVersion
}

func (i *IntermediateRepresentation) GetApiName() *common.Name {
	if i == nil {
		return nil
	}
	return i.ApiName
}

func (i *IntermediateRepresentation) GetApiDisplayName() *string {
	if i == nil {
		return nil
	}
	return i.ApiDisplayName
}

func (i *IntermediateRepresentation) GetApiDocs() *string {
	if i == nil {
		return nil
	}
	return i.ApiDocs
}

func (i *IntermediateRepresentation) GetAuth() *ApiAuth {
	if i == nil {
		return nil
	}
	return i.Auth
}

func (i *IntermediateRepresentation) GetHeaders() []*HttpHeader {
	if i == nil {
		return nil
	}
	return i.Headers
}

func (i *IntermediateRepresentation) GetIdempotencyHeaders() []*HttpHeader {
	if i == nil {
		return nil
	}
	return i.IdempotencyHeaders
}

func (i *IntermediateRepresentation) GetTypes() map[common.TypeId]*TypeDeclaration {
	if i == nil {
		return nil
	}
	return i.Types
}

func (i *IntermediateRepresentation) GetServices() map[ServiceId]*HttpService {
	if i == nil {
		return nil
	}
	return i.Services
}

func (i *IntermediateRepresentation) GetWebhookGroups() map[WebhookGroupId]WebhookGroup {
	if i == nil {
		return nil
	}
	return i.WebhookGroups
}

func (i *IntermediateRepresentation) GetWebsocketChannels() map[WebSocketChannelId]*WebSocketChannel {
	if i == nil {
		return nil
	}
	return i.WebsocketChannels
}

func (i *IntermediateRepresentation) GetErrors() map[ErrorId]*ErrorDeclaration {
	if i == nil {
		return nil
	}
	return i.Errors
}

func (i *IntermediateRepresentation) GetSubpackages() map[SubpackageId]*Subpackage {
	if i == nil {
		return nil
	}
	return i.Subpackages
}

func (i *IntermediateRepresentation) GetRootPackage() *Package {
	if i == nil {
		return nil
	}
	return i.RootPackage
}

func (i *IntermediateRepresentation) GetConstants() *Constants {
	if i == nil {
		return nil
	}
	return i.Constants
}

func (i *IntermediateRepresentation) GetEnvironments() *common.EnvironmentsConfig {
	if i == nil {
		return nil
	}
	return i.Environments
}

func (i *IntermediateRepresentation) GetBasePath() *HttpPath {
	if i == nil {
		return nil
	}
	return i.BasePath
}

func (i *IntermediateRepresentation) GetPathParameters() []*PathParameter {
	if i == nil {
		return nil
	}
	return i.PathParameters
}

func (i *IntermediateRepresentation) GetErrorDiscriminationStrategy() *ErrorDiscriminationStrategy {
	if i == nil {
		return nil
	}
	return i.ErrorDiscriminationStrategy
}

func (i *IntermediateRepresentation) GetSdkConfig() *SdkConfig {
	if i == nil {
		return nil
	}
	return i.SdkConfig
}

func (i *IntermediateRepresentation) GetVariables() []*VariableDeclaration {
	if i == nil {
		return nil
	}
	return i.Variables
}

func (i *IntermediateRepresentation) GetServiceTypeReferenceInfo() *ServiceTypeReferenceInfo {
	if i == nil {
		return nil
	}
	return i.ServiceTypeReferenceInfo
}

func (i *IntermediateRepresentation) GetReadmeConfig() *ReadmeConfig {
	if i == nil {
		return nil
	}
	return i.ReadmeConfig
}

func (i *IntermediateRepresentation) GetSourceConfig() *SourceConfig {
	if i == nil {
		return nil
	}
	return i.SourceConfig
}

func (i *IntermediateRepresentation) GetPublishConfig() *PublishingConfig {
	if i == nil {
		return nil
	}
	return i.PublishConfig
}

func (i *IntermediateRepresentation) GetDynamic() *dynamic.DynamicIntermediateRepresentation {
	if i == nil {
		return nil
	}
	return i.Dynamic
}

func (i *IntermediateRepresentation) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntermediateRepresentation) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermediateRepresentation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermediateRepresentation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntermediateRepresentation) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Package struct {
	Docs               *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *common.FernFilepath     `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty" url:"service,omitempty"`
	Types              []common.TypeId          `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty" url:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty" url:"webhooks,omitempty"`
	Websocket          *WebSocketChannelId      `json:"websocket,omitempty" url:"websocket,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty" url:"navigationConfig,omitempty"`

	extraProperties map[string]interface{}
}

func (p *Package) GetDocs() *string {
	if p == nil {
		return nil
	}
	return p.Docs
}

func (p *Package) GetFernFilepath() *common.FernFilepath {
	if p == nil {
		return nil
	}
	return p.FernFilepath
}

func (p *Package) GetService() *ServiceId {
	if p == nil {
		return nil
	}
	return p.Service
}

func (p *Package) GetTypes() []common.TypeId {
	if p == nil {
		return nil
	}
	return p.Types
}

func (p *Package) GetErrors() []ErrorId {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *Package) GetWebhooks() *WebhookGroupId {
	if p == nil {
		return nil
	}
	return p.Webhooks
}

func (p *Package) GetWebsocket() *WebSocketChannelId {
	if p == nil {
		return nil
	}
	return p.Websocket
}

func (p *Package) GetSubpackages() []SubpackageId {
	if p == nil {
		return nil
	}
	return p.Subpackages
}

func (p *Package) GetHasEndpointsInTree() bool {
	if p == nil {
		return false
	}
	return p.HasEndpointsInTree
}

func (p *Package) GetNavigationConfig() *PackageNavigationConfig {
	if p == nil {
		return nil
	}
	return p.NavigationConfig
}

func (p *Package) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Package) UnmarshalJSON(data []byte) error {
	type unmarshaler Package
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Package(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *Package) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PackageNavigationConfig struct {
	PointsTo SubpackageId `json:"pointsTo" url:"pointsTo"`

	extraProperties map[string]interface{}
}

func (p *PackageNavigationConfig) GetPointsTo() SubpackageId {
	if p == nil {
		return ""
	}
	return p.PointsTo
}

func (p *PackageNavigationConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PackageNavigationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PackageNavigationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PackageNavigationConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PackageNavigationConfig) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlatformHeaders struct {
	Language   string     `json:"language" url:"language"`
	SdkName    string     `json:"sdkName" url:"sdkName"`
	SdkVersion string     `json:"sdkVersion" url:"sdkVersion"`
	UserAgent  *UserAgent `json:"userAgent,omitempty" url:"userAgent,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PlatformHeaders) GetLanguage() string {
	if p == nil {
		return ""
	}
	return p.Language
}

func (p *PlatformHeaders) GetSdkName() string {
	if p == nil {
		return ""
	}
	return p.SdkName
}

func (p *PlatformHeaders) GetSdkVersion() string {
	if p == nil {
		return ""
	}
	return p.SdkVersion
}

func (p *PlatformHeaders) GetUserAgent() *UserAgent {
	if p == nil {
		return nil
	}
	return p.UserAgent
}

func (p *PlatformHeaders) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlatformHeaders) UnmarshalJSON(data []byte) error {
	type unmarshaler PlatformHeaders
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlatformHeaders(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PlatformHeaders) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProtoSource struct {
	Id ApiDefinitionSourceId `json:"id" url:"id"`
	// The URL containing the `.proto` root directory source. This can be used
	// to pull down the original `.proto` source files during code generation.
	ProtoRootUrl string `json:"protoRootUrl" url:"protoRootUrl"`

	extraProperties map[string]interface{}
}

func (p *ProtoSource) GetId() ApiDefinitionSourceId {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *ProtoSource) GetProtoRootUrl() string {
	if p == nil {
		return ""
	}
	return p.ProtoRootUrl
}

func (p *ProtoSource) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtoSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtoSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtoSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtoSource) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The configuration used to generate a README.md file. If present, the generator
// should call the generator-cli to produce a README.md.
type ReadmeConfig struct {
	// If specified, this endpoint should be used in every snippet (if possible).
	// Note that some endpoints aren't suitable for every feature (e.g. a non-list
	// endpoint for pagination), so the default is a no-op in those cases.
	DefaultEndpoint  *common.EndpointId `json:"defaultEndpoint,omitempty" url:"defaultEndpoint,omitempty"`
	BannerLink       *string            `json:"bannerLink,omitempty" url:"bannerLink,omitempty"`
	Introduction     *string            `json:"introduction,omitempty" url:"introduction,omitempty"`
	ApiReferenceLink *string            `json:"apiReferenceLink,omitempty" url:"apiReferenceLink,omitempty"`
	// If specified, configures the list of endpoints to associate
	// with each feature.
	Features map[FeatureId][]common.EndpointId `json:"features,omitempty" url:"features,omitempty"`

	extraProperties map[string]interface{}
}

func (r *ReadmeConfig) GetDefaultEndpoint() *common.EndpointId {
	if r == nil {
		return nil
	}
	return r.DefaultEndpoint
}

func (r *ReadmeConfig) GetBannerLink() *string {
	if r == nil {
		return nil
	}
	return r.BannerLink
}

func (r *ReadmeConfig) GetIntroduction() *string {
	if r == nil {
		return nil
	}
	return r.Introduction
}

func (r *ReadmeConfig) GetApiReferenceLink() *string {
	if r == nil {
		return nil
	}
	return r.ApiReferenceLink
}

func (r *ReadmeConfig) GetFeatures() map[FeatureId][]common.EndpointId {
	if r == nil {
		return nil
	}
	return r.Features
}

func (r *ReadmeConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadmeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadmeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadmeConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ReadmeConfig) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SdkConfig struct {
	IsAuthMandatory          bool             `json:"isAuthMandatory" url:"isAuthMandatory"`
	HasStreamingEndpoints    bool             `json:"hasStreamingEndpoints" url:"hasStreamingEndpoints"`
	HasPaginatedEndpoints    bool             `json:"hasPaginatedEndpoints" url:"hasPaginatedEndpoints"`
	HasFileDownloadEndpoints bool             `json:"hasFileDownloadEndpoints" url:"hasFileDownloadEndpoints"`
	PlatformHeaders          *PlatformHeaders `json:"platformHeaders,omitempty" url:"platformHeaders,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkConfig) GetIsAuthMandatory() bool {
	if s == nil {
		return false
	}
	return s.IsAuthMandatory
}

func (s *SdkConfig) GetHasStreamingEndpoints() bool {
	if s == nil {
		return false
	}
	return s.HasStreamingEndpoints
}

func (s *SdkConfig) GetHasPaginatedEndpoints() bool {
	if s == nil {
		return false
	}
	return s.HasPaginatedEndpoints
}

func (s *SdkConfig) GetHasFileDownloadEndpoints() bool {
	if s == nil {
		return false
	}
	return s.HasFileDownloadEndpoints
}

func (s *SdkConfig) GetPlatformHeaders() *PlatformHeaders {
	if s == nil {
		return nil
	}
	return s.PlatformHeaders
}

func (s *SdkConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkConfig) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceTypeReferenceInfo struct {
	// Types referenced by exactly one service.
	TypesReferencedOnlyByService map[ServiceId][]common.TypeId `json:"typesReferencedOnlyByService,omitempty" url:"typesReferencedOnlyByService,omitempty"`
	// Types referenced by either zero or multiple services.
	SharedTypes []common.TypeId `json:"sharedTypes,omitempty" url:"sharedTypes,omitempty"`

	extraProperties map[string]interface{}
}

func (s *ServiceTypeReferenceInfo) GetTypesReferencedOnlyByService() map[ServiceId][]common.TypeId {
	if s == nil {
		return nil
	}
	return s.TypesReferencedOnlyByService
}

func (s *ServiceTypeReferenceInfo) GetSharedTypes() []common.TypeId {
	if s == nil {
		return nil
	}
	return s.SharedTypes
}

func (s *ServiceTypeReferenceInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServiceTypeReferenceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ServiceTypeReferenceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServiceTypeReferenceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *ServiceTypeReferenceInfo) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceConfig struct {
	// The raw API definitions that produced the IR.
	Sources []*ApiDefinitionSource `json:"sources,omitempty" url:"sources,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SourceConfig) GetSources() []*ApiDefinitionSource {
	if s == nil {
		return nil
	}
	return s.Sources
}

func (s *SourceConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SourceConfig) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subpackage struct {
	Docs               *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *common.FernFilepath     `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty" url:"service,omitempty"`
	Types              []common.TypeId          `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty" url:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty" url:"webhooks,omitempty"`
	Websocket          *WebSocketChannelId      `json:"websocket,omitempty" url:"websocket,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty" url:"navigationConfig,omitempty"`
	Name               *common.Name             `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (s *Subpackage) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *Subpackage) GetFernFilepath() *common.FernFilepath {
	if s == nil {
		return nil
	}
	return s.FernFilepath
}

func (s *Subpackage) GetService() *ServiceId {
	if s == nil {
		return nil
	}
	return s.Service
}

func (s *Subpackage) GetTypes() []common.TypeId {
	if s == nil {
		return nil
	}
	return s.Types
}

func (s *Subpackage) GetErrors() []ErrorId {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *Subpackage) GetWebhooks() *WebhookGroupId {
	if s == nil {
		return nil
	}
	return s.Webhooks
}

func (s *Subpackage) GetWebsocket() *WebSocketChannelId {
	if s == nil {
		return nil
	}
	return s.Websocket
}

func (s *Subpackage) GetSubpackages() []SubpackageId {
	if s == nil {
		return nil
	}
	return s.Subpackages
}

func (s *Subpackage) GetHasEndpointsInTree() bool {
	if s == nil {
		return false
	}
	return s.HasEndpointsInTree
}

func (s *Subpackage) GetNavigationConfig() *PackageNavigationConfig {
	if s == nil {
		return nil
	}
	return s.NavigationConfig
}

func (s *Subpackage) GetName() *common.Name {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *Subpackage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subpackage) UnmarshalJSON(data []byte) error {
	type unmarshaler Subpackage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Subpackage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *Subpackage) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UserAgent struct {
	// The user agent header for ease of access to generators.
	// Formatted as "<package>/<version>"
	Value  string `json:"value" url:"value"`
	header string

	extraProperties map[string]interface{}
}

func (u *UserAgent) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserAgent) Header() string {
	return u.header
}

func (u *UserAgent) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserAgent) UnmarshalJSON(data []byte) error {
	type embed UserAgent
	var unmarshaler = struct {
		embed
		Header string `json:"header"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserAgent(unmarshaler.embed)
	if unmarshaler.Header != "User-Agent" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "User-Agent", unmarshaler.Header)
	}
	u.header = unmarshaler.Header
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "header")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UserAgent) MarshalJSON() ([]byte, error) {
	type embed UserAgent
	var marshaler = struct {
		embed
		Header string `json:"header"`
	}{
		embed:  embed(*u),
		Header: "User-Agent",
	}
	return json.Marshal(marshaler)
}

func (u *UserAgent) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

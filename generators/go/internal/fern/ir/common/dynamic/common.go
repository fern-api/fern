// Code generated by Fern. DO NOT EDIT.

package dynamic

import (
	json "encoding/json"
	fmt "fmt"

	common "github.com/fern-api/fern-go/internal/fern/ir/common"
	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type Auth struct {
	Type     string
	Basic    *BasicAuth
	Bearer   *BearerAuth
	Header   *HeaderAuth
	Oauth    *OAuth
	Inferred *InferredAuth
}

func (a *Auth) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *Auth) GetBasic() *BasicAuth {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *Auth) GetBearer() *BearerAuth {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *Auth) GetHeader() *HeaderAuth {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *Auth) GetOauth() *OAuth {
	if a == nil {
		return nil
	}
	return a.Oauth
}

func (a *Auth) GetInferred() *InferredAuth {
	if a == nil {
		return nil
	}
	return a.Inferred
}

func (a *Auth) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	case "inferred":
		value := new(InferredAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Inferred = value
	}
	return nil
}

func (a Auth) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	}
	if a.Bearer != nil {
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	}
	if a.Header != nil {
		return internal.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
	if a.Oauth != nil {
		return internal.MarshalJSONWithExtraProperty(a.Oauth, "type", "oauth")
	}
	if a.Inferred != nil {
		return internal.MarshalJSONWithExtraProperty(a.Inferred, "type", "inferred")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AuthVisitor interface {
	VisitBasic(*BasicAuth) error
	VisitBearer(*BearerAuth) error
	VisitHeader(*HeaderAuth) error
	VisitOauth(*OAuth) error
	VisitInferred(*InferredAuth) error
}

func (a *Auth) Accept(visitor AuthVisitor) error {
	if a.Basic != nil {
		return visitor.VisitBasic(a.Basic)
	}
	if a.Bearer != nil {
		return visitor.VisitBearer(a.Bearer)
	}
	if a.Header != nil {
		return visitor.VisitHeader(a.Header)
	}
	if a.Oauth != nil {
		return visitor.VisitOauth(a.Oauth)
	}
	if a.Inferred != nil {
		return visitor.VisitInferred(a.Inferred)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *Auth) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if a.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if a.Inferred != nil {
		fields = append(fields, "inferred")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AuthValues struct {
	Type     string
	Basic    *BasicAuthValues
	Bearer   *BearerAuthValues
	Header   *HeaderAuthValues
	Oauth    *OAuthValues
	Inferred *InferredAuthValues
}

func (a *AuthValues) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AuthValues) GetBasic() *BasicAuthValues {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *AuthValues) GetBearer() *BearerAuthValues {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *AuthValues) GetHeader() *HeaderAuthValues {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *AuthValues) GetOauth() *OAuthValues {
	if a == nil {
		return nil
	}
	return a.Oauth
}

func (a *AuthValues) GetInferred() *InferredAuthValues {
	if a == nil {
		return nil
	}
	return a.Inferred
}

func (a *AuthValues) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	case "inferred":
		value := new(InferredAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Inferred = value
	}
	return nil
}

func (a AuthValues) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	}
	if a.Bearer != nil {
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	}
	if a.Header != nil {
		return internal.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
	if a.Oauth != nil {
		return internal.MarshalJSONWithExtraProperty(a.Oauth, "type", "oauth")
	}
	if a.Inferred != nil {
		return internal.MarshalJSONWithExtraProperty(a.Inferred, "type", "inferred")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AuthValuesVisitor interface {
	VisitBasic(*BasicAuthValues) error
	VisitBearer(*BearerAuthValues) error
	VisitHeader(*HeaderAuthValues) error
	VisitOauth(*OAuthValues) error
	VisitInferred(*InferredAuthValues) error
}

func (a *AuthValues) Accept(visitor AuthValuesVisitor) error {
	if a.Basic != nil {
		return visitor.VisitBasic(a.Basic)
	}
	if a.Bearer != nil {
		return visitor.VisitBearer(a.Bearer)
	}
	if a.Header != nil {
		return visitor.VisitHeader(a.Header)
	}
	if a.Oauth != nil {
		return visitor.VisitOauth(a.Oauth)
	}
	if a.Inferred != nil {
		return visitor.VisitInferred(a.Inferred)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AuthValues) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if a.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if a.Inferred != nil {
		fields = append(fields, "inferred")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type BasicAuth struct {
	Username *common.Name `json:"username" url:"username"`
	Password *common.Name `json:"password" url:"password"`

	extraProperties map[string]interface{}
}

func (b *BasicAuth) GetUsername() *common.Name {
	if b == nil {
		return nil
	}
	return b.Username
}

func (b *BasicAuth) GetPassword() *common.Name {
	if b == nil {
		return nil
	}
	return b.Password
}

func (b *BasicAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuth) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BasicAuthValues struct {
	Username string `json:"username" url:"username"`
	Password string `json:"password" url:"password"`

	extraProperties map[string]interface{}
}

func (b *BasicAuthValues) GetUsername() string {
	if b == nil {
		return ""
	}
	return b.Username
}

func (b *BasicAuthValues) GetPassword() string {
	if b == nil {
		return ""
	}
	return b.Password
}

func (b *BasicAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuthValues) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuth struct {
	Token *common.Name `json:"token" url:"token"`

	extraProperties map[string]interface{}
}

func (b *BearerAuth) GetToken() *common.Name {
	if b == nil {
		return nil
	}
	return b.Token
}

func (b *BearerAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuth) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthValues struct {
	Token string `json:"token" url:"token"`

	extraProperties map[string]interface{}
}

func (b *BearerAuthValues) GetToken() string {
	if b == nil {
		return ""
	}
	return b.Token
}

func (b *BearerAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuthValues) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type HeaderAuth struct {
	Header *NamedParameter `json:"header" url:"header"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuth) GetHeader() *NamedParameter {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HeaderAuth) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuth) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HeaderAuthValues struct {
	Value interface{} `json:"value" url:"value"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuthValues) GetValue() interface{} {
	if h == nil {
		return nil
	}
	return h.Value
}

func (h *HeaderAuthValues) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuthValues) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InferredAuth struct {
	extraProperties map[string]interface{}
}

func (i *InferredAuth) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InferredAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler InferredAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InferredAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InferredAuth) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InferredAuthValues struct {
	extraProperties map[string]interface{}
}

func (i *InferredAuthValues) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InferredAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler InferredAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InferredAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InferredAuthValues) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type OAuth struct {
	ClientId     *common.Name `json:"clientId" url:"clientId"`
	ClientSecret *common.Name `json:"clientSecret" url:"clientSecret"`

	extraProperties map[string]interface{}
}

func (o *OAuth) GetClientId() *common.Name {
	if o == nil {
		return nil
	}
	return o.ClientId
}

func (o *OAuth) GetClientSecret() *common.Name {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

func (o *OAuth) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuth) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthValues struct {
	ClientId     string `json:"clientId" url:"clientId"`
	ClientSecret string `json:"clientSecret" url:"clientSecret"`

	extraProperties map[string]interface{}
}

func (o *OAuthValues) GetClientId() string {
	if o == nil {
		return ""
	}
	return o.ClientId
}

func (o *OAuthValues) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *OAuthValues) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthValues) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Declaration struct {
	FernFilepath *common.FernFilepath `json:"fernFilepath" url:"fernFilepath"`
	Name         *common.Name         `json:"name" url:"name"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetFernFilepath() *common.FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *Declaration) GetName() *common.Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Declaration) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type BodyRequest struct {
	PathParameters []*NamedParameter          `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	Body           *ReferencedRequestBodyType `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BodyRequest) GetPathParameters() []*NamedParameter {
	if b == nil {
		return nil
	}
	return b.PathParameters
}

func (b *BodyRequest) GetBody() *ReferencedRequestBodyType {
	if b == nil {
		return nil
	}
	return b.Body
}

func (b *BodyRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BodyRequest) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Endpoint struct {
	Auth        *Auth              `json:"auth,omitempty" url:"auth,omitempty"`
	Declaration *Declaration       `json:"declaration" url:"declaration"`
	Location    *EndpointLocation  `json:"location" url:"location"`
	Request     *Request           `json:"request" url:"request"`
	Response    *Response          `json:"response" url:"response"`
	Examples    []*EndpointExample `json:"examples,omitempty" url:"examples,omitempty"`

	extraProperties map[string]interface{}
}

func (e *Endpoint) GetAuth() *Auth {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *Endpoint) GetDeclaration() *Declaration {
	if e == nil {
		return nil
	}
	return e.Declaration
}

func (e *Endpoint) GetLocation() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Location
}

func (e *Endpoint) GetRequest() *Request {
	if e == nil {
		return nil
	}
	return e.Request
}

func (e *Endpoint) GetResponse() *Response {
	if e == nil {
		return nil
	}
	return e.Response
}

func (e *Endpoint) GetExamples() []*EndpointExample {
	if e == nil {
		return nil
	}
	return e.Examples
}

func (e *Endpoint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Endpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler Endpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Endpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *Endpoint) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EndpointExample struct {
	Endpoint        *EndpointLocation  `json:"endpoint" url:"endpoint"`
	BaseUrl         *string            `json:"baseURL,omitempty" url:"baseURL,omitempty"`
	Environment     *EnvironmentValues `json:"environment,omitempty" url:"environment,omitempty"`
	Auth            *AuthValues        `json:"auth,omitempty" url:"auth,omitempty"`
	PathParameters  *Values            `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters *Values            `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         *Values            `json:"headers,omitempty" url:"headers,omitempty"`
	RequestBody     interface{}        `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	// The unique identifier for the example.
	Id string `json:"id" url:"id"`
	// The name of the example, if any.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EndpointExample) GetEndpoint() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Endpoint
}

func (e *EndpointExample) GetBaseUrl() *string {
	if e == nil {
		return nil
	}
	return e.BaseUrl
}

func (e *EndpointExample) GetEnvironment() *EnvironmentValues {
	if e == nil {
		return nil
	}
	return e.Environment
}

func (e *EndpointExample) GetAuth() *AuthValues {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *EndpointExample) GetPathParameters() *Values {
	if e == nil {
		return nil
	}
	return e.PathParameters
}

func (e *EndpointExample) GetQueryParameters() *Values {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *EndpointExample) GetHeaders() *Values {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EndpointExample) GetRequestBody() interface{} {
	if e == nil {
		return nil
	}
	return e.RequestBody
}

func (e *EndpointExample) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EndpointExample) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EndpointExample) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointExample) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointExample) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents the endpoint location (e.g. "POST /users").
type EndpointLocation struct {
	Method common.HttpMethod `json:"method" url:"method"`
	Path   string            `json:"path" url:"path"`

	extraProperties map[string]interface{}
}

func (e *EndpointLocation) GetMethod() common.HttpMethod {
	if e == nil {
		return ""
	}
	return e.Method
}

func (e *EndpointLocation) GetPath() string {
	if e == nil {
		return ""
	}
	return e.Path
}

func (e *EndpointLocation) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointLocation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointLocation) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FileUploadRequestBody struct {
	Properties []*FileUploadRequestBodyProperty `json:"properties" url:"properties"`

	extraProperties map[string]interface{}
}

func (f *FileUploadRequestBody) GetProperties() []*FileUploadRequestBodyProperty {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FileUploadRequestBody) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileUploadRequestBody) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestBodyProperty struct {
	Type         string
	File         *common.NameAndWireValue
	FileArray    *common.NameAndWireValue
	BodyProperty *NamedParameter
}

func (f *FileUploadRequestBodyProperty) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FileUploadRequestBodyProperty) GetFile() *common.NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FileUploadRequestBodyProperty) GetFileArray() *common.NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.FileArray
}

func (f *FileUploadRequestBodyProperty) GetBodyProperty() *NamedParameter {
	if f == nil {
		return nil
	}
	return f.BodyProperty
}

func (f *FileUploadRequestBodyProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		value := new(common.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "fileArray":
		value := new(common.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.FileArray = value
	case "bodyProperty":
		value := new(NamedParameter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestBodyProperty) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	if f.File != nil {
		return internal.MarshalJSONWithExtraProperty(f.File, "type", "file")
	}
	if f.FileArray != nil {
		return internal.MarshalJSONWithExtraProperty(f.FileArray, "type", "fileArray")
	}
	if f.BodyProperty != nil {
		return internal.MarshalJSONWithExtraProperty(f.BodyProperty, "type", "bodyProperty")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FileUploadRequestBodyPropertyVisitor interface {
	VisitFile(*common.NameAndWireValue) error
	VisitFileArray(*common.NameAndWireValue) error
	VisitBodyProperty(*NamedParameter) error
}

func (f *FileUploadRequestBodyProperty) Accept(visitor FileUploadRequestBodyPropertyVisitor) error {
	if f.File != nil {
		return visitor.VisitFile(f.File)
	}
	if f.FileArray != nil {
		return visitor.VisitFileArray(f.FileArray)
	}
	if f.BodyProperty != nil {
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

func (f *FileUploadRequestBodyProperty) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.File != nil {
		fields = append(fields, "file")
	}
	if f.FileArray != nil {
		fields = append(fields, "fileArray")
	}
	if f.BodyProperty != nil {
		fields = append(fields, "bodyProperty")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type InlinedRequest struct {
	Declaration     *Declaration            `json:"declaration" url:"declaration"`
	PathParameters  []*NamedParameter       `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters []*NamedParameter       `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         []*NamedParameter       `json:"headers,omitempty" url:"headers,omitempty"`
	Body            *InlinedRequestBody     `json:"body,omitempty" url:"body,omitempty"`
	Metadata        *InlinedRequestMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequest) GetDeclaration() *Declaration {
	if i == nil {
		return nil
	}
	return i.Declaration
}

func (i *InlinedRequest) GetPathParameters() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.PathParameters
}

func (i *InlinedRequest) GetQueryParameters() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.QueryParameters
}

func (i *InlinedRequest) GetHeaders() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.Headers
}

func (i *InlinedRequest) GetBody() *InlinedRequestBody {
	if i == nil {
		return nil
	}
	return i.Body
}

func (i *InlinedRequest) GetMetadata() *InlinedRequestMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InlinedRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequest) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBody struct {
	Type       string
	Properties []*NamedParameter
	Referenced *ReferencedRequestBody
	FileUpload *FileUploadRequestBody
}

func (i *InlinedRequestBody) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InlinedRequestBody) GetProperties() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedRequestBody) GetReferenced() *ReferencedRequestBody {
	if i == nil {
		return nil
	}
	return i.Referenced
}

func (i *InlinedRequestBody) GetFileUpload() *FileUploadRequestBody {
	if i == nil {
		return nil
	}
	return i.FileUpload
}

func (i *InlinedRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "properties":
		var valueUnmarshaler struct {
			Properties []*NamedParameter `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.Properties = valueUnmarshaler.Properties
	case "referenced":
		value := new(ReferencedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Referenced = value
	case "fileUpload":
		value := new(FileUploadRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.FileUpload = value
	}
	return nil
}

func (i InlinedRequestBody) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.Properties != nil {
		var marshaler = struct {
			Type       string            `json:"type"`
			Properties []*NamedParameter `json:"value"`
		}{
			Type:       "properties",
			Properties: i.Properties,
		}
		return json.Marshal(marshaler)
	}
	if i.Referenced != nil {
		return internal.MarshalJSONWithExtraProperty(i.Referenced, "type", "referenced")
	}
	if i.FileUpload != nil {
		return internal.MarshalJSONWithExtraProperty(i.FileUpload, "type", "fileUpload")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InlinedRequestBodyVisitor interface {
	VisitProperties([]*NamedParameter) error
	VisitReferenced(*ReferencedRequestBody) error
	VisitFileUpload(*FileUploadRequestBody) error
}

func (i *InlinedRequestBody) Accept(visitor InlinedRequestBodyVisitor) error {
	if i.Properties != nil {
		return visitor.VisitProperties(i.Properties)
	}
	if i.Referenced != nil {
		return visitor.VisitReferenced(i.Referenced)
	}
	if i.FileUpload != nil {
		return visitor.VisitFileUpload(i.FileUpload)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InlinedRequestBody) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.Properties != nil {
		fields = append(fields, "properties")
	}
	if i.Referenced != nil {
		fields = append(fields, "referenced")
	}
	if i.FileUpload != nil {
		fields = append(fields, "fileUpload")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

type InlinedRequestMetadata struct {
	// If true, the path parameters should be included as properties in the
	// inlined request type, but only if the generator is explicitly configured
	// to do so.
	//
	// By default, the path parameters are generated as positional parameters.
	IncludePathParameters bool `json:"includePathParameters" url:"includePathParameters"`
	// If true, the path parameters are the only parameters specified in the
	// inlined request.
	//
	// In combination with includePathParameters, this influences whether or not the
	// inlined request type should be generated at all.
	OnlyPathParameters bool `json:"onlyPathParameters" url:"onlyPathParameters"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestMetadata) GetIncludePathParameters() bool {
	if i == nil {
		return false
	}
	return i.IncludePathParameters
}

func (i *InlinedRequestMetadata) GetOnlyPathParameters() bool {
	if i == nil {
		return false
	}
	return i.OnlyPathParameters
}

func (i *InlinedRequestMetadata) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequestMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestMetadata) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type ReferencedRequestBody struct {
	BodyKey  *common.Name               `json:"bodyKey" url:"bodyKey"`
	BodyType *ReferencedRequestBodyType `json:"bodyType" url:"bodyType"`

	extraProperties map[string]interface{}
}

func (r *ReferencedRequestBody) GetBodyKey() *common.Name {
	if r == nil {
		return nil
	}
	return r.BodyKey
}

func (r *ReferencedRequestBody) GetBodyType() *ReferencedRequestBodyType {
	if r == nil {
		return nil
	}
	return r.BodyType
}

func (r *ReferencedRequestBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ReferencedRequestBody) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencedRequestBodyType struct {
	Type          string
	Bytes         interface{}
	TypeReference *TypeReference
}

func (r *ReferencedRequestBodyType) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ReferencedRequestBodyType) GetBytes() interface{} {
	if r == nil {
		return nil
	}
	return r.Bytes
}

func (r *ReferencedRequestBodyType) GetTypeReference() *TypeReference {
	if r == nil {
		return nil
	}
	return r.TypeReference
}

func (r *ReferencedRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "bytes":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Bytes = value
	case "typeReference":
		var valueUnmarshaler struct {
			TypeReference *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TypeReference = valueUnmarshaler.TypeReference
	}
	return nil
}

func (r ReferencedRequestBodyType) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Bytes != nil {
		var marshaler = struct {
			Type  string      `json:"type"`
			Bytes interface{} `json:"bytes,omitempty"`
		}{
			Type:  "bytes",
			Bytes: r.Bytes,
		}
		return json.Marshal(marshaler)
	}
	if r.TypeReference != nil {
		var marshaler = struct {
			Type          string         `json:"type"`
			TypeReference *TypeReference `json:"value"`
		}{
			Type:          "typeReference",
			TypeReference: r.TypeReference,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ReferencedRequestBodyTypeVisitor interface {
	VisitBytes(interface{}) error
	VisitTypeReference(*TypeReference) error
}

func (r *ReferencedRequestBodyType) Accept(visitor ReferencedRequestBodyTypeVisitor) error {
	if r.Bytes != nil {
		return visitor.VisitBytes(r.Bytes)
	}
	if r.TypeReference != nil {
		return visitor.VisitTypeReference(r.TypeReference)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ReferencedRequestBodyType) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if r.TypeReference != nil {
		fields = append(fields, "typeReference")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the request parameters required to call a specific endpoint.
type Request struct {
	Type    string
	Body    *BodyRequest
	Inlined *InlinedRequest
}

func (r *Request) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Request) GetBody() *BodyRequest {
	if r == nil {
		return nil
	}
	return r.Body
}

func (r *Request) GetInlined() *InlinedRequest {
	if r == nil {
		return nil
	}
	return r.Inlined
}

func (r *Request) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "body":
		value := new(BodyRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Body = value
	case "inlined":
		value := new(InlinedRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Inlined = value
	}
	return nil
}

func (r Request) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Body != nil {
		return internal.MarshalJSONWithExtraProperty(r.Body, "type", "body")
	}
	if r.Inlined != nil {
		return internal.MarshalJSONWithExtraProperty(r.Inlined, "type", "inlined")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RequestVisitor interface {
	VisitBody(*BodyRequest) error
	VisitInlined(*InlinedRequest) error
}

func (r *Request) Accept(visitor RequestVisitor) error {
	if r.Body != nil {
		return visitor.VisitBody(r.Body)
	}
	if r.Inlined != nil {
		return visitor.VisitInlined(r.Inlined)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *Request) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Body != nil {
		fields = append(fields, "body")
	}
	if r.Inlined != nil {
		fields = append(fields, "inlined")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the response returned by a specific endpoint.
//
// For now, we only support json responses, but this is set up to support a
// variety of other endpoint response types (e.g. file download, pagination,
// streaming, etc).
type Response struct {
	Type string
	Json interface{}
}

func (r *Response) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Response) GetJson() interface{} {
	if r == nil {
		return nil
	}
	return r.Json
}

func (r *Response) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "json":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Json = value
	}
	return nil
}

func (r Response) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Json != nil {
		var marshaler = struct {
			Type string      `json:"type"`
			Json interface{} `json:"json,omitempty"`
		}{
			Type: "json",
			Json: r.Json,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResponseVisitor interface {
	VisitJson(interface{}) error
}

func (r *Response) Accept(visitor ResponseVisitor) error {
	if r.Json != nil {
		return visitor.VisitJson(r.Json)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *Response) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Json != nil {
		fields = append(fields, "json")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the value to use for a specific environment. There are three cases:
//
// 1. When sent as an EnvironmentId string, the generator assumes the value matches the name of the
// environment (e.g. "Staging"), and returns an error otherwise.
//
//  2. If the API supports multiple environment URLs, send a map of URLs, e.g.
//     {
//     "ec2": "https://staging.ec2.aws.com",
//     "s3": "https://staging.s3.aws.com"
//     }
type EnvironmentValues struct {
	EnvironmentId                common.EnvironmentId
	MultipleEnvironmentUrlValues MultipleEnvironmentUrlValues

	typ string
}

func (e *EnvironmentValues) GetEnvironmentId() common.EnvironmentId {
	if e == nil {
		return ""
	}
	return e.EnvironmentId
}

func (e *EnvironmentValues) GetMultipleEnvironmentUrlValues() MultipleEnvironmentUrlValues {
	if e == nil {
		return nil
	}
	return e.MultipleEnvironmentUrlValues
}

func (e *EnvironmentValues) UnmarshalJSON(data []byte) error {
	var valueEnvironmentId common.EnvironmentId
	if err := json.Unmarshal(data, &valueEnvironmentId); err == nil {
		e.typ = "EnvironmentId"
		e.EnvironmentId = valueEnvironmentId
		return nil
	}
	var valueMultipleEnvironmentUrlValues MultipleEnvironmentUrlValues
	if err := json.Unmarshal(data, &valueMultipleEnvironmentUrlValues); err == nil {
		e.typ = "MultipleEnvironmentUrlValues"
		e.MultipleEnvironmentUrlValues = valueMultipleEnvironmentUrlValues
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EnvironmentValues) MarshalJSON() ([]byte, error) {
	if e.typ == "EnvironmentId" || e.EnvironmentId != "" {
		return json.Marshal(e.EnvironmentId)
	}
	if e.typ == "MultipleEnvironmentUrlValues" || e.MultipleEnvironmentUrlValues != nil {
		return json.Marshal(e.MultipleEnvironmentUrlValues)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EnvironmentValuesVisitor interface {
	VisitEnvironmentId(common.EnvironmentId) error
	VisitMultipleEnvironmentUrlValues(MultipleEnvironmentUrlValues) error
}

func (e *EnvironmentValues) Accept(visitor EnvironmentValuesVisitor) error {
	if e.typ == "EnvironmentId" || e.EnvironmentId != "" {
		return visitor.VisitEnvironmentId(e.EnvironmentId)
	}
	if e.typ == "MultipleEnvironmentUrlValues" || e.MultipleEnvironmentUrlValues != nil {
		return visitor.VisitMultipleEnvironmentUrlValues(e.MultipleEnvironmentUrlValues)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type MultipleEnvironmentUrlValues = map[common.EnvironmentBaseUrlId]common.EnvironmentUrl

// This represents the IR required to generate dynamic snippets.
//
// This IR minimizes the space required to generate snippets in a variety
// of environments (e.g. web, offline, etc).
type DynamicIntermediateRepresentation struct {
	// The version of the dynamic IR. This is independent from the version
	// of the primary IR.
	Types        map[common.TypeId]*NamedType    `json:"types" url:"types"`
	Endpoints    map[common.EndpointId]*Endpoint `json:"endpoints" url:"endpoints"`
	Environments *common.EnvironmentsConfig      `json:"environments,omitempty" url:"environments,omitempty"`
	// The headers that are required on every request. These headers
	// are typically included in the SDK's client constructor.
	Headers []*NamedParameter `json:"headers,omitempty" url:"headers,omitempty"`
	// The path parameters that are required on every request. These
	// path parameters are typically included in the SDK's client
	// constructor.
	PathParameters  []*NamedParameter `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	GeneratorConfig *GeneratorConfig  `json:"generatorConfig,omitempty" url:"generatorConfig,omitempty"`
	version         string

	extraProperties map[string]interface{}
}

func (d *DynamicIntermediateRepresentation) GetTypes() map[common.TypeId]*NamedType {
	if d == nil {
		return nil
	}
	return d.Types
}

func (d *DynamicIntermediateRepresentation) GetEndpoints() map[common.EndpointId]*Endpoint {
	if d == nil {
		return nil
	}
	return d.Endpoints
}

func (d *DynamicIntermediateRepresentation) GetEnvironments() *common.EnvironmentsConfig {
	if d == nil {
		return nil
	}
	return d.Environments
}

func (d *DynamicIntermediateRepresentation) GetHeaders() []*NamedParameter {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DynamicIntermediateRepresentation) GetPathParameters() []*NamedParameter {
	if d == nil {
		return nil
	}
	return d.PathParameters
}

func (d *DynamicIntermediateRepresentation) GetGeneratorConfig() *GeneratorConfig {
	if d == nil {
		return nil
	}
	return d.GeneratorConfig
}

func (d *DynamicIntermediateRepresentation) Version() string {
	return d.version
}

func (d *DynamicIntermediateRepresentation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicIntermediateRepresentation) UnmarshalJSON(data []byte) error {
	type embed DynamicIntermediateRepresentation
	var unmarshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DynamicIntermediateRepresentation(unmarshaler.embed)
	if unmarshaler.Version != "1.0.0" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "1.0.0", unmarshaler.Version)
	}
	d.version = unmarshaler.Version
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "version")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DynamicIntermediateRepresentation) MarshalJSON() ([]byte, error) {
	type embed DynamicIntermediateRepresentation
	var marshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed:   embed(*d),
		Version: "1.0.0",
	}
	return json.Marshal(marshaler)
}

func (d *DynamicIntermediateRepresentation) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The configuration for the generator. This is a simplified version of the
// generator-exec GeneratorConfig configuration.
type GeneratorConfig struct {
	// The name of the API. This is equivalent to the workspace name in the
	// generator-exec configuration.
	ApiName      string                 `json:"apiName" url:"apiName"`
	Organization string                 `json:"organization" url:"organization"`
	CustomConfig interface{}            `json:"customConfig" url:"customConfig"`
	OutputConfig *GeneratorOutputConfig `json:"outputConfig" url:"outputConfig"`

	extraProperties map[string]interface{}
}

func (g *GeneratorConfig) GetApiName() string {
	if g == nil {
		return ""
	}
	return g.ApiName
}

func (g *GeneratorConfig) GetOrganization() string {
	if g == nil {
		return ""
	}
	return g.Organization
}

func (g *GeneratorConfig) GetCustomConfig() interface{} {
	if g == nil {
		return nil
	}
	return g.CustomConfig
}

func (g *GeneratorConfig) GetOutputConfig() *GeneratorOutputConfig {
	if g == nil {
		return nil
	}
	return g.OutputConfig
}

func (g *GeneratorConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The configuration for the output of the generator. This is a simplified version of
// the generator-exec output.mode configuration.
type GeneratorOutputConfig struct {
	Type    string
	Publish *PublishInfo
	Local   interface{}
}

func (g *GeneratorOutputConfig) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorOutputConfig) GetPublish() *PublishInfo {
	if g == nil {
		return nil
	}
	return g.Publish
}

func (g *GeneratorOutputConfig) GetLocal() interface{} {
	if g == nil {
		return nil
	}
	return g.Local
}

func (g *GeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "publish":
		var valueUnmarshaler struct {
			Publish *PublishInfo `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.Publish = valueUnmarshaler.Publish
	case "local":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	}
	return nil
}

func (g GeneratorOutputConfig) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Publish != nil {
		var marshaler = struct {
			Type    string       `json:"type"`
			Publish *PublishInfo `json:"value"`
		}{
			Type:    "publish",
			Publish: g.Publish,
		}
		return json.Marshal(marshaler)
	}
	if g.Local != nil {
		var marshaler = struct {
			Type  string      `json:"type"`
			Local interface{} `json:"local,omitempty"`
		}{
			Type:  "local",
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorOutputConfigVisitor interface {
	VisitPublish(*PublishInfo) error
	VisitLocal(interface{}) error
}

func (g *GeneratorOutputConfig) Accept(visitor GeneratorOutputConfigVisitor) error {
	if g.Publish != nil {
		return visitor.VisitPublish(g.Publish)
	}
	if g.Local != nil {
		return visitor.VisitLocal(g.Local)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorOutputConfig) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Publish != nil {
		fields = append(fields, "publish")
	}
	if g.Local != nil {
		fields = append(fields, "local")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

type GoPublishInfo struct {
	Version string `json:"version" url:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`

	extraProperties map[string]interface{}
}

func (g *GoPublishInfo) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GoPublishInfo) GetRepoUrl() string {
	if g == nil {
		return ""
	}
	return g.RepoUrl
}

func (g *GoPublishInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GoPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GoPublishInfo) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type MavenPublishInfo struct {
	Version    string  `json:"version" url:"version"`
	Coordinate string  `json:"coordinate" url:"coordinate"`
	RepoUrl    *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenPublishInfo) GetVersion() string {
	if m == nil {
		return ""
	}
	return m.Version
}

func (m *MavenPublishInfo) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenPublishInfo) GetRepoUrl() *string {
	if m == nil {
		return nil
	}
	return m.RepoUrl
}

func (m *MavenPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenPublishInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NpmPublishInfo) GetVersion() string {
	if n == nil {
		return ""
	}
	return n.Version
}

func (n *NpmPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmPublishInfo) GetRepoUrl() *string {
	if n == nil {
		return nil
	}
	return n.RepoUrl
}

func (n *NpmPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NugetPublishInfo) GetVersion() string {
	if n == nil {
		return ""
	}
	return n.Version
}

func (n *NugetPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetPublishInfo) GetRepoUrl() *string {
	if n == nil {
		return nil
	}
	return n.RepoUrl
}

func (n *NugetPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PublishInfo struct {
	Type     string
	Go       *GoPublishInfo
	Maven    *MavenPublishInfo
	Npm      *NpmPublishInfo
	Nuget    *NugetPublishInfo
	Pypi     *PypiPublishInfo
	Rubygems *RubyGemsPublishInfo
}

func (p *PublishInfo) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishInfo) GetGo() *GoPublishInfo {
	if p == nil {
		return nil
	}
	return p.Go
}

func (p *PublishInfo) GetMaven() *MavenPublishInfo {
	if p == nil {
		return nil
	}
	return p.Maven
}

func (p *PublishInfo) GetNpm() *NpmPublishInfo {
	if p == nil {
		return nil
	}
	return p.Npm
}

func (p *PublishInfo) GetNuget() *NugetPublishInfo {
	if p == nil {
		return nil
	}
	return p.Nuget
}

func (p *PublishInfo) GetPypi() *PypiPublishInfo {
	if p == nil {
		return nil
	}
	return p.Pypi
}

func (p *PublishInfo) GetRubygems() *RubyGemsPublishInfo {
	if p == nil {
		return nil
	}
	return p.Rubygems
}

func (p *PublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "go":
		value := new(GoPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Go = value
	case "maven":
		value := new(MavenPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "npm":
		value := new(NpmPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "nuget":
		value := new(NugetPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Nuget = value
	case "pypi":
		value := new(PypiPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Pypi = value
	case "rubygems":
		value := new(RubyGemsPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Rubygems = value
	}
	return nil
}

func (p PublishInfo) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Go != nil {
		return internal.MarshalJSONWithExtraProperty(p.Go, "type", "go")
	}
	if p.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(p.Maven, "type", "maven")
	}
	if p.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(p.Npm, "type", "npm")
	}
	if p.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(p.Nuget, "type", "nuget")
	}
	if p.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(p.Pypi, "type", "pypi")
	}
	if p.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(p.Rubygems, "type", "rubygems")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishInfoVisitor interface {
	VisitGo(*GoPublishInfo) error
	VisitMaven(*MavenPublishInfo) error
	VisitNpm(*NpmPublishInfo) error
	VisitNuget(*NugetPublishInfo) error
	VisitPypi(*PypiPublishInfo) error
	VisitRubygems(*RubyGemsPublishInfo) error
}

func (p *PublishInfo) Accept(visitor PublishInfoVisitor) error {
	if p.Go != nil {
		return visitor.VisitGo(p.Go)
	}
	if p.Maven != nil {
		return visitor.VisitMaven(p.Maven)
	}
	if p.Npm != nil {
		return visitor.VisitNpm(p.Npm)
	}
	if p.Nuget != nil {
		return visitor.VisitNuget(p.Nuget)
	}
	if p.Pypi != nil {
		return visitor.VisitPypi(p.Pypi)
	}
	if p.Rubygems != nil {
		return visitor.VisitRubygems(p.Rubygems)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishInfo) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Go != nil {
		fields = append(fields, "go")
	}
	if p.Maven != nil {
		fields = append(fields, "maven")
	}
	if p.Npm != nil {
		fields = append(fields, "npm")
	}
	if p.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if p.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if p.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PypiPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiPublishInfo) GetVersion() string {
	if p == nil {
		return ""
	}
	return p.Version
}

func (p *PypiPublishInfo) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiPublishInfo) GetRepoUrl() *string {
	if p == nil {
		return nil
	}
	return p.RepoUrl
}

func (p *PypiPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RubyGemsPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsPublishInfo) GetVersion() string {
	if r == nil {
		return ""
	}
	return r.Version
}

func (r *RubyGemsPublishInfo) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsPublishInfo) GetRepoUrl() *string {
	if r == nil {
		return nil
	}
	return r.RepoUrl
}

func (r *RubyGemsPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsPublishInfo) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The user-facing request type used to generate a dynamic snippet.
type EndpointSnippetRequest struct {
	Endpoint        *EndpointLocation  `json:"endpoint" url:"endpoint"`
	BaseUrl         *string            `json:"baseURL,omitempty" url:"baseURL,omitempty"`
	Environment     *EnvironmentValues `json:"environment,omitempty" url:"environment,omitempty"`
	Auth            *AuthValues        `json:"auth,omitempty" url:"auth,omitempty"`
	PathParameters  *Values            `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters *Values            `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         *Values            `json:"headers,omitempty" url:"headers,omitempty"`
	RequestBody     interface{}        `json:"requestBody,omitempty" url:"requestBody,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EndpointSnippetRequest) GetEndpoint() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Endpoint
}

func (e *EndpointSnippetRequest) GetBaseUrl() *string {
	if e == nil {
		return nil
	}
	return e.BaseUrl
}

func (e *EndpointSnippetRequest) GetEnvironment() *EnvironmentValues {
	if e == nil {
		return nil
	}
	return e.Environment
}

func (e *EndpointSnippetRequest) GetAuth() *AuthValues {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *EndpointSnippetRequest) GetPathParameters() *Values {
	if e == nil {
		return nil
	}
	return e.PathParameters
}

func (e *EndpointSnippetRequest) GetQueryParameters() *Values {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *EndpointSnippetRequest) GetHeaders() *Values {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EndpointSnippetRequest) GetRequestBody() interface{} {
	if e == nil {
		return nil
	}
	return e.RequestBody
}

func (e *EndpointSnippetRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointSnippetRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointSnippetRequest) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Snippet values are represented as arbitrary key, value
// pairs (i.e. JSON objects). The keys are expected to be
// in the parameter's wire representation. For path parameters,
// the name will match the parameter name.
type Values = map[string]interface{}

type AliasType struct {
	Declaration   *Declaration   `json:"declaration" url:"declaration"`
	TypeReference *TypeReference `json:"typeReference" url:"typeReference"`

	extraProperties map[string]interface{}
}

func (a *AliasType) GetDeclaration() *Declaration {
	if a == nil {
		return nil
	}
	return a.Declaration
}

func (a *AliasType) GetTypeReference() *TypeReference {
	if a == nil {
		return nil
	}
	return a.TypeReference
}

func (a *AliasType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AliasType) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type DiscriminatedUnionType struct {
	Declaration  *Declaration             `json:"declaration" url:"declaration"`
	Discriminant *common.NameAndWireValue `json:"discriminant" url:"discriminant"`
	// Map from the discriminant value (e.g. "user") to the type (e.g. User).
	Types map[string]*SingleDiscriminatedUnionType `json:"types" url:"types"`

	extraProperties map[string]interface{}
}

func (d *DiscriminatedUnionType) GetDeclaration() *Declaration {
	if d == nil {
		return nil
	}
	return d.Declaration
}

func (d *DiscriminatedUnionType) GetDiscriminant() *common.NameAndWireValue {
	if d == nil {
		return nil
	}
	return d.Discriminant
}

func (d *DiscriminatedUnionType) GetTypes() map[string]*SingleDiscriminatedUnionType {
	if d == nil {
		return nil
	}
	return d.Types
}

func (d *DiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumType struct {
	Declaration *Declaration               `json:"declaration" url:"declaration"`
	Values      []*common.NameAndWireValue `json:"values" url:"values"`

	extraProperties map[string]interface{}
}

func (e *EnumType) GetDeclaration() *Declaration {
	if e == nil {
		return nil
	}
	return e.Declaration
}

func (e *EnumType) GetValues() []*common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Values
}

func (e *EnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type LiteralType struct {
	Type    string
	Boolean bool
	String  string
}

func (l *LiteralType) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LiteralType) GetBoolean() bool {
	if l == nil {
		return false
	}
	return l.Boolean
}

func (l *LiteralType) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LiteralType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	}
	return nil
}

func (l LiteralType) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	if l.Boolean != false {
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"value"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
	if l.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LiteralTypeVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (l *LiteralType) Accept(visitor LiteralTypeVisitor) error {
	if l.Boolean != false {
		return visitor.VisitBoolean(l.Boolean)
	}
	if l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

func (l *LiteralType) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.Boolean != false {
		fields = append(fields, "boolean")
	}
	if l.String != "" {
		fields = append(fields, "string")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

type MapType struct {
	Key   *TypeReference `json:"key" url:"key"`
	Value *TypeReference `json:"value" url:"value"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetKey() *TypeReference {
	if m == nil {
		return nil
	}
	return m.Key
}

func (m *MapType) GetValue() *TypeReference {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MapType) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NamedParameter struct {
	Name          *common.NameAndWireValue `json:"name" url:"name"`
	TypeReference *TypeReference           `json:"typeReference" url:"typeReference"`

	extraProperties map[string]interface{}
}

func (n *NamedParameter) GetName() *common.NameAndWireValue {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NamedParameter) GetTypeReference() *TypeReference {
	if n == nil {
		return nil
	}
	return n.TypeReference
}

func (n *NamedParameter) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NamedParameter) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Represents the type of a parameter that can be used to generate a dynamic type.
type NamedType struct {
	Type                 string
	Alias                *AliasType
	Enum                 *EnumType
	Object               *ObjectType
	DiscriminatedUnion   *DiscriminatedUnionType
	UndiscriminatedUnion *UndiscriminatedUnionType
}

func (n *NamedType) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NamedType) GetAlias() *AliasType {
	if n == nil {
		return nil
	}
	return n.Alias
}

func (n *NamedType) GetEnum() *EnumType {
	if n == nil {
		return nil
	}
	return n.Enum
}

func (n *NamedType) GetObject() *ObjectType {
	if n == nil {
		return nil
	}
	return n.Object
}

func (n *NamedType) GetDiscriminatedUnion() *DiscriminatedUnionType {
	if n == nil {
		return nil
	}
	return n.DiscriminatedUnion
}

func (n *NamedType) GetUndiscriminatedUnion() *UndiscriminatedUnionType {
	if n == nil {
		return nil
	}
	return n.UndiscriminatedUnion
}

func (n *NamedType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Alias = value
	case "enum":
		value := new(EnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Enum = value
	case "object":
		value := new(ObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Object = value
	case "discriminatedUnion":
		value := new(DiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.DiscriminatedUnion = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.UndiscriminatedUnion = value
	}
	return nil
}

func (n NamedType) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	if n.Alias != nil {
		return internal.MarshalJSONWithExtraProperty(n.Alias, "type", "alias")
	}
	if n.Enum != nil {
		return internal.MarshalJSONWithExtraProperty(n.Enum, "type", "enum")
	}
	if n.Object != nil {
		return internal.MarshalJSONWithExtraProperty(n.Object, "type", "object")
	}
	if n.DiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(n.DiscriminatedUnion, "type", "discriminatedUnion")
	}
	if n.UndiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(n.UndiscriminatedUnion, "type", "undiscriminatedUnion")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NamedTypeVisitor interface {
	VisitAlias(*AliasType) error
	VisitEnum(*EnumType) error
	VisitObject(*ObjectType) error
	VisitDiscriminatedUnion(*DiscriminatedUnionType) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionType) error
}

func (n *NamedType) Accept(visitor NamedTypeVisitor) error {
	if n.Alias != nil {
		return visitor.VisitAlias(n.Alias)
	}
	if n.Enum != nil {
		return visitor.VisitEnum(n.Enum)
	}
	if n.Object != nil {
		return visitor.VisitObject(n.Object)
	}
	if n.DiscriminatedUnion != nil {
		return visitor.VisitDiscriminatedUnion(n.DiscriminatedUnion)
	}
	if n.UndiscriminatedUnion != nil {
		return visitor.VisitUndiscriminatedUnion(n.UndiscriminatedUnion)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

func (n *NamedType) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Alias != nil {
		fields = append(fields, "alias")
	}
	if n.Enum != nil {
		fields = append(fields, "enum")
	}
	if n.Object != nil {
		fields = append(fields, "object")
	}
	if n.DiscriminatedUnion != nil {
		fields = append(fields, "discriminatedUnion")
	}
	if n.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

type ObjectType struct {
	Declaration *Declaration      `json:"declaration" url:"declaration"`
	Properties  []*NamedParameter `json:"properties" url:"properties"`
	// Whether the type allows additional properties.
	AdditionalProperties *bool `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *ObjectType) GetDeclaration() *Declaration {
	if o == nil {
		return nil
	}
	return o.Declaration
}

func (o *ObjectType) GetProperties() []*NamedParameter {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *ObjectType) GetAdditionalProperties() *bool {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *ObjectType) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectType) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type SingleDiscriminatedUnionType struct {
	Type                   string
	SamePropertiesAsObject *SingleDiscriminatedUnionTypeObject
	SingleProperty         *SingleDiscriminatedUnionTypeSingleProperty
	NoProperties           *SingleDiscriminatedUnionTypeNoProperties
}

func (s *SingleDiscriminatedUnionType) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleDiscriminatedUnionType) GetSamePropertiesAsObject() *SingleDiscriminatedUnionTypeObject {
	if s == nil {
		return nil
	}
	return s.SamePropertiesAsObject
}

func (s *SingleDiscriminatedUnionType) GetSingleProperty() *SingleDiscriminatedUnionTypeSingleProperty {
	if s == nil {
		return nil
	}
	return s.SingleProperty
}

func (s *SingleDiscriminatedUnionType) GetNoProperties() *SingleDiscriminatedUnionTypeNoProperties {
	if s == nil {
		return nil
	}
	return s.NoProperties
}

func (s *SingleDiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(SingleDiscriminatedUnionTypeObject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleDiscriminatedUnionTypeSingleProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := new(SingleDiscriminatedUnionTypeNoProperties)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleDiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.SamePropertiesAsObject != nil {
		return internal.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		return internal.MarshalJSONWithExtraProperty(s.SingleProperty, "type", "singleProperty")
	}
	if s.NoProperties != nil {
		return internal.MarshalJSONWithExtraProperty(s.NoProperties, "type", "noProperties")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleDiscriminatedUnionTypeVisitor interface {
	VisitSamePropertiesAsObject(*SingleDiscriminatedUnionTypeObject) error
	VisitSingleProperty(*SingleDiscriminatedUnionTypeSingleProperty) error
	VisitNoProperties(*SingleDiscriminatedUnionTypeNoProperties) error
}

func (s *SingleDiscriminatedUnionType) Accept(visitor SingleDiscriminatedUnionTypeVisitor) error {
	if s.SamePropertiesAsObject != nil {
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	}
	if s.SingleProperty != nil {
		return visitor.VisitSingleProperty(s.SingleProperty)
	}
	if s.NoProperties != nil {
		return visitor.VisitNoProperties(s.NoProperties)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleDiscriminatedUnionType) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if s.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SingleDiscriminatedUnionTypeNoProperties struct {
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeNoProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeNoProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeNoProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeNoProperties) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleDiscriminatedUnionTypeObject struct {
	TypeId            common.TypeId            `json:"typeId" url:"typeId"`
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties" url:"properties"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeObject) GetTypeId() common.TypeId {
	if s == nil {
		return ""
	}
	return s.TypeId
}

func (s *SingleDiscriminatedUnionTypeObject) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeObject) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeObject) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleDiscriminatedUnionTypeSingleProperty struct {
	TypeReference     *TypeReference           `json:"typeReference" url:"typeReference"`
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetTypeReference() *TypeReference {
	if s == nil {
		return nil
	}
	return s.TypeReference
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeSingleProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeSingleProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypeReference struct {
	Type      string
	List      *TypeReference
	Literal   *LiteralType
	Map       *MapType
	Named     common.TypeId
	Nullable  *TypeReference
	Optional  *TypeReference
	Primitive common.PrimitiveTypeV1
	Set       *TypeReference
	Unknown   interface{}
}

func (t *TypeReference) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TypeReference) GetList() *TypeReference {
	if t == nil {
		return nil
	}
	return t.List
}

func (t *TypeReference) GetLiteral() *LiteralType {
	if t == nil {
		return nil
	}
	return t.Literal
}

func (t *TypeReference) GetMap() *MapType {
	if t == nil {
		return nil
	}
	return t.Map
}

func (t *TypeReference) GetNamed() common.TypeId {
	if t == nil {
		return ""
	}
	return t.Named
}

func (t *TypeReference) GetNullable() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Nullable
}

func (t *TypeReference) GetOptional() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Optional
}

func (t *TypeReference) GetPrimitive() common.PrimitiveTypeV1 {
	if t == nil {
		return ""
	}
	return t.Primitive
}

func (t *TypeReference) GetSet() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Set
}

func (t *TypeReference) GetUnknown() interface{} {
	if t == nil {
		return nil
	}
	return t.Unknown
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.List = valueUnmarshaler.List
	case "literal":
		var valueUnmarshaler struct {
			Literal *LiteralType `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Literal = valueUnmarshaler.Literal
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Map = value
	case "named":
		var valueUnmarshaler struct {
			Named common.TypeId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Named = valueUnmarshaler.Named
	case "nullable":
		var valueUnmarshaler struct {
			Nullable *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Nullable = valueUnmarshaler.Nullable
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Optional = valueUnmarshaler.Optional
	case "primitive":
		var valueUnmarshaler struct {
			Primitive common.PrimitiveTypeV1 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Set = valueUnmarshaler.Set
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.List != nil {
		var marshaler = struct {
			Type string         `json:"type"`
			List *TypeReference `json:"value"`
		}{
			Type: "list",
			List: t.List,
		}
		return json.Marshal(marshaler)
	}
	if t.Literal != nil {
		var marshaler = struct {
			Type    string       `json:"type"`
			Literal *LiteralType `json:"value"`
		}{
			Type:    "literal",
			Literal: t.Literal,
		}
		return json.Marshal(marshaler)
	}
	if t.Map != nil {
		return internal.MarshalJSONWithExtraProperty(t.Map, "type", "map")
	}
	if t.Named != "" {
		var marshaler = struct {
			Type  string        `json:"type"`
			Named common.TypeId `json:"value"`
		}{
			Type:  "named",
			Named: t.Named,
		}
		return json.Marshal(marshaler)
	}
	if t.Nullable != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			Nullable *TypeReference `json:"value"`
		}{
			Type:     "nullable",
			Nullable: t.Nullable,
		}
		return json.Marshal(marshaler)
	}
	if t.Optional != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			Optional *TypeReference `json:"value"`
		}{
			Type:     "optional",
			Optional: t.Optional,
		}
		return json.Marshal(marshaler)
	}
	if t.Primitive != "" {
		var marshaler = struct {
			Type      string                 `json:"type"`
			Primitive common.PrimitiveTypeV1 `json:"value"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if t.Set != nil {
		var marshaler = struct {
			Type string         `json:"type"`
			Set  *TypeReference `json:"value"`
		}{
			Type: "set",
			Set:  t.Set,
		}
		return json.Marshal(marshaler)
	}
	if t.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TypeReferenceVisitor interface {
	VisitList(*TypeReference) error
	VisitLiteral(*LiteralType) error
	VisitMap(*MapType) error
	VisitNamed(common.TypeId) error
	VisitNullable(*TypeReference) error
	VisitOptional(*TypeReference) error
	VisitPrimitive(common.PrimitiveTypeV1) error
	VisitSet(*TypeReference) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	if t.List != nil {
		return visitor.VisitList(t.List)
	}
	if t.Literal != nil {
		return visitor.VisitLiteral(t.Literal)
	}
	if t.Map != nil {
		return visitor.VisitMap(t.Map)
	}
	if t.Named != "" {
		return visitor.VisitNamed(t.Named)
	}
	if t.Nullable != nil {
		return visitor.VisitNullable(t.Nullable)
	}
	if t.Optional != nil {
		return visitor.VisitOptional(t.Optional)
	}
	if t.Primitive != "" {
		return visitor.VisitPrimitive(t.Primitive)
	}
	if t.Set != nil {
		return visitor.VisitSet(t.Set)
	}
	if t.Unknown != nil {
		return visitor.VisitUnknown(t.Unknown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *TypeReference) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.List != nil {
		fields = append(fields, "list")
	}
	if t.Literal != nil {
		fields = append(fields, "literal")
	}
	if t.Map != nil {
		fields = append(fields, "map")
	}
	if t.Named != "" {
		fields = append(fields, "named")
	}
	if t.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if t.Optional != nil {
		fields = append(fields, "optional")
	}
	if t.Primitive != "" {
		fields = append(fields, "primitive")
	}
	if t.Set != nil {
		fields = append(fields, "set")
	}
	if t.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type UndiscriminatedUnionType struct {
	Declaration *Declaration `json:"declaration" url:"declaration"`
	// The dynamic type will be rendered with the first type that matches.
	Types []*TypeReference `json:"types" url:"types"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionType) GetDeclaration() *Declaration {
	if u == nil {
		return nil
	}
	return u.Declaration
}

func (u *UndiscriminatedUnionType) GetTypes() []*TypeReference {
	if u == nil {
		return nil
	}
	return u.Types
}

func (u *UndiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

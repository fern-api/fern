// Code generated by Fern. DO NOT EDIT.

package dynamic

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	common "github.com/fern-api/fern-go/internal/fern/ir/common"
	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type Auth struct {
	Type     string
	Basic    *BasicAuth
	Bearer   *BearerAuth
	Header   *HeaderAuth
	Oauth    *OAuth
	Inferred *InferredAuth
}

func (a *Auth) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *Auth) GetBasic() *BasicAuth {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *Auth) GetBearer() *BearerAuth {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *Auth) GetHeader() *HeaderAuth {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *Auth) GetOauth() *OAuth {
	if a == nil {
		return nil
	}
	return a.Oauth
}

func (a *Auth) GetInferred() *InferredAuth {
	if a == nil {
		return nil
	}
	return a.Inferred
}

func (a *Auth) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	case "inferred":
		value := new(InferredAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Inferred = value
	}
	return nil
}

func (a Auth) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	}
	if a.Bearer != nil {
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	}
	if a.Header != nil {
		return internal.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
	if a.Oauth != nil {
		return internal.MarshalJSONWithExtraProperty(a.Oauth, "type", "oauth")
	}
	if a.Inferred != nil {
		return internal.MarshalJSONWithExtraProperty(a.Inferred, "type", "inferred")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AuthVisitor interface {
	VisitBasic(*BasicAuth) error
	VisitBearer(*BearerAuth) error
	VisitHeader(*HeaderAuth) error
	VisitOauth(*OAuth) error
	VisitInferred(*InferredAuth) error
}

func (a *Auth) Accept(visitor AuthVisitor) error {
	if a.Basic != nil {
		return visitor.VisitBasic(a.Basic)
	}
	if a.Bearer != nil {
		return visitor.VisitBearer(a.Bearer)
	}
	if a.Header != nil {
		return visitor.VisitHeader(a.Header)
	}
	if a.Oauth != nil {
		return visitor.VisitOauth(a.Oauth)
	}
	if a.Inferred != nil {
		return visitor.VisitInferred(a.Inferred)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *Auth) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if a.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if a.Inferred != nil {
		fields = append(fields, "inferred")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AuthValues struct {
	Type     string
	Basic    *BasicAuthValues
	Bearer   *BearerAuthValues
	Header   *HeaderAuthValues
	Oauth    *OAuthValues
	Inferred *InferredAuthValues
}

func (a *AuthValues) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AuthValues) GetBasic() *BasicAuthValues {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *AuthValues) GetBearer() *BearerAuthValues {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *AuthValues) GetHeader() *HeaderAuthValues {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *AuthValues) GetOauth() *OAuthValues {
	if a == nil {
		return nil
	}
	return a.Oauth
}

func (a *AuthValues) GetInferred() *InferredAuthValues {
	if a == nil {
		return nil
	}
	return a.Inferred
}

func (a *AuthValues) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	case "inferred":
		value := new(InferredAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Inferred = value
	}
	return nil
}

func (a AuthValues) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	}
	if a.Bearer != nil {
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	}
	if a.Header != nil {
		return internal.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
	if a.Oauth != nil {
		return internal.MarshalJSONWithExtraProperty(a.Oauth, "type", "oauth")
	}
	if a.Inferred != nil {
		return internal.MarshalJSONWithExtraProperty(a.Inferred, "type", "inferred")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AuthValuesVisitor interface {
	VisitBasic(*BasicAuthValues) error
	VisitBearer(*BearerAuthValues) error
	VisitHeader(*HeaderAuthValues) error
	VisitOauth(*OAuthValues) error
	VisitInferred(*InferredAuthValues) error
}

func (a *AuthValues) Accept(visitor AuthValuesVisitor) error {
	if a.Basic != nil {
		return visitor.VisitBasic(a.Basic)
	}
	if a.Bearer != nil {
		return visitor.VisitBearer(a.Bearer)
	}
	if a.Header != nil {
		return visitor.VisitHeader(a.Header)
	}
	if a.Oauth != nil {
		return visitor.VisitOauth(a.Oauth)
	}
	if a.Inferred != nil {
		return visitor.VisitInferred(a.Inferred)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AuthValues) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if a.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if a.Inferred != nil {
		fields = append(fields, "inferred")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

var (
	basicAuthFieldUsername = big.NewInt(1 << 0)
	basicAuthFieldPassword = big.NewInt(1 << 1)
)

type BasicAuth struct {
	Username *common.Name `json:"username" url:"username"`
	Password *common.Name `json:"password" url:"password"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BasicAuth) GetUsername() *common.Name {
	if b == nil {
		return nil
	}
	return b.Username
}

func (b *BasicAuth) GetPassword() *common.Name {
	if b == nil {
		return nil
	}
	return b.Password
}

func (b *BasicAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuth) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasicAuth) SetUsername(username *common.Name) {
	b.Username = username
	b.require(basicAuthFieldUsername)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasicAuth) SetPassword(password *common.Name) {
	b.Password = password
	b.require(basicAuthFieldPassword)
}

func (b *BasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuth) MarshalJSON() ([]byte, error) {
	type embed BasicAuth
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasicAuth) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	basicAuthValuesFieldUsername = big.NewInt(1 << 0)
	basicAuthValuesFieldPassword = big.NewInt(1 << 1)
)

type BasicAuthValues struct {
	Username string `json:"username" url:"username"`
	Password string `json:"password" url:"password"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BasicAuthValues) GetUsername() string {
	if b == nil {
		return ""
	}
	return b.Username
}

func (b *BasicAuthValues) GetPassword() string {
	if b == nil {
		return ""
	}
	return b.Password
}

func (b *BasicAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuthValues) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasicAuthValues) SetUsername(username string) {
	b.Username = username
	b.require(basicAuthValuesFieldUsername)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasicAuthValues) SetPassword(password string) {
	b.Password = password
	b.require(basicAuthValuesFieldPassword)
}

func (b *BasicAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuthValues) MarshalJSON() ([]byte, error) {
	type embed BasicAuthValues
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasicAuthValues) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bearerAuthFieldToken = big.NewInt(1 << 0)
)

type BearerAuth struct {
	Token *common.Name `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BearerAuth) GetToken() *common.Name {
	if b == nil {
		return nil
	}
	return b.Token
}

func (b *BearerAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuth) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BearerAuth) SetToken(token *common.Name) {
	b.Token = token
	b.require(bearerAuthFieldToken)
}

func (b *BearerAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuth) MarshalJSON() ([]byte, error) {
	type embed BearerAuth
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BearerAuth) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bearerAuthValuesFieldToken = big.NewInt(1 << 0)
)

type BearerAuthValues struct {
	Token string `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BearerAuthValues) GetToken() string {
	if b == nil {
		return ""
	}
	return b.Token
}

func (b *BearerAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuthValues) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BearerAuthValues) SetToken(token string) {
	b.Token = token
	b.require(bearerAuthValuesFieldToken)
}

func (b *BearerAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuthValues) MarshalJSON() ([]byte, error) {
	type embed BearerAuthValues
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BearerAuthValues) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	headerAuthFieldHeader = big.NewInt(1 << 0)
)

type HeaderAuth struct {
	Header *NamedParameter `json:"header" url:"header"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuth) GetHeader() *NamedParameter {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HeaderAuth) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuth) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeaderAuth) SetHeader(header *NamedParameter) {
	h.Header = header
	h.require(headerAuthFieldHeader)
}

func (h *HeaderAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuth) MarshalJSON() ([]byte, error) {
	type embed HeaderAuth
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HeaderAuth) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

var (
	headerAuthValuesFieldValue = big.NewInt(1 << 0)
)

type HeaderAuthValues struct {
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuthValues) GetValue() interface{} {
	if h == nil {
		return nil
	}
	return h.Value
}

func (h *HeaderAuthValues) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuthValues) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeaderAuthValues) SetValue(value interface{}) {
	h.Value = value
	h.require(headerAuthValuesFieldValue)
}

func (h *HeaderAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuthValues) MarshalJSON() ([]byte, error) {
	type embed HeaderAuthValues
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HeaderAuthValues) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InferredAuth struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InferredAuth) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InferredAuth) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

func (i *InferredAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler InferredAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InferredAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InferredAuth) MarshalJSON() ([]byte, error) {
	type embed InferredAuth
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InferredAuth) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InferredAuthValues struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InferredAuthValues) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InferredAuthValues) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

func (i *InferredAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler InferredAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InferredAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InferredAuthValues) MarshalJSON() ([]byte, error) {
	type embed InferredAuthValues
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InferredAuthValues) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	oAuthFieldClientId     = big.NewInt(1 << 0)
	oAuthFieldClientSecret = big.NewInt(1 << 1)
)

type OAuth struct {
	ClientId     *common.Name `json:"clientId" url:"clientId"`
	ClientSecret *common.Name `json:"clientSecret" url:"clientSecret"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *OAuth) GetClientId() *common.Name {
	if o == nil {
		return nil
	}
	return o.ClientId
}

func (o *OAuth) GetClientSecret() *common.Name {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

func (o *OAuth) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuth) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetClientId sets the ClientId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuth) SetClientId(clientId *common.Name) {
	o.ClientId = clientId
	o.require(oAuthFieldClientId)
}

// SetClientSecret sets the ClientSecret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuth) SetClientSecret(clientSecret *common.Name) {
	o.ClientSecret = clientSecret
	o.require(oAuthFieldClientSecret)
}

func (o *OAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuth) MarshalJSON() ([]byte, error) {
	type embed OAuth
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OAuth) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	oAuthValuesFieldClientId     = big.NewInt(1 << 0)
	oAuthValuesFieldClientSecret = big.NewInt(1 << 1)
)

type OAuthValues struct {
	ClientId     string `json:"clientId" url:"clientId"`
	ClientSecret string `json:"clientSecret" url:"clientSecret"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *OAuthValues) GetClientId() string {
	if o == nil {
		return ""
	}
	return o.ClientId
}

func (o *OAuthValues) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *OAuthValues) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthValues) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetClientId sets the ClientId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthValues) SetClientId(clientId string) {
	o.ClientId = clientId
	o.require(oAuthValuesFieldClientId)
}

// SetClientSecret sets the ClientSecret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthValues) SetClientSecret(clientSecret string) {
	o.ClientSecret = clientSecret
	o.require(oAuthValuesFieldClientSecret)
}

func (o *OAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthValues) MarshalJSON() ([]byte, error) {
	type embed OAuthValues
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OAuthValues) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	declarationFieldFernFilepath = big.NewInt(1 << 0)
	declarationFieldName         = big.NewInt(1 << 1)
)

type Declaration struct {
	FernFilepath *common.FernFilepath `json:"fernFilepath" url:"fernFilepath"`
	Name         *common.Name         `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetFernFilepath() *common.FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *Declaration) GetName() *common.Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetFernFilepath sets the FernFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Declaration) SetFernFilepath(fernFilepath *common.FernFilepath) {
	d.FernFilepath = fernFilepath
	d.require(declarationFieldFernFilepath)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Declaration) SetName(name *common.Name) {
	d.Name = name
	d.require(declarationFieldName)
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Declaration) MarshalJSON() ([]byte, error) {
	type embed Declaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Declaration) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	bodyRequestFieldPathParameters = big.NewInt(1 << 0)
	bodyRequestFieldBody           = big.NewInt(1 << 1)
)

type BodyRequest struct {
	PathParameters []*NamedParameter          `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	Body           *ReferencedRequestBodyType `json:"body,omitempty" url:"body,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BodyRequest) GetPathParameters() []*NamedParameter {
	if b == nil {
		return nil
	}
	return b.PathParameters
}

func (b *BodyRequest) GetBody() *ReferencedRequestBodyType {
	if b == nil {
		return nil
	}
	return b.Body
}

func (b *BodyRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPathParameters sets the PathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyRequest) SetPathParameters(pathParameters []*NamedParameter) {
	b.PathParameters = pathParameters
	b.require(bodyRequestFieldPathParameters)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyRequest) SetBody(body *ReferencedRequestBodyType) {
	b.Body = body
	b.require(bodyRequestFieldBody)
}

func (b *BodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BodyRequest) MarshalJSON() ([]byte, error) {
	type embed BodyRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BodyRequest) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	endpointFieldAuth        = big.NewInt(1 << 0)
	endpointFieldDeclaration = big.NewInt(1 << 1)
	endpointFieldLocation    = big.NewInt(1 << 2)
	endpointFieldRequest     = big.NewInt(1 << 3)
	endpointFieldResponse    = big.NewInt(1 << 4)
	endpointFieldExamples    = big.NewInt(1 << 5)
)

type Endpoint struct {
	Auth        *Auth              `json:"auth,omitempty" url:"auth,omitempty"`
	Declaration *Declaration       `json:"declaration" url:"declaration"`
	Location    *EndpointLocation  `json:"location" url:"location"`
	Request     *Request           `json:"request" url:"request"`
	Response    *Response          `json:"response" url:"response"`
	Examples    []*EndpointExample `json:"examples,omitempty" url:"examples,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *Endpoint) GetAuth() *Auth {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *Endpoint) GetDeclaration() *Declaration {
	if e == nil {
		return nil
	}
	return e.Declaration
}

func (e *Endpoint) GetLocation() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Location
}

func (e *Endpoint) GetRequest() *Request {
	if e == nil {
		return nil
	}
	return e.Request
}

func (e *Endpoint) GetResponse() *Response {
	if e == nil {
		return nil
	}
	return e.Response
}

func (e *Endpoint) GetExamples() []*EndpointExample {
	if e == nil {
		return nil
	}
	return e.Examples
}

func (e *Endpoint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Endpoint) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetAuth sets the Auth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetAuth(auth *Auth) {
	e.Auth = auth
	e.require(endpointFieldAuth)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetDeclaration(declaration *Declaration) {
	e.Declaration = declaration
	e.require(endpointFieldDeclaration)
}

// SetLocation sets the Location field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetLocation(location *EndpointLocation) {
	e.Location = location
	e.require(endpointFieldLocation)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetRequest(request *Request) {
	e.Request = request
	e.require(endpointFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetResponse(response *Response) {
	e.Response = response
	e.require(endpointFieldResponse)
}

// SetExamples sets the Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Endpoint) SetExamples(examples []*EndpointExample) {
	e.Examples = examples
	e.require(endpointFieldExamples)
}

func (e *Endpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler Endpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Endpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *Endpoint) MarshalJSON() ([]byte, error) {
	type embed Endpoint
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Endpoint) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	endpointExampleFieldEndpoint        = big.NewInt(1 << 0)
	endpointExampleFieldBaseUrl         = big.NewInt(1 << 1)
	endpointExampleFieldEnvironment     = big.NewInt(1 << 2)
	endpointExampleFieldAuth            = big.NewInt(1 << 3)
	endpointExampleFieldPathParameters  = big.NewInt(1 << 4)
	endpointExampleFieldQueryParameters = big.NewInt(1 << 5)
	endpointExampleFieldHeaders         = big.NewInt(1 << 6)
	endpointExampleFieldRequestBody     = big.NewInt(1 << 7)
	endpointExampleFieldId              = big.NewInt(1 << 8)
	endpointExampleFieldName            = big.NewInt(1 << 9)
)

type EndpointExample struct {
	Endpoint        *EndpointLocation  `json:"endpoint" url:"endpoint"`
	BaseUrl         *string            `json:"baseURL,omitempty" url:"baseURL,omitempty"`
	Environment     *EnvironmentValues `json:"environment,omitempty" url:"environment,omitempty"`
	Auth            *AuthValues        `json:"auth,omitempty" url:"auth,omitempty"`
	PathParameters  *Values            `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters *Values            `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         *Values            `json:"headers,omitempty" url:"headers,omitempty"`
	RequestBody     interface{}        `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	// The unique identifier for the example.
	Id string `json:"id" url:"id"`
	// The name of the example, if any.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EndpointExample) GetEndpoint() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Endpoint
}

func (e *EndpointExample) GetBaseUrl() *string {
	if e == nil {
		return nil
	}
	return e.BaseUrl
}

func (e *EndpointExample) GetEnvironment() *EnvironmentValues {
	if e == nil {
		return nil
	}
	return e.Environment
}

func (e *EndpointExample) GetAuth() *AuthValues {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *EndpointExample) GetPathParameters() *Values {
	if e == nil {
		return nil
	}
	return e.PathParameters
}

func (e *EndpointExample) GetQueryParameters() *Values {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *EndpointExample) GetHeaders() *Values {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EndpointExample) GetRequestBody() interface{} {
	if e == nil {
		return nil
	}
	return e.RequestBody
}

func (e *EndpointExample) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EndpointExample) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EndpointExample) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointExample) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEndpoint sets the Endpoint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetEndpoint(endpoint *EndpointLocation) {
	e.Endpoint = endpoint
	e.require(endpointExampleFieldEndpoint)
}

// SetBaseUrl sets the BaseUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetBaseUrl(baseUrl *string) {
	e.BaseUrl = baseUrl
	e.require(endpointExampleFieldBaseUrl)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetEnvironment(environment *EnvironmentValues) {
	e.Environment = environment
	e.require(endpointExampleFieldEnvironment)
}

// SetAuth sets the Auth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetAuth(auth *AuthValues) {
	e.Auth = auth
	e.require(endpointExampleFieldAuth)
}

// SetPathParameters sets the PathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetPathParameters(pathParameters *Values) {
	e.PathParameters = pathParameters
	e.require(endpointExampleFieldPathParameters)
}

// SetQueryParameters sets the QueryParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetQueryParameters(queryParameters *Values) {
	e.QueryParameters = queryParameters
	e.require(endpointExampleFieldQueryParameters)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetHeaders(headers *Values) {
	e.Headers = headers
	e.require(endpointExampleFieldHeaders)
}

// SetRequestBody sets the RequestBody field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetRequestBody(requestBody interface{}) {
	e.RequestBody = requestBody
	e.require(endpointExampleFieldRequestBody)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetId(id string) {
	e.Id = id
	e.require(endpointExampleFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointExample) SetName(name *string) {
	e.Name = name
	e.require(endpointExampleFieldName)
}

func (e *EndpointExample) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointExample) MarshalJSON() ([]byte, error) {
	type embed EndpointExample
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EndpointExample) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents the endpoint location (e.g. "POST /users").
var (
	endpointLocationFieldMethod = big.NewInt(1 << 0)
	endpointLocationFieldPath   = big.NewInt(1 << 1)
)

type EndpointLocation struct {
	Method common.HttpMethod `json:"method" url:"method"`
	Path   string            `json:"path" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EndpointLocation) GetMethod() common.HttpMethod {
	if e == nil {
		return ""
	}
	return e.Method
}

func (e *EndpointLocation) GetPath() string {
	if e == nil {
		return ""
	}
	return e.Path
}

func (e *EndpointLocation) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointLocation) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointLocation) SetMethod(method common.HttpMethod) {
	e.Method = method
	e.require(endpointLocationFieldMethod)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointLocation) SetPath(path string) {
	e.Path = path
	e.require(endpointLocationFieldPath)
}

func (e *EndpointLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointLocation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointLocation) MarshalJSON() ([]byte, error) {
	type embed EndpointLocation
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EndpointLocation) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	fileUploadRequestBodyFieldProperties = big.NewInt(1 << 0)
)

type FileUploadRequestBody struct {
	Properties []*FileUploadRequestBodyProperty `json:"properties" url:"properties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (f *FileUploadRequestBody) GetProperties() []*FileUploadRequestBodyProperty {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FileUploadRequestBody) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadRequestBody) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileUploadRequestBody) SetProperties(properties []*FileUploadRequestBodyProperty) {
	f.Properties = properties
	f.require(fileUploadRequestBodyFieldProperties)
}

func (f *FileUploadRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileUploadRequestBody) MarshalJSON() ([]byte, error) {
	type embed FileUploadRequestBody
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileUploadRequestBody) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestBodyProperty struct {
	Type         string
	File         *common.NameAndWireValue
	FileArray    *common.NameAndWireValue
	BodyProperty *NamedParameter
}

func (f *FileUploadRequestBodyProperty) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FileUploadRequestBodyProperty) GetFile() *common.NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FileUploadRequestBodyProperty) GetFileArray() *common.NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.FileArray
}

func (f *FileUploadRequestBodyProperty) GetBodyProperty() *NamedParameter {
	if f == nil {
		return nil
	}
	return f.BodyProperty
}

func (f *FileUploadRequestBodyProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		value := new(common.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "fileArray":
		value := new(common.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.FileArray = value
	case "bodyProperty":
		value := new(NamedParameter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestBodyProperty) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	if f.File != nil {
		return internal.MarshalJSONWithExtraProperty(f.File, "type", "file")
	}
	if f.FileArray != nil {
		return internal.MarshalJSONWithExtraProperty(f.FileArray, "type", "fileArray")
	}
	if f.BodyProperty != nil {
		return internal.MarshalJSONWithExtraProperty(f.BodyProperty, "type", "bodyProperty")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FileUploadRequestBodyPropertyVisitor interface {
	VisitFile(*common.NameAndWireValue) error
	VisitFileArray(*common.NameAndWireValue) error
	VisitBodyProperty(*NamedParameter) error
}

func (f *FileUploadRequestBodyProperty) Accept(visitor FileUploadRequestBodyPropertyVisitor) error {
	if f.File != nil {
		return visitor.VisitFile(f.File)
	}
	if f.FileArray != nil {
		return visitor.VisitFileArray(f.FileArray)
	}
	if f.BodyProperty != nil {
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

func (f *FileUploadRequestBodyProperty) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.File != nil {
		fields = append(fields, "file")
	}
	if f.FileArray != nil {
		fields = append(fields, "fileArray")
	}
	if f.BodyProperty != nil {
		fields = append(fields, "bodyProperty")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

var (
	inlinedRequestFieldDeclaration     = big.NewInt(1 << 0)
	inlinedRequestFieldPathParameters  = big.NewInt(1 << 1)
	inlinedRequestFieldQueryParameters = big.NewInt(1 << 2)
	inlinedRequestFieldHeaders         = big.NewInt(1 << 3)
	inlinedRequestFieldBody            = big.NewInt(1 << 4)
	inlinedRequestFieldMetadata        = big.NewInt(1 << 5)
)

type InlinedRequest struct {
	Declaration     *Declaration            `json:"declaration" url:"declaration"`
	PathParameters  []*NamedParameter       `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters []*NamedParameter       `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         []*NamedParameter       `json:"headers,omitempty" url:"headers,omitempty"`
	Body            *InlinedRequestBody     `json:"body,omitempty" url:"body,omitempty"`
	Metadata        *InlinedRequestMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequest) GetDeclaration() *Declaration {
	if i == nil {
		return nil
	}
	return i.Declaration
}

func (i *InlinedRequest) GetPathParameters() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.PathParameters
}

func (i *InlinedRequest) GetQueryParameters() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.QueryParameters
}

func (i *InlinedRequest) GetHeaders() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.Headers
}

func (i *InlinedRequest) GetBody() *InlinedRequestBody {
	if i == nil {
		return nil
	}
	return i.Body
}

func (i *InlinedRequest) GetMetadata() *InlinedRequestMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InlinedRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetDeclaration(declaration *Declaration) {
	i.Declaration = declaration
	i.require(inlinedRequestFieldDeclaration)
}

// SetPathParameters sets the PathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetPathParameters(pathParameters []*NamedParameter) {
	i.PathParameters = pathParameters
	i.require(inlinedRequestFieldPathParameters)
}

// SetQueryParameters sets the QueryParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetQueryParameters(queryParameters []*NamedParameter) {
	i.QueryParameters = queryParameters
	i.require(inlinedRequestFieldQueryParameters)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetHeaders(headers []*NamedParameter) {
	i.Headers = headers
	i.require(inlinedRequestFieldHeaders)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetBody(body *InlinedRequestBody) {
	i.Body = body
	i.require(inlinedRequestFieldBody)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequest) SetMetadata(metadata *InlinedRequestMetadata) {
	i.Metadata = metadata
	i.require(inlinedRequestFieldMetadata)
}

func (i *InlinedRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequest) MarshalJSON() ([]byte, error) {
	type embed InlinedRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InlinedRequest) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBody struct {
	Type       string
	Properties []*NamedParameter
	Referenced *ReferencedRequestBody
	FileUpload *FileUploadRequestBody
}

func (i *InlinedRequestBody) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InlinedRequestBody) GetProperties() []*NamedParameter {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedRequestBody) GetReferenced() *ReferencedRequestBody {
	if i == nil {
		return nil
	}
	return i.Referenced
}

func (i *InlinedRequestBody) GetFileUpload() *FileUploadRequestBody {
	if i == nil {
		return nil
	}
	return i.FileUpload
}

func (i *InlinedRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "properties":
		var valueUnmarshaler struct {
			Properties []*NamedParameter `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.Properties = valueUnmarshaler.Properties
	case "referenced":
		value := new(ReferencedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Referenced = value
	case "fileUpload":
		value := new(FileUploadRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.FileUpload = value
	}
	return nil
}

func (i InlinedRequestBody) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.Properties != nil {
		var marshaler = struct {
			Type       string            `json:"type"`
			Properties []*NamedParameter `json:"value"`
		}{
			Type:       "properties",
			Properties: i.Properties,
		}
		return json.Marshal(marshaler)
	}
	if i.Referenced != nil {
		return internal.MarshalJSONWithExtraProperty(i.Referenced, "type", "referenced")
	}
	if i.FileUpload != nil {
		return internal.MarshalJSONWithExtraProperty(i.FileUpload, "type", "fileUpload")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InlinedRequestBodyVisitor interface {
	VisitProperties([]*NamedParameter) error
	VisitReferenced(*ReferencedRequestBody) error
	VisitFileUpload(*FileUploadRequestBody) error
}

func (i *InlinedRequestBody) Accept(visitor InlinedRequestBodyVisitor) error {
	if i.Properties != nil {
		return visitor.VisitProperties(i.Properties)
	}
	if i.Referenced != nil {
		return visitor.VisitReferenced(i.Referenced)
	}
	if i.FileUpload != nil {
		return visitor.VisitFileUpload(i.FileUpload)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InlinedRequestBody) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.Properties != nil {
		fields = append(fields, "properties")
	}
	if i.Referenced != nil {
		fields = append(fields, "referenced")
	}
	if i.FileUpload != nil {
		fields = append(fields, "fileUpload")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

var (
	inlinedRequestMetadataFieldIncludePathParameters = big.NewInt(1 << 0)
	inlinedRequestMetadataFieldOnlyPathParameters    = big.NewInt(1 << 1)
)

type InlinedRequestMetadata struct {
	// If true, the path parameters should be included as properties in the
	// inlined request type, but only if the generator is explicitly configured
	// to do so.
	//
	// By default, the path parameters are generated as positional parameters.
	IncludePathParameters bool `json:"includePathParameters" url:"includePathParameters"`
	// If true, the path parameters are the only parameters specified in the
	// inlined request.
	//
	// In combination with includePathParameters, this influences whether or not the
	// inlined request type should be generated at all.
	OnlyPathParameters bool `json:"onlyPathParameters" url:"onlyPathParameters"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestMetadata) GetIncludePathParameters() bool {
	if i == nil {
		return false
	}
	return i.IncludePathParameters
}

func (i *InlinedRequestMetadata) GetOnlyPathParameters() bool {
	if i == nil {
		return false
	}
	return i.OnlyPathParameters
}

func (i *InlinedRequestMetadata) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequestMetadata) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetIncludePathParameters sets the IncludePathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequestMetadata) SetIncludePathParameters(includePathParameters bool) {
	i.IncludePathParameters = includePathParameters
	i.require(inlinedRequestMetadataFieldIncludePathParameters)
}

// SetOnlyPathParameters sets the OnlyPathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedRequestMetadata) SetOnlyPathParameters(onlyPathParameters bool) {
	i.OnlyPathParameters = onlyPathParameters
	i.require(inlinedRequestMetadataFieldOnlyPathParameters)
}

func (i *InlinedRequestMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestMetadata) MarshalJSON() ([]byte, error) {
	type embed InlinedRequestMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InlinedRequestMetadata) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	referencedRequestBodyFieldBodyKey  = big.NewInt(1 << 0)
	referencedRequestBodyFieldBodyType = big.NewInt(1 << 1)
)

type ReferencedRequestBody struct {
	BodyKey  *common.Name               `json:"bodyKey" url:"bodyKey"`
	BodyType *ReferencedRequestBodyType `json:"bodyType" url:"bodyType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *ReferencedRequestBody) GetBodyKey() *common.Name {
	if r == nil {
		return nil
	}
	return r.BodyKey
}

func (r *ReferencedRequestBody) GetBodyType() *ReferencedRequestBodyType {
	if r == nil {
		return nil
	}
	return r.BodyType
}

func (r *ReferencedRequestBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencedRequestBody) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetBodyKey sets the BodyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRequestBody) SetBodyKey(bodyKey *common.Name) {
	r.BodyKey = bodyKey
	r.require(referencedRequestBodyFieldBodyKey)
}

// SetBodyType sets the BodyType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRequestBody) SetBodyType(bodyType *ReferencedRequestBodyType) {
	r.BodyType = bodyType
	r.require(referencedRequestBodyFieldBodyType)
}

func (r *ReferencedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ReferencedRequestBody) MarshalJSON() ([]byte, error) {
	type embed ReferencedRequestBody
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ReferencedRequestBody) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencedRequestBodyType struct {
	Type          string
	Bytes         interface{}
	TypeReference *TypeReference
}

func (r *ReferencedRequestBodyType) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ReferencedRequestBodyType) GetBytes() interface{} {
	if r == nil {
		return nil
	}
	return r.Bytes
}

func (r *ReferencedRequestBodyType) GetTypeReference() *TypeReference {
	if r == nil {
		return nil
	}
	return r.TypeReference
}

func (r *ReferencedRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "bytes":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Bytes = value
	case "typeReference":
		var valueUnmarshaler struct {
			TypeReference *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TypeReference = valueUnmarshaler.TypeReference
	}
	return nil
}

func (r ReferencedRequestBodyType) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Bytes != nil {
		var marshaler = struct {
			Type  string      `json:"type"`
			Bytes interface{} `json:"bytes,omitempty"`
		}{
			Type:  "bytes",
			Bytes: r.Bytes,
		}
		return json.Marshal(marshaler)
	}
	if r.TypeReference != nil {
		var marshaler = struct {
			Type          string         `json:"type"`
			TypeReference *TypeReference `json:"value"`
		}{
			Type:          "typeReference",
			TypeReference: r.TypeReference,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ReferencedRequestBodyTypeVisitor interface {
	VisitBytes(interface{}) error
	VisitTypeReference(*TypeReference) error
}

func (r *ReferencedRequestBodyType) Accept(visitor ReferencedRequestBodyTypeVisitor) error {
	if r.Bytes != nil {
		return visitor.VisitBytes(r.Bytes)
	}
	if r.TypeReference != nil {
		return visitor.VisitTypeReference(r.TypeReference)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ReferencedRequestBodyType) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Bytes != nil {
		fields = append(fields, "bytes")
	}
	if r.TypeReference != nil {
		fields = append(fields, "typeReference")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the request parameters required to call a specific endpoint.
type Request struct {
	Type    string
	Body    *BodyRequest
	Inlined *InlinedRequest
}

func (r *Request) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Request) GetBody() *BodyRequest {
	if r == nil {
		return nil
	}
	return r.Body
}

func (r *Request) GetInlined() *InlinedRequest {
	if r == nil {
		return nil
	}
	return r.Inlined
}

func (r *Request) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "body":
		value := new(BodyRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Body = value
	case "inlined":
		value := new(InlinedRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Inlined = value
	}
	return nil
}

func (r Request) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Body != nil {
		return internal.MarshalJSONWithExtraProperty(r.Body, "type", "body")
	}
	if r.Inlined != nil {
		return internal.MarshalJSONWithExtraProperty(r.Inlined, "type", "inlined")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RequestVisitor interface {
	VisitBody(*BodyRequest) error
	VisitInlined(*InlinedRequest) error
}

func (r *Request) Accept(visitor RequestVisitor) error {
	if r.Body != nil {
		return visitor.VisitBody(r.Body)
	}
	if r.Inlined != nil {
		return visitor.VisitInlined(r.Inlined)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *Request) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Body != nil {
		fields = append(fields, "body")
	}
	if r.Inlined != nil {
		fields = append(fields, "inlined")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the response returned by a specific endpoint.
//
// For now, we only support json responses, but this is set up to support a
// variety of other endpoint response types (e.g. file download, pagination,
// streaming, etc).
type Response struct {
	Type string
	Json interface{}
}

func (r *Response) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Response) GetJson() interface{} {
	if r == nil {
		return nil
	}
	return r.Json
}

func (r *Response) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "json":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Json = value
	}
	return nil
}

func (r Response) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Json != nil {
		var marshaler = struct {
			Type string      `json:"type"`
			Json interface{} `json:"json,omitempty"`
		}{
			Type: "json",
			Json: r.Json,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResponseVisitor interface {
	VisitJson(interface{}) error
}

func (r *Response) Accept(visitor ResponseVisitor) error {
	if r.Json != nil {
		return visitor.VisitJson(r.Json)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *Response) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Json != nil {
		fields = append(fields, "json")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Represents the value to use for a specific environment. There are three cases:
//
// 1. When sent as an EnvironmentId string, the generator assumes the value matches the name of the
// environment (e.g. "Staging"), and returns an error otherwise.
//
//  2. If the API supports multiple environment URLs, send a map of URLs, e.g.
//     {
//     "ec2": "https://staging.ec2.aws.com",
//     "s3": "https://staging.s3.aws.com"
//     }
type EnvironmentValues struct {
	EnvironmentId                common.EnvironmentId
	MultipleEnvironmentUrlValues MultipleEnvironmentUrlValues

	typ string
}

func (e *EnvironmentValues) GetEnvironmentId() common.EnvironmentId {
	if e == nil {
		return ""
	}
	return e.EnvironmentId
}

func (e *EnvironmentValues) GetMultipleEnvironmentUrlValues() MultipleEnvironmentUrlValues {
	if e == nil {
		return nil
	}
	return e.MultipleEnvironmentUrlValues
}

func (e *EnvironmentValues) UnmarshalJSON(data []byte) error {
	var valueEnvironmentId common.EnvironmentId
	if err := json.Unmarshal(data, &valueEnvironmentId); err == nil {
		e.typ = "EnvironmentId"
		e.EnvironmentId = valueEnvironmentId
		return nil
	}
	var valueMultipleEnvironmentUrlValues MultipleEnvironmentUrlValues
	if err := json.Unmarshal(data, &valueMultipleEnvironmentUrlValues); err == nil {
		e.typ = "MultipleEnvironmentUrlValues"
		e.MultipleEnvironmentUrlValues = valueMultipleEnvironmentUrlValues
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EnvironmentValues) MarshalJSON() ([]byte, error) {
	if e.typ == "EnvironmentId" || e.EnvironmentId != "" {
		return json.Marshal(e.EnvironmentId)
	}
	if e.typ == "MultipleEnvironmentUrlValues" || e.MultipleEnvironmentUrlValues != nil {
		return json.Marshal(e.MultipleEnvironmentUrlValues)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EnvironmentValuesVisitor interface {
	VisitEnvironmentId(common.EnvironmentId) error
	VisitMultipleEnvironmentUrlValues(MultipleEnvironmentUrlValues) error
}

func (e *EnvironmentValues) Accept(visitor EnvironmentValuesVisitor) error {
	if e.typ == "EnvironmentId" || e.EnvironmentId != "" {
		return visitor.VisitEnvironmentId(e.EnvironmentId)
	}
	if e.typ == "MultipleEnvironmentUrlValues" || e.MultipleEnvironmentUrlValues != nil {
		return visitor.VisitMultipleEnvironmentUrlValues(e.MultipleEnvironmentUrlValues)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type MultipleEnvironmentUrlValues = map[common.EnvironmentBaseUrlId]common.EnvironmentUrl

// This represents the IR required to generate dynamic snippets.
//
// This IR minimizes the space required to generate snippets in a variety
// of environments (e.g. web, offline, etc).
var (
	dynamicIntermediateRepresentationFieldTypes           = big.NewInt(1 << 0)
	dynamicIntermediateRepresentationFieldEndpoints       = big.NewInt(1 << 1)
	dynamicIntermediateRepresentationFieldEnvironments    = big.NewInt(1 << 2)
	dynamicIntermediateRepresentationFieldHeaders         = big.NewInt(1 << 3)
	dynamicIntermediateRepresentationFieldPathParameters  = big.NewInt(1 << 4)
	dynamicIntermediateRepresentationFieldGeneratorConfig = big.NewInt(1 << 5)
)

type DynamicIntermediateRepresentation struct {
	// The version of the dynamic IR. This is independent from the version
	// of the primary IR.
	Types        map[common.TypeId]*NamedType    `json:"types" url:"types"`
	Endpoints    map[common.EndpointId]*Endpoint `json:"endpoints" url:"endpoints"`
	Environments *common.EnvironmentsConfig      `json:"environments,omitempty" url:"environments,omitempty"`
	// The headers that are required on every request. These headers
	// are typically included in the SDK's client constructor.
	Headers []*NamedParameter `json:"headers,omitempty" url:"headers,omitempty"`
	// The path parameters that are required on every request. These
	// path parameters are typically included in the SDK's client
	// constructor.
	PathParameters  []*NamedParameter `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	GeneratorConfig *GeneratorConfig  `json:"generatorConfig,omitempty" url:"generatorConfig,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	version        string

	extraProperties map[string]interface{}
}

func (d *DynamicIntermediateRepresentation) GetTypes() map[common.TypeId]*NamedType {
	if d == nil {
		return nil
	}
	return d.Types
}

func (d *DynamicIntermediateRepresentation) GetEndpoints() map[common.EndpointId]*Endpoint {
	if d == nil {
		return nil
	}
	return d.Endpoints
}

func (d *DynamicIntermediateRepresentation) GetEnvironments() *common.EnvironmentsConfig {
	if d == nil {
		return nil
	}
	return d.Environments
}

func (d *DynamicIntermediateRepresentation) GetHeaders() []*NamedParameter {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DynamicIntermediateRepresentation) GetPathParameters() []*NamedParameter {
	if d == nil {
		return nil
	}
	return d.PathParameters
}

func (d *DynamicIntermediateRepresentation) GetGeneratorConfig() *GeneratorConfig {
	if d == nil {
		return nil
	}
	return d.GeneratorConfig
}

func (d *DynamicIntermediateRepresentation) Version() string {
	return d.version
}

func (d *DynamicIntermediateRepresentation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicIntermediateRepresentation) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTypes sets the Types field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetTypes(types map[common.TypeId]*NamedType) {
	d.Types = types
	d.require(dynamicIntermediateRepresentationFieldTypes)
}

// SetEndpoints sets the Endpoints field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetEndpoints(endpoints map[common.EndpointId]*Endpoint) {
	d.Endpoints = endpoints
	d.require(dynamicIntermediateRepresentationFieldEndpoints)
}

// SetEnvironments sets the Environments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetEnvironments(environments *common.EnvironmentsConfig) {
	d.Environments = environments
	d.require(dynamicIntermediateRepresentationFieldEnvironments)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetHeaders(headers []*NamedParameter) {
	d.Headers = headers
	d.require(dynamicIntermediateRepresentationFieldHeaders)
}

// SetPathParameters sets the PathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetPathParameters(pathParameters []*NamedParameter) {
	d.PathParameters = pathParameters
	d.require(dynamicIntermediateRepresentationFieldPathParameters)
}

// SetGeneratorConfig sets the GeneratorConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicIntermediateRepresentation) SetGeneratorConfig(generatorConfig *GeneratorConfig) {
	d.GeneratorConfig = generatorConfig
	d.require(dynamicIntermediateRepresentationFieldGeneratorConfig)
}

func (d *DynamicIntermediateRepresentation) UnmarshalJSON(data []byte) error {
	type embed DynamicIntermediateRepresentation
	var unmarshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DynamicIntermediateRepresentation(unmarshaler.embed)
	if unmarshaler.Version != "1.0.0" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "1.0.0", unmarshaler.Version)
	}
	d.version = unmarshaler.Version
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "version")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DynamicIntermediateRepresentation) MarshalJSON() ([]byte, error) {
	type embed DynamicIntermediateRepresentation
	var marshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed:   embed(*d),
		Version: "1.0.0",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DynamicIntermediateRepresentation) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The configuration for the generator. This is a simplified version of the
// generator-exec GeneratorConfig configuration.
var (
	generatorConfigFieldApiName      = big.NewInt(1 << 0)
	generatorConfigFieldOrganization = big.NewInt(1 << 1)
	generatorConfigFieldCustomConfig = big.NewInt(1 << 2)
	generatorConfigFieldOutputConfig = big.NewInt(1 << 3)
)

type GeneratorConfig struct {
	// The name of the API. This is equivalent to the workspace name in the
	// generator-exec configuration.
	ApiName      string                 `json:"apiName" url:"apiName"`
	Organization string                 `json:"organization" url:"organization"`
	CustomConfig interface{}            `json:"customConfig" url:"customConfig"`
	OutputConfig *GeneratorOutputConfig `json:"outputConfig" url:"outputConfig"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorConfig) GetApiName() string {
	if g == nil {
		return ""
	}
	return g.ApiName
}

func (g *GeneratorConfig) GetOrganization() string {
	if g == nil {
		return ""
	}
	return g.Organization
}

func (g *GeneratorConfig) GetCustomConfig() interface{} {
	if g == nil {
		return nil
	}
	return g.CustomConfig
}

func (g *GeneratorConfig) GetOutputConfig() *GeneratorOutputConfig {
	if g == nil {
		return nil
	}
	return g.OutputConfig
}

func (g *GeneratorConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorConfig) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetApiName sets the ApiName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetApiName(apiName string) {
	g.ApiName = apiName
	g.require(generatorConfigFieldApiName)
}

// SetOrganization sets the Organization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetOrganization(organization string) {
	g.Organization = organization
	g.require(generatorConfigFieldOrganization)
}

// SetCustomConfig sets the CustomConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetCustomConfig(customConfig interface{}) {
	g.CustomConfig = customConfig
	g.require(generatorConfigFieldCustomConfig)
}

// SetOutputConfig sets the OutputConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetOutputConfig(outputConfig *GeneratorOutputConfig) {
	g.OutputConfig = outputConfig
	g.require(generatorConfigFieldOutputConfig)
}

func (g *GeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorConfig) MarshalJSON() ([]byte, error) {
	type embed GeneratorConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The configuration for the output of the generator. This is a simplified version of
// the generator-exec output.mode configuration.
type GeneratorOutputConfig struct {
	Type    string
	Publish *PublishInfo
	Local   interface{}
}

func (g *GeneratorOutputConfig) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorOutputConfig) GetPublish() *PublishInfo {
	if g == nil {
		return nil
	}
	return g.Publish
}

func (g *GeneratorOutputConfig) GetLocal() interface{} {
	if g == nil {
		return nil
	}
	return g.Local
}

func (g *GeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "publish":
		var valueUnmarshaler struct {
			Publish *PublishInfo `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.Publish = valueUnmarshaler.Publish
	case "local":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	}
	return nil
}

func (g GeneratorOutputConfig) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Publish != nil {
		var marshaler = struct {
			Type    string       `json:"type"`
			Publish *PublishInfo `json:"value"`
		}{
			Type:    "publish",
			Publish: g.Publish,
		}
		return json.Marshal(marshaler)
	}
	if g.Local != nil {
		var marshaler = struct {
			Type  string      `json:"type"`
			Local interface{} `json:"local,omitempty"`
		}{
			Type:  "local",
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorOutputConfigVisitor interface {
	VisitPublish(*PublishInfo) error
	VisitLocal(interface{}) error
}

func (g *GeneratorOutputConfig) Accept(visitor GeneratorOutputConfigVisitor) error {
	if g.Publish != nil {
		return visitor.VisitPublish(g.Publish)
	}
	if g.Local != nil {
		return visitor.VisitLocal(g.Local)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorOutputConfig) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Publish != nil {
		fields = append(fields, "publish")
	}
	if g.Local != nil {
		fields = append(fields, "local")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

var (
	goPublishInfoFieldVersion = big.NewInt(1 << 0)
	goPublishInfoFieldRepoUrl = big.NewInt(1 << 1)
)

type GoPublishInfo struct {
	Version string `json:"version" url:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GoPublishInfo) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GoPublishInfo) GetRepoUrl() string {
	if g == nil {
		return ""
	}
	return g.RepoUrl
}

func (g *GoPublishInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoPublishInfo) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoPublishInfo) SetVersion(version string) {
	g.Version = version
	g.require(goPublishInfoFieldVersion)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GoPublishInfo) SetRepoUrl(repoUrl string) {
	g.RepoUrl = repoUrl
	g.require(goPublishInfoFieldRepoUrl)
}

func (g *GoPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GoPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GoPublishInfo) MarshalJSON() ([]byte, error) {
	type embed GoPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GoPublishInfo) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	mavenPublishInfoFieldVersion    = big.NewInt(1 << 0)
	mavenPublishInfoFieldCoordinate = big.NewInt(1 << 1)
	mavenPublishInfoFieldRepoUrl    = big.NewInt(1 << 2)
)

type MavenPublishInfo struct {
	Version    string  `json:"version" url:"version"`
	Coordinate string  `json:"coordinate" url:"coordinate"`
	RepoUrl    *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenPublishInfo) GetVersion() string {
	if m == nil {
		return ""
	}
	return m.Version
}

func (m *MavenPublishInfo) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenPublishInfo) GetRepoUrl() *string {
	if m == nil {
		return nil
	}
	return m.RepoUrl
}

func (m *MavenPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishInfo) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishInfo) SetVersion(version string) {
	m.Version = version
	m.require(mavenPublishInfoFieldVersion)
}

// SetCoordinate sets the Coordinate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishInfo) SetCoordinate(coordinate string) {
	m.Coordinate = coordinate
	m.require(mavenPublishInfoFieldCoordinate)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenPublishInfo) SetRepoUrl(repoUrl *string) {
	m.RepoUrl = repoUrl
	m.require(mavenPublishInfoFieldRepoUrl)
}

func (m *MavenPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenPublishInfo) MarshalJSON() ([]byte, error) {
	type embed MavenPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenPublishInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	npmPublishInfoFieldVersion     = big.NewInt(1 << 0)
	npmPublishInfoFieldPackageName = big.NewInt(1 << 1)
	npmPublishInfoFieldRepoUrl     = big.NewInt(1 << 2)
)

type NpmPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NpmPublishInfo) GetVersion() string {
	if n == nil {
		return ""
	}
	return n.Version
}

func (n *NpmPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmPublishInfo) GetRepoUrl() *string {
	if n == nil {
		return nil
	}
	return n.RepoUrl
}

func (n *NpmPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishInfo) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishInfo) SetVersion(version string) {
	n.Version = version
	n.require(npmPublishInfoFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishInfo) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(npmPublishInfoFieldPackageName)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmPublishInfo) SetRepoUrl(repoUrl *string) {
	n.RepoUrl = repoUrl
	n.require(npmPublishInfoFieldRepoUrl)
}

func (n *NpmPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmPublishInfo) MarshalJSON() ([]byte, error) {
	type embed NpmPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nugetPublishInfoFieldVersion     = big.NewInt(1 << 0)
	nugetPublishInfoFieldPackageName = big.NewInt(1 << 1)
	nugetPublishInfoFieldRepoUrl     = big.NewInt(1 << 2)
)

type NugetPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NugetPublishInfo) GetVersion() string {
	if n == nil {
		return ""
	}
	return n.Version
}

func (n *NugetPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetPublishInfo) GetRepoUrl() *string {
	if n == nil {
		return nil
	}
	return n.RepoUrl
}

func (n *NugetPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetPublishInfo) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetPublishInfo) SetVersion(version string) {
	n.Version = version
	n.require(nugetPublishInfoFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetPublishInfo) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(nugetPublishInfoFieldPackageName)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetPublishInfo) SetRepoUrl(repoUrl *string) {
	n.RepoUrl = repoUrl
	n.require(nugetPublishInfoFieldRepoUrl)
}

func (n *NugetPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetPublishInfo) MarshalJSON() ([]byte, error) {
	type embed NugetPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NugetPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PublishInfo struct {
	Type     string
	Go       *GoPublishInfo
	Maven    *MavenPublishInfo
	Npm      *NpmPublishInfo
	Nuget    *NugetPublishInfo
	Pypi     *PypiPublishInfo
	Rubygems *RubyGemsPublishInfo
}

func (p *PublishInfo) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PublishInfo) GetGo() *GoPublishInfo {
	if p == nil {
		return nil
	}
	return p.Go
}

func (p *PublishInfo) GetMaven() *MavenPublishInfo {
	if p == nil {
		return nil
	}
	return p.Maven
}

func (p *PublishInfo) GetNpm() *NpmPublishInfo {
	if p == nil {
		return nil
	}
	return p.Npm
}

func (p *PublishInfo) GetNuget() *NugetPublishInfo {
	if p == nil {
		return nil
	}
	return p.Nuget
}

func (p *PublishInfo) GetPypi() *PypiPublishInfo {
	if p == nil {
		return nil
	}
	return p.Pypi
}

func (p *PublishInfo) GetRubygems() *RubyGemsPublishInfo {
	if p == nil {
		return nil
	}
	return p.Rubygems
}

func (p *PublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "go":
		value := new(GoPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Go = value
	case "maven":
		value := new(MavenPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "npm":
		value := new(NpmPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "nuget":
		value := new(NugetPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Nuget = value
	case "pypi":
		value := new(PypiPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Pypi = value
	case "rubygems":
		value := new(RubyGemsPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Rubygems = value
	}
	return nil
}

func (p PublishInfo) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Go != nil {
		return internal.MarshalJSONWithExtraProperty(p.Go, "type", "go")
	}
	if p.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(p.Maven, "type", "maven")
	}
	if p.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(p.Npm, "type", "npm")
	}
	if p.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(p.Nuget, "type", "nuget")
	}
	if p.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(p.Pypi, "type", "pypi")
	}
	if p.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(p.Rubygems, "type", "rubygems")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PublishInfoVisitor interface {
	VisitGo(*GoPublishInfo) error
	VisitMaven(*MavenPublishInfo) error
	VisitNpm(*NpmPublishInfo) error
	VisitNuget(*NugetPublishInfo) error
	VisitPypi(*PypiPublishInfo) error
	VisitRubygems(*RubyGemsPublishInfo) error
}

func (p *PublishInfo) Accept(visitor PublishInfoVisitor) error {
	if p.Go != nil {
		return visitor.VisitGo(p.Go)
	}
	if p.Maven != nil {
		return visitor.VisitMaven(p.Maven)
	}
	if p.Npm != nil {
		return visitor.VisitNpm(p.Npm)
	}
	if p.Nuget != nil {
		return visitor.VisitNuget(p.Nuget)
	}
	if p.Pypi != nil {
		return visitor.VisitPypi(p.Pypi)
	}
	if p.Rubygems != nil {
		return visitor.VisitRubygems(p.Rubygems)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PublishInfo) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Go != nil {
		fields = append(fields, "go")
	}
	if p.Maven != nil {
		fields = append(fields, "maven")
	}
	if p.Npm != nil {
		fields = append(fields, "npm")
	}
	if p.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if p.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if p.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

var (
	pypiPublishInfoFieldVersion     = big.NewInt(1 << 0)
	pypiPublishInfoFieldPackageName = big.NewInt(1 << 1)
	pypiPublishInfoFieldRepoUrl     = big.NewInt(1 << 2)
)

type PypiPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PypiPublishInfo) GetVersion() string {
	if p == nil {
		return ""
	}
	return p.Version
}

func (p *PypiPublishInfo) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiPublishInfo) GetRepoUrl() *string {
	if p == nil {
		return nil
	}
	return p.RepoUrl
}

func (p *PypiPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishInfo) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiPublishInfo) SetVersion(version string) {
	p.Version = version
	p.require(pypiPublishInfoFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiPublishInfo) SetPackageName(packageName string) {
	p.PackageName = packageName
	p.require(pypiPublishInfoFieldPackageName)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiPublishInfo) SetRepoUrl(repoUrl *string) {
	p.RepoUrl = repoUrl
	p.require(pypiPublishInfoFieldRepoUrl)
}

func (p *PypiPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiPublishInfo) MarshalJSON() ([]byte, error) {
	type embed PypiPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PypiPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	rubyGemsPublishInfoFieldVersion     = big.NewInt(1 << 0)
	rubyGemsPublishInfoFieldPackageName = big.NewInt(1 << 1)
	rubyGemsPublishInfoFieldRepoUrl     = big.NewInt(1 << 2)
)

type RubyGemsPublishInfo struct {
	Version     string  `json:"version" url:"version"`
	PackageName string  `json:"packageName" url:"packageName"`
	RepoUrl     *string `json:"repoUrl,omitempty" url:"repoUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsPublishInfo) GetVersion() string {
	if r == nil {
		return ""
	}
	return r.Version
}

func (r *RubyGemsPublishInfo) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsPublishInfo) GetRepoUrl() *string {
	if r == nil {
		return nil
	}
	return r.RepoUrl
}

func (r *RubyGemsPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsPublishInfo) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsPublishInfo) SetVersion(version string) {
	r.Version = version
	r.require(rubyGemsPublishInfoFieldVersion)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsPublishInfo) SetPackageName(packageName string) {
	r.PackageName = packageName
	r.require(rubyGemsPublishInfoFieldPackageName)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsPublishInfo) SetRepoUrl(repoUrl *string) {
	r.RepoUrl = repoUrl
	r.require(rubyGemsPublishInfoFieldRepoUrl)
}

func (r *RubyGemsPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsPublishInfo) MarshalJSON() ([]byte, error) {
	type embed RubyGemsPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RubyGemsPublishInfo) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The user-facing request type used to generate a dynamic snippet.
var (
	endpointSnippetRequestFieldEndpoint        = big.NewInt(1 << 0)
	endpointSnippetRequestFieldBaseUrl         = big.NewInt(1 << 1)
	endpointSnippetRequestFieldEnvironment     = big.NewInt(1 << 2)
	endpointSnippetRequestFieldAuth            = big.NewInt(1 << 3)
	endpointSnippetRequestFieldPathParameters  = big.NewInt(1 << 4)
	endpointSnippetRequestFieldQueryParameters = big.NewInt(1 << 5)
	endpointSnippetRequestFieldHeaders         = big.NewInt(1 << 6)
	endpointSnippetRequestFieldRequestBody     = big.NewInt(1 << 7)
)

type EndpointSnippetRequest struct {
	Endpoint        *EndpointLocation  `json:"endpoint" url:"endpoint"`
	BaseUrl         *string            `json:"baseURL,omitempty" url:"baseURL,omitempty"`
	Environment     *EnvironmentValues `json:"environment,omitempty" url:"environment,omitempty"`
	Auth            *AuthValues        `json:"auth,omitempty" url:"auth,omitempty"`
	PathParameters  *Values            `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters *Values            `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         *Values            `json:"headers,omitempty" url:"headers,omitempty"`
	RequestBody     interface{}        `json:"requestBody,omitempty" url:"requestBody,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EndpointSnippetRequest) GetEndpoint() *EndpointLocation {
	if e == nil {
		return nil
	}
	return e.Endpoint
}

func (e *EndpointSnippetRequest) GetBaseUrl() *string {
	if e == nil {
		return nil
	}
	return e.BaseUrl
}

func (e *EndpointSnippetRequest) GetEnvironment() *EnvironmentValues {
	if e == nil {
		return nil
	}
	return e.Environment
}

func (e *EndpointSnippetRequest) GetAuth() *AuthValues {
	if e == nil {
		return nil
	}
	return e.Auth
}

func (e *EndpointSnippetRequest) GetPathParameters() *Values {
	if e == nil {
		return nil
	}
	return e.PathParameters
}

func (e *EndpointSnippetRequest) GetQueryParameters() *Values {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *EndpointSnippetRequest) GetHeaders() *Values {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EndpointSnippetRequest) GetRequestBody() interface{} {
	if e == nil {
		return nil
	}
	return e.RequestBody
}

func (e *EndpointSnippetRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointSnippetRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEndpoint sets the Endpoint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetEndpoint(endpoint *EndpointLocation) {
	e.Endpoint = endpoint
	e.require(endpointSnippetRequestFieldEndpoint)
}

// SetBaseUrl sets the BaseUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetBaseUrl(baseUrl *string) {
	e.BaseUrl = baseUrl
	e.require(endpointSnippetRequestFieldBaseUrl)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetEnvironment(environment *EnvironmentValues) {
	e.Environment = environment
	e.require(endpointSnippetRequestFieldEnvironment)
}

// SetAuth sets the Auth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetAuth(auth *AuthValues) {
	e.Auth = auth
	e.require(endpointSnippetRequestFieldAuth)
}

// SetPathParameters sets the PathParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetPathParameters(pathParameters *Values) {
	e.PathParameters = pathParameters
	e.require(endpointSnippetRequestFieldPathParameters)
}

// SetQueryParameters sets the QueryParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetQueryParameters(queryParameters *Values) {
	e.QueryParameters = queryParameters
	e.require(endpointSnippetRequestFieldQueryParameters)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetHeaders(headers *Values) {
	e.Headers = headers
	e.require(endpointSnippetRequestFieldHeaders)
}

// SetRequestBody sets the RequestBody field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EndpointSnippetRequest) SetRequestBody(requestBody interface{}) {
	e.RequestBody = requestBody
	e.require(endpointSnippetRequestFieldRequestBody)
}

func (e *EndpointSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointSnippetRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EndpointSnippetRequest) MarshalJSON() ([]byte, error) {
	type embed EndpointSnippetRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EndpointSnippetRequest) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Snippet values are represented as arbitrary key, value
// pairs (i.e. JSON objects). The keys are expected to be
// in the parameter's wire representation. For path parameters,
// the name will match the parameter name.
type Values = map[string]interface{}

var (
	aliasTypeFieldDeclaration   = big.NewInt(1 << 0)
	aliasTypeFieldTypeReference = big.NewInt(1 << 1)
)

type AliasType struct {
	Declaration   *Declaration   `json:"declaration" url:"declaration"`
	TypeReference *TypeReference `json:"typeReference" url:"typeReference"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (a *AliasType) GetDeclaration() *Declaration {
	if a == nil {
		return nil
	}
	return a.Declaration
}

func (a *AliasType) GetTypeReference() *TypeReference {
	if a == nil {
		return nil
	}
	return a.TypeReference
}

func (a *AliasType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasType) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AliasType) SetDeclaration(declaration *Declaration) {
	a.Declaration = declaration
	a.require(aliasTypeFieldDeclaration)
}

// SetTypeReference sets the TypeReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AliasType) SetTypeReference(typeReference *TypeReference) {
	a.TypeReference = typeReference
	a.require(aliasTypeFieldTypeReference)
}

func (a *AliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AliasType) MarshalJSON() ([]byte, error) {
	type embed AliasType
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AliasType) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	discriminatedUnionTypeFieldDeclaration  = big.NewInt(1 << 0)
	discriminatedUnionTypeFieldDiscriminant = big.NewInt(1 << 1)
	discriminatedUnionTypeFieldTypes        = big.NewInt(1 << 2)
)

type DiscriminatedUnionType struct {
	Declaration  *Declaration             `json:"declaration" url:"declaration"`
	Discriminant *common.NameAndWireValue `json:"discriminant" url:"discriminant"`
	// Map from the discriminant value (e.g. "user") to the type (e.g. User).
	Types map[string]*SingleDiscriminatedUnionType `json:"types" url:"types"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DiscriminatedUnionType) GetDeclaration() *Declaration {
	if d == nil {
		return nil
	}
	return d.Declaration
}

func (d *DiscriminatedUnionType) GetDiscriminant() *common.NameAndWireValue {
	if d == nil {
		return nil
	}
	return d.Discriminant
}

func (d *DiscriminatedUnionType) GetTypes() map[string]*SingleDiscriminatedUnionType {
	if d == nil {
		return nil
	}
	return d.Types
}

func (d *DiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiscriminatedUnionType) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DiscriminatedUnionType) SetDeclaration(declaration *Declaration) {
	d.Declaration = declaration
	d.require(discriminatedUnionTypeFieldDeclaration)
}

// SetDiscriminant sets the Discriminant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DiscriminatedUnionType) SetDiscriminant(discriminant *common.NameAndWireValue) {
	d.Discriminant = discriminant
	d.require(discriminatedUnionTypeFieldDiscriminant)
}

// SetTypes sets the Types field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DiscriminatedUnionType) SetTypes(types map[string]*SingleDiscriminatedUnionType) {
	d.Types = types
	d.require(discriminatedUnionTypeFieldTypes)
}

func (d *DiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	type embed DiscriminatedUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	enumTypeFieldDeclaration = big.NewInt(1 << 0)
	enumTypeFieldValues      = big.NewInt(1 << 1)
)

type EnumType struct {
	Declaration *Declaration               `json:"declaration" url:"declaration"`
	Values      []*common.NameAndWireValue `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnumType) GetDeclaration() *Declaration {
	if e == nil {
		return nil
	}
	return e.Declaration
}

func (e *EnumType) GetValues() []*common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Values
}

func (e *EnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumType) SetDeclaration(declaration *Declaration) {
	e.Declaration = declaration
	e.require(enumTypeFieldDeclaration)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumType) SetValues(values []*common.NameAndWireValue) {
	e.Values = values
	e.require(enumTypeFieldValues)
}

func (e *EnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumType) MarshalJSON() ([]byte, error) {
	type embed EnumType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnumType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type LiteralType struct {
	Type    string
	Boolean bool
	String  string
}

func (l *LiteralType) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LiteralType) GetBoolean() bool {
	if l == nil {
		return false
	}
	return l.Boolean
}

func (l *LiteralType) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LiteralType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	}
	return nil
}

func (l LiteralType) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	if l.Boolean != false {
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"value"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
	if l.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LiteralTypeVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (l *LiteralType) Accept(visitor LiteralTypeVisitor) error {
	if l.Boolean != false {
		return visitor.VisitBoolean(l.Boolean)
	}
	if l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

func (l *LiteralType) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.Boolean != false {
		fields = append(fields, "boolean")
	}
	if l.String != "" {
		fields = append(fields, "string")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

var (
	mapTypeFieldKey   = big.NewInt(1 << 0)
	mapTypeFieldValue = big.NewInt(1 << 1)
)

type MapType struct {
	Key   *TypeReference `json:"key" url:"key"`
	Value *TypeReference `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetKey() *TypeReference {
	if m == nil {
		return nil
	}
	return m.Key
}

func (m *MapType) GetValue() *TypeReference {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MapType) SetKey(key *TypeReference) {
	m.Key = key
	m.require(mapTypeFieldKey)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MapType) SetValue(value *TypeReference) {
	m.Value = value
	m.require(mapTypeFieldValue)
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MapType) MarshalJSON() ([]byte, error) {
	type embed MapType
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MapType) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	namedParameterFieldName           = big.NewInt(1 << 0)
	namedParameterFieldTypeReference  = big.NewInt(1 << 1)
	namedParameterFieldPropertyAccess = big.NewInt(1 << 2)
)

type NamedParameter struct {
	Name           *common.NameAndWireValue     `json:"name" url:"name"`
	TypeReference  *TypeReference               `json:"typeReference" url:"typeReference"`
	PropertyAccess *common.ObjectPropertyAccess `json:"propertyAccess,omitempty" url:"propertyAccess,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NamedParameter) GetName() *common.NameAndWireValue {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NamedParameter) GetTypeReference() *TypeReference {
	if n == nil {
		return nil
	}
	return n.TypeReference
}

func (n *NamedParameter) GetPropertyAccess() *common.ObjectPropertyAccess {
	if n == nil {
		return nil
	}
	return n.PropertyAccess
}

func (n *NamedParameter) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedParameter) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedParameter) SetName(name *common.NameAndWireValue) {
	n.Name = name
	n.require(namedParameterFieldName)
}

// SetTypeReference sets the TypeReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedParameter) SetTypeReference(typeReference *TypeReference) {
	n.TypeReference = typeReference
	n.require(namedParameterFieldTypeReference)
}

// SetPropertyAccess sets the PropertyAccess field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedParameter) SetPropertyAccess(propertyAccess *common.ObjectPropertyAccess) {
	n.PropertyAccess = propertyAccess
	n.require(namedParameterFieldPropertyAccess)
}

func (n *NamedParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NamedParameter) MarshalJSON() ([]byte, error) {
	type embed NamedParameter
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NamedParameter) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Represents the type of a parameter that can be used to generate a dynamic type.
type NamedType struct {
	Type                 string
	Alias                *AliasType
	Enum                 *EnumType
	Object               *ObjectType
	DiscriminatedUnion   *DiscriminatedUnionType
	UndiscriminatedUnion *UndiscriminatedUnionType
}

func (n *NamedType) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NamedType) GetAlias() *AliasType {
	if n == nil {
		return nil
	}
	return n.Alias
}

func (n *NamedType) GetEnum() *EnumType {
	if n == nil {
		return nil
	}
	return n.Enum
}

func (n *NamedType) GetObject() *ObjectType {
	if n == nil {
		return nil
	}
	return n.Object
}

func (n *NamedType) GetDiscriminatedUnion() *DiscriminatedUnionType {
	if n == nil {
		return nil
	}
	return n.DiscriminatedUnion
}

func (n *NamedType) GetUndiscriminatedUnion() *UndiscriminatedUnionType {
	if n == nil {
		return nil
	}
	return n.UndiscriminatedUnion
}

func (n *NamedType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Alias = value
	case "enum":
		value := new(EnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Enum = value
	case "object":
		value := new(ObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Object = value
	case "discriminatedUnion":
		value := new(DiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.DiscriminatedUnion = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.UndiscriminatedUnion = value
	}
	return nil
}

func (n NamedType) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	if n.Alias != nil {
		return internal.MarshalJSONWithExtraProperty(n.Alias, "type", "alias")
	}
	if n.Enum != nil {
		return internal.MarshalJSONWithExtraProperty(n.Enum, "type", "enum")
	}
	if n.Object != nil {
		return internal.MarshalJSONWithExtraProperty(n.Object, "type", "object")
	}
	if n.DiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(n.DiscriminatedUnion, "type", "discriminatedUnion")
	}
	if n.UndiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(n.UndiscriminatedUnion, "type", "undiscriminatedUnion")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NamedTypeVisitor interface {
	VisitAlias(*AliasType) error
	VisitEnum(*EnumType) error
	VisitObject(*ObjectType) error
	VisitDiscriminatedUnion(*DiscriminatedUnionType) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionType) error
}

func (n *NamedType) Accept(visitor NamedTypeVisitor) error {
	if n.Alias != nil {
		return visitor.VisitAlias(n.Alias)
	}
	if n.Enum != nil {
		return visitor.VisitEnum(n.Enum)
	}
	if n.Object != nil {
		return visitor.VisitObject(n.Object)
	}
	if n.DiscriminatedUnion != nil {
		return visitor.VisitDiscriminatedUnion(n.DiscriminatedUnion)
	}
	if n.UndiscriminatedUnion != nil {
		return visitor.VisitUndiscriminatedUnion(n.UndiscriminatedUnion)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

func (n *NamedType) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Alias != nil {
		fields = append(fields, "alias")
	}
	if n.Enum != nil {
		fields = append(fields, "enum")
	}
	if n.Object != nil {
		fields = append(fields, "object")
	}
	if n.DiscriminatedUnion != nil {
		fields = append(fields, "discriminatedUnion")
	}
	if n.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

var (
	objectTypeFieldDeclaration          = big.NewInt(1 << 0)
	objectTypeFieldProperties           = big.NewInt(1 << 1)
	objectTypeFieldAdditionalProperties = big.NewInt(1 << 2)
)

type ObjectType struct {
	Declaration *Declaration      `json:"declaration" url:"declaration"`
	Properties  []*NamedParameter `json:"properties" url:"properties"`
	// Whether the type allows additional properties.
	AdditionalProperties *bool `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *ObjectType) GetDeclaration() *Declaration {
	if o == nil {
		return nil
	}
	return o.Declaration
}

func (o *ObjectType) GetProperties() []*NamedParameter {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *ObjectType) GetAdditionalProperties() *bool {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *ObjectType) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectType) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectType) SetDeclaration(declaration *Declaration) {
	o.Declaration = declaration
	o.require(objectTypeFieldDeclaration)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectType) SetProperties(properties []*NamedParameter) {
	o.Properties = properties
	o.require(objectTypeFieldProperties)
}

// SetAdditionalProperties sets the AdditionalProperties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectType) SetAdditionalProperties(additionalProperties *bool) {
	o.AdditionalProperties = additionalProperties
	o.require(objectTypeFieldAdditionalProperties)
}

func (o *ObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectType) MarshalJSON() ([]byte, error) {
	type embed ObjectType
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectType) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type SingleDiscriminatedUnionType struct {
	Type                   string
	SamePropertiesAsObject *SingleDiscriminatedUnionTypeObject
	SingleProperty         *SingleDiscriminatedUnionTypeSingleProperty
	NoProperties           *SingleDiscriminatedUnionTypeNoProperties
}

func (s *SingleDiscriminatedUnionType) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleDiscriminatedUnionType) GetSamePropertiesAsObject() *SingleDiscriminatedUnionTypeObject {
	if s == nil {
		return nil
	}
	return s.SamePropertiesAsObject
}

func (s *SingleDiscriminatedUnionType) GetSingleProperty() *SingleDiscriminatedUnionTypeSingleProperty {
	if s == nil {
		return nil
	}
	return s.SingleProperty
}

func (s *SingleDiscriminatedUnionType) GetNoProperties() *SingleDiscriminatedUnionTypeNoProperties {
	if s == nil {
		return nil
	}
	return s.NoProperties
}

func (s *SingleDiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(SingleDiscriminatedUnionTypeObject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleDiscriminatedUnionTypeSingleProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := new(SingleDiscriminatedUnionTypeNoProperties)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleDiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.SamePropertiesAsObject != nil {
		return internal.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		return internal.MarshalJSONWithExtraProperty(s.SingleProperty, "type", "singleProperty")
	}
	if s.NoProperties != nil {
		return internal.MarshalJSONWithExtraProperty(s.NoProperties, "type", "noProperties")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleDiscriminatedUnionTypeVisitor interface {
	VisitSamePropertiesAsObject(*SingleDiscriminatedUnionTypeObject) error
	VisitSingleProperty(*SingleDiscriminatedUnionTypeSingleProperty) error
	VisitNoProperties(*SingleDiscriminatedUnionTypeNoProperties) error
}

func (s *SingleDiscriminatedUnionType) Accept(visitor SingleDiscriminatedUnionTypeVisitor) error {
	if s.SamePropertiesAsObject != nil {
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	}
	if s.SingleProperty != nil {
		return visitor.VisitSingleProperty(s.SingleProperty)
	}
	if s.NoProperties != nil {
		return visitor.VisitNoProperties(s.NoProperties)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleDiscriminatedUnionType) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if s.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

var (
	singleDiscriminatedUnionTypeNoPropertiesFieldDiscriminantValue = big.NewInt(1 << 0)
	singleDiscriminatedUnionTypeNoPropertiesFieldProperties        = big.NewInt(1 << 1)
)

type SingleDiscriminatedUnionTypeNoProperties struct {
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeNoProperties) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDiscriminantValue sets the DiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeNoProperties) SetDiscriminantValue(discriminantValue *common.NameAndWireValue) {
	s.DiscriminantValue = discriminantValue
	s.require(singleDiscriminatedUnionTypeNoPropertiesFieldDiscriminantValue)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeNoProperties) SetProperties(properties []*NamedParameter) {
	s.Properties = properties
	s.require(singleDiscriminatedUnionTypeNoPropertiesFieldProperties)
}

func (s *SingleDiscriminatedUnionTypeNoProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeNoProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeNoProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeNoProperties) MarshalJSON() ([]byte, error) {
	type embed SingleDiscriminatedUnionTypeNoProperties
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleDiscriminatedUnionTypeNoProperties) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	singleDiscriminatedUnionTypeObjectFieldTypeId            = big.NewInt(1 << 0)
	singleDiscriminatedUnionTypeObjectFieldDiscriminantValue = big.NewInt(1 << 1)
	singleDiscriminatedUnionTypeObjectFieldProperties        = big.NewInt(1 << 2)
)

type SingleDiscriminatedUnionTypeObject struct {
	TypeId            common.TypeId            `json:"typeId" url:"typeId"`
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties" url:"properties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeObject) GetTypeId() common.TypeId {
	if s == nil {
		return ""
	}
	return s.TypeId
}

func (s *SingleDiscriminatedUnionTypeObject) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeObject) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeObject) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTypeId sets the TypeId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeObject) SetTypeId(typeId common.TypeId) {
	s.TypeId = typeId
	s.require(singleDiscriminatedUnionTypeObjectFieldTypeId)
}

// SetDiscriminantValue sets the DiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeObject) SetDiscriminantValue(discriminantValue *common.NameAndWireValue) {
	s.DiscriminantValue = discriminantValue
	s.require(singleDiscriminatedUnionTypeObjectFieldDiscriminantValue)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeObject) SetProperties(properties []*NamedParameter) {
	s.Properties = properties
	s.require(singleDiscriminatedUnionTypeObjectFieldProperties)
}

func (s *SingleDiscriminatedUnionTypeObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeObject) MarshalJSON() ([]byte, error) {
	type embed SingleDiscriminatedUnionTypeObject
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleDiscriminatedUnionTypeObject) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	singleDiscriminatedUnionTypeSinglePropertyFieldTypeReference     = big.NewInt(1 << 0)
	singleDiscriminatedUnionTypeSinglePropertyFieldDiscriminantValue = big.NewInt(1 << 1)
	singleDiscriminatedUnionTypeSinglePropertyFieldProperties        = big.NewInt(1 << 2)
)

type SingleDiscriminatedUnionTypeSingleProperty struct {
	TypeReference     *TypeReference           `json:"typeReference" url:"typeReference"`
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetTypeReference() *TypeReference {
	if s == nil {
		return nil
	}
	return s.TypeReference
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetProperties() []*NamedParameter {
	if s == nil {
		return nil
	}
	return s.Properties
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTypeReference sets the TypeReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeSingleProperty) SetTypeReference(typeReference *TypeReference) {
	s.TypeReference = typeReference
	s.require(singleDiscriminatedUnionTypeSinglePropertyFieldTypeReference)
}

// SetDiscriminantValue sets the DiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeSingleProperty) SetDiscriminantValue(discriminantValue *common.NameAndWireValue) {
	s.DiscriminantValue = discriminantValue
	s.require(singleDiscriminatedUnionTypeSinglePropertyFieldDiscriminantValue)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleDiscriminatedUnionTypeSingleProperty) SetProperties(properties []*NamedParameter) {
	s.Properties = properties
	s.require(singleDiscriminatedUnionTypeSinglePropertyFieldProperties)
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeSingleProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeSingleProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) MarshalJSON() ([]byte, error) {
	type embed SingleDiscriminatedUnionTypeSingleProperty
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypeReference struct {
	Type      string
	List      *TypeReference
	Literal   *LiteralType
	Map       *MapType
	Named     common.TypeId
	Nullable  *TypeReference
	Optional  *TypeReference
	Primitive common.PrimitiveTypeV1
	Set       *TypeReference
	Unknown   interface{}
}

func (t *TypeReference) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TypeReference) GetList() *TypeReference {
	if t == nil {
		return nil
	}
	return t.List
}

func (t *TypeReference) GetLiteral() *LiteralType {
	if t == nil {
		return nil
	}
	return t.Literal
}

func (t *TypeReference) GetMap() *MapType {
	if t == nil {
		return nil
	}
	return t.Map
}

func (t *TypeReference) GetNamed() common.TypeId {
	if t == nil {
		return ""
	}
	return t.Named
}

func (t *TypeReference) GetNullable() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Nullable
}

func (t *TypeReference) GetOptional() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Optional
}

func (t *TypeReference) GetPrimitive() common.PrimitiveTypeV1 {
	if t == nil {
		return ""
	}
	return t.Primitive
}

func (t *TypeReference) GetSet() *TypeReference {
	if t == nil {
		return nil
	}
	return t.Set
}

func (t *TypeReference) GetUnknown() interface{} {
	if t == nil {
		return nil
	}
	return t.Unknown
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.List = valueUnmarshaler.List
	case "literal":
		var valueUnmarshaler struct {
			Literal *LiteralType `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Literal = valueUnmarshaler.Literal
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Map = value
	case "named":
		var valueUnmarshaler struct {
			Named common.TypeId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Named = valueUnmarshaler.Named
	case "nullable":
		var valueUnmarshaler struct {
			Nullable *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Nullable = valueUnmarshaler.Nullable
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Optional = valueUnmarshaler.Optional
	case "primitive":
		var valueUnmarshaler struct {
			Primitive common.PrimitiveTypeV1 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Set = valueUnmarshaler.Set
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.List != nil {
		var marshaler = struct {
			Type string         `json:"type"`
			List *TypeReference `json:"value"`
		}{
			Type: "list",
			List: t.List,
		}
		return json.Marshal(marshaler)
	}
	if t.Literal != nil {
		var marshaler = struct {
			Type    string       `json:"type"`
			Literal *LiteralType `json:"value"`
		}{
			Type:    "literal",
			Literal: t.Literal,
		}
		return json.Marshal(marshaler)
	}
	if t.Map != nil {
		return internal.MarshalJSONWithExtraProperty(t.Map, "type", "map")
	}
	if t.Named != "" {
		var marshaler = struct {
			Type  string        `json:"type"`
			Named common.TypeId `json:"value"`
		}{
			Type:  "named",
			Named: t.Named,
		}
		return json.Marshal(marshaler)
	}
	if t.Nullable != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			Nullable *TypeReference `json:"value"`
		}{
			Type:     "nullable",
			Nullable: t.Nullable,
		}
		return json.Marshal(marshaler)
	}
	if t.Optional != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			Optional *TypeReference `json:"value"`
		}{
			Type:     "optional",
			Optional: t.Optional,
		}
		return json.Marshal(marshaler)
	}
	if t.Primitive != "" {
		var marshaler = struct {
			Type      string                 `json:"type"`
			Primitive common.PrimitiveTypeV1 `json:"value"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if t.Set != nil {
		var marshaler = struct {
			Type string         `json:"type"`
			Set  *TypeReference `json:"value"`
		}{
			Type: "set",
			Set:  t.Set,
		}
		return json.Marshal(marshaler)
	}
	if t.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TypeReferenceVisitor interface {
	VisitList(*TypeReference) error
	VisitLiteral(*LiteralType) error
	VisitMap(*MapType) error
	VisitNamed(common.TypeId) error
	VisitNullable(*TypeReference) error
	VisitOptional(*TypeReference) error
	VisitPrimitive(common.PrimitiveTypeV1) error
	VisitSet(*TypeReference) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	if t.List != nil {
		return visitor.VisitList(t.List)
	}
	if t.Literal != nil {
		return visitor.VisitLiteral(t.Literal)
	}
	if t.Map != nil {
		return visitor.VisitMap(t.Map)
	}
	if t.Named != "" {
		return visitor.VisitNamed(t.Named)
	}
	if t.Nullable != nil {
		return visitor.VisitNullable(t.Nullable)
	}
	if t.Optional != nil {
		return visitor.VisitOptional(t.Optional)
	}
	if t.Primitive != "" {
		return visitor.VisitPrimitive(t.Primitive)
	}
	if t.Set != nil {
		return visitor.VisitSet(t.Set)
	}
	if t.Unknown != nil {
		return visitor.VisitUnknown(t.Unknown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *TypeReference) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.List != nil {
		fields = append(fields, "list")
	}
	if t.Literal != nil {
		fields = append(fields, "literal")
	}
	if t.Map != nil {
		fields = append(fields, "map")
	}
	if t.Named != "" {
		fields = append(fields, "named")
	}
	if t.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if t.Optional != nil {
		fields = append(fields, "optional")
	}
	if t.Primitive != "" {
		fields = append(fields, "primitive")
	}
	if t.Set != nil {
		fields = append(fields, "set")
	}
	if t.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

var (
	undiscriminatedUnionTypeFieldDeclaration = big.NewInt(1 << 0)
	undiscriminatedUnionTypeFieldTypes       = big.NewInt(1 << 1)
)

type UndiscriminatedUnionType struct {
	Declaration *Declaration `json:"declaration" url:"declaration"`
	// The dynamic type will be rendered with the first type that matches.
	Types []*TypeReference `json:"types" url:"types"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionType) GetDeclaration() *Declaration {
	if u == nil {
		return nil
	}
	return u.Declaration
}

func (u *UndiscriminatedUnionType) GetTypes() []*TypeReference {
	if u == nil {
		return nil
	}
	return u.Types
}

func (u *UndiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionType) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetDeclaration sets the Declaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UndiscriminatedUnionType) SetDeclaration(declaration *Declaration) {
	u.Declaration = declaration
	u.require(undiscriminatedUnionTypeFieldDeclaration)
}

// SetTypes sets the Types field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UndiscriminatedUnionType) SetTypes(types []*TypeReference) {
	u.Types = types
	u.require(undiscriminatedUnionTypeFieldTypes)
}

func (u *UndiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	type embed UndiscriminatedUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UndiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Code generated by Fern. DO NOT EDIT.

package common

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type EndpointId = string

var (
	fernFilepathFieldAllParts    = big.NewInt(1 << 0)
	fernFilepathFieldPackagePath = big.NewInt(1 << 1)
	fernFilepathFieldFile        = big.NewInt(1 << 2)
)

type FernFilepath struct {
	AllParts    []*Name `json:"allParts" url:"allParts"`
	PackagePath []*Name `json:"packagePath" url:"packagePath"`
	File        *Name   `json:"file,omitempty" url:"file,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (f *FernFilepath) GetAllParts() []*Name {
	if f == nil {
		return nil
	}
	return f.AllParts
}

func (f *FernFilepath) GetPackagePath() []*Name {
	if f == nil {
		return nil
	}
	return f.PackagePath
}

func (f *FernFilepath) GetFile() *Name {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FernFilepath) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FernFilepath) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetAllParts sets the AllParts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FernFilepath) SetAllParts(allParts []*Name) {
	f.AllParts = allParts
	f.require(fernFilepathFieldAllParts)
}

// SetPackagePath sets the PackagePath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FernFilepath) SetPackagePath(packagePath []*Name) {
	f.PackagePath = packagePath
	f.require(fernFilepathFieldPackagePath)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FernFilepath) SetFile(file *Name) {
	f.File = file
	f.require(fernFilepathFieldFile)
}

func (f *FernFilepath) UnmarshalJSON(data []byte) error {
	type unmarshaler FernFilepath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FernFilepath(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FernFilepath) MarshalJSON() ([]byte, error) {
	type embed FernFilepath
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FernFilepath) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	nameFieldOriginalName       = big.NewInt(1 << 0)
	nameFieldCamelCase          = big.NewInt(1 << 1)
	nameFieldPascalCase         = big.NewInt(1 << 2)
	nameFieldSnakeCase          = big.NewInt(1 << 3)
	nameFieldScreamingSnakeCase = big.NewInt(1 << 4)
)

type Name struct {
	OriginalName       string               `json:"originalName" url:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase" url:"camelCase"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase" url:"pascalCase"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase" url:"snakeCase"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase" url:"screamingSnakeCase"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *Name) GetOriginalName() string {
	if n == nil {
		return ""
	}
	return n.OriginalName
}

func (n *Name) GetCamelCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.CamelCase
}

func (n *Name) GetPascalCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.PascalCase
}

func (n *Name) GetSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.SnakeCase
}

func (n *Name) GetScreamingSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.ScreamingSnakeCase
}

func (n *Name) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Name) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetOriginalName sets the OriginalName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Name) SetOriginalName(originalName string) {
	n.OriginalName = originalName
	n.require(nameFieldOriginalName)
}

// SetCamelCase sets the CamelCase field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Name) SetCamelCase(camelCase *SafeAndUnsafeString) {
	n.CamelCase = camelCase
	n.require(nameFieldCamelCase)
}

// SetPascalCase sets the PascalCase field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Name) SetPascalCase(pascalCase *SafeAndUnsafeString) {
	n.PascalCase = pascalCase
	n.require(nameFieldPascalCase)
}

// SetSnakeCase sets the SnakeCase field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Name) SetSnakeCase(snakeCase *SafeAndUnsafeString) {
	n.SnakeCase = snakeCase
	n.require(nameFieldSnakeCase)
}

// SetScreamingSnakeCase sets the ScreamingSnakeCase field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *Name) SetScreamingSnakeCase(screamingSnakeCase *SafeAndUnsafeString) {
	n.ScreamingSnakeCase = screamingSnakeCase
	n.require(nameFieldScreamingSnakeCase)
}

func (n *Name) UnmarshalJSON(data []byte) error {
	type unmarshaler Name
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Name(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *Name) MarshalJSON() ([]byte, error) {
	type embed Name
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *Name) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nameAndWireValueFieldWireValue = big.NewInt(1 << 0)
	nameAndWireValueFieldName      = big.NewInt(1 << 1)
)

type NameAndWireValue struct {
	WireValue string `json:"wireValue" url:"wireValue"`
	Name      *Name  `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NameAndWireValue) GetWireValue() string {
	if n == nil {
		return ""
	}
	return n.WireValue
}

func (n *NameAndWireValue) GetName() *Name {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NameAndWireValue) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NameAndWireValue) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetWireValue sets the WireValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NameAndWireValue) SetWireValue(wireValue string) {
	n.WireValue = wireValue
	n.require(nameAndWireValueFieldWireValue)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NameAndWireValue) SetName(name *Name) {
	n.Name = name
	n.require(nameAndWireValueFieldName)
}

func (n *NameAndWireValue) UnmarshalJSON(data []byte) error {
	type unmarshaler NameAndWireValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NameAndWireValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NameAndWireValue) MarshalJSON() ([]byte, error) {
	type embed NameAndWireValue
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NameAndWireValue) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	safeAndUnsafeStringFieldUnsafeName = big.NewInt(1 << 0)
	safeAndUnsafeStringFieldSafeName   = big.NewInt(1 << 1)
)

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName" url:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName" url:"safeName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SafeAndUnsafeString) GetUnsafeName() string {
	if s == nil {
		return ""
	}
	return s.UnsafeName
}

func (s *SafeAndUnsafeString) GetSafeName() string {
	if s == nil {
		return ""
	}
	return s.SafeName
}

func (s *SafeAndUnsafeString) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SafeAndUnsafeString) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUnsafeName sets the UnsafeName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SafeAndUnsafeString) SetUnsafeName(unsafeName string) {
	s.UnsafeName = unsafeName
	s.require(safeAndUnsafeStringFieldUnsafeName)
}

// SetSafeName sets the SafeName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SafeAndUnsafeString) SetSafeName(safeName string) {
	s.SafeName = safeName
	s.require(safeAndUnsafeStringFieldSafeName)
}

func (s *SafeAndUnsafeString) UnmarshalJSON(data []byte) error {
	type unmarshaler SafeAndUnsafeString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SafeAndUnsafeString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SafeAndUnsafeString) MarshalJSON() ([]byte, error) {
	type embed SafeAndUnsafeString
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SafeAndUnsafeString) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypeId = string

var (
	withDocsFieldDocs = big.NewInt(1 << 0)
)

type WithDocs struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WithDocs) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WithDocs) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithDocs) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WithDocs) SetDocs(docs *string) {
	w.Docs = docs
	w.require(withDocsFieldDocs)
}

func (w *WithDocs) UnmarshalJSON(data []byte) error {
	type unmarshaler WithDocs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithDocs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithDocs) MarshalJSON() ([]byte, error) {
	type embed WithDocs
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WithDocs) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type EnvironmentBaseUrlId = string

var (
	environmentBaseUrlWithIdFieldId   = big.NewInt(1 << 0)
	environmentBaseUrlWithIdFieldName = big.NewInt(1 << 1)
)

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id" url:"id"`
	Name *Name                `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentBaseUrlWithId) GetId() EnvironmentBaseUrlId {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EnvironmentBaseUrlWithId) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnvironmentBaseUrlWithId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentBaseUrlWithId) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnvironmentBaseUrlWithId) SetId(id EnvironmentBaseUrlId) {
	e.Id = id
	e.require(environmentBaseUrlWithIdFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnvironmentBaseUrlWithId) SetName(name *Name) {
	e.Name = name
	e.require(environmentBaseUrlWithIdFieldName)
}

func (e *EnvironmentBaseUrlWithId) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentBaseUrlWithId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentBaseUrlWithId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentBaseUrlWithId) MarshalJSON() ([]byte, error) {
	type embed EnvironmentBaseUrlWithId
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnvironmentBaseUrlWithId) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func (e *Environments) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *Environments) GetSingleBaseUrl() *SingleBaseUrlEnvironments {
	if e == nil {
		return nil
	}
	return e.SingleBaseUrl
}

func (e *Environments) GetMultipleBaseUrls() *MultipleBaseUrlsEnvironments {
	if e == nil {
		return nil
	}
	return e.MultipleBaseUrls
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.SingleBaseUrl != nil {
		return internal.MarshalJSONWithExtraProperty(e.SingleBaseUrl, "type", "singleBaseUrl")
	}
	if e.MultipleBaseUrls != nil {
		return internal.MarshalJSONWithExtraProperty(e.MultipleBaseUrls, "type", "multipleBaseUrls")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	if e.SingleBaseUrl != nil {
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	}
	if e.MultipleBaseUrls != nil {
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *Environments) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SingleBaseUrl != nil {
		fields = append(fields, "singleBaseUrl")
	}
	if e.MultipleBaseUrls != nil {
		fields = append(fields, "multipleBaseUrls")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	environmentsConfigFieldDefaultEnvironment = big.NewInt(1 << 0)
	environmentsConfigFieldEnvironments       = big.NewInt(1 << 1)
)

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty" url:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments" url:"environments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentsConfig) GetDefaultEnvironment() *EnvironmentId {
	if e == nil {
		return nil
	}
	return e.DefaultEnvironment
}

func (e *EnvironmentsConfig) GetEnvironments() *Environments {
	if e == nil {
		return nil
	}
	return e.Environments
}

func (e *EnvironmentsConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentsConfig) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDefaultEnvironment sets the DefaultEnvironment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnvironmentsConfig) SetDefaultEnvironment(defaultEnvironment *EnvironmentId) {
	e.DefaultEnvironment = defaultEnvironment
	e.require(environmentsConfigFieldDefaultEnvironment)
}

// SetEnvironments sets the Environments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnvironmentsConfig) SetEnvironments(environments *Environments) {
	e.Environments = environments
	e.require(environmentsConfigFieldEnvironments)
}

func (e *EnvironmentsConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentsConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentsConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentsConfig) MarshalJSON() ([]byte, error) {
	type embed EnvironmentsConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnvironmentsConfig) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	multipleBaseUrlsEnvironmentFieldDocs = big.NewInt(1 << 0)
	multipleBaseUrlsEnvironmentFieldId   = big.NewInt(1 << 1)
	multipleBaseUrlsEnvironmentFieldName = big.NewInt(1 << 2)
	multipleBaseUrlsEnvironmentFieldUrls = big.NewInt(1 << 3)
)

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id" url:"id"`
	Name *Name                                   `json:"name" url:"name"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls" url:"urls"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironment) GetDocs() *string {
	if m == nil {
		return nil
	}
	return m.Docs
}

func (m *MultipleBaseUrlsEnvironment) GetId() EnvironmentId {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MultipleBaseUrlsEnvironment) GetName() *Name {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MultipleBaseUrlsEnvironment) GetUrls() map[EnvironmentBaseUrlId]EnvironmentUrl {
	if m == nil {
		return nil
	}
	return m.Urls
}

func (m *MultipleBaseUrlsEnvironment) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironment) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironment) SetDocs(docs *string) {
	m.Docs = docs
	m.require(multipleBaseUrlsEnvironmentFieldDocs)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironment) SetId(id EnvironmentId) {
	m.Id = id
	m.require(multipleBaseUrlsEnvironmentFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironment) SetName(name *Name) {
	m.Name = name
	m.require(multipleBaseUrlsEnvironmentFieldName)
}

// SetUrls sets the Urls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironment) SetUrls(urls map[EnvironmentBaseUrlId]EnvironmentUrl) {
	m.Urls = urls
	m.require(multipleBaseUrlsEnvironmentFieldUrls)
}

func (m *MultipleBaseUrlsEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironment) MarshalJSON() ([]byte, error) {
	type embed MultipleBaseUrlsEnvironment
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultipleBaseUrlsEnvironment) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	multipleBaseUrlsEnvironmentsFieldBaseUrls     = big.NewInt(1 << 0)
	multipleBaseUrlsEnvironmentsFieldEnvironments = big.NewInt(1 << 1)
)

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls" url:"baseUrls"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments" url:"environments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironments) GetBaseUrls() []*EnvironmentBaseUrlWithId {
	if m == nil {
		return nil
	}
	return m.BaseUrls
}

func (m *MultipleBaseUrlsEnvironments) GetEnvironments() []*MultipleBaseUrlsEnvironment {
	if m == nil {
		return nil
	}
	return m.Environments
}

func (m *MultipleBaseUrlsEnvironments) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironments) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetBaseUrls sets the BaseUrls field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironments) SetBaseUrls(baseUrls []*EnvironmentBaseUrlWithId) {
	m.BaseUrls = baseUrls
	m.require(multipleBaseUrlsEnvironmentsFieldBaseUrls)
}

// SetEnvironments sets the Environments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultipleBaseUrlsEnvironments) SetEnvironments(environments []*MultipleBaseUrlsEnvironment) {
	m.Environments = environments
	m.require(multipleBaseUrlsEnvironmentsFieldEnvironments)
}

func (m *MultipleBaseUrlsEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironments) MarshalJSON() ([]byte, error) {
	type embed MultipleBaseUrlsEnvironments
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultipleBaseUrlsEnvironments) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	singleBaseUrlEnvironmentFieldDocs = big.NewInt(1 << 0)
	singleBaseUrlEnvironmentFieldId   = big.NewInt(1 << 1)
	singleBaseUrlEnvironmentFieldName = big.NewInt(1 << 2)
	singleBaseUrlEnvironmentFieldUrl  = big.NewInt(1 << 3)
)

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId  `json:"id" url:"id"`
	Name *Name          `json:"name" url:"name"`
	Url  EnvironmentUrl `json:"url" url:"url"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironment) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleBaseUrlEnvironment) GetId() EnvironmentId {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SingleBaseUrlEnvironment) GetName() *Name {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleBaseUrlEnvironment) GetUrl() EnvironmentUrl {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *SingleBaseUrlEnvironment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironment) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleBaseUrlEnvironment) SetDocs(docs *string) {
	s.Docs = docs
	s.require(singleBaseUrlEnvironmentFieldDocs)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleBaseUrlEnvironment) SetId(id EnvironmentId) {
	s.Id = id
	s.require(singleBaseUrlEnvironmentFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleBaseUrlEnvironment) SetName(name *Name) {
	s.Name = name
	s.require(singleBaseUrlEnvironmentFieldName)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleBaseUrlEnvironment) SetUrl(url EnvironmentUrl) {
	s.Url = url
	s.require(singleBaseUrlEnvironmentFieldUrl)
}

func (s *SingleBaseUrlEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironment) MarshalJSON() ([]byte, error) {
	type embed SingleBaseUrlEnvironment
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleBaseUrlEnvironment) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	singleBaseUrlEnvironmentsFieldEnvironments = big.NewInt(1 << 0)
)

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments" url:"environments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironments) GetEnvironments() []*SingleBaseUrlEnvironment {
	if s == nil {
		return nil
	}
	return s.Environments
}

func (s *SingleBaseUrlEnvironments) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironments) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetEnvironments sets the Environments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleBaseUrlEnvironments) SetEnvironments(environments []*SingleBaseUrlEnvironment) {
	s.Environments = environments
	s.require(singleBaseUrlEnvironmentsFieldEnvironments)
}

func (s *SingleBaseUrlEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironments) MarshalJSON() ([]byte, error) {
	type embed SingleBaseUrlEnvironments
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleBaseUrlEnvironments) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
	HttpMethodHead   HttpMethod = "HEAD"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	case "HEAD":
		return HttpMethodHead, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type ObjectPropertyAccess string

const (
	ObjectPropertyAccessReadOnly  ObjectPropertyAccess = "READ_ONLY"
	ObjectPropertyAccessWriteOnly ObjectPropertyAccess = "WRITE_ONLY"
)

func NewObjectPropertyAccessFromString(s string) (ObjectPropertyAccess, error) {
	switch s {
	case "READ_ONLY":
		return ObjectPropertyAccessReadOnly, nil
	case "WRITE_ONLY":
		return ObjectPropertyAccessWriteOnly, nil
	}
	var t ObjectPropertyAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o ObjectPropertyAccess) Ptr() *ObjectPropertyAccess {
	return &o
}

type PrimitiveTypeV1 string

const (
	PrimitiveTypeV1Integer PrimitiveTypeV1 = "INTEGER"
	// Within the range -2^53 to 2^53
	PrimitiveTypeV1Long       PrimitiveTypeV1 = "LONG"
	PrimitiveTypeV1Uint       PrimitiveTypeV1 = "UINT"
	PrimitiveTypeV1Uint64     PrimitiveTypeV1 = "UINT_64"
	PrimitiveTypeV1Float      PrimitiveTypeV1 = "FLOAT"
	PrimitiveTypeV1Double     PrimitiveTypeV1 = "DOUBLE"
	PrimitiveTypeV1Boolean    PrimitiveTypeV1 = "BOOLEAN"
	PrimitiveTypeV1String     PrimitiveTypeV1 = "STRING"
	PrimitiveTypeV1Date       PrimitiveTypeV1 = "DATE"
	PrimitiveTypeV1DateTime   PrimitiveTypeV1 = "DATE_TIME"
	PrimitiveTypeV1Uuid       PrimitiveTypeV1 = "UUID"
	PrimitiveTypeV1Base64     PrimitiveTypeV1 = "BASE_64"
	PrimitiveTypeV1BigInteger PrimitiveTypeV1 = "BIG_INTEGER"
)

func NewPrimitiveTypeV1FromString(s string) (PrimitiveTypeV1, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeV1Integer, nil
	case "LONG":
		return PrimitiveTypeV1Long, nil
	case "UINT":
		return PrimitiveTypeV1Uint, nil
	case "UINT_64":
		return PrimitiveTypeV1Uint64, nil
	case "FLOAT":
		return PrimitiveTypeV1Float, nil
	case "DOUBLE":
		return PrimitiveTypeV1Double, nil
	case "BOOLEAN":
		return PrimitiveTypeV1Boolean, nil
	case "STRING":
		return PrimitiveTypeV1String, nil
	case "DATE":
		return PrimitiveTypeV1Date, nil
	case "DATE_TIME":
		return PrimitiveTypeV1DateTime, nil
	case "UUID":
		return PrimitiveTypeV1Uuid, nil
	case "BASE_64":
		return PrimitiveTypeV1Base64, nil
	case "BIG_INTEGER":
		return PrimitiveTypeV1BigInteger, nil
	}
	var t PrimitiveTypeV1
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveTypeV1) Ptr() *PrimitiveTypeV1 {
	return &p
}

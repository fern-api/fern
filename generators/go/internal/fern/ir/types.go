// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
	uuid "github.com/google/uuid"
)

type DeclaredErrorName struct {
	ErrorId      ErrorId       `json:"errorId" url:"errorId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredErrorName) GetErrorId() ErrorId {
	if d == nil {
		return ""
	}
	return d.ErrorId
}

func (d *DeclaredErrorName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredErrorName) GetName() *Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredErrorName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredErrorName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredErrorName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredErrorName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredErrorName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ErrorDeclaration struct {
	Docs              *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Name              *DeclaredErrorName `json:"name,omitempty" url:"name,omitempty"`
	DiscriminantValue *NameAndWireValue  `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Type              *TypeReference     `json:"type,omitempty" url:"type,omitempty"`
	StatusCode        int                `json:"statusCode" url:"statusCode"`
	Examples          []*ExampleError    `json:"examples,omitempty" url:"examples,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ErrorDeclaration) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ErrorDeclaration) GetName() *DeclaredErrorName {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ErrorDeclaration) GetDiscriminantValue() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.DiscriminantValue
}

func (e *ErrorDeclaration) GetType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.Type
}

func (e *ErrorDeclaration) GetStatusCode() int {
	if e == nil {
		return 0
	}
	return e.StatusCode
}

func (e *ErrorDeclaration) GetExamples() []*ExampleError {
	if e == nil {
		return nil
	}
	return e.Examples
}

func (e *ErrorDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ErrorDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *NameAndWireValue
	StatusCode interface{}
}

func NewErrorDeclarationDiscriminantValueFromProperty(value *NameAndWireValue) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "property", Property: value}
}

func NewErrorDeclarationDiscriminantValueFromStatusCode(value interface{}) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "statusCode", StatusCode: value}
}

func (e *ErrorDeclarationDiscriminantValue) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ErrorDeclarationDiscriminantValue) GetProperty() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Property
}

func (e *ErrorDeclarationDiscriminantValue) GetStatusCode() interface{} {
	if e == nil {
		return nil
	}
	return e.StatusCode
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "property":
		value := new(NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return internal.MarshalJSONWithExtraProperty(e.Property, "type", "property")
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*NameAndWireValue) error
	VisitStatusCode(interface{}) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return visitor.VisitProperty(e.Property)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	}
}

func (e *ErrorDeclarationDiscriminantValue) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Property != nil {
		fields = append(fields, "property")
	}
	if e.StatusCode != nil {
		fields = append(fields, "statusCode")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleError struct {
	JsonExample interface{}           `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Docs        *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *Name                 `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeReference `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleError) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleError) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleError) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleError) GetShape() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleError) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleError) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleError) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf,omitempty" url:"aliasOf,omitempty"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType,omitempty" url:"resolvedType,omitempty"`

	extraProperties map[string]interface{}
}

func (a *AliasTypeDeclaration) GetAliasOf() *TypeReference {
	if a == nil {
		return nil
	}
	return a.AliasOf
}

func (a *AliasTypeDeclaration) GetResolvedType() *ResolvedTypeReference {
	if a == nil {
		return nil
	}
	return a.ResolvedType
}

func (a *AliasTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AliasTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Base64Type struct {
	extraProperties map[string]interface{}
}

func (b *Base64Type) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base64Type) UnmarshalJSON(data []byte) error {
	type unmarshaler Base64Type
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Base64Type(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *Base64Type) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BigIntegerType struct {
	Default *string `json:"default,omitempty" url:"default,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BigIntegerType) GetDefault() *string {
	if b == nil {
		return nil
	}
	return b.Default
}

func (b *BigIntegerType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BigIntegerType) UnmarshalJSON(data []byte) error {
	type unmarshaler BigIntegerType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BigIntegerType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BigIntegerType) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanType struct {
	Default *bool `json:"default,omitempty" url:"default,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BooleanType) GetDefault() *bool {
	if b == nil {
		return nil
	}
	return b.Default
}

func (b *BooleanType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanType) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BooleanType) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Nullable *TypeReference
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func NewContainerTypeFromList(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "list", List: value}
}

func NewContainerTypeFromMap(value *MapType) *ContainerType {
	return &ContainerType{Type: "map", Map: value}
}

func NewContainerTypeFromNullable(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "nullable", Nullable: value}
}

func NewContainerTypeFromOptional(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "optional", Optional: value}
}

func NewContainerTypeFromSet(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "set", Set: value}
}

func NewContainerTypeFromLiteral(value *Literal) *ContainerType {
	return &ContainerType{Type: "literal", Literal: value}
}

func (c *ContainerType) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContainerType) GetList() *TypeReference {
	if c == nil {
		return nil
	}
	return c.List
}

func (c *ContainerType) GetMap() *MapType {
	if c == nil {
		return nil
	}
	return c.Map
}

func (c *ContainerType) GetNullable() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Nullable
}

func (c *ContainerType) GetOptional() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Optional
}

func (c *ContainerType) GetSet() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Set
}

func (c *ContainerType) GetLiteral() *Literal {
	if c == nil {
		return nil
	}
	return c.Literal
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", c)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "nullable":
		var valueUnmarshaler struct {
			Nullable *TypeReference `json:"nullable,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Nullable = valueUnmarshaler.Nullable
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list,omitempty"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "map":
		return internal.MarshalJSONWithExtraProperty(c.Map, "_type", "map")
	case "nullable":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Nullable *TypeReference `json:"nullable,omitempty"`
		}{
			Type:     "nullable",
			Nullable: c.Nullable,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional,omitempty"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set,omitempty"`
		}{
			Type: "set",
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal,omitempty"`
		}{
			Type:    "literal",
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitNullable(*TypeReference) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "map":
		return visitor.VisitMap(c.Map)
	case "nullable":
		return visitor.VisitNullable(c.Nullable)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	case "set":
		return visitor.VisitSet(c.Set)
	case "literal":
		return visitor.VisitLiteral(c.Literal)
	}
}

func (c *ContainerType) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.List != nil {
		fields = append(fields, "list")
	}
	if c.Map != nil {
		fields = append(fields, "map")
	}
	if c.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if c.Optional != nil {
		fields = append(fields, "optional")
	}
	if c.Set != nil {
		fields = append(fields, "set")
	}
	if c.Literal != nil {
		fields = append(fields, "literal")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type DateTimeType struct {
	extraProperties map[string]interface{}
}

func (d *DateTimeType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateTimeType) UnmarshalJSON(data []byte) error {
	type unmarshaler DateTimeType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateTimeType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DateTimeType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DateType struct {
	extraProperties map[string]interface{}
}

func (d *DateType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateType) UnmarshalJSON(data []byte) error {
	type unmarshaler DateType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DateType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeclaredTypeName struct {
	TypeId       TypeId        `json:"typeId" url:"typeId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredTypeName) GetTypeId() TypeId {
	if d == nil {
		return ""
	}
	return d.TypeId
}

func (d *DeclaredTypeName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredTypeName) GetName() *Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredTypeName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredTypeName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredTypeName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredTypeName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredTypeName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DoubleType struct {
	Default    *float64               `json:"default,omitempty" url:"default,omitempty"`
	Validation *DoubleValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DoubleType) GetDefault() *float64 {
	if d == nil {
		return nil
	}
	return d.Default
}

func (d *DoubleType) GetValidation() *DoubleValidationRules {
	if d == nil {
		return nil
	}
	return d.Validation
}

func (d *DoubleType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleType) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DoubleType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DoubleValidationRules struct {
	Min          *float64 `json:"min,omitempty" url:"min,omitempty"`
	Max          *float64 `json:"max,omitempty" url:"max,omitempty"`
	ExclusiveMin *bool    `json:"exclusiveMin,omitempty" url:"exclusiveMin,omitempty"`
	ExclusiveMax *bool    `json:"exclusiveMax,omitempty" url:"exclusiveMax,omitempty"`
	MultipleOf   *float64 `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DoubleValidationRules) GetMin() *float64 {
	if d == nil {
		return nil
	}
	return d.Min
}

func (d *DoubleValidationRules) GetMax() *float64 {
	if d == nil {
		return nil
	}
	return d.Max
}

func (d *DoubleValidationRules) GetExclusiveMin() *bool {
	if d == nil {
		return nil
	}
	return d.ExclusiveMin
}

func (d *DoubleValidationRules) GetExclusiveMax() *bool {
	if d == nil {
		return nil
	}
	return d.ExclusiveMax
}

func (d *DoubleValidationRules) GetMultipleOf() *float64 {
	if d == nil {
		return nil
	}
	return d.MultipleOf
}

func (d *DoubleValidationRules) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DoubleValidationRules) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type Encoding struct {
	Json  *JsonEncoding  `json:"json,omitempty" url:"json,omitempty"`
	Proto *ProtoEncoding `json:"proto,omitempty" url:"proto,omitempty"`

	extraProperties map[string]interface{}
}

func (e *Encoding) GetJson() *JsonEncoding {
	if e == nil {
		return nil
	}
	return e.Json
}

func (e *Encoding) GetProto() *ProtoEncoding {
	if e == nil {
		return nil
	}
	return e.Proto
}

func (e *Encoding) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Encoding) UnmarshalJSON(data []byte) error {
	type unmarshaler Encoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Encoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *Encoding) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumTypeDeclaration struct {
	Default *EnumValue   `json:"default,omitempty" url:"default,omitempty"`
	Values  []*EnumValue `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumTypeDeclaration) GetDefault() *EnumValue {
	if e == nil {
		return nil
	}
	return e.Default
}

func (e *EnumTypeDeclaration) GetValues() []*EnumValue {
	if e == nil {
		return nil
	}
	return e.Values
}

func (e *EnumTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumTypeReference struct {
	Default *EnumValue        `json:"default,omitempty" url:"default,omitempty"`
	Name    *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumTypeReference) GetDefault() *EnumValue {
	if e == nil {
		return nil
	}
	return e.Default
}

func (e *EnumTypeReference) GetName() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnumTypeReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumTypeReference) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumTypeReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumTypeReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumTypeReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumValue) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *EnumValue) GetAvailability() *Availability {
	if e == nil {
		return nil
	}
	return e.Availability
}

func (e *EnumValue) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnumValue) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumValue) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumValue) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleAliasType) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleAliasType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleAliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleAliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleAliasType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleAliasType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleContainer struct {
	Type     string
	List     *ExampleListContainer
	Set      *ExampleSetContainer
	Optional *ExampleOptionalContainer
	Nullable *ExampleNullableContainer
	Map      *ExampleMapContainer
	Literal  *ExampleLiteralContainer
}

func NewExampleContainerFromList(value *ExampleListContainer) *ExampleContainer {
	return &ExampleContainer{Type: "list", List: value}
}

func NewExampleContainerFromSet(value *ExampleSetContainer) *ExampleContainer {
	return &ExampleContainer{Type: "set", Set: value}
}

func NewExampleContainerFromOptional(value *ExampleOptionalContainer) *ExampleContainer {
	return &ExampleContainer{Type: "optional", Optional: value}
}

func NewExampleContainerFromNullable(value *ExampleNullableContainer) *ExampleContainer {
	return &ExampleContainer{Type: "nullable", Nullable: value}
}

func NewExampleContainerFromMap(value *ExampleMapContainer) *ExampleContainer {
	return &ExampleContainer{Type: "map", Map: value}
}

func NewExampleContainerFromLiteral(value *ExampleLiteralContainer) *ExampleContainer {
	return &ExampleContainer{Type: "literal", Literal: value}
}

func (e *ExampleContainer) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleContainer) GetList() *ExampleListContainer {
	if e == nil {
		return nil
	}
	return e.List
}

func (e *ExampleContainer) GetSet() *ExampleSetContainer {
	if e == nil {
		return nil
	}
	return e.Set
}

func (e *ExampleContainer) GetOptional() *ExampleOptionalContainer {
	if e == nil {
		return nil
	}
	return e.Optional
}

func (e *ExampleContainer) GetNullable() *ExampleNullableContainer {
	if e == nil {
		return nil
	}
	return e.Nullable
}

func (e *ExampleContainer) GetMap() *ExampleMapContainer {
	if e == nil {
		return nil
	}
	return e.Map
}

func (e *ExampleContainer) GetLiteral() *ExampleLiteralContainer {
	if e == nil {
		return nil
	}
	return e.Literal
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "list":
		value := new(ExampleListContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.List = value
	case "set":
		value := new(ExampleSetContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Set = value
	case "optional":
		value := new(ExampleOptionalContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Optional = value
	case "nullable":
		value := new(ExampleNullableContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Nullable = value
	case "map":
		value := new(ExampleMapContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Map = value
	case "literal":
		value := new(ExampleLiteralContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Literal = value
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return internal.MarshalJSONWithExtraProperty(e.List, "type", "list")
	case "set":
		return internal.MarshalJSONWithExtraProperty(e.Set, "type", "set")
	case "optional":
		return internal.MarshalJSONWithExtraProperty(e.Optional, "type", "optional")
	case "nullable":
		return internal.MarshalJSONWithExtraProperty(e.Nullable, "type", "nullable")
	case "map":
		return internal.MarshalJSONWithExtraProperty(e.Map, "type", "map")
	case "literal":
		return internal.MarshalJSONWithExtraProperty(e.Literal, "type", "literal")
	}
}

type ExampleContainerVisitor interface {
	VisitList(*ExampleListContainer) error
	VisitSet(*ExampleSetContainer) error
	VisitOptional(*ExampleOptionalContainer) error
	VisitNullable(*ExampleNullableContainer) error
	VisitMap(*ExampleMapContainer) error
	VisitLiteral(*ExampleLiteralContainer) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return visitor.VisitList(e.List)
	case "set":
		return visitor.VisitSet(e.Set)
	case "optional":
		return visitor.VisitOptional(e.Optional)
	case "nullable":
		return visitor.VisitNullable(e.Nullable)
	case "map":
		return visitor.VisitMap(e.Map)
	case "literal":
		return visitor.VisitLiteral(e.Literal)
	}
}

func (e *ExampleContainer) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.List != nil {
		fields = append(fields, "list")
	}
	if e.Set != nil {
		fields = append(fields, "set")
	}
	if e.Optional != nil {
		fields = append(fields, "optional")
	}
	if e.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if e.Map != nil {
		fields = append(fields, "map")
	}
	if e.Literal != nil {
		fields = append(fields, "literal")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleDatetime struct {
	Datetime time.Time `json:"datetime" url:"datetime"`
	Raw      *string   `json:"raw,omitempty" url:"raw,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleDatetime) GetDatetime() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Datetime
}

func (e *ExampleDatetime) GetRaw() *string {
	if e == nil {
		return nil
	}
	return e.Raw
}

func (e *ExampleDatetime) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleDatetime) UnmarshalJSON(data []byte) error {
	type embed ExampleDatetime
	var unmarshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExampleDatetime(unmarshaler.embed)
	e.Datetime = unmarshaler.Datetime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleDatetime) MarshalJSON() ([]byte, error) {
	type embed ExampleDatetime
	var marshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed:    embed(*e),
		Datetime: internal.NewDateTime(e.Datetime),
	}
	return json.Marshal(marshaler)
}

func (e *ExampleDatetime) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEnumType struct {
	Value *NameAndWireValue `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEnumType) GetValue() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleEnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEnumType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEnumType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key,omitempty" url:"key,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleKeyValuePair) GetKey() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *ExampleKeyValuePair) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleKeyValuePair) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleKeyValuePair) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleKeyValuePair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleKeyValuePair(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleKeyValuePair) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleListContainer struct {
	List     []*ExampleTypeReference `json:"list,omitempty" url:"list,omitempty"`
	ItemType *TypeReference          `json:"itemType,omitempty" url:"itemType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleListContainer) GetList() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.List
}

func (e *ExampleListContainer) GetItemType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ItemType
}

func (e *ExampleListContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleListContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleListContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleListContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleListContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleLiteralContainer struct {
	Literal *ExamplePrimitive `json:"literal,omitempty" url:"literal,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleLiteralContainer) GetLiteral() *ExamplePrimitive {
	if e == nil {
		return nil
	}
	return e.Literal
}

func (e *ExampleLiteralContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleLiteralContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleLiteralContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleLiteralContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleLiteralContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleMapContainer struct {
	Map       []*ExampleKeyValuePair `json:"map,omitempty" url:"map,omitempty"`
	KeyType   *TypeReference         `json:"keyType,omitempty" url:"keyType,omitempty"`
	ValueType *TypeReference         `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleMapContainer) GetMap() []*ExampleKeyValuePair {
	if e == nil {
		return nil
	}
	return e.Map
}

func (e *ExampleMapContainer) GetKeyType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.KeyType
}

func (e *ExampleMapContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleMapContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleMapContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleMapContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleMapContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleMapContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName,omitempty" url:"typeName,omitempty"`
	Shape    *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleNamedType) GetTypeName() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.TypeName
}

func (e *ExampleNamedType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleNamedType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleNamedType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleNullableContainer struct {
	Nullable  *ExampleTypeReference `json:"nullable,omitempty" url:"nullable,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleNullableContainer) GetNullable() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Nullable
}

func (e *ExampleNullableContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleNullableContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleNullableContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleNullableContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleNullableContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleNullableContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property.
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectProperty) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleObjectProperty) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleObjectProperty) GetOriginalTypeDeclaration() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.OriginalTypeDeclaration
}

func (e *ExampleObjectProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectProperty) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectType) GetProperties() []*ExampleObjectProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleObjectType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectTypeWithTypeId struct {
	TypeId TypeId             `json:"typeId" url:"typeId"`
	Object *ExampleObjectType `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectTypeWithTypeId) GetTypeId() TypeId {
	if e == nil {
		return ""
	}
	return e.TypeId
}

func (e *ExampleObjectTypeWithTypeId) GetObject() *ExampleObjectType {
	if e == nil {
		return nil
	}
	return e.Object
}

func (e *ExampleObjectTypeWithTypeId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectTypeWithTypeId) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectTypeWithTypeId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectTypeWithTypeId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectTypeWithTypeId) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleOptionalContainer struct {
	Optional  *ExampleTypeReference `json:"optional,omitempty" url:"optional,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleOptionalContainer) GetOptional() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Optional
}

func (e *ExampleOptionalContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleOptionalContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleOptionalContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleOptionalContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleOptionalContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleOptionalContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePrimitive struct {
	Type       string
	Integer    int
	Long       int64
	Uint       int
	Uint64     int64
	Float      float64
	Double     float64
	Boolean    bool
	String     *EscapedString
	Date       time.Time
	Datetime   *ExampleDatetime
	Uuid       uuid.UUID
	Base64     []byte
	BigInteger string
}

func NewExamplePrimitiveFromInteger(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "integer", Integer: value}
}

func NewExamplePrimitiveFromLong(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "long", Long: value}
}

func NewExamplePrimitiveFromUint(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uint", Uint: value}
}

func NewExamplePrimitiveFromUint64(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uint64", Uint64: value}
}

func NewExamplePrimitiveFromFloat(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "float", Float: value}
}

func NewExamplePrimitiveFromDouble(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "double", Double: value}
}

func NewExamplePrimitiveFromBoolean(value bool) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "boolean", Boolean: value}
}

func NewExamplePrimitiveFromString(value *EscapedString) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "string", String: value}
}

func NewExamplePrimitiveFromDate(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "date", Date: value}
}

func NewExamplePrimitiveFromDatetime(value *ExampleDatetime) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "datetime", Datetime: value}
}

func NewExamplePrimitiveFromUuid(value uuid.UUID) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uuid", Uuid: value}
}

func NewExamplePrimitiveFromBase64(value []byte) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "base64", Base64: value}
}

func NewExamplePrimitiveFromBigInteger(value string) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "bigInteger", BigInteger: value}
}

func (e *ExamplePrimitive) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExamplePrimitive) GetInteger() int {
	if e == nil {
		return 0
	}
	return e.Integer
}

func (e *ExamplePrimitive) GetLong() int64 {
	if e == nil {
		return 0
	}
	return e.Long
}

func (e *ExamplePrimitive) GetUint() int {
	if e == nil {
		return 0
	}
	return e.Uint
}

func (e *ExamplePrimitive) GetUint64() int64 {
	if e == nil {
		return 0
	}
	return e.Uint64
}

func (e *ExamplePrimitive) GetFloat() float64 {
	if e == nil {
		return 0
	}
	return e.Float
}

func (e *ExamplePrimitive) GetDouble() float64 {
	if e == nil {
		return 0
	}
	return e.Double
}

func (e *ExamplePrimitive) GetBoolean() bool {
	if e == nil {
		return false
	}
	return e.Boolean
}

func (e *ExamplePrimitive) GetString() *EscapedString {
	if e == nil {
		return nil
	}
	return e.String
}

func (e *ExamplePrimitive) GetDate() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Date
}

func (e *ExamplePrimitive) GetDatetime() *ExampleDatetime {
	if e == nil {
		return nil
	}
	return e.Datetime
}

func (e *ExamplePrimitive) GetUuid() uuid.UUID {
	if e == nil {
		return uuid.Nil
	}
	return e.Uuid
}

func (e *ExamplePrimitive) GetBase64() []byte {
	if e == nil {
		return nil
	}
	return e.Base64
}

func (e *ExamplePrimitive) GetBigInteger() string {
	if e == nil {
		return ""
	}
	return e.BigInteger
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "uint":
		var valueUnmarshaler struct {
			Uint int `json:"uint"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uint = valueUnmarshaler.Uint
	case "uint64":
		var valueUnmarshaler struct {
			Uint64 int64 `json:"uint64"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uint64 = valueUnmarshaler.Uint64
	case "float":
		var valueUnmarshaler struct {
			Float float64 `json:"float"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Float = valueUnmarshaler.Float
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "string":
		var valueUnmarshaler struct {
			String *EscapedString `json:"string,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.String = valueUnmarshaler.String
	case "date":
		var valueUnmarshaler struct {
			Date *internal.Date `json:"date" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date.Time()
	case "datetime":
		value := new(ExampleDatetime)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Datetime = value
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	case "base64":
		var valueUnmarshaler struct {
			Base64 []byte `json:"base64"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Base64 = valueUnmarshaler.Base64
	case "bigInteger":
		var valueUnmarshaler struct {
			BigInteger string `json:"bigInteger"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BigInteger = valueUnmarshaler.BigInteger
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    "integer",
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	case "long":
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: "long",
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	case "uint":
		var marshaler = struct {
			Type string `json:"type"`
			Uint int    `json:"uint"`
		}{
			Type: "uint",
			Uint: e.Uint,
		}
		return json.Marshal(marshaler)
	case "uint64":
		var marshaler = struct {
			Type   string `json:"type"`
			Uint64 int64  `json:"uint64"`
		}{
			Type:   "uint64",
			Uint64: e.Uint64,
		}
		return json.Marshal(marshaler)
	case "float":
		var marshaler = struct {
			Type  string  `json:"type"`
			Float float64 `json:"float"`
		}{
			Type:  "float",
			Float: e.Float,
		}
		return json.Marshal(marshaler)
	case "double":
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   "double",
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string         `json:"type"`
			String *EscapedString `json:"string,omitempty"`
		}{
			Type:   "string",
			String: e.String,
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string         `json:"type"`
			Date *internal.Date `json:"date" format:"date"`
		}{
			Type: "date",
			Date: internal.NewDate(e.Date),
		}
		return json.Marshal(marshaler)
	case "datetime":
		return internal.MarshalJSONWithExtraProperty(e.Datetime, "type", "datetime")
	case "uuid":
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: "uuid",
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	case "base64":
		var marshaler = struct {
			Type   string `json:"type"`
			Base64 []byte `json:"base64"`
		}{
			Type:   "base64",
			Base64: e.Base64,
		}
		return json.Marshal(marshaler)
	case "bigInteger":
		var marshaler = struct {
			Type       string `json:"type"`
			BigInteger string `json:"bigInteger"`
		}{
			Type:       "bigInteger",
			BigInteger: e.BigInteger,
		}
		return json.Marshal(marshaler)
	}
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitLong(int64) error
	VisitUint(int) error
	VisitUint64(int64) error
	VisitFloat(float64) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitString(*EscapedString) error
	VisitDate(time.Time) error
	VisitDatetime(*ExampleDatetime) error
	VisitUuid(uuid.UUID) error
	VisitBase64([]byte) error
	VisitBigInteger(string) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "long":
		return visitor.VisitLong(e.Long)
	case "uint":
		return visitor.VisitUint(e.Uint)
	case "uint64":
		return visitor.VisitUint64(e.Uint64)
	case "float":
		return visitor.VisitFloat(e.Float)
	case "double":
		return visitor.VisitDouble(e.Double)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	case "string":
		return visitor.VisitString(e.String)
	case "date":
		return visitor.VisitDate(e.Date)
	case "datetime":
		return visitor.VisitDatetime(e.Datetime)
	case "uuid":
		return visitor.VisitUuid(e.Uuid)
	case "base64":
		return visitor.VisitBase64(e.Base64)
	case "bigInteger":
		return visitor.VisitBigInteger(e.BigInteger)
	}
}

func (e *ExamplePrimitive) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Integer != 0 {
		fields = append(fields, "integer")
	}
	if e.Long != 0 {
		fields = append(fields, "long")
	}
	if e.Uint != 0 {
		fields = append(fields, "uint")
	}
	if e.Uint64 != 0 {
		fields = append(fields, "uint64")
	}
	if e.Float != 0 {
		fields = append(fields, "float")
	}
	if e.Double != 0 {
		fields = append(fields, "double")
	}
	if e.Boolean != false {
		fields = append(fields, "boolean")
	}
	if e.String != nil {
		fields = append(fields, "string")
	}
	if !e.Date.IsZero() {
		fields = append(fields, "date")
	}
	if e.Datetime != nil {
		fields = append(fields, "datetime")
	}
	if e.Uuid != uuid.Nil {
		fields = append(fields, "uuid")
	}
	if e.Base64 != nil {
		fields = append(fields, "base64")
	}
	if e.BigInteger != "" {
		fields = append(fields, "bigInteger")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleSetContainer struct {
	Set      []*ExampleTypeReference `json:"set,omitempty" url:"set,omitempty"`
	ItemType *TypeReference          `json:"itemType,omitempty" url:"itemType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleSetContainer) GetSet() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Set
}

func (e *ExampleSetContainer) GetItemType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ItemType
}

func (e *ExampleSetContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleSetContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleSetContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleSetContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleSetContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionType struct {
	WireDiscriminantValue *NameAndWireValue                 `json:"wireDiscriminantValue,omitempty" url:"wireDiscriminantValue,omitempty"`
	Shape                 *ExampleSingleUnionTypeProperties `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleSingleUnionType) GetWireDiscriminantValue() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.WireDiscriminantValue
}

func (e *ExampleSingleUnionType) GetShape() *ExampleSingleUnionTypeProperties {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleSingleUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleSingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleSingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleSingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleSingleUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleObjectTypeWithTypeId
	SingleProperty         *ExampleTypeReference
	NoProperties           interface{}
}

func NewExampleSingleUnionTypePropertiesFromSamePropertiesAsObject(value *ExampleObjectTypeWithTypeId) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewExampleSingleUnionTypePropertiesFromSingleProperty(value *ExampleTypeReference) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "singleProperty", SingleProperty: value}
}

func NewExampleSingleUnionTypePropertiesFromNoProperties(value interface{}) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "noProperties", NoProperties: value}
}

func (e *ExampleSingleUnionTypeProperties) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleSingleUnionTypeProperties) GetSamePropertiesAsObject() *ExampleObjectTypeWithTypeId {
	if e == nil {
		return nil
	}
	return e.SamePropertiesAsObject
}

func (e *ExampleSingleUnionTypeProperties) GetSingleProperty() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.SingleProperty
}

func (e *ExampleSingleUnionTypeProperties) GetNoProperties() interface{} {
	if e == nil {
		return nil
	}
	return e.NoProperties
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleObjectTypeWithTypeId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return internal.MarshalJSONWithExtraProperty(e.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	case "singleProperty":
		return internal.MarshalJSONWithExtraProperty(e.SingleProperty, "type", "singleProperty")
	case "noProperties":
		var marshaler = struct {
			Type         string      `json:"type"`
			NoProperties interface{} `json:"noProperties,omitempty"`
		}{
			Type:         "noProperties",
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleObjectTypeWithTypeId) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(interface{}) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(e.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(e.NoProperties)
	}
}

func (e *ExampleSingleUnionTypeProperties) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if e.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if e.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleType struct {
	JsonExample interface{}       `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *Name             `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleType) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleType) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleType) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReference struct {
	JsonExample interface{}                `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Shape       *ExampleTypeReferenceShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleTypeReference) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleTypeReference) GetShape() *ExampleTypeReferenceShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleTypeReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleTypeReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleTypeReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleTypeReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleTypeReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   interface{}
	Named     *ExampleNamedType
}

func NewExampleTypeReferenceShapeFromPrimitive(value *ExamplePrimitive) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "primitive", Primitive: value}
}

func NewExampleTypeReferenceShapeFromContainer(value *ExampleContainer) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "container", Container: value}
}

func NewExampleTypeReferenceShapeFromUnknown(value interface{}) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "unknown", Unknown: value}
}

func NewExampleTypeReferenceShapeFromNamed(value *ExampleNamedType) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "named", Named: value}
}

func (e *ExampleTypeReferenceShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeReferenceShape) GetPrimitive() *ExamplePrimitive {
	if e == nil {
		return nil
	}
	return e.Primitive
}

func (e *ExampleTypeReferenceShape) GetContainer() *ExampleContainer {
	if e == nil {
		return nil
	}
	return e.Container
}

func (e *ExampleTypeReferenceShape) GetUnknown() interface{} {
	if e == nil {
		return nil
	}
	return e.Unknown
}

func (e *ExampleTypeReferenceShape) GetNamed() *ExampleNamedType {
	if e == nil {
		return nil
	}
	return e.Named
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown interface{} `json:"unknown,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	case "container":
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(e.Named, "type", "named")
	}
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(interface{}) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		return visitor.VisitPrimitive(e.Primitive)
	case "container":
		return visitor.VisitContainer(e.Container)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	case "named":
		return visitor.VisitNamed(e.Named)
	}
}

func (e *ExampleTypeReferenceShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if e.Container != nil {
		fields = append(fields, "container")
	}
	if e.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if e.Named != nil {
		fields = append(fields, "named")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleTypeShape struct {
	Type                 string
	Alias                *ExampleAliasType
	Enum                 *ExampleEnumType
	Object               *ExampleObjectType
	Union                *ExampleUnionType
	UndiscriminatedUnion *ExampleUndiscriminatedUnionType
}

func NewExampleTypeShapeFromAlias(value *ExampleAliasType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "alias", Alias: value}
}

func NewExampleTypeShapeFromEnum(value *ExampleEnumType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "enum", Enum: value}
}

func NewExampleTypeShapeFromObject(value *ExampleObjectType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "object", Object: value}
}

func NewExampleTypeShapeFromUnion(value *ExampleUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "union", Union: value}
}

func NewExampleTypeShapeFromUndiscriminatedUnion(value *ExampleUndiscriminatedUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (e *ExampleTypeShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeShape) GetAlias() *ExampleAliasType {
	if e == nil {
		return nil
	}
	return e.Alias
}

func (e *ExampleTypeShape) GetEnum() *ExampleEnumType {
	if e == nil {
		return nil
	}
	return e.Enum
}

func (e *ExampleTypeShape) GetObject() *ExampleObjectType {
	if e == nil {
		return nil
	}
	return e.Object
}

func (e *ExampleTypeShape) GetUnion() *ExampleUnionType {
	if e == nil {
		return nil
	}
	return e.Union
}

func (e *ExampleTypeShape) GetUndiscriminatedUnion() *ExampleUndiscriminatedUnionType {
	if e == nil {
		return nil
	}
	return e.UndiscriminatedUnion
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	case "undiscriminatedUnion":
		value := new(ExampleUndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UndiscriminatedUnion = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return internal.MarshalJSONWithExtraProperty(e.Alias, "type", "alias")
	case "enum":
		return internal.MarshalJSONWithExtraProperty(e.Enum, "type", "enum")
	case "object":
		return internal.MarshalJSONWithExtraProperty(e.Object, "type", "object")
	case "union":
		return internal.MarshalJSONWithExtraProperty(e.Union, "type", "union")
	case "undiscriminatedUnion":
		return internal.MarshalJSONWithExtraProperty(e.UndiscriminatedUnion, "type", "undiscriminatedUnion")
	}
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleUnionType) error
	VisitUndiscriminatedUnion(*ExampleUndiscriminatedUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return visitor.VisitAlias(e.Alias)
	case "enum":
		return visitor.VisitEnum(e.Enum)
	case "object":
		return visitor.VisitObject(e.Object)
	case "union":
		return visitor.VisitUnion(e.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(e.UndiscriminatedUnion)
	}
}

func (e *ExampleTypeShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Alias != nil {
		fields = append(fields, "alias")
	}
	if e.Enum != nil {
		fields = append(fields, "enum")
	}
	if e.Object != nil {
		fields = append(fields, "object")
	}
	if e.Union != nil {
		fields = append(fields, "union")
	}
	if e.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleUndiscriminatedUnionType struct {
	// The zero-based index of the undiscriminated union variant.
	// For the following undiscriminated union
	// ```
	// MyUnion:
	//
	//	discriminated: false
	//	union:
	//	  - string
	//	  - integer
	//
	// ```
	// a string example would have an index 0 and an integer example
	// would have an index 1.
	Index           int                   `json:"index" url:"index"`
	SingleUnionType *ExampleTypeReference `json:"singleUnionType,omitempty" url:"singleUnionType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleUndiscriminatedUnionType) GetIndex() int {
	if e == nil {
		return 0
	}
	return e.Index
}

func (e *ExampleUndiscriminatedUnionType) GetSingleUnionType() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.SingleUnionType
}

func (e *ExampleUndiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleUndiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleUndiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleUndiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleUndiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleUnionType struct {
	Discriminant    *NameAndWireValue       `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	SingleUnionType *ExampleSingleUnionType `json:"singleUnionType,omitempty" url:"singleUnionType,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleUnionType) GetDiscriminant() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Discriminant
}

func (e *ExampleUnionType) GetSingleUnionType() *ExampleSingleUnionType {
	if e == nil {
		return nil
	}
	return e.SingleUnionType
}

func (e *ExampleUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FloatType struct {
	extraProperties map[string]interface{}
}

func (f *FloatType) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FloatType) UnmarshalJSON(data []byte) error {
	type unmarshaler FloatType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FloatType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FloatType) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IntegerType struct {
	Default    *int                    `json:"default,omitempty" url:"default,omitempty"`
	Validation *IntegerValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	extraProperties map[string]interface{}
}

func (i *IntegerType) GetDefault() *int {
	if i == nil {
		return nil
	}
	return i.Default
}

func (i *IntegerType) GetValidation() *IntegerValidationRules {
	if i == nil {
		return nil
	}
	return i.Validation
}

func (i *IntegerType) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegerType) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegerType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegerType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntegerType) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntegerValidationRules struct {
	Min          *int  `json:"min,omitempty" url:"min,omitempty"`
	Max          *int  `json:"max,omitempty" url:"max,omitempty"`
	ExclusiveMin *bool `json:"exclusiveMin,omitempty" url:"exclusiveMin,omitempty"`
	ExclusiveMax *bool `json:"exclusiveMax,omitempty" url:"exclusiveMax,omitempty"`
	MultipleOf   *int  `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`

	extraProperties map[string]interface{}
}

func (i *IntegerValidationRules) GetMin() *int {
	if i == nil {
		return nil
	}
	return i.Min
}

func (i *IntegerValidationRules) GetMax() *int {
	if i == nil {
		return nil
	}
	return i.Max
}

func (i *IntegerValidationRules) GetExclusiveMin() *bool {
	if i == nil {
		return nil
	}
	return i.ExclusiveMin
}

func (i *IntegerValidationRules) GetExclusiveMax() *bool {
	if i == nil {
		return nil
	}
	return i.ExclusiveMax
}

func (i *IntegerValidationRules) GetMultipleOf() *int {
	if i == nil {
		return nil
	}
	return i.MultipleOf
}

func (i *IntegerValidationRules) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegerValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegerValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegerValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntegerValidationRules) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonEncoding struct {
	extraProperties map[string]interface{}
}

func (j *JsonEncoding) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonEncoding) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonEncoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonEncoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonEncoding) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type Literal struct {
	Type    string
	String  string
	Boolean bool
}

func NewLiteralFromString(value string) *Literal {
	return &Literal{Type: "string", String: value}
}

func NewLiteralFromBoolean(value bool) *Literal {
	return &Literal{Type: "boolean", Boolean: value}
}

func (l *Literal) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *Literal) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *Literal) GetBoolean() bool {
	if l == nil {
		return false
	}
	return l.Boolean
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		return visitor.VisitString(l.String)
	case "boolean":
		return visitor.VisitBoolean(l.Boolean)
	}
}

func (l *Literal) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.String != "" {
		fields = append(fields, "string")
	}
	if l.Boolean != false {
		fields = append(fields, "boolean")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

type LongType struct {
	Default *int64 `json:"default,omitempty" url:"default,omitempty"`

	extraProperties map[string]interface{}
}

func (l *LongType) GetDefault() *int64 {
	if l == nil {
		return nil
	}
	return l.Default
}

func (l *LongType) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LongType) UnmarshalJSON(data []byte) error {
	type unmarshaler LongType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LongType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *LongType) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MapType struct {
	KeyType   *TypeReference `json:"keyType,omitempty" url:"keyType,omitempty"`
	ValueType *TypeReference `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetKeyType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.KeyType
}

func (m *MapType) GetValueType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.ValueType
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MapType) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// A reference to a named type. For backwards compatibility, this type must be fully compatible
// with the DeclaredTypeName.
type NamedType struct {
	TypeId       TypeId            `json:"typeId" url:"typeId"`
	FernFilepath *FernFilepath     `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name             `json:"name,omitempty" url:"name,omitempty"`
	Default      *NamedTypeDefault `json:"default,omitempty" url:"default,omitempty"`
	// Use the inline property on the TypeDeclaration instead.
	Inline *bool `json:"inline,omitempty" url:"inline,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NamedType) GetTypeId() TypeId {
	if n == nil {
		return ""
	}
	return n.TypeId
}

func (n *NamedType) GetFernFilepath() *FernFilepath {
	if n == nil {
		return nil
	}
	return n.FernFilepath
}

func (n *NamedType) GetName() *Name {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NamedType) GetDefault() *NamedTypeDefault {
	if n == nil {
		return nil
	}
	return n.Default
}

func (n *NamedType) GetInline() *bool {
	if n == nil {
		return nil
	}
	return n.Inline
}

func (n *NamedType) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NamedType) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NamedTypeDefault struct {
	Type string
	Enum *EnumValue
}

func NewNamedTypeDefaultFromEnum(value *EnumValue) *NamedTypeDefault {
	return &NamedTypeDefault{Type: "enum", Enum: value}
}

func (n *NamedTypeDefault) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NamedTypeDefault) GetEnum() *EnumValue {
	if n == nil {
		return nil
	}
	return n.Enum
}

func (n *NamedTypeDefault) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "enum":
		value := new(EnumValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Enum = value
	}
	return nil
}

func (n NamedTypeDefault) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	switch n.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "enum":
		return internal.MarshalJSONWithExtraProperty(n.Enum, "type", "enum")
	}
}

type NamedTypeDefaultVisitor interface {
	VisitEnum(*EnumValue) error
}

func (n *NamedTypeDefault) Accept(visitor NamedTypeDefaultVisitor) error {
	switch n.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "enum":
		return visitor.VisitEnum(n.Enum)
	}
}

func (n *NamedTypeDefault) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Enum != nil {
		fields = append(fields, "enum")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

type ObjectProperty struct {
	Docs           *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Availability   *Availability         `json:"availability,omitempty" url:"availability,omitempty"`
	Name           *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	ValueType      *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`
	PropertyAccess *ObjectPropertyAccess `json:"propertyAccess,omitempty" url:"propertyAccess,omitempty"`

	extraProperties map[string]interface{}
}

func (o *ObjectProperty) GetDocs() *string {
	if o == nil {
		return nil
	}
	return o.Docs
}

func (o *ObjectProperty) GetAvailability() *Availability {
	if o == nil {
		return nil
	}
	return o.Availability
}

func (o *ObjectProperty) GetName() *NameAndWireValue {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ObjectProperty) GetValueType() *TypeReference {
	if o == nil {
		return nil
	}
	return o.ValueType
}

func (o *ObjectProperty) GetPropertyAccess() *ObjectPropertyAccess {
	if o == nil {
		return nil
	}
	return o.PropertyAccess
}

func (o *ObjectProperty) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectProperty) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectPropertyAccess string

const (
	ObjectPropertyAccessReadOnly  ObjectPropertyAccess = "READ_ONLY"
	ObjectPropertyAccessWriteOnly ObjectPropertyAccess = "WRITE_ONLY"
)

func NewObjectPropertyAccessFromString(s string) (ObjectPropertyAccess, error) {
	switch s {
	case "READ_ONLY":
		return ObjectPropertyAccessReadOnly, nil
	case "WRITE_ONLY":
		return ObjectPropertyAccessWriteOnly, nil
	}
	var t ObjectPropertyAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o ObjectPropertyAccess) Ptr() *ObjectPropertyAccess {
	return &o
}

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*ObjectProperty   `json:"properties,omitempty" url:"properties,omitempty"`
	// A list of properties that all the parents of this object have.
	ExtendedProperties []*ObjectProperty `json:"extendedProperties,omitempty" url:"extendedProperties,omitempty"`
	// Whether to allow extra properties on the object.
	ExtraProperties bool `json:"extra-properties" url:"extra-properties"`

	extraProperties map[string]interface{}
}

func (o *ObjectTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if o == nil {
		return nil
	}
	return o.Extends
}

func (o *ObjectTypeDeclaration) GetProperties() []*ObjectProperty {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *ObjectTypeDeclaration) GetExtendedProperties() []*ObjectProperty {
	if o == nil {
		return nil
	}
	return o.ExtendedProperties
}

func (o *ObjectTypeDeclaration) GetExtraProperties() bool {
	if o == nil {
		return false
	}
	return o.ExtraProperties
}

func (o *ObjectTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveType struct {
	V1 PrimitiveTypeV1  `json:"v1" url:"v1"`
	V2 *PrimitiveTypeV2 `json:"v2,omitempty" url:"v2,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PrimitiveType) GetV1() PrimitiveTypeV1 {
	if p == nil {
		return ""
	}
	return p.V1
}

func (p *PrimitiveType) GetV2() *PrimitiveTypeV2 {
	if p == nil {
		return nil
	}
	return p.V2
}

func (p *PrimitiveType) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrimitiveType) UnmarshalJSON(data []byte) error {
	type unmarshaler PrimitiveType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrimitiveType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PrimitiveType) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PrimitiveTypeV2 struct {
	Type       string
	Integer    *IntegerType
	Long       *LongType
	Uint       *UintType
	Uint64     *Uint64Type
	Float      *FloatType
	Double     *DoubleType
	Boolean    *BooleanType
	String     *StringType
	Date       *DateType
	DateTime   *DateTimeType
	Uuid       *UuidType
	Base64     *Base64Type
	BigInteger *BigIntegerType
}

func NewPrimitiveTypeV2FromInteger(value *IntegerType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "integer", Integer: value}
}

func NewPrimitiveTypeV2FromLong(value *LongType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "long", Long: value}
}

func NewPrimitiveTypeV2FromUint(value *UintType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "uint", Uint: value}
}

func NewPrimitiveTypeV2FromUint64(value *Uint64Type) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "uint64", Uint64: value}
}

func NewPrimitiveTypeV2FromFloat(value *FloatType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "float", Float: value}
}

func NewPrimitiveTypeV2FromDouble(value *DoubleType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "double", Double: value}
}

func NewPrimitiveTypeV2FromBoolean(value *BooleanType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "boolean", Boolean: value}
}

func NewPrimitiveTypeV2FromString(value *StringType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "string", String: value}
}

func NewPrimitiveTypeV2FromDate(value *DateType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "date", Date: value}
}

func NewPrimitiveTypeV2FromDateTime(value *DateTimeType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "dateTime", DateTime: value}
}

func NewPrimitiveTypeV2FromUuid(value *UuidType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "uuid", Uuid: value}
}

func NewPrimitiveTypeV2FromBase64(value *Base64Type) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "base64", Base64: value}
}

func NewPrimitiveTypeV2FromBigInteger(value *BigIntegerType) *PrimitiveTypeV2 {
	return &PrimitiveTypeV2{Type: "bigInteger", BigInteger: value}
}

func (p *PrimitiveTypeV2) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PrimitiveTypeV2) GetInteger() *IntegerType {
	if p == nil {
		return nil
	}
	return p.Integer
}

func (p *PrimitiveTypeV2) GetLong() *LongType {
	if p == nil {
		return nil
	}
	return p.Long
}

func (p *PrimitiveTypeV2) GetUint() *UintType {
	if p == nil {
		return nil
	}
	return p.Uint
}

func (p *PrimitiveTypeV2) GetUint64() *Uint64Type {
	if p == nil {
		return nil
	}
	return p.Uint64
}

func (p *PrimitiveTypeV2) GetFloat() *FloatType {
	if p == nil {
		return nil
	}
	return p.Float
}

func (p *PrimitiveTypeV2) GetDouble() *DoubleType {
	if p == nil {
		return nil
	}
	return p.Double
}

func (p *PrimitiveTypeV2) GetBoolean() *BooleanType {
	if p == nil {
		return nil
	}
	return p.Boolean
}

func (p *PrimitiveTypeV2) GetString() *StringType {
	if p == nil {
		return nil
	}
	return p.String
}

func (p *PrimitiveTypeV2) GetDate() *DateType {
	if p == nil {
		return nil
	}
	return p.Date
}

func (p *PrimitiveTypeV2) GetDateTime() *DateTimeType {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PrimitiveTypeV2) GetUuid() *UuidType {
	if p == nil {
		return nil
	}
	return p.Uuid
}

func (p *PrimitiveTypeV2) GetBase64() *Base64Type {
	if p == nil {
		return nil
	}
	return p.Base64
}

func (p *PrimitiveTypeV2) GetBigInteger() *BigIntegerType {
	if p == nil {
		return nil
	}
	return p.BigInteger
}

func (p *PrimitiveTypeV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "integer":
		value := new(IntegerType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Integer = value
	case "long":
		value := new(LongType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Long = value
	case "uint":
		value := new(UintType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uint = value
	case "uint64":
		value := new(Uint64Type)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uint64 = value
	case "float":
		value := new(FloatType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Float = value
	case "double":
		value := new(DoubleType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Double = value
	case "boolean":
		value := new(BooleanType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Boolean = value
	case "string":
		value := new(StringType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.String = value
	case "date":
		value := new(DateType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Date = value
	case "dateTime":
		value := new(DateTimeType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.DateTime = value
	case "uuid":
		value := new(UuidType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uuid = value
	case "base64":
		value := new(Base64Type)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Base64 = value
	case "bigInteger":
		value := new(BigIntegerType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BigInteger = value
	}
	return nil
}

func (p PrimitiveTypeV2) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "integer":
		return internal.MarshalJSONWithExtraProperty(p.Integer, "type", "integer")
	case "long":
		return internal.MarshalJSONWithExtraProperty(p.Long, "type", "long")
	case "uint":
		return internal.MarshalJSONWithExtraProperty(p.Uint, "type", "uint")
	case "uint64":
		return internal.MarshalJSONWithExtraProperty(p.Uint64, "type", "uint64")
	case "float":
		return internal.MarshalJSONWithExtraProperty(p.Float, "type", "float")
	case "double":
		return internal.MarshalJSONWithExtraProperty(p.Double, "type", "double")
	case "boolean":
		return internal.MarshalJSONWithExtraProperty(p.Boolean, "type", "boolean")
	case "string":
		return internal.MarshalJSONWithExtraProperty(p.String, "type", "string")
	case "date":
		return internal.MarshalJSONWithExtraProperty(p.Date, "type", "date")
	case "dateTime":
		return internal.MarshalJSONWithExtraProperty(p.DateTime, "type", "dateTime")
	case "uuid":
		return internal.MarshalJSONWithExtraProperty(p.Uuid, "type", "uuid")
	case "base64":
		return internal.MarshalJSONWithExtraProperty(p.Base64, "type", "base64")
	case "bigInteger":
		return internal.MarshalJSONWithExtraProperty(p.BigInteger, "type", "bigInteger")
	}
}

type PrimitiveTypeV2Visitor interface {
	VisitInteger(*IntegerType) error
	VisitLong(*LongType) error
	VisitUint(*UintType) error
	VisitUint64(*Uint64Type) error
	VisitFloat(*FloatType) error
	VisitDouble(*DoubleType) error
	VisitBoolean(*BooleanType) error
	VisitString(*StringType) error
	VisitDate(*DateType) error
	VisitDateTime(*DateTimeType) error
	VisitUuid(*UuidType) error
	VisitBase64(*Base64Type) error
	VisitBigInteger(*BigIntegerType) error
}

func (p *PrimitiveTypeV2) Accept(visitor PrimitiveTypeV2Visitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "integer":
		return visitor.VisitInteger(p.Integer)
	case "long":
		return visitor.VisitLong(p.Long)
	case "uint":
		return visitor.VisitUint(p.Uint)
	case "uint64":
		return visitor.VisitUint64(p.Uint64)
	case "float":
		return visitor.VisitFloat(p.Float)
	case "double":
		return visitor.VisitDouble(p.Double)
	case "boolean":
		return visitor.VisitBoolean(p.Boolean)
	case "string":
		return visitor.VisitString(p.String)
	case "date":
		return visitor.VisitDate(p.Date)
	case "dateTime":
		return visitor.VisitDateTime(p.DateTime)
	case "uuid":
		return visitor.VisitUuid(p.Uuid)
	case "base64":
		return visitor.VisitBase64(p.Base64)
	case "bigInteger":
		return visitor.VisitBigInteger(p.BigInteger)
	}
}

func (p *PrimitiveTypeV2) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Integer != nil {
		fields = append(fields, "integer")
	}
	if p.Long != nil {
		fields = append(fields, "long")
	}
	if p.Uint != nil {
		fields = append(fields, "uint")
	}
	if p.Uint64 != nil {
		fields = append(fields, "uint64")
	}
	if p.Float != nil {
		fields = append(fields, "float")
	}
	if p.Double != nil {
		fields = append(fields, "double")
	}
	if p.Boolean != nil {
		fields = append(fields, "boolean")
	}
	if p.String != nil {
		fields = append(fields, "string")
	}
	if p.Date != nil {
		fields = append(fields, "date")
	}
	if p.DateTime != nil {
		fields = append(fields, "dateTime")
	}
	if p.Uuid != nil {
		fields = append(fields, "uuid")
	}
	if p.Base64 != nil {
		fields = append(fields, "base64")
	}
	if p.BigInteger != nil {
		fields = append(fields, "bigInteger")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type ProtoEncoding struct {
	extraProperties map[string]interface{}
}

func (p *ProtoEncoding) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtoEncoding) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtoEncoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtoEncoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtoEncoding) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape ShapeType         `json:"shape" url:"shape"`

	extraProperties map[string]interface{}
}

func (r *ResolvedNamedType) GetName() *DeclaredTypeName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *ResolvedNamedType) GetShape() ShapeType {
	if r == nil {
		return ""
	}
	return r.Shape
}

func (r *ResolvedNamedType) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolvedNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolvedNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolvedNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResolvedNamedType) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive *PrimitiveType
	Unknown   interface{}
}

func NewResolvedTypeReferenceFromContainer(value *ContainerType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "container", Container: value}
}

func NewResolvedTypeReferenceFromNamed(value *ResolvedNamedType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "named", Named: value}
}

func NewResolvedTypeReferenceFromPrimitive(value *PrimitiveType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "primitive", Primitive: value}
}

func NewResolvedTypeReferenceFromUnknown(value interface{}) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "unknown", Unknown: value}
}

func (r *ResolvedTypeReference) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResolvedTypeReference) GetContainer() *ContainerType {
	if r == nil {
		return nil
	}
	return r.Container
}

func (r *ResolvedTypeReference) GetNamed() *ResolvedNamedType {
	if r == nil {
		return nil
	}
	return r.Named
}

func (r *ResolvedTypeReference) GetPrimitive() *PrimitiveType {
	if r == nil {
		return nil
	}
	return r.Primitive
}

func (r *ResolvedTypeReference) GetUnknown() interface{} {
	if r == nil {
		return nil
	}
	return r.Unknown
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", r)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(r.Named, "_type", "named")
	case "primitive":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Primitive *PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(*PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		return visitor.VisitContainer(r.Container)
	case "named":
		return visitor.VisitNamed(r.Named)
	case "primitive":
		return visitor.VisitPrimitive(r.Primitive)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

func (r *ResolvedTypeReference) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Container != nil {
		fields = append(fields, "container")
	}
	if r.Named != nil {
		fields = append(fields, "named")
	}
	if r.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if r.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty" url:"docs,omitempty"`
	DiscriminantValue *NameAndWireValue          `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Shape             *SingleUnionTypeProperties `json:"shape,omitempty" url:"shape,omitempty"`
	DisplayName       *string                    `json:"displayName,omitempty" url:"displayName,omitempty"`
	Availability      *Availability              `json:"availability,omitempty" url:"availability,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionType) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleUnionType) GetDiscriminantValue() *NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleUnionType) GetShape() *SingleUnionTypeProperties {
	if s == nil {
		return nil
	}
	return s.Shape
}

func (s *SingleUnionType) GetDisplayName() *string {
	if s == nil {
		return nil
	}
	return s.DisplayName
}

func (s *SingleUnionType) GetAvailability() *Availability {
	if s == nil {
		return nil
	}
	return s.Availability
}

func (s *SingleUnionType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionType) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           interface{}
}

func NewSingleUnionTypePropertiesFromSamePropertiesAsObject(value *DeclaredTypeName) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleUnionTypePropertiesFromSingleProperty(value *SingleUnionTypeProperty) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "singleProperty", SingleProperty: value}
}

func NewSingleUnionTypePropertiesFromNoProperties(value interface{}) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "noProperties", NoProperties: value}
}

func (s *SingleUnionTypeProperties) GetPropertiesType() string {
	if s == nil {
		return ""
	}
	return s.PropertiesType
}

func (s *SingleUnionTypeProperties) GetSamePropertiesAsObject() *DeclaredTypeName {
	if s == nil {
		return nil
	}
	return s.SamePropertiesAsObject
}

func (s *SingleUnionTypeProperties) GetSingleProperty() *SingleUnionTypeProperty {
	if s == nil {
		return nil
	}
	return s.SingleProperty
}

func (s *SingleUnionTypeProperties) GetNoProperties() interface{} {
	if s == nil {
		return nil
	}
	return s.NoProperties
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	if unmarshaler.PropertiesType == "" {
		return fmt.Errorf("%T did not include discriminant _type", s)
	}
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.PropertiesType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return internal.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "_type", "samePropertiesAsObject")
	case "singleProperty":
		return internal.MarshalJSONWithExtraProperty(s.SingleProperty, "_type", "singleProperty")
	case "noProperties":
		var marshaler = struct {
			PropertiesType string      `json:"_type"`
			NoProperties   interface{} `json:"noProperties,omitempty"`
		}{
			PropertiesType: "noProperties",
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(interface{}) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	switch s.PropertiesType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

func (s *SingleUnionTypeProperties) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if s.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if s.PropertiesType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.PropertiesType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.PropertiesType != "" {
		field := fields[0]
		if s.PropertiesType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.PropertiesType,
				s,
			)
		}
	}
	return nil
}

type SingleUnionTypeProperty struct {
	Name *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	Type *TypeReference    `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionTypeProperty) GetName() *NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleUnionTypeProperty) GetType() *TypeReference {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SingleUnionTypeProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionTypeProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionTypeProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionTypeProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionTypeProperty) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The original source of the declared type (e.g. a `.proto` file).
type Source struct {
	Type  string
	Proto *ProtobufType
}

func NewSourceFromProto(value *ProtobufType) *Source {
	return &Source{Type: "proto", Proto: value}
}

func (s *Source) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Source) GetProto() *ProtobufType {
	if s == nil {
		return nil
	}
	return s.Proto
}

func (s *Source) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "proto":
		var valueUnmarshaler struct {
			Proto *ProtobufType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.Proto = valueUnmarshaler.Proto
	}
	return nil
}

func (s Source) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "proto":
		var marshaler = struct {
			Type  string        `json:"type"`
			Proto *ProtobufType `json:"value,omitempty"`
		}{
			Type:  "proto",
			Proto: s.Proto,
		}
		return json.Marshal(marshaler)
	}
}

type SourceVisitor interface {
	VisitProto(*ProtobufType) error
}

func (s *Source) Accept(visitor SourceVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "proto":
		return visitor.VisitProto(s.Proto)
	}
}

func (s *Source) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Proto != nil {
		fields = append(fields, "proto")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type StringType struct {
	Default    *string                `json:"default,omitempty" url:"default,omitempty"`
	Validation *StringValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	extraProperties map[string]interface{}
}

func (s *StringType) GetDefault() *string {
	if s == nil {
		return nil
	}
	return s.Default
}

func (s *StringType) GetValidation() *StringValidationRules {
	if s == nil {
		return nil
	}
	return s.Validation
}

func (s *StringType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringType) UnmarshalJSON(data []byte) error {
	type unmarshaler StringType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StringType) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StringValidationRules struct {
	Format    *string `json:"format,omitempty" url:"format,omitempty"`
	Pattern   *string `json:"pattern,omitempty" url:"pattern,omitempty"`
	MinLength *int    `json:"minLength,omitempty" url:"minLength,omitempty"`
	MaxLength *int    `json:"maxLength,omitempty" url:"maxLength,omitempty"`

	extraProperties map[string]interface{}
}

func (s *StringValidationRules) GetFormat() *string {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *StringValidationRules) GetPattern() *string {
	if s == nil {
		return nil
	}
	return s.Pattern
}

func (s *StringValidationRules) GetMinLength() *int {
	if s == nil {
		return nil
	}
	return s.MinLength
}

func (s *StringValidationRules) GetMaxLength() *int {
	if s == nil {
		return nil
	}
	return s.MaxLength
}

func (s *StringValidationRules) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler StringValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StringValidationRules) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Type) GetAlias() *AliasTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Alias
}

func (t *Type) GetEnum() *EnumTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Enum
}

func (t *Type) GetObject() *ObjectTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *Type) GetUnion() *UnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Union
}

func (t *Type) GetUndiscriminatedUnion() *UndiscriminatedUnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.UndiscriminatedUnion
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return internal.MarshalJSONWithExtraProperty(t.Alias, "_type", "alias")
	case "enum":
		return internal.MarshalJSONWithExtraProperty(t.Enum, "_type", "enum")
	case "object":
		return internal.MarshalJSONWithExtraProperty(t.Object, "_type", "object")
	case "union":
		return internal.MarshalJSONWithExtraProperty(t.Union, "_type", "union")
	case "undiscriminatedUnion":
		return internal.MarshalJSONWithExtraProperty(t.UndiscriminatedUnion, "_type", "undiscriminatedUnion")
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return visitor.VisitAlias(t.Alias)
	case "enum":
		return visitor.VisitEnum(t.Enum)
	case "object":
		return visitor.VisitObject(t.Object)
	case "union":
		return visitor.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}

func (t *Type) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Alias != nil {
		fields = append(fields, "alias")
	}
	if t.Enum != nil {
		fields = append(fields, "enum")
	}
	if t.Object != nil {
		fields = append(fields, "object")
	}
	if t.Union != nil {
		fields = append(fields, "union")
	}
	if t.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// A type, which is a name and a shape
type TypeDeclaration struct {
	Docs                  *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability          *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name                  *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape                 *Type             `json:"shape,omitempty" url:"shape,omitempty"`
	AutogeneratedExamples []*ExampleType    `json:"autogeneratedExamples,omitempty" url:"autogeneratedExamples,omitempty"`
	UserProvidedExamples  []*ExampleType    `json:"userProvidedExamples,omitempty" url:"userProvidedExamples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []TypeId  `json:"referencedTypes,omitempty" url:"referencedTypes,omitempty"`
	Encoding        *Encoding `json:"encoding,omitempty" url:"encoding,omitempty"`
	Source          *Source   `json:"source,omitempty" url:"source,omitempty"`
	// Whether to try and inline the type declaration
	Inline *bool `json:"inline,omitempty" url:"inline,omitempty"`

	extraProperties map[string]interface{}
}

func (t *TypeDeclaration) GetDocs() *string {
	if t == nil {
		return nil
	}
	return t.Docs
}

func (t *TypeDeclaration) GetAvailability() *Availability {
	if t == nil {
		return nil
	}
	return t.Availability
}

func (t *TypeDeclaration) GetName() *DeclaredTypeName {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TypeDeclaration) GetShape() *Type {
	if t == nil {
		return nil
	}
	return t.Shape
}

func (t *TypeDeclaration) GetAutogeneratedExamples() []*ExampleType {
	if t == nil {
		return nil
	}
	return t.AutogeneratedExamples
}

func (t *TypeDeclaration) GetUserProvidedExamples() []*ExampleType {
	if t == nil {
		return nil
	}
	return t.UserProvidedExamples
}

func (t *TypeDeclaration) GetReferencedTypes() []TypeId {
	if t == nil {
		return nil
	}
	return t.ReferencedTypes
}

func (t *TypeDeclaration) GetEncoding() *Encoding {
	if t == nil {
		return nil
	}
	return t.Encoding
}

func (t *TypeDeclaration) GetSource() *Source {
	if t == nil {
		return nil
	}
	return t.Source
}

func (t *TypeDeclaration) GetInline() *bool {
	if t == nil {
		return nil
	}
	return t.Inline
}

func (t *TypeDeclaration) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler TypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *NamedType
	Primitive *PrimitiveType
	Unknown   interface{}
}

func NewTypeReferenceFromContainer(value *ContainerType) *TypeReference {
	return &TypeReference{Type: "container", Container: value}
}

func NewTypeReferenceFromNamed(value *NamedType) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromPrimitive(value *PrimitiveType) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromUnknown(value interface{}) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TypeReference) GetContainer() *ContainerType {
	if t == nil {
		return nil
	}
	return t.Container
}

func (t *TypeReference) GetNamed() *NamedType {
	if t == nil {
		return nil
	}
	return t.Named
}

func (t *TypeReference) GetPrimitive() *PrimitiveType {
	if t == nil {
		return nil
	}
	return t.Primitive
}

func (t *TypeReference) GetUnknown() interface{} {
	if t == nil {
		return nil
	}
	return t.Unknown
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(NamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(t.Named, "_type", "named")
	case "primitive":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Primitive *PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*NamedType) error
	VisitPrimitive(*PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		return visitor.VisitContainer(t.Container)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

func (t *TypeReference) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Container != nil {
		fields = append(fields, "container")
	}
	if t.Named != nil {
		fields = append(fields, "named")
	}
	if t.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if t.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type Uint64Type struct {
	extraProperties map[string]interface{}
}

func (u *Uint64Type) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Uint64Type) UnmarshalJSON(data []byte) error {
	type unmarshaler Uint64Type
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Uint64Type(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *Uint64Type) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UintType struct {
	extraProperties map[string]interface{}
}

func (u *UintType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UintType) UnmarshalJSON(data []byte) error {
	type unmarshaler UintType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UintType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UintType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Type *TypeReference `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionMember) GetDocs() *string {
	if u == nil {
		return nil
	}
	return u.Docs
}

func (u *UndiscriminatedUnionMember) GetType() *TypeReference {
	if u == nil {
		return nil
	}
	return u.Type
}

func (u *UndiscriminatedUnionMember) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionMember) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionMember(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionMember) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members,omitempty" url:"members,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionTypeDeclaration) GetMembers() []*UndiscriminatedUnionMember {
	if u == nil {
		return nil
	}
	return u.Members
}

func (u *UndiscriminatedUnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnionTypeDeclaration struct {
	Discriminant *NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Types          []*SingleUnionType  `json:"types,omitempty" url:"types,omitempty"`
	BaseProperties []*ObjectProperty   `json:"baseProperties,omitempty" url:"baseProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UnionTypeDeclaration) GetDiscriminant() *NameAndWireValue {
	if u == nil {
		return nil
	}
	return u.Discriminant
}

func (u *UnionTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if u == nil {
		return nil
	}
	return u.Extends
}

func (u *UnionTypeDeclaration) GetTypes() []*SingleUnionType {
	if u == nil {
		return nil
	}
	return u.Types
}

func (u *UnionTypeDeclaration) GetBaseProperties() []*ObjectProperty {
	if u == nil {
		return nil
	}
	return u.BaseProperties
}

func (u *UnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UuidType struct {
	extraProperties map[string]interface{}
}

func (u *UuidType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UuidType) UnmarshalJSON(data []byte) error {
	type unmarshaler UuidType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UuidType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UuidType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

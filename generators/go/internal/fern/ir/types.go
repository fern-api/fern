// Code generated by Fern. DO NOT EDIT.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	big "math/big"
	common "sdk/common"
	internal "sdk/internal"
	time "time"
)

var (
	declaredErrorNameFieldErrorId      = big.NewInt(1 << 0)
	declaredErrorNameFieldFernFilepath = big.NewInt(1 << 1)
	declaredErrorNameFieldName         = big.NewInt(1 << 2)
)

type DeclaredErrorName struct {
	ErrorId      ErrorId              `json:"errorId" url:"errorId"`
	FernFilepath *common.FernFilepath `json:"fernFilepath" url:"fernFilepath"`
	Name         *common.Name         `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DeclaredErrorName) GetErrorId() ErrorId {
	if d == nil {
		return ""
	}
	return d.ErrorId
}

func (d *DeclaredErrorName) GetFernFilepath() *common.FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredErrorName) GetName() *common.Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredErrorName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredErrorName) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetErrorId sets the ErrorId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredErrorName) SetErrorId(errorId ErrorId) {
	d.ErrorId = errorId
	d.require(declaredErrorNameFieldErrorId)
}

// SetFernFilepath sets the FernFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredErrorName) SetFernFilepath(fernFilepath *common.FernFilepath) {
	d.FernFilepath = fernFilepath
	d.require(declaredErrorNameFieldFernFilepath)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredErrorName) SetName(name *common.Name) {
	d.Name = name
	d.require(declaredErrorNameFieldName)
}

func (d *DeclaredErrorName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredErrorName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredErrorName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredErrorName) MarshalJSON() ([]byte, error) {
	type embed DeclaredErrorName
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeclaredErrorName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	errorDeclarationFieldDocs              = big.NewInt(1 << 0)
	errorDeclarationFieldName              = big.NewInt(1 << 1)
	errorDeclarationFieldDisplayName       = big.NewInt(1 << 2)
	errorDeclarationFieldDiscriminantValue = big.NewInt(1 << 3)
	errorDeclarationFieldType              = big.NewInt(1 << 4)
	errorDeclarationFieldStatusCode        = big.NewInt(1 << 5)
	errorDeclarationFieldExamples          = big.NewInt(1 << 6)
	errorDeclarationFieldV2Examples        = big.NewInt(1 << 7)
)

type ErrorDeclaration struct {
	Docs              *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Name              *DeclaredErrorName       `json:"name" url:"name"`
	DisplayName       *string                  `json:"displayName,omitempty" url:"displayName,omitempty"`
	DiscriminantValue *common.NameAndWireValue `json:"discriminantValue" url:"discriminantValue"`
	Type              *TypeReference           `json:"type,omitempty" url:"type,omitempty"`
	StatusCode        int                      `json:"statusCode" url:"statusCode"`
	Examples          []*ExampleError          `json:"examples" url:"examples"`
	V2Examples        *V2SchemaExamples        `json:"v2Examples,omitempty" url:"v2Examples,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ErrorDeclaration) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ErrorDeclaration) GetName() *DeclaredErrorName {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ErrorDeclaration) GetDisplayName() *string {
	if e == nil {
		return nil
	}
	return e.DisplayName
}

func (e *ErrorDeclaration) GetDiscriminantValue() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.DiscriminantValue
}

func (e *ErrorDeclaration) GetType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.Type
}

func (e *ErrorDeclaration) GetStatusCode() int {
	if e == nil {
		return 0
	}
	return e.StatusCode
}

func (e *ErrorDeclaration) GetExamples() []*ExampleError {
	if e == nil {
		return nil
	}
	return e.Examples
}

func (e *ErrorDeclaration) GetV2Examples() *V2SchemaExamples {
	if e == nil {
		return nil
	}
	return e.V2Examples
}

func (e *ErrorDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorDeclaration) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetDocs(docs *string) {
	e.Docs = docs
	e.require(errorDeclarationFieldDocs)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetName(name *DeclaredErrorName) {
	e.Name = name
	e.require(errorDeclarationFieldName)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetDisplayName(displayName *string) {
	e.DisplayName = displayName
	e.require(errorDeclarationFieldDisplayName)
}

// SetDiscriminantValue sets the DiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetDiscriminantValue(discriminantValue *common.NameAndWireValue) {
	e.DiscriminantValue = discriminantValue
	e.require(errorDeclarationFieldDiscriminantValue)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetType(type_ *TypeReference) {
	e.Type = type_
	e.require(errorDeclarationFieldType)
}

// SetStatusCode sets the StatusCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetStatusCode(statusCode int) {
	e.StatusCode = statusCode
	e.require(errorDeclarationFieldStatusCode)
}

// SetExamples sets the Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetExamples(examples []*ExampleError) {
	e.Examples = examples
	e.require(errorDeclarationFieldExamples)
}

// SetV2Examples sets the V2Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorDeclaration) SetV2Examples(v2Examples *V2SchemaExamples) {
	e.V2Examples = v2Examples
	e.require(errorDeclarationFieldV2Examples)
}

func (e *ErrorDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ErrorDeclaration) MarshalJSON() ([]byte, error) {
	type embed ErrorDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ErrorDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *common.NameAndWireValue
	StatusCode interface{}
}

func (e *ErrorDeclarationDiscriminantValue) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ErrorDeclarationDiscriminantValue) GetProperty() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Property
}

func (e *ErrorDeclarationDiscriminantValue) GetStatusCode() interface{} {
	if e == nil {
		return nil
	}
	return e.StatusCode
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "property":
		value := new(common.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Property != nil {
		return internal.MarshalJSONWithExtraProperty(e.Property, "type", "property")
	}
	if e.StatusCode != nil {
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*common.NameAndWireValue) error
	VisitStatusCode(interface{}) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	if e.Property != nil {
		return visitor.VisitProperty(e.Property)
	}
	if e.StatusCode != nil {
		return visitor.VisitStatusCode(e.StatusCode)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ErrorDeclarationDiscriminantValue) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Property != nil {
		fields = append(fields, "property")
	}
	if e.StatusCode != nil {
		fields = append(fields, "statusCode")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exampleErrorFieldJsonExample = big.NewInt(1 << 0)
	exampleErrorFieldDocs        = big.NewInt(1 << 1)
	exampleErrorFieldName        = big.NewInt(1 << 2)
	exampleErrorFieldShape       = big.NewInt(1 << 3)
)

type ExampleError struct {
	JsonExample interface{}           `json:"jsonExample" url:"jsonExample"`
	Docs        *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *common.Name          `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeReference `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleError) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleError) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleError) GetName() *common.Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleError) GetShape() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleError) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleError) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetJsonExample sets the JsonExample field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleError) SetJsonExample(jsonExample interface{}) {
	e.JsonExample = jsonExample
	e.require(exampleErrorFieldJsonExample)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleError) SetDocs(docs *string) {
	e.Docs = docs
	e.require(exampleErrorFieldDocs)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleError) SetName(name *common.Name) {
	e.Name = name
	e.require(exampleErrorFieldName)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleError) SetShape(shape *ExampleTypeReference) {
	e.Shape = shape
	e.require(exampleErrorFieldShape)
}

func (e *ExampleError) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleError) MarshalJSON() ([]byte, error) {
	type embed ExampleError
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleError) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	aliasTypeDeclarationFieldAliasOf      = big.NewInt(1 << 0)
	aliasTypeDeclarationFieldResolvedType = big.NewInt(1 << 1)
)

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf" url:"aliasOf"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType" url:"resolvedType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (a *AliasTypeDeclaration) GetAliasOf() *TypeReference {
	if a == nil {
		return nil
	}
	return a.AliasOf
}

func (a *AliasTypeDeclaration) GetResolvedType() *ResolvedTypeReference {
	if a == nil {
		return nil
	}
	return a.ResolvedType
}

func (a *AliasTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasTypeDeclaration) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAliasOf sets the AliasOf field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AliasTypeDeclaration) SetAliasOf(aliasOf *TypeReference) {
	a.AliasOf = aliasOf
	a.require(aliasTypeDeclarationFieldAliasOf)
}

// SetResolvedType sets the ResolvedType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AliasTypeDeclaration) SetResolvedType(resolvedType *ResolvedTypeReference) {
	a.ResolvedType = resolvedType
	a.require(aliasTypeDeclarationFieldResolvedType)
}

func (a *AliasTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AliasTypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed AliasTypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AliasTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Base64Type struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *Base64Type) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base64Type) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

func (b *Base64Type) UnmarshalJSON(data []byte) error {
	type unmarshaler Base64Type
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Base64Type(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *Base64Type) MarshalJSON() ([]byte, error) {
	type embed Base64Type
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Base64Type) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bigIntegerTypeFieldDefault = big.NewInt(1 << 0)
)

type BigIntegerType struct {
	Default *string `json:"default,omitempty" url:"default,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BigIntegerType) GetDefault() *string {
	if b == nil {
		return nil
	}
	return b.Default
}

func (b *BigIntegerType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BigIntegerType) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BigIntegerType) SetDefault(default_ *string) {
	b.Default = default_
	b.require(bigIntegerTypeFieldDefault)
}

func (b *BigIntegerType) UnmarshalJSON(data []byte) error {
	type unmarshaler BigIntegerType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BigIntegerType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BigIntegerType) MarshalJSON() ([]byte, error) {
	type embed BigIntegerType
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BigIntegerType) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	booleanTypeFieldDefault = big.NewInt(1 << 0)
)

type BooleanType struct {
	Default *bool `json:"default,omitempty" url:"default,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BooleanType) GetDefault() *bool {
	if b == nil {
		return nil
	}
	return b.Default
}

func (b *BooleanType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanType) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanType) SetDefault(default_ *bool) {
	b.Default = default_
	b.require(booleanTypeFieldDefault)
}

func (b *BooleanType) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BooleanType) MarshalJSON() ([]byte, error) {
	type embed BooleanType
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BooleanType) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Nullable *TypeReference
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func (c *ContainerType) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContainerType) GetList() *TypeReference {
	if c == nil {
		return nil
	}
	return c.List
}

func (c *ContainerType) GetMap() *MapType {
	if c == nil {
		return nil
	}
	return c.Map
}

func (c *ContainerType) GetNullable() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Nullable
}

func (c *ContainerType) GetOptional() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Optional
}

func (c *ContainerType) GetSet() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Set
}

func (c *ContainerType) GetLiteral() *Literal {
	if c == nil {
		return nil
	}
	return c.Literal
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", c)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "nullable":
		var valueUnmarshaler struct {
			Nullable *TypeReference `json:"nullable"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Nullable = valueUnmarshaler.Nullable
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.List != nil {
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	}
	if c.Map != nil {
		return internal.MarshalJSONWithExtraProperty(c.Map, "_type", "map")
	}
	if c.Nullable != nil {
		var marshaler = struct {
			Type     string         `json:"_type"`
			Nullable *TypeReference `json:"nullable"`
		}{
			Type:     "nullable",
			Nullable: c.Nullable,
		}
		return json.Marshal(marshaler)
	}
	if c.Optional != nil {
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	}
	if c.Set != nil {
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set"`
		}{
			Type: "set",
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	}
	if c.Literal != nil {
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal"`
		}{
			Type:    "literal",
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitNullable(*TypeReference) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	if c.List != nil {
		return visitor.VisitList(c.List)
	}
	if c.Map != nil {
		return visitor.VisitMap(c.Map)
	}
	if c.Nullable != nil {
		return visitor.VisitNullable(c.Nullable)
	}
	if c.Optional != nil {
		return visitor.VisitOptional(c.Optional)
	}
	if c.Set != nil {
		return visitor.VisitSet(c.Set)
	}
	if c.Literal != nil {
		return visitor.VisitLiteral(c.Literal)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ContainerType) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.List != nil {
		fields = append(fields, "list")
	}
	if c.Map != nil {
		fields = append(fields, "map")
	}
	if c.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if c.Optional != nil {
		fields = append(fields, "optional")
	}
	if c.Set != nil {
		fields = append(fields, "set")
	}
	if c.Literal != nil {
		fields = append(fields, "literal")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type DateTimeType struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DateTimeType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateTimeType) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

func (d *DateTimeType) UnmarshalJSON(data []byte) error {
	type unmarshaler DateTimeType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateTimeType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DateTimeType) MarshalJSON() ([]byte, error) {
	type embed DateTimeType
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DateTimeType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DateType struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DateType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateType) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

func (d *DateType) UnmarshalJSON(data []byte) error {
	type unmarshaler DateType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DateType) MarshalJSON() ([]byte, error) {
	type embed DateType
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DateType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	declaredTypeNameFieldTypeId       = big.NewInt(1 << 0)
	declaredTypeNameFieldFernFilepath = big.NewInt(1 << 1)
	declaredTypeNameFieldName         = big.NewInt(1 << 2)
	declaredTypeNameFieldDisplayName  = big.NewInt(1 << 3)
)

type DeclaredTypeName struct {
	TypeId       common.TypeId        `json:"typeId" url:"typeId"`
	FernFilepath *common.FernFilepath `json:"fernFilepath" url:"fernFilepath"`
	Name         *common.Name         `json:"name" url:"name"`
	DisplayName  *DisplayName         `json:"displayName,omitempty" url:"displayName,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DeclaredTypeName) GetTypeId() common.TypeId {
	if d == nil {
		return ""
	}
	return d.TypeId
}

func (d *DeclaredTypeName) GetFernFilepath() *common.FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredTypeName) GetName() *common.Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredTypeName) GetDisplayName() *DisplayName {
	if d == nil {
		return nil
	}
	return d.DisplayName
}

func (d *DeclaredTypeName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredTypeName) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTypeId sets the TypeId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredTypeName) SetTypeId(typeId common.TypeId) {
	d.TypeId = typeId
	d.require(declaredTypeNameFieldTypeId)
}

// SetFernFilepath sets the FernFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredTypeName) SetFernFilepath(fernFilepath *common.FernFilepath) {
	d.FernFilepath = fernFilepath
	d.require(declaredTypeNameFieldFernFilepath)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredTypeName) SetName(name *common.Name) {
	d.Name = name
	d.require(declaredTypeNameFieldName)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeclaredTypeName) SetDisplayName(displayName *DisplayName) {
	d.DisplayName = displayName
	d.require(declaredTypeNameFieldDisplayName)
}

func (d *DeclaredTypeName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredTypeName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredTypeName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredTypeName) MarshalJSON() ([]byte, error) {
	type embed DeclaredTypeName
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeclaredTypeName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	doubleTypeFieldDefault    = big.NewInt(1 << 0)
	doubleTypeFieldValidation = big.NewInt(1 << 1)
)

type DoubleType struct {
	Default    *float64               `json:"default,omitempty" url:"default,omitempty"`
	Validation *DoubleValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DoubleType) GetDefault() *float64 {
	if d == nil {
		return nil
	}
	return d.Default
}

func (d *DoubleType) GetValidation() *DoubleValidationRules {
	if d == nil {
		return nil
	}
	return d.Validation
}

func (d *DoubleType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleType) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleType) SetDefault(default_ *float64) {
	d.Default = default_
	d.require(doubleTypeFieldDefault)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleType) SetValidation(validation *DoubleValidationRules) {
	d.Validation = validation
	d.require(doubleTypeFieldValidation)
}

func (d *DoubleType) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DoubleType) MarshalJSON() ([]byte, error) {
	type embed DoubleType
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DoubleType) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	doubleValidationRulesFieldMin          = big.NewInt(1 << 0)
	doubleValidationRulesFieldMax          = big.NewInt(1 << 1)
	doubleValidationRulesFieldExclusiveMin = big.NewInt(1 << 2)
	doubleValidationRulesFieldExclusiveMax = big.NewInt(1 << 3)
	doubleValidationRulesFieldMultipleOf   = big.NewInt(1 << 4)
)

type DoubleValidationRules struct {
	Min          *float64 `json:"min,omitempty" url:"min,omitempty"`
	Max          *float64 `json:"max,omitempty" url:"max,omitempty"`
	ExclusiveMin *bool    `json:"exclusiveMin,omitempty" url:"exclusiveMin,omitempty"`
	ExclusiveMax *bool    `json:"exclusiveMax,omitempty" url:"exclusiveMax,omitempty"`
	MultipleOf   *float64 `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (d *DoubleValidationRules) GetMin() *float64 {
	if d == nil {
		return nil
	}
	return d.Min
}

func (d *DoubleValidationRules) GetMax() *float64 {
	if d == nil {
		return nil
	}
	return d.Max
}

func (d *DoubleValidationRules) GetExclusiveMin() *bool {
	if d == nil {
		return nil
	}
	return d.ExclusiveMin
}

func (d *DoubleValidationRules) GetExclusiveMax() *bool {
	if d == nil {
		return nil
	}
	return d.ExclusiveMax
}

func (d *DoubleValidationRules) GetMultipleOf() *float64 {
	if d == nil {
		return nil
	}
	return d.MultipleOf
}

func (d *DoubleValidationRules) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleValidationRules) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMin sets the Min field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleValidationRules) SetMin(min *float64) {
	d.Min = min
	d.require(doubleValidationRulesFieldMin)
}

// SetMax sets the Max field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleValidationRules) SetMax(max *float64) {
	d.Max = max
	d.require(doubleValidationRulesFieldMax)
}

// SetExclusiveMin sets the ExclusiveMin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleValidationRules) SetExclusiveMin(exclusiveMin *bool) {
	d.ExclusiveMin = exclusiveMin
	d.require(doubleValidationRulesFieldExclusiveMin)
}

// SetExclusiveMax sets the ExclusiveMax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleValidationRules) SetExclusiveMax(exclusiveMax *bool) {
	d.ExclusiveMax = exclusiveMax
	d.require(doubleValidationRulesFieldExclusiveMax)
}

// SetMultipleOf sets the MultipleOf field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleValidationRules) SetMultipleOf(multipleOf *float64) {
	d.MultipleOf = multipleOf
	d.require(doubleValidationRulesFieldMultipleOf)
}

func (d *DoubleValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DoubleValidationRules) MarshalJSON() ([]byte, error) {
	type embed DoubleValidationRules
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DoubleValidationRules) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	encodingFieldJson  = big.NewInt(1 << 0)
	encodingFieldProto = big.NewInt(1 << 1)
)

type Encoding struct {
	Json  *JsonEncoding  `json:"json,omitempty" url:"json,omitempty"`
	Proto *ProtoEncoding `json:"proto,omitempty" url:"proto,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *Encoding) GetJson() *JsonEncoding {
	if e == nil {
		return nil
	}
	return e.Json
}

func (e *Encoding) GetProto() *ProtoEncoding {
	if e == nil {
		return nil
	}
	return e.Proto
}

func (e *Encoding) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Encoding) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetJson sets the Json field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Encoding) SetJson(json *JsonEncoding) {
	e.Json = json
	e.require(encodingFieldJson)
}

// SetProto sets the Proto field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Encoding) SetProto(proto *ProtoEncoding) {
	e.Proto = proto
	e.require(encodingFieldProto)
}

func (e *Encoding) UnmarshalJSON(data []byte) error {
	type unmarshaler Encoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Encoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *Encoding) MarshalJSON() ([]byte, error) {
	type embed Encoding
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Encoding) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	enumTypeDeclarationFieldDefault = big.NewInt(1 << 0)
	enumTypeDeclarationFieldValues  = big.NewInt(1 << 1)
)

type EnumTypeDeclaration struct {
	Default *EnumValue   `json:"default,omitempty" url:"default,omitempty"`
	Values  []*EnumValue `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnumTypeDeclaration) GetDefault() *EnumValue {
	if e == nil {
		return nil
	}
	return e.Default
}

func (e *EnumTypeDeclaration) GetValues() []*EnumValue {
	if e == nil {
		return nil
	}
	return e.Values
}

func (e *EnumTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumTypeDeclaration) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumTypeDeclaration) SetDefault(default_ *EnumValue) {
	e.Default = default_
	e.require(enumTypeDeclarationFieldDefault)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumTypeDeclaration) SetValues(values []*EnumValue) {
	e.Values = values
	e.require(enumTypeDeclarationFieldValues)
}

func (e *EnumTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumTypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed EnumTypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnumTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	enumTypeReferenceFieldDefault = big.NewInt(1 << 0)
	enumTypeReferenceFieldName    = big.NewInt(1 << 1)
)

type EnumTypeReference struct {
	Default *EnumValue        `json:"default,omitempty" url:"default,omitempty"`
	Name    *DeclaredTypeName `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnumTypeReference) GetDefault() *EnumValue {
	if e == nil {
		return nil
	}
	return e.Default
}

func (e *EnumTypeReference) GetName() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnumTypeReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumTypeReference) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumTypeReference) SetDefault(default_ *EnumValue) {
	e.Default = default_
	e.require(enumTypeReferenceFieldDefault)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumTypeReference) SetName(name *DeclaredTypeName) {
	e.Name = name
	e.require(enumTypeReferenceFieldName)
}

func (e *EnumTypeReference) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumTypeReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumTypeReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumTypeReference) MarshalJSON() ([]byte, error) {
	type embed EnumTypeReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnumTypeReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	enumValueFieldDocs         = big.NewInt(1 << 0)
	enumValueFieldAvailability = big.NewInt(1 << 1)
	enumValueFieldName         = big.NewInt(1 << 2)
)

type EnumValue struct {
	Docs         *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability            `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *common.NameAndWireValue `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *EnumValue) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *EnumValue) GetAvailability() *Availability {
	if e == nil {
		return nil
	}
	return e.Availability
}

func (e *EnumValue) GetName() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnumValue) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumValue) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumValue) SetDocs(docs *string) {
	e.Docs = docs
	e.require(enumValueFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumValue) SetAvailability(availability *Availability) {
	e.Availability = availability
	e.require(enumValueFieldAvailability)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnumValue) SetName(name *common.NameAndWireValue) {
	e.Name = name
	e.require(enumValueFieldName)
}

func (e *EnumValue) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumValue) MarshalJSON() ([]byte, error) {
	type embed EnumValue
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnumValue) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleAliasTypeFieldValue = big.NewInt(1 << 0)
)

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleAliasType) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleAliasType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleAliasType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleAliasType) SetValue(value *ExampleTypeReference) {
	e.Value = value
	e.require(exampleAliasTypeFieldValue)
}

func (e *ExampleAliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleAliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleAliasType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleAliasType) MarshalJSON() ([]byte, error) {
	type embed ExampleAliasType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleAliasType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleContainer struct {
	Type     string
	List     *ExampleListContainer
	Set      *ExampleSetContainer
	Optional *ExampleOptionalContainer
	Nullable *ExampleNullableContainer
	Map      *ExampleMapContainer
	Literal  *ExampleLiteralContainer
}

func (e *ExampleContainer) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleContainer) GetList() *ExampleListContainer {
	if e == nil {
		return nil
	}
	return e.List
}

func (e *ExampleContainer) GetSet() *ExampleSetContainer {
	if e == nil {
		return nil
	}
	return e.Set
}

func (e *ExampleContainer) GetOptional() *ExampleOptionalContainer {
	if e == nil {
		return nil
	}
	return e.Optional
}

func (e *ExampleContainer) GetNullable() *ExampleNullableContainer {
	if e == nil {
		return nil
	}
	return e.Nullable
}

func (e *ExampleContainer) GetMap() *ExampleMapContainer {
	if e == nil {
		return nil
	}
	return e.Map
}

func (e *ExampleContainer) GetLiteral() *ExampleLiteralContainer {
	if e == nil {
		return nil
	}
	return e.Literal
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "list":
		value := new(ExampleListContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.List = value
	case "set":
		value := new(ExampleSetContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Set = value
	case "optional":
		value := new(ExampleOptionalContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Optional = value
	case "nullable":
		value := new(ExampleNullableContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Nullable = value
	case "map":
		value := new(ExampleMapContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Map = value
	case "literal":
		value := new(ExampleLiteralContainer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Literal = value
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.List != nil {
		return internal.MarshalJSONWithExtraProperty(e.List, "type", "list")
	}
	if e.Set != nil {
		return internal.MarshalJSONWithExtraProperty(e.Set, "type", "set")
	}
	if e.Optional != nil {
		return internal.MarshalJSONWithExtraProperty(e.Optional, "type", "optional")
	}
	if e.Nullable != nil {
		return internal.MarshalJSONWithExtraProperty(e.Nullable, "type", "nullable")
	}
	if e.Map != nil {
		return internal.MarshalJSONWithExtraProperty(e.Map, "type", "map")
	}
	if e.Literal != nil {
		return internal.MarshalJSONWithExtraProperty(e.Literal, "type", "literal")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExampleContainerVisitor interface {
	VisitList(*ExampleListContainer) error
	VisitSet(*ExampleSetContainer) error
	VisitOptional(*ExampleOptionalContainer) error
	VisitNullable(*ExampleNullableContainer) error
	VisitMap(*ExampleMapContainer) error
	VisitLiteral(*ExampleLiteralContainer) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	if e.List != nil {
		return visitor.VisitList(e.List)
	}
	if e.Set != nil {
		return visitor.VisitSet(e.Set)
	}
	if e.Optional != nil {
		return visitor.VisitOptional(e.Optional)
	}
	if e.Nullable != nil {
		return visitor.VisitNullable(e.Nullable)
	}
	if e.Map != nil {
		return visitor.VisitMap(e.Map)
	}
	if e.Literal != nil {
		return visitor.VisitLiteral(e.Literal)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExampleContainer) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.List != nil {
		fields = append(fields, "list")
	}
	if e.Set != nil {
		fields = append(fields, "set")
	}
	if e.Optional != nil {
		fields = append(fields, "optional")
	}
	if e.Nullable != nil {
		fields = append(fields, "nullable")
	}
	if e.Map != nil {
		fields = append(fields, "map")
	}
	if e.Literal != nil {
		fields = append(fields, "literal")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exampleDatetimeFieldDatetime = big.NewInt(1 << 0)
	exampleDatetimeFieldRaw      = big.NewInt(1 << 1)
)

type ExampleDatetime struct {
	Datetime time.Time `json:"datetime" url:"datetime"`
	Raw      *string   `json:"raw,omitempty" url:"raw,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleDatetime) GetDatetime() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Datetime
}

func (e *ExampleDatetime) GetRaw() *string {
	if e == nil {
		return nil
	}
	return e.Raw
}

func (e *ExampleDatetime) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleDatetime) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDatetime sets the Datetime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleDatetime) SetDatetime(datetime time.Time) {
	e.Datetime = datetime
	e.require(exampleDatetimeFieldDatetime)
}

// SetRaw sets the Raw field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleDatetime) SetRaw(raw *string) {
	e.Raw = raw
	e.require(exampleDatetimeFieldRaw)
}

func (e *ExampleDatetime) UnmarshalJSON(data []byte) error {
	type embed ExampleDatetime
	var unmarshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExampleDatetime(unmarshaler.embed)
	e.Datetime = unmarshaler.Datetime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleDatetime) MarshalJSON() ([]byte, error) {
	type embed ExampleDatetime
	var marshaler = struct {
		embed
		Datetime *internal.DateTime `json:"datetime"`
	}{
		embed:    embed(*e),
		Datetime: internal.NewDateTime(e.Datetime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleDatetime) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleEnumTypeFieldValue = big.NewInt(1 << 0)
)

type ExampleEnumType struct {
	Value *common.NameAndWireValue `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleEnumType) GetValue() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleEnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEnumType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleEnumType) SetValue(value *common.NameAndWireValue) {
	e.Value = value
	e.require(exampleEnumTypeFieldValue)
}

func (e *ExampleEnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEnumType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEnumType) MarshalJSON() ([]byte, error) {
	type embed ExampleEnumType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleEnumType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleKeyValuePairFieldKey   = big.NewInt(1 << 0)
	exampleKeyValuePairFieldValue = big.NewInt(1 << 1)
)

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key" url:"key"`
	Value *ExampleTypeReference `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleKeyValuePair) GetKey() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *ExampleKeyValuePair) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleKeyValuePair) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleKeyValuePair) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleKeyValuePair) SetKey(key *ExampleTypeReference) {
	e.Key = key
	e.require(exampleKeyValuePairFieldKey)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleKeyValuePair) SetValue(value *ExampleTypeReference) {
	e.Value = value
	e.require(exampleKeyValuePairFieldValue)
}

func (e *ExampleKeyValuePair) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleKeyValuePair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleKeyValuePair(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleKeyValuePair) MarshalJSON() ([]byte, error) {
	type embed ExampleKeyValuePair
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleKeyValuePair) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleListContainerFieldList     = big.NewInt(1 << 0)
	exampleListContainerFieldItemType = big.NewInt(1 << 1)
)

type ExampleListContainer struct {
	List     []*ExampleTypeReference `json:"list" url:"list"`
	ItemType *TypeReference          `json:"itemType" url:"itemType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleListContainer) GetList() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.List
}

func (e *ExampleListContainer) GetItemType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ItemType
}

func (e *ExampleListContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleListContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetList sets the List field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleListContainer) SetList(list []*ExampleTypeReference) {
	e.List = list
	e.require(exampleListContainerFieldList)
}

// SetItemType sets the ItemType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleListContainer) SetItemType(itemType *TypeReference) {
	e.ItemType = itemType
	e.require(exampleListContainerFieldItemType)
}

func (e *ExampleListContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleListContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleListContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleListContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleListContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleListContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleLiteralContainerFieldLiteral = big.NewInt(1 << 0)
)

type ExampleLiteralContainer struct {
	Literal *ExamplePrimitive `json:"literal" url:"literal"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleLiteralContainer) GetLiteral() *ExamplePrimitive {
	if e == nil {
		return nil
	}
	return e.Literal
}

func (e *ExampleLiteralContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleLiteralContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetLiteral sets the Literal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleLiteralContainer) SetLiteral(literal *ExamplePrimitive) {
	e.Literal = literal
	e.require(exampleLiteralContainerFieldLiteral)
}

func (e *ExampleLiteralContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleLiteralContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleLiteralContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleLiteralContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleLiteralContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleLiteralContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleMapContainerFieldMap       = big.NewInt(1 << 0)
	exampleMapContainerFieldKeyType   = big.NewInt(1 << 1)
	exampleMapContainerFieldValueType = big.NewInt(1 << 2)
)

type ExampleMapContainer struct {
	Map       []*ExampleKeyValuePair `json:"map" url:"map"`
	KeyType   *TypeReference         `json:"keyType" url:"keyType"`
	ValueType *TypeReference         `json:"valueType" url:"valueType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleMapContainer) GetMap() []*ExampleKeyValuePair {
	if e == nil {
		return nil
	}
	return e.Map
}

func (e *ExampleMapContainer) GetKeyType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.KeyType
}

func (e *ExampleMapContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleMapContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleMapContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMap sets the Map field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleMapContainer) SetMap(map_ []*ExampleKeyValuePair) {
	e.Map = map_
	e.require(exampleMapContainerFieldMap)
}

// SetKeyType sets the KeyType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleMapContainer) SetKeyType(keyType *TypeReference) {
	e.KeyType = keyType
	e.require(exampleMapContainerFieldKeyType)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleMapContainer) SetValueType(valueType *TypeReference) {
	e.ValueType = valueType
	e.require(exampleMapContainerFieldValueType)
}

func (e *ExampleMapContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleMapContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleMapContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleMapContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleMapContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleMapContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleNamedTypeFieldTypeName = big.NewInt(1 << 0)
	exampleNamedTypeFieldShape    = big.NewInt(1 << 1)
)

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName" url:"typeName"`
	Shape    *ExampleTypeShape `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleNamedType) GetTypeName() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.TypeName
}

func (e *ExampleNamedType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleNamedType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleNamedType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTypeName sets the TypeName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleNamedType) SetTypeName(typeName *DeclaredTypeName) {
	e.TypeName = typeName
	e.require(exampleNamedTypeFieldTypeName)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleNamedType) SetShape(shape *ExampleTypeShape) {
	e.Shape = shape
	e.require(exampleNamedTypeFieldShape)
}

func (e *ExampleNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleNamedType) MarshalJSON() ([]byte, error) {
	type embed ExampleNamedType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleNamedType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleNullableContainerFieldNullable  = big.NewInt(1 << 0)
	exampleNullableContainerFieldValueType = big.NewInt(1 << 1)
)

type ExampleNullableContainer struct {
	Nullable  *ExampleTypeReference `json:"nullable,omitempty" url:"nullable,omitempty"`
	ValueType *TypeReference        `json:"valueType" url:"valueType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleNullableContainer) GetNullable() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Nullable
}

func (e *ExampleNullableContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleNullableContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleNullableContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetNullable sets the Nullable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleNullableContainer) SetNullable(nullable *ExampleTypeReference) {
	e.Nullable = nullable
	e.require(exampleNullableContainerFieldNullable)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleNullableContainer) SetValueType(valueType *TypeReference) {
	e.ValueType = valueType
	e.require(exampleNullableContainerFieldValueType)
}

func (e *ExampleNullableContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleNullableContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleNullableContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleNullableContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleNullableContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleNullableContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleObjectPropertyFieldName                    = big.NewInt(1 << 0)
	exampleObjectPropertyFieldValue                   = big.NewInt(1 << 1)
	exampleObjectPropertyFieldPropertyAccess          = big.NewInt(1 << 2)
	exampleObjectPropertyFieldOriginalTypeDeclaration = big.NewInt(1 << 3)
)

type ExampleObjectProperty struct {
	Name           *common.NameAndWireValue     `json:"name" url:"name"`
	Value          *ExampleTypeReference        `json:"value" url:"value"`
	PropertyAccess *common.ObjectPropertyAccess `json:"propertyAccess,omitempty" url:"propertyAccess,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property.
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration" url:"originalTypeDeclaration"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectProperty) GetName() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleObjectProperty) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleObjectProperty) GetPropertyAccess() *common.ObjectPropertyAccess {
	if e == nil {
		return nil
	}
	return e.PropertyAccess
}

func (e *ExampleObjectProperty) GetOriginalTypeDeclaration() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.OriginalTypeDeclaration
}

func (e *ExampleObjectProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectProperty) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectProperty) SetName(name *common.NameAndWireValue) {
	e.Name = name
	e.require(exampleObjectPropertyFieldName)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectProperty) SetValue(value *ExampleTypeReference) {
	e.Value = value
	e.require(exampleObjectPropertyFieldValue)
}

// SetPropertyAccess sets the PropertyAccess field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectProperty) SetPropertyAccess(propertyAccess *common.ObjectPropertyAccess) {
	e.PropertyAccess = propertyAccess
	e.require(exampleObjectPropertyFieldPropertyAccess)
}

// SetOriginalTypeDeclaration sets the OriginalTypeDeclaration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectProperty) SetOriginalTypeDeclaration(originalTypeDeclaration *DeclaredTypeName) {
	e.OriginalTypeDeclaration = originalTypeDeclaration
	e.require(exampleObjectPropertyFieldOriginalTypeDeclaration)
}

func (e *ExampleObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectProperty) MarshalJSON() ([]byte, error) {
	type embed ExampleObjectProperty
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleObjectProperty) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleObjectTypeFieldProperties = big.NewInt(1 << 0)
)

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties" url:"properties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectType) GetProperties() []*ExampleObjectProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleObjectType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectType) SetProperties(properties []*ExampleObjectProperty) {
	e.Properties = properties
	e.require(exampleObjectTypeFieldProperties)
}

func (e *ExampleObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectType) MarshalJSON() ([]byte, error) {
	type embed ExampleObjectType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleObjectType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleObjectTypeWithTypeIdFieldTypeId = big.NewInt(1 << 0)
	exampleObjectTypeWithTypeIdFieldObject = big.NewInt(1 << 1)
)

type ExampleObjectTypeWithTypeId struct {
	TypeId common.TypeId      `json:"typeId" url:"typeId"`
	Object *ExampleObjectType `json:"object" url:"object"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectTypeWithTypeId) GetTypeId() common.TypeId {
	if e == nil {
		return ""
	}
	return e.TypeId
}

func (e *ExampleObjectTypeWithTypeId) GetObject() *ExampleObjectType {
	if e == nil {
		return nil
	}
	return e.Object
}

func (e *ExampleObjectTypeWithTypeId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectTypeWithTypeId) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTypeId sets the TypeId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectTypeWithTypeId) SetTypeId(typeId common.TypeId) {
	e.TypeId = typeId
	e.require(exampleObjectTypeWithTypeIdFieldTypeId)
}

// SetObject sets the Object field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleObjectTypeWithTypeId) SetObject(object *ExampleObjectType) {
	e.Object = object
	e.require(exampleObjectTypeWithTypeIdFieldObject)
}

func (e *ExampleObjectTypeWithTypeId) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectTypeWithTypeId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectTypeWithTypeId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectTypeWithTypeId) MarshalJSON() ([]byte, error) {
	type embed ExampleObjectTypeWithTypeId
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleObjectTypeWithTypeId) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleOptionalContainerFieldOptional  = big.NewInt(1 << 0)
	exampleOptionalContainerFieldValueType = big.NewInt(1 << 1)
)

type ExampleOptionalContainer struct {
	Optional  *ExampleTypeReference `json:"optional,omitempty" url:"optional,omitempty"`
	ValueType *TypeReference        `json:"valueType" url:"valueType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleOptionalContainer) GetOptional() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Optional
}

func (e *ExampleOptionalContainer) GetValueType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ValueType
}

func (e *ExampleOptionalContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleOptionalContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetOptional sets the Optional field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleOptionalContainer) SetOptional(optional *ExampleTypeReference) {
	e.Optional = optional
	e.require(exampleOptionalContainerFieldOptional)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleOptionalContainer) SetValueType(valueType *TypeReference) {
	e.ValueType = valueType
	e.require(exampleOptionalContainerFieldValueType)
}

func (e *ExampleOptionalContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleOptionalContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleOptionalContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleOptionalContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleOptionalContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleOptionalContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePrimitive struct {
	Type        string
	Integer     int
	Long        int64
	Uint        int
	Uint64      int64
	Float       float64
	Double      float64
	Boolean     bool
	FieldString *EscapedString
	Date        time.Time
	Datetime    *ExampleDatetime
	Uuid        uuid.UUID
	Base64      []byte
	BigInteger  string
}

func (e *ExamplePrimitive) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExamplePrimitive) GetInteger() int {
	if e == nil {
		return 0
	}
	return e.Integer
}

func (e *ExamplePrimitive) GetLong() int64 {
	if e == nil {
		return 0
	}
	return e.Long
}

func (e *ExamplePrimitive) GetUint() int {
	if e == nil {
		return 0
	}
	return e.Uint
}

func (e *ExamplePrimitive) GetUint64() int64 {
	if e == nil {
		return 0
	}
	return e.Uint64
}

func (e *ExamplePrimitive) GetFloat() float64 {
	if e == nil {
		return 0
	}
	return e.Float
}

func (e *ExamplePrimitive) GetDouble() float64 {
	if e == nil {
		return 0
	}
	return e.Double
}

func (e *ExamplePrimitive) GetBoolean() bool {
	if e == nil {
		return false
	}
	return e.Boolean
}

func (e *ExamplePrimitive) GetFieldString() *EscapedString {
	if e == nil {
		return nil
	}
	return e.FieldString
}

func (e *ExamplePrimitive) GetDate() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Date
}

func (e *ExamplePrimitive) GetDatetime() *ExampleDatetime {
	if e == nil {
		return nil
	}
	return e.Datetime
}

func (e *ExamplePrimitive) GetUuid() uuid.UUID {
	if e == nil {
		return uuid.Nil
	}
	return e.Uuid
}

func (e *ExamplePrimitive) GetBase64() []byte {
	if e == nil {
		return nil
	}
	return e.Base64
}

func (e *ExamplePrimitive) GetBigInteger() string {
	if e == nil {
		return ""
	}
	return e.BigInteger
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "uint":
		var valueUnmarshaler struct {
			Uint int `json:"uint"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uint = valueUnmarshaler.Uint
	case "uint64":
		var valueUnmarshaler struct {
			Uint64 int64 `json:"uint64"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uint64 = valueUnmarshaler.Uint64
	case "float":
		var valueUnmarshaler struct {
			Float float64 `json:"float"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Float = valueUnmarshaler.Float
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "string":
		var valueUnmarshaler struct {
			FieldString *EscapedString `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.FieldString = valueUnmarshaler.FieldString
	case "date":
		var valueUnmarshaler struct {
			Date *internal.Date `json:"date" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date.Time()
	case "datetime":
		value := new(ExampleDatetime)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Datetime = value
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	case "base64":
		var valueUnmarshaler struct {
			Base64 []byte `json:"base64"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Base64 = valueUnmarshaler.Base64
	case "bigInteger":
		var valueUnmarshaler struct {
			BigInteger string `json:"bigInteger"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BigInteger = valueUnmarshaler.BigInteger
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Integer != 0 {
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    "integer",
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	}
	if e.Long != 0 {
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: "long",
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	}
	if e.Uint != 0 {
		var marshaler = struct {
			Type string `json:"type"`
			Uint int    `json:"uint"`
		}{
			Type: "uint",
			Uint: e.Uint,
		}
		return json.Marshal(marshaler)
	}
	if e.Uint64 != 0 {
		var marshaler = struct {
			Type   string `json:"type"`
			Uint64 int64  `json:"uint64"`
		}{
			Type:   "uint64",
			Uint64: e.Uint64,
		}
		return json.Marshal(marshaler)
	}
	if e.Float != 0 {
		var marshaler = struct {
			Type  string  `json:"type"`
			Float float64 `json:"float"`
		}{
			Type:  "float",
			Float: e.Float,
		}
		return json.Marshal(marshaler)
	}
	if e.Double != 0 {
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   "double",
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	}
	if e.Boolean != false {
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	}
	if e.FieldString != nil {
		var marshaler = struct {
			Type        string         `json:"type"`
			FieldString *EscapedString `json:"string"`
		}{
			Type:        "string",
			FieldString: e.FieldString,
		}
		return json.Marshal(marshaler)
	}
	if !e.Date.IsZero() {
		var marshaler = struct {
			Type string         `json:"type"`
			Date *internal.Date `json:"date" format:"date"`
		}{
			Type: "date",
			Date: internal.NewDate(e.Date),
		}
		return json.Marshal(marshaler)
	}
	if e.Datetime != nil {
		return internal.MarshalJSONWithExtraProperty(e.Datetime, "type", "datetime")
	}
	if e.Uuid != uuid.Nil {
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: "uuid",
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	}
	if e.Base64 != nil {
		var marshaler = struct {
			Type   string `json:"type"`
			Base64 []byte `json:"base64"`
		}{
			Type:   "base64",
			Base64: e.Base64,
		}
		return json.Marshal(marshaler)
	}
	if e.BigInteger != "" {
		var marshaler = struct {
			Type       string `json:"type"`
			BigInteger string `json:"bigInteger"`
		}{
			Type:       "bigInteger",
			BigInteger: e.BigInteger,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitLong(int64) error
	VisitUint(int) error
	VisitUint64(int64) error
	VisitFloat(float64) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitFieldString(*EscapedString) error
	VisitDate(time.Time) error
	VisitDatetime(*ExampleDatetime) error
	VisitUuid(uuid.UUID) error
	VisitBase64([]byte) error
	VisitBigInteger(string) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	if e.Integer != 0 {
		return visitor.VisitInteger(e.Integer)
	}
	if e.Long != 0 {
		return visitor.VisitLong(e.Long)
	}
	if e.Uint != 0 {
		return visitor.VisitUint(e.Uint)
	}
	if e.Uint64 != 0 {
		return visitor.VisitUint64(e.Uint64)
	}
	if e.Float != 0 {
		return visitor.VisitFloat(e.Float)
	}
	if e.Double != 0 {
		return visitor.VisitDouble(e.Double)
	}
	if e.Boolean != false {
		return visitor.VisitBoolean(e.Boolean)
	}
	if e.FieldString != nil {
		return visitor.VisitFieldString(e.FieldString)
	}
	if !e.Date.IsZero() {
		return visitor.VisitDate(e.Date)
	}
	if e.Datetime != nil {
		return visitor.VisitDatetime(e.Datetime)
	}
	if e.Uuid != uuid.Nil {
		return visitor.VisitUuid(e.Uuid)
	}
	if e.Base64 != nil {
		return visitor.VisitBase64(e.Base64)
	}
	if e.BigInteger != "" {
		return visitor.VisitBigInteger(e.BigInteger)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExamplePrimitive) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Integer != 0 {
		fields = append(fields, "integer")
	}
	if e.Long != 0 {
		fields = append(fields, "long")
	}
	if e.Uint != 0 {
		fields = append(fields, "uint")
	}
	if e.Uint64 != 0 {
		fields = append(fields, "uint64")
	}
	if e.Float != 0 {
		fields = append(fields, "float")
	}
	if e.Double != 0 {
		fields = append(fields, "double")
	}
	if e.Boolean != false {
		fields = append(fields, "boolean")
	}
	if e.FieldString != nil {
		fields = append(fields, "string")
	}
	if !e.Date.IsZero() {
		fields = append(fields, "date")
	}
	if e.Datetime != nil {
		fields = append(fields, "datetime")
	}
	if e.Uuid != uuid.Nil {
		fields = append(fields, "uuid")
	}
	if e.Base64 != nil {
		fields = append(fields, "base64")
	}
	if e.BigInteger != "" {
		fields = append(fields, "bigInteger")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exampleSetContainerFieldSet      = big.NewInt(1 << 0)
	exampleSetContainerFieldItemType = big.NewInt(1 << 1)
)

type ExampleSetContainer struct {
	Set      []*ExampleTypeReference `json:"set" url:"set"`
	ItemType *TypeReference          `json:"itemType" url:"itemType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleSetContainer) GetSet() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Set
}

func (e *ExampleSetContainer) GetItemType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.ItemType
}

func (e *ExampleSetContainer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleSetContainer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSet sets the Set field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleSetContainer) SetSet(set []*ExampleTypeReference) {
	e.Set = set
	e.require(exampleSetContainerFieldSet)
}

// SetItemType sets the ItemType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleSetContainer) SetItemType(itemType *TypeReference) {
	e.ItemType = itemType
	e.require(exampleSetContainerFieldItemType)
}

func (e *ExampleSetContainer) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleSetContainer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleSetContainer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleSetContainer) MarshalJSON() ([]byte, error) {
	type embed ExampleSetContainer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleSetContainer) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleSingleUnionTypeFieldWireDiscriminantValue = big.NewInt(1 << 0)
	exampleSingleUnionTypeFieldShape                 = big.NewInt(1 << 1)
)

type ExampleSingleUnionType struct {
	WireDiscriminantValue *common.NameAndWireValue          `json:"wireDiscriminantValue" url:"wireDiscriminantValue"`
	Shape                 *ExampleSingleUnionTypeProperties `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleSingleUnionType) GetWireDiscriminantValue() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.WireDiscriminantValue
}

func (e *ExampleSingleUnionType) GetShape() *ExampleSingleUnionTypeProperties {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleSingleUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleSingleUnionType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetWireDiscriminantValue sets the WireDiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleSingleUnionType) SetWireDiscriminantValue(wireDiscriminantValue *common.NameAndWireValue) {
	e.WireDiscriminantValue = wireDiscriminantValue
	e.require(exampleSingleUnionTypeFieldWireDiscriminantValue)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleSingleUnionType) SetShape(shape *ExampleSingleUnionTypeProperties) {
	e.Shape = shape
	e.require(exampleSingleUnionTypeFieldShape)
}

func (e *ExampleSingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleSingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleSingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleSingleUnionType) MarshalJSON() ([]byte, error) {
	type embed ExampleSingleUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleSingleUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleObjectTypeWithTypeId
	SingleProperty         *ExampleTypeReference
	NoProperties           interface{}
}

func (e *ExampleSingleUnionTypeProperties) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleSingleUnionTypeProperties) GetSamePropertiesAsObject() *ExampleObjectTypeWithTypeId {
	if e == nil {
		return nil
	}
	return e.SamePropertiesAsObject
}

func (e *ExampleSingleUnionTypeProperties) GetSingleProperty() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.SingleProperty
}

func (e *ExampleSingleUnionTypeProperties) GetNoProperties() interface{} {
	if e == nil {
		return nil
	}
	return e.NoProperties
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleObjectTypeWithTypeId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.SamePropertiesAsObject != nil {
		return internal.MarshalJSONWithExtraProperty(e.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	}
	if e.SingleProperty != nil {
		return internal.MarshalJSONWithExtraProperty(e.SingleProperty, "type", "singleProperty")
	}
	if e.NoProperties != nil {
		var marshaler = struct {
			Type         string      `json:"type"`
			NoProperties interface{} `json:"noProperties,omitempty"`
		}{
			Type:         "noProperties",
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleObjectTypeWithTypeId) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(interface{}) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	if e.SamePropertiesAsObject != nil {
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	}
	if e.SingleProperty != nil {
		return visitor.VisitSingleProperty(e.SingleProperty)
	}
	if e.NoProperties != nil {
		return visitor.VisitNoProperties(e.NoProperties)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExampleSingleUnionTypeProperties) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if e.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if e.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exampleTypeFieldJsonExample = big.NewInt(1 << 0)
	exampleTypeFieldDocs        = big.NewInt(1 << 1)
	exampleTypeFieldName        = big.NewInt(1 << 2)
	exampleTypeFieldShape       = big.NewInt(1 << 3)
)

type ExampleType struct {
	JsonExample interface{}       `json:"jsonExample" url:"jsonExample"`
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *common.Name      `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleType) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleType) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleType) GetName() *common.Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetJsonExample sets the JsonExample field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleType) SetJsonExample(jsonExample interface{}) {
	e.JsonExample = jsonExample
	e.require(exampleTypeFieldJsonExample)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleType) SetDocs(docs *string) {
	e.Docs = docs
	e.require(exampleTypeFieldDocs)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleType) SetName(name *common.Name) {
	e.Name = name
	e.require(exampleTypeFieldName)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleType) SetShape(shape *ExampleTypeShape) {
	e.Shape = shape
	e.require(exampleTypeFieldShape)
}

func (e *ExampleType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleType) MarshalJSON() ([]byte, error) {
	type embed ExampleType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleTypeReferenceFieldJsonExample = big.NewInt(1 << 0)
	exampleTypeReferenceFieldShape       = big.NewInt(1 << 1)
)

type ExampleTypeReference struct {
	JsonExample interface{}                `json:"jsonExample" url:"jsonExample"`
	Shape       *ExampleTypeReferenceShape `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleTypeReference) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleTypeReference) GetShape() *ExampleTypeReferenceShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleTypeReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleTypeReference) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetJsonExample sets the JsonExample field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleTypeReference) SetJsonExample(jsonExample interface{}) {
	e.JsonExample = jsonExample
	e.require(exampleTypeReferenceFieldJsonExample)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleTypeReference) SetShape(shape *ExampleTypeReferenceShape) {
	e.Shape = shape
	e.require(exampleTypeReferenceFieldShape)
}

func (e *ExampleTypeReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleTypeReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleTypeReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleTypeReference) MarshalJSON() ([]byte, error) {
	type embed ExampleTypeReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleTypeReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   interface{}
	Named     *ExampleNamedType
}

func (e *ExampleTypeReferenceShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeReferenceShape) GetPrimitive() *ExamplePrimitive {
	if e == nil {
		return nil
	}
	return e.Primitive
}

func (e *ExampleTypeReferenceShape) GetContainer() *ExampleContainer {
	if e == nil {
		return nil
	}
	return e.Container
}

func (e *ExampleTypeReferenceShape) GetUnknown() interface{} {
	if e == nil {
		return nil
	}
	return e.Unknown
}

func (e *ExampleTypeReferenceShape) GetNamed() *ExampleNamedType {
	if e == nil {
		return nil
	}
	return e.Named
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown interface{} `json:"unknown"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Primitive != nil {
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive"`
		}{
			Type:      "primitive",
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if e.Container != nil {
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container"`
		}{
			Type:      "container",
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	}
	if e.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown"`
		}{
			Type:    "unknown",
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	}
	if e.Named != nil {
		return internal.MarshalJSONWithExtraProperty(e.Named, "type", "named")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(interface{}) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	if e.Primitive != nil {
		return visitor.VisitPrimitive(e.Primitive)
	}
	if e.Container != nil {
		return visitor.VisitContainer(e.Container)
	}
	if e.Unknown != nil {
		return visitor.VisitUnknown(e.Unknown)
	}
	if e.Named != nil {
		return visitor.VisitNamed(e.Named)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExampleTypeReferenceShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if e.Container != nil {
		fields = append(fields, "container")
	}
	if e.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if e.Named != nil {
		fields = append(fields, "named")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleTypeShape struct {
	Type                 string
	Alias                *ExampleAliasType
	Enum                 *ExampleEnumType
	Object               *ExampleObjectType
	Union                *ExampleUnionType
	UndiscriminatedUnion *ExampleUndiscriminatedUnionType
}

func (e *ExampleTypeShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeShape) GetAlias() *ExampleAliasType {
	if e == nil {
		return nil
	}
	return e.Alias
}

func (e *ExampleTypeShape) GetEnum() *ExampleEnumType {
	if e == nil {
		return nil
	}
	return e.Enum
}

func (e *ExampleTypeShape) GetObject() *ExampleObjectType {
	if e == nil {
		return nil
	}
	return e.Object
}

func (e *ExampleTypeShape) GetUnion() *ExampleUnionType {
	if e == nil {
		return nil
	}
	return e.Union
}

func (e *ExampleTypeShape) GetUndiscriminatedUnion() *ExampleUndiscriminatedUnionType {
	if e == nil {
		return nil
	}
	return e.UndiscriminatedUnion
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	case "undiscriminatedUnion":
		value := new(ExampleUndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UndiscriminatedUnion = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Alias != nil {
		return internal.MarshalJSONWithExtraProperty(e.Alias, "type", "alias")
	}
	if e.Enum != nil {
		return internal.MarshalJSONWithExtraProperty(e.Enum, "type", "enum")
	}
	if e.Object != nil {
		return internal.MarshalJSONWithExtraProperty(e.Object, "type", "object")
	}
	if e.Union != nil {
		return internal.MarshalJSONWithExtraProperty(e.Union, "type", "union")
	}
	if e.UndiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(e.UndiscriminatedUnion, "type", "undiscriminatedUnion")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleUnionType) error
	VisitUndiscriminatedUnion(*ExampleUndiscriminatedUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	if e.Alias != nil {
		return visitor.VisitAlias(e.Alias)
	}
	if e.Enum != nil {
		return visitor.VisitEnum(e.Enum)
	}
	if e.Object != nil {
		return visitor.VisitObject(e.Object)
	}
	if e.Union != nil {
		return visitor.VisitUnion(e.Union)
	}
	if e.UndiscriminatedUnion != nil {
		return visitor.VisitUndiscriminatedUnion(e.UndiscriminatedUnion)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExampleTypeShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Alias != nil {
		fields = append(fields, "alias")
	}
	if e.Enum != nil {
		fields = append(fields, "enum")
	}
	if e.Object != nil {
		fields = append(fields, "object")
	}
	if e.Union != nil {
		fields = append(fields, "union")
	}
	if e.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	exampleUndiscriminatedUnionTypeFieldIndex           = big.NewInt(1 << 0)
	exampleUndiscriminatedUnionTypeFieldSingleUnionType = big.NewInt(1 << 1)
)

type ExampleUndiscriminatedUnionType struct {
	// The zero-based index of the undiscriminated union variant.
	// For the following undiscriminated union
	// ```
	// MyUnion:
	//
	//	discriminated: false
	//	union:
	//	  - string
	//	  - integer
	//
	// ```
	// a string example would have an index 0 and an integer example
	// would have an index 1.
	Index           int                   `json:"index" url:"index"`
	SingleUnionType *ExampleTypeReference `json:"singleUnionType" url:"singleUnionType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleUndiscriminatedUnionType) GetIndex() int {
	if e == nil {
		return 0
	}
	return e.Index
}

func (e *ExampleUndiscriminatedUnionType) GetSingleUnionType() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.SingleUnionType
}

func (e *ExampleUndiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleUndiscriminatedUnionType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetIndex sets the Index field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleUndiscriminatedUnionType) SetIndex(index int) {
	e.Index = index
	e.require(exampleUndiscriminatedUnionTypeFieldIndex)
}

// SetSingleUnionType sets the SingleUnionType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleUndiscriminatedUnionType) SetSingleUnionType(singleUnionType *ExampleTypeReference) {
	e.SingleUnionType = singleUnionType
	e.require(exampleUndiscriminatedUnionTypeFieldSingleUnionType)
}

func (e *ExampleUndiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleUndiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleUndiscriminatedUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleUndiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	type embed ExampleUndiscriminatedUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleUndiscriminatedUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	exampleUnionTypeFieldDiscriminant    = big.NewInt(1 << 0)
	exampleUnionTypeFieldSingleUnionType = big.NewInt(1 << 1)
)

type ExampleUnionType struct {
	Discriminant    *common.NameAndWireValue `json:"discriminant" url:"discriminant"`
	SingleUnionType *ExampleSingleUnionType  `json:"singleUnionType" url:"singleUnionType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleUnionType) GetDiscriminant() *common.NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Discriminant
}

func (e *ExampleUnionType) GetSingleUnionType() *ExampleSingleUnionType {
	if e == nil {
		return nil
	}
	return e.SingleUnionType
}

func (e *ExampleUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleUnionType) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDiscriminant sets the Discriminant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleUnionType) SetDiscriminant(discriminant *common.NameAndWireValue) {
	e.Discriminant = discriminant
	e.require(exampleUnionTypeFieldDiscriminant)
}

// SetSingleUnionType sets the SingleUnionType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleUnionType) SetSingleUnionType(singleUnionType *ExampleSingleUnionType) {
	e.SingleUnionType = singleUnionType
	e.require(exampleUnionTypeFieldSingleUnionType)
}

func (e *ExampleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleUnionType) MarshalJSON() ([]byte, error) {
	type embed ExampleUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FloatType struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (f *FloatType) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FloatType) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

func (f *FloatType) UnmarshalJSON(data []byte) error {
	type unmarshaler FloatType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FloatType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FloatType) MarshalJSON() ([]byte, error) {
	type embed FloatType
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FloatType) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	integerTypeFieldDefault    = big.NewInt(1 << 0)
	integerTypeFieldValidation = big.NewInt(1 << 1)
)

type IntegerType struct {
	Default    *int                    `json:"default,omitempty" url:"default,omitempty"`
	Validation *IntegerValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *IntegerType) GetDefault() *int {
	if i == nil {
		return nil
	}
	return i.Default
}

func (i *IntegerType) GetValidation() *IntegerValidationRules {
	if i == nil {
		return nil
	}
	return i.Validation
}

func (i *IntegerType) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegerType) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerType) SetDefault(default_ *int) {
	i.Default = default_
	i.require(integerTypeFieldDefault)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerType) SetValidation(validation *IntegerValidationRules) {
	i.Validation = validation
	i.require(integerTypeFieldValidation)
}

func (i *IntegerType) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegerType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegerType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntegerType) MarshalJSON() ([]byte, error) {
	type embed IntegerType
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegerType) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	integerValidationRulesFieldMin          = big.NewInt(1 << 0)
	integerValidationRulesFieldMax          = big.NewInt(1 << 1)
	integerValidationRulesFieldExclusiveMin = big.NewInt(1 << 2)
	integerValidationRulesFieldExclusiveMax = big.NewInt(1 << 3)
	integerValidationRulesFieldMultipleOf   = big.NewInt(1 << 4)
)

type IntegerValidationRules struct {
	Min          *int  `json:"min,omitempty" url:"min,omitempty"`
	Max          *int  `json:"max,omitempty" url:"max,omitempty"`
	ExclusiveMin *bool `json:"exclusiveMin,omitempty" url:"exclusiveMin,omitempty"`
	ExclusiveMax *bool `json:"exclusiveMax,omitempty" url:"exclusiveMax,omitempty"`
	MultipleOf   *int  `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *IntegerValidationRules) GetMin() *int {
	if i == nil {
		return nil
	}
	return i.Min
}

func (i *IntegerValidationRules) GetMax() *int {
	if i == nil {
		return nil
	}
	return i.Max
}

func (i *IntegerValidationRules) GetExclusiveMin() *bool {
	if i == nil {
		return nil
	}
	return i.ExclusiveMin
}

func (i *IntegerValidationRules) GetExclusiveMax() *bool {
	if i == nil {
		return nil
	}
	return i.ExclusiveMax
}

func (i *IntegerValidationRules) GetMultipleOf() *int {
	if i == nil {
		return nil
	}
	return i.MultipleOf
}

func (i *IntegerValidationRules) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegerValidationRules) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetMin sets the Min field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerValidationRules) SetMin(min *int) {
	i.Min = min
	i.require(integerValidationRulesFieldMin)
}

// SetMax sets the Max field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerValidationRules) SetMax(max *int) {
	i.Max = max
	i.require(integerValidationRulesFieldMax)
}

// SetExclusiveMin sets the ExclusiveMin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerValidationRules) SetExclusiveMin(exclusiveMin *bool) {
	i.ExclusiveMin = exclusiveMin
	i.require(integerValidationRulesFieldExclusiveMin)
}

// SetExclusiveMax sets the ExclusiveMax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerValidationRules) SetExclusiveMax(exclusiveMax *bool) {
	i.ExclusiveMax = exclusiveMax
	i.require(integerValidationRulesFieldExclusiveMax)
}

// SetMultipleOf sets the MultipleOf field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegerValidationRules) SetMultipleOf(multipleOf *int) {
	i.MultipleOf = multipleOf
	i.require(integerValidationRulesFieldMultipleOf)
}

func (i *IntegerValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegerValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegerValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntegerValidationRules) MarshalJSON() ([]byte, error) {
	type embed IntegerValidationRules
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegerValidationRules) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonEncoding struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (j *JsonEncoding) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonEncoding) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

func (j *JsonEncoding) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonEncoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonEncoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonEncoding) MarshalJSON() ([]byte, error) {
	type embed JsonEncoding
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JsonEncoding) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type Literal struct {
	Type        string
	FieldString string
	Boolean     bool
}

func (l *Literal) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *Literal) GetFieldString() string {
	if l == nil {
		return ""
	}
	return l.FieldString
}

func (l *Literal) GetBoolean() bool {
	if l == nil {
		return false
	}
	return l.Boolean
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			FieldString string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.FieldString = valueUnmarshaler.FieldString
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	if l.FieldString != "" {
		var marshaler = struct {
			Type        string `json:"type"`
			FieldString string `json:"string"`
		}{
			Type:        "string",
			FieldString: l.FieldString,
		}
		return json.Marshal(marshaler)
	}
	if l.Boolean != false {
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LiteralVisitor interface {
	VisitFieldString(string) error
	VisitBoolean(bool) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	if l.FieldString != "" {
		return visitor.VisitFieldString(l.FieldString)
	}
	if l.Boolean != false {
		return visitor.VisitBoolean(l.Boolean)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

func (l *Literal) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.FieldString != "" {
		fields = append(fields, "string")
	}
	if l.Boolean != false {
		fields = append(fields, "boolean")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

var (
	longTypeFieldDefault = big.NewInt(1 << 0)
)

type LongType struct {
	Default *int64 `json:"default,omitempty" url:"default,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (l *LongType) GetDefault() *int64 {
	if l == nil {
		return nil
	}
	return l.Default
}

func (l *LongType) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LongType) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LongType) SetDefault(default_ *int64) {
	l.Default = default_
	l.require(longTypeFieldDefault)
}

func (l *LongType) UnmarshalJSON(data []byte) error {
	type unmarshaler LongType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LongType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	return nil
}

func (l *LongType) MarshalJSON() ([]byte, error) {
	type embed LongType
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LongType) String() string {
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	mapTypeFieldKeyType   = big.NewInt(1 << 0)
	mapTypeFieldValueType = big.NewInt(1 << 1)
)

type MapType struct {
	KeyType   *TypeReference `json:"keyType" url:"keyType"`
	ValueType *TypeReference `json:"valueType" url:"valueType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetKeyType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.KeyType
}

func (m *MapType) GetValueType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.ValueType
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetKeyType sets the KeyType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MapType) SetKeyType(keyType *TypeReference) {
	m.KeyType = keyType
	m.require(mapTypeFieldKeyType)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MapType) SetValueType(valueType *TypeReference) {
	m.ValueType = valueType
	m.require(mapTypeFieldValueType)
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MapType) MarshalJSON() ([]byte, error) {
	type embed MapType
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MapType) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// A reference to a named type. For backwards compatibility, this type must be fully compatible
// with the DeclaredTypeName.
var (
	namedTypeFieldTypeId       = big.NewInt(1 << 0)
	namedTypeFieldFernFilepath = big.NewInt(1 << 1)
	namedTypeFieldName         = big.NewInt(1 << 2)
	namedTypeFieldDisplayName  = big.NewInt(1 << 3)
	namedTypeFieldDefault      = big.NewInt(1 << 4)
	namedTypeFieldInline       = big.NewInt(1 << 5)
)

type NamedType struct {
	TypeId       common.TypeId        `json:"typeId" url:"typeId"`
	FernFilepath *common.FernFilepath `json:"fernFilepath" url:"fernFilepath"`
	Name         *common.Name         `json:"name" url:"name"`
	DisplayName  *DisplayName         `json:"displayName,omitempty" url:"displayName,omitempty"`
	Default      *NamedTypeDefault    `json:"default,omitempty" url:"default,omitempty"`
	// Use the inline property on the TypeDeclaration instead.
	Inline *bool `json:"inline,omitempty" url:"inline,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NamedType) GetTypeId() common.TypeId {
	if n == nil {
		return ""
	}
	return n.TypeId
}

func (n *NamedType) GetFernFilepath() *common.FernFilepath {
	if n == nil {
		return nil
	}
	return n.FernFilepath
}

func (n *NamedType) GetName() *common.Name {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NamedType) GetDisplayName() *DisplayName {
	if n == nil {
		return nil
	}
	return n.DisplayName
}

func (n *NamedType) GetDefault() *NamedTypeDefault {
	if n == nil {
		return nil
	}
	return n.Default
}

func (n *NamedType) GetInline() *bool {
	if n == nil {
		return nil
	}
	return n.Inline
}

func (n *NamedType) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedType) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTypeId sets the TypeId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetTypeId(typeId common.TypeId) {
	n.TypeId = typeId
	n.require(namedTypeFieldTypeId)
}

// SetFernFilepath sets the FernFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetFernFilepath(fernFilepath *common.FernFilepath) {
	n.FernFilepath = fernFilepath
	n.require(namedTypeFieldFernFilepath)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetName(name *common.Name) {
	n.Name = name
	n.require(namedTypeFieldName)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetDisplayName(displayName *DisplayName) {
	n.DisplayName = displayName
	n.require(namedTypeFieldDisplayName)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetDefault(default_ *NamedTypeDefault) {
	n.Default = default_
	n.require(namedTypeFieldDefault)
}

// SetInline sets the Inline field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NamedType) SetInline(inline *bool) {
	n.Inline = inline
	n.require(namedTypeFieldInline)
}

func (n *NamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NamedType) MarshalJSON() ([]byte, error) {
	type embed NamedType
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NamedType) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NamedTypeDefault struct {
	Type string
	Enum *EnumValue
}

func (n *NamedTypeDefault) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NamedTypeDefault) GetEnum() *EnumValue {
	if n == nil {
		return nil
	}
	return n.Enum
}

func (n *NamedTypeDefault) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "enum":
		value := new(EnumValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Enum = value
	}
	return nil
}

func (n NamedTypeDefault) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	if n.Enum != nil {
		return internal.MarshalJSONWithExtraProperty(n.Enum, "type", "enum")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NamedTypeDefaultVisitor interface {
	VisitEnum(*EnumValue) error
}

func (n *NamedTypeDefault) Accept(visitor NamedTypeDefaultVisitor) error {
	if n.Enum != nil {
		return visitor.VisitEnum(n.Enum)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

func (n *NamedTypeDefault) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Enum != nil {
		fields = append(fields, "enum")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

var (
	objectPropertyFieldDocs           = big.NewInt(1 << 0)
	objectPropertyFieldAvailability   = big.NewInt(1 << 1)
	objectPropertyFieldName           = big.NewInt(1 << 2)
	objectPropertyFieldValueType      = big.NewInt(1 << 3)
	objectPropertyFieldPropertyAccess = big.NewInt(1 << 4)
	objectPropertyFieldV2Examples     = big.NewInt(1 << 5)
)

type ObjectProperty struct {
	Docs           *string                      `json:"docs,omitempty" url:"docs,omitempty"`
	Availability   *Availability                `json:"availability,omitempty" url:"availability,omitempty"`
	Name           *common.NameAndWireValue     `json:"name" url:"name"`
	ValueType      *TypeReference               `json:"valueType" url:"valueType"`
	PropertyAccess *common.ObjectPropertyAccess `json:"propertyAccess,omitempty" url:"propertyAccess,omitempty"`
	V2Examples     *V2SchemaExamples            `json:"v2Examples,omitempty" url:"v2Examples,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *ObjectProperty) GetDocs() *string {
	if o == nil {
		return nil
	}
	return o.Docs
}

func (o *ObjectProperty) GetAvailability() *Availability {
	if o == nil {
		return nil
	}
	return o.Availability
}

func (o *ObjectProperty) GetName() *common.NameAndWireValue {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ObjectProperty) GetValueType() *TypeReference {
	if o == nil {
		return nil
	}
	return o.ValueType
}

func (o *ObjectProperty) GetPropertyAccess() *common.ObjectPropertyAccess {
	if o == nil {
		return nil
	}
	return o.PropertyAccess
}

func (o *ObjectProperty) GetV2Examples() *V2SchemaExamples {
	if o == nil {
		return nil
	}
	return o.V2Examples
}

func (o *ObjectProperty) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectProperty) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetDocs(docs *string) {
	o.Docs = docs
	o.require(objectPropertyFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetAvailability(availability *Availability) {
	o.Availability = availability
	o.require(objectPropertyFieldAvailability)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetName(name *common.NameAndWireValue) {
	o.Name = name
	o.require(objectPropertyFieldName)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetValueType(valueType *TypeReference) {
	o.ValueType = valueType
	o.require(objectPropertyFieldValueType)
}

// SetPropertyAccess sets the PropertyAccess field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetPropertyAccess(propertyAccess *common.ObjectPropertyAccess) {
	o.PropertyAccess = propertyAccess
	o.require(objectPropertyFieldPropertyAccess)
}

// SetV2Examples sets the V2Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectProperty) SetV2Examples(v2Examples *V2SchemaExamples) {
	o.V2Examples = v2Examples
	o.require(objectPropertyFieldV2Examples)
}

func (o *ObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectProperty) MarshalJSON() ([]byte, error) {
	type embed ObjectProperty
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectProperty) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	objectTypeDeclarationFieldExtends            = big.NewInt(1 << 0)
	objectTypeDeclarationFieldProperties         = big.NewInt(1 << 1)
	objectTypeDeclarationFieldExtendedProperties = big.NewInt(1 << 2)
	objectTypeDeclarationFieldExtraProperties    = big.NewInt(1 << 3)
)

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends" url:"extends"`
	Properties []*ObjectProperty   `json:"properties" url:"properties"`
	// A list of properties that all the parents of this object have.
	ExtendedProperties []*ObjectProperty `json:"extendedProperties,omitempty" url:"extendedProperties,omitempty"`
	// Whether to allow extra properties on the object.
	ExtraProperties bool `json:"extra-properties" url:"extra-properties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *ObjectTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if o == nil {
		return nil
	}
	return o.Extends
}

func (o *ObjectTypeDeclaration) GetProperties() []*ObjectProperty {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *ObjectTypeDeclaration) GetExtendedProperties() []*ObjectProperty {
	if o == nil {
		return nil
	}
	return o.ExtendedProperties
}

func (o *ObjectTypeDeclaration) GetExtraProperties() bool {
	if o == nil {
		return false
	}
	return o.ExtraProperties
}

func (o *ObjectTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectTypeDeclaration) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetExtends sets the Extends field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectTypeDeclaration) SetExtends(extends []*DeclaredTypeName) {
	o.Extends = extends
	o.require(objectTypeDeclarationFieldExtends)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectTypeDeclaration) SetProperties(properties []*ObjectProperty) {
	o.Properties = properties
	o.require(objectTypeDeclarationFieldProperties)
}

// SetExtendedProperties sets the ExtendedProperties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectTypeDeclaration) SetExtendedProperties(extendedProperties []*ObjectProperty) {
	o.ExtendedProperties = extendedProperties
	o.require(objectTypeDeclarationFieldExtendedProperties)
}

// SetExtraProperties sets the ExtraProperties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *ObjectTypeDeclaration) SetExtraProperties(extraProperties bool) {
	o.ExtraProperties = extraProperties
	o.require(objectTypeDeclarationFieldExtraProperties)
}

func (o *ObjectTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectTypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed ObjectTypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *ObjectTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	primitiveTypeFieldV1 = big.NewInt(1 << 0)
	primitiveTypeFieldV2 = big.NewInt(1 << 1)
)

type PrimitiveType struct {
	V1 common.PrimitiveTypeV1 `json:"v1" url:"v1"`
	V2 *PrimitiveTypeV2       `json:"v2,omitempty" url:"v2,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PrimitiveType) GetV1() common.PrimitiveTypeV1 {
	if p == nil {
		return ""
	}
	return p.V1
}

func (p *PrimitiveType) GetV2() *PrimitiveTypeV2 {
	if p == nil {
		return nil
	}
	return p.V2
}

func (p *PrimitiveType) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrimitiveType) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetV1 sets the V1 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PrimitiveType) SetV1(v1 common.PrimitiveTypeV1) {
	p.V1 = v1
	p.require(primitiveTypeFieldV1)
}

// SetV2 sets the V2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PrimitiveType) SetV2(v2 *PrimitiveTypeV2) {
	p.V2 = v2
	p.require(primitiveTypeFieldV2)
}

func (p *PrimitiveType) UnmarshalJSON(data []byte) error {
	type unmarshaler PrimitiveType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrimitiveType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PrimitiveType) MarshalJSON() ([]byte, error) {
	type embed PrimitiveType
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PrimitiveType) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PrimitiveTypeV2 struct {
	Type        string
	Integer     *IntegerType
	Long        *LongType
	Uint        *UintType
	Uint64      *Uint64Type
	Float       *FloatType
	Double      *DoubleType
	Boolean     *BooleanType
	FieldString *StringType
	Date        *DateType
	DateTime    *DateTimeType
	Uuid        *UuidType
	Base64      *Base64Type
	BigInteger  *BigIntegerType
}

func (p *PrimitiveTypeV2) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PrimitiveTypeV2) GetInteger() *IntegerType {
	if p == nil {
		return nil
	}
	return p.Integer
}

func (p *PrimitiveTypeV2) GetLong() *LongType {
	if p == nil {
		return nil
	}
	return p.Long
}

func (p *PrimitiveTypeV2) GetUint() *UintType {
	if p == nil {
		return nil
	}
	return p.Uint
}

func (p *PrimitiveTypeV2) GetUint64() *Uint64Type {
	if p == nil {
		return nil
	}
	return p.Uint64
}

func (p *PrimitiveTypeV2) GetFloat() *FloatType {
	if p == nil {
		return nil
	}
	return p.Float
}

func (p *PrimitiveTypeV2) GetDouble() *DoubleType {
	if p == nil {
		return nil
	}
	return p.Double
}

func (p *PrimitiveTypeV2) GetBoolean() *BooleanType {
	if p == nil {
		return nil
	}
	return p.Boolean
}

func (p *PrimitiveTypeV2) GetFieldString() *StringType {
	if p == nil {
		return nil
	}
	return p.FieldString
}

func (p *PrimitiveTypeV2) GetDate() *DateType {
	if p == nil {
		return nil
	}
	return p.Date
}

func (p *PrimitiveTypeV2) GetDateTime() *DateTimeType {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PrimitiveTypeV2) GetUuid() *UuidType {
	if p == nil {
		return nil
	}
	return p.Uuid
}

func (p *PrimitiveTypeV2) GetBase64() *Base64Type {
	if p == nil {
		return nil
	}
	return p.Base64
}

func (p *PrimitiveTypeV2) GetBigInteger() *BigIntegerType {
	if p == nil {
		return nil
	}
	return p.BigInteger
}

func (p *PrimitiveTypeV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "integer":
		value := new(IntegerType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Integer = value
	case "long":
		value := new(LongType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Long = value
	case "uint":
		value := new(UintType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uint = value
	case "uint64":
		value := new(Uint64Type)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uint64 = value
	case "float":
		value := new(FloatType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Float = value
	case "double":
		value := new(DoubleType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Double = value
	case "boolean":
		value := new(BooleanType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Boolean = value
	case "string":
		value := new(StringType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.FieldString = value
	case "date":
		value := new(DateType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Date = value
	case "dateTime":
		value := new(DateTimeType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.DateTime = value
	case "uuid":
		value := new(UuidType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Uuid = value
	case "base64":
		value := new(Base64Type)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Base64 = value
	case "bigInteger":
		value := new(BigIntegerType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BigInteger = value
	}
	return nil
}

func (p PrimitiveTypeV2) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Integer != nil {
		return internal.MarshalJSONWithExtraProperty(p.Integer, "type", "integer")
	}
	if p.Long != nil {
		return internal.MarshalJSONWithExtraProperty(p.Long, "type", "long")
	}
	if p.Uint != nil {
		return internal.MarshalJSONWithExtraProperty(p.Uint, "type", "uint")
	}
	if p.Uint64 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Uint64, "type", "uint64")
	}
	if p.Float != nil {
		return internal.MarshalJSONWithExtraProperty(p.Float, "type", "float")
	}
	if p.Double != nil {
		return internal.MarshalJSONWithExtraProperty(p.Double, "type", "double")
	}
	if p.Boolean != nil {
		return internal.MarshalJSONWithExtraProperty(p.Boolean, "type", "boolean")
	}
	if p.FieldString != nil {
		return internal.MarshalJSONWithExtraProperty(p.FieldString, "type", "string")
	}
	if p.Date != nil {
		return internal.MarshalJSONWithExtraProperty(p.Date, "type", "date")
	}
	if p.DateTime != nil {
		return internal.MarshalJSONWithExtraProperty(p.DateTime, "type", "dateTime")
	}
	if p.Uuid != nil {
		return internal.MarshalJSONWithExtraProperty(p.Uuid, "type", "uuid")
	}
	if p.Base64 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Base64, "type", "base64")
	}
	if p.BigInteger != nil {
		return internal.MarshalJSONWithExtraProperty(p.BigInteger, "type", "bigInteger")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PrimitiveTypeV2Visitor interface {
	VisitInteger(*IntegerType) error
	VisitLong(*LongType) error
	VisitUint(*UintType) error
	VisitUint64(*Uint64Type) error
	VisitFloat(*FloatType) error
	VisitDouble(*DoubleType) error
	VisitBoolean(*BooleanType) error
	VisitFieldString(*StringType) error
	VisitDate(*DateType) error
	VisitDateTime(*DateTimeType) error
	VisitUuid(*UuidType) error
	VisitBase64(*Base64Type) error
	VisitBigInteger(*BigIntegerType) error
}

func (p *PrimitiveTypeV2) Accept(visitor PrimitiveTypeV2Visitor) error {
	if p.Integer != nil {
		return visitor.VisitInteger(p.Integer)
	}
	if p.Long != nil {
		return visitor.VisitLong(p.Long)
	}
	if p.Uint != nil {
		return visitor.VisitUint(p.Uint)
	}
	if p.Uint64 != nil {
		return visitor.VisitUint64(p.Uint64)
	}
	if p.Float != nil {
		return visitor.VisitFloat(p.Float)
	}
	if p.Double != nil {
		return visitor.VisitDouble(p.Double)
	}
	if p.Boolean != nil {
		return visitor.VisitBoolean(p.Boolean)
	}
	if p.FieldString != nil {
		return visitor.VisitFieldString(p.FieldString)
	}
	if p.Date != nil {
		return visitor.VisitDate(p.Date)
	}
	if p.DateTime != nil {
		return visitor.VisitDateTime(p.DateTime)
	}
	if p.Uuid != nil {
		return visitor.VisitUuid(p.Uuid)
	}
	if p.Base64 != nil {
		return visitor.VisitBase64(p.Base64)
	}
	if p.BigInteger != nil {
		return visitor.VisitBigInteger(p.BigInteger)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PrimitiveTypeV2) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Integer != nil {
		fields = append(fields, "integer")
	}
	if p.Long != nil {
		fields = append(fields, "long")
	}
	if p.Uint != nil {
		fields = append(fields, "uint")
	}
	if p.Uint64 != nil {
		fields = append(fields, "uint64")
	}
	if p.Float != nil {
		fields = append(fields, "float")
	}
	if p.Double != nil {
		fields = append(fields, "double")
	}
	if p.Boolean != nil {
		fields = append(fields, "boolean")
	}
	if p.FieldString != nil {
		fields = append(fields, "string")
	}
	if p.Date != nil {
		fields = append(fields, "date")
	}
	if p.DateTime != nil {
		fields = append(fields, "dateTime")
	}
	if p.Uuid != nil {
		fields = append(fields, "uuid")
	}
	if p.Base64 != nil {
		fields = append(fields, "base64")
	}
	if p.BigInteger != nil {
		fields = append(fields, "bigInteger")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type ProtoEncoding struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *ProtoEncoding) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProtoEncoding) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

func (p *ProtoEncoding) UnmarshalJSON(data []byte) error {
	type unmarshaler ProtoEncoding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProtoEncoding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *ProtoEncoding) MarshalJSON() ([]byte, error) {
	type embed ProtoEncoding
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProtoEncoding) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	resolvedNamedTypeFieldName  = big.NewInt(1 << 0)
	resolvedNamedTypeFieldShape = big.NewInt(1 << 1)
)

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name" url:"name"`
	Shape ShapeType         `json:"shape" url:"shape"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *ResolvedNamedType) GetName() *DeclaredTypeName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *ResolvedNamedType) GetShape() ShapeType {
	if r == nil {
		return ""
	}
	return r.Shape
}

func (r *ResolvedNamedType) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolvedNamedType) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResolvedNamedType) SetName(name *DeclaredTypeName) {
	r.Name = name
	r.require(resolvedNamedTypeFieldName)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResolvedNamedType) SetShape(shape ShapeType) {
	r.Shape = shape
	r.require(resolvedNamedTypeFieldShape)
}

func (r *ResolvedNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolvedNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolvedNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResolvedNamedType) MarshalJSON() ([]byte, error) {
	type embed ResolvedNamedType
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResolvedNamedType) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive *PrimitiveType
	Unknown   interface{}
}

func (r *ResolvedTypeReference) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResolvedTypeReference) GetContainer() *ContainerType {
	if r == nil {
		return nil
	}
	return r.Container
}

func (r *ResolvedTypeReference) GetNamed() *ResolvedNamedType {
	if r == nil {
		return nil
	}
	return r.Named
}

func (r *ResolvedTypeReference) GetPrimitive() *PrimitiveType {
	if r == nil {
		return nil
	}
	return r.Primitive
}

func (r *ResolvedTypeReference) GetUnknown() interface{} {
	if r == nil {
		return nil
	}
	return r.Unknown
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", r)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *PrimitiveType `json:"primitive"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Container != nil {
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container"`
		}{
			Type:      "container",
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	}
	if r.Named != nil {
		return internal.MarshalJSONWithExtraProperty(r.Named, "_type", "named")
	}
	if r.Primitive != nil {
		var marshaler = struct {
			Type      string         `json:"_type"`
			Primitive *PrimitiveType `json:"primitive"`
		}{
			Type:      "primitive",
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if r.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(*PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	if r.Container != nil {
		return visitor.VisitContainer(r.Container)
	}
	if r.Named != nil {
		return visitor.VisitNamed(r.Named)
	}
	if r.Primitive != nil {
		return visitor.VisitPrimitive(r.Primitive)
	}
	if r.Unknown != nil {
		return visitor.VisitUnknown(r.Unknown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ResolvedTypeReference) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Container != nil {
		fields = append(fields, "container")
	}
	if r.Named != nil {
		fields = append(fields, "named")
	}
	if r.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if r.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

var (
	singleUnionTypeFieldDocs              = big.NewInt(1 << 0)
	singleUnionTypeFieldDiscriminantValue = big.NewInt(1 << 1)
	singleUnionTypeFieldShape             = big.NewInt(1 << 2)
	singleUnionTypeFieldDisplayName       = big.NewInt(1 << 3)
	singleUnionTypeFieldAvailability      = big.NewInt(1 << 4)
)

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty" url:"docs,omitempty"`
	DiscriminantValue *common.NameAndWireValue   `json:"discriminantValue" url:"discriminantValue"`
	Shape             *SingleUnionTypeProperties `json:"shape" url:"shape"`
	DisplayName       *string                    `json:"displayName,omitempty" url:"displayName,omitempty"`
	Availability      *Availability              `json:"availability,omitempty" url:"availability,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionType) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleUnionType) GetDiscriminantValue() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleUnionType) GetShape() *SingleUnionTypeProperties {
	if s == nil {
		return nil
	}
	return s.Shape
}

func (s *SingleUnionType) GetDisplayName() *string {
	if s == nil {
		return nil
	}
	return s.DisplayName
}

func (s *SingleUnionType) GetAvailability() *Availability {
	if s == nil {
		return nil
	}
	return s.Availability
}

func (s *SingleUnionType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionType) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionType) SetDocs(docs *string) {
	s.Docs = docs
	s.require(singleUnionTypeFieldDocs)
}

// SetDiscriminantValue sets the DiscriminantValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionType) SetDiscriminantValue(discriminantValue *common.NameAndWireValue) {
	s.DiscriminantValue = discriminantValue
	s.require(singleUnionTypeFieldDiscriminantValue)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionType) SetShape(shape *SingleUnionTypeProperties) {
	s.Shape = shape
	s.require(singleUnionTypeFieldShape)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionType) SetDisplayName(displayName *string) {
	s.DisplayName = displayName
	s.require(singleUnionTypeFieldDisplayName)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionType) SetAvailability(availability *Availability) {
	s.Availability = availability
	s.require(singleUnionTypeFieldAvailability)
}

func (s *SingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionType) MarshalJSON() ([]byte, error) {
	type embed SingleUnionType
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUnionType) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           interface{}
}

func (s *SingleUnionTypeProperties) GetPropertiesType() string {
	if s == nil {
		return ""
	}
	return s.PropertiesType
}

func (s *SingleUnionTypeProperties) GetSamePropertiesAsObject() *DeclaredTypeName {
	if s == nil {
		return nil
	}
	return s.SamePropertiesAsObject
}

func (s *SingleUnionTypeProperties) GetSingleProperty() *SingleUnionTypeProperty {
	if s == nil {
		return nil
	}
	return s.SingleProperty
}

func (s *SingleUnionTypeProperties) GetNoProperties() interface{} {
	if s == nil {
		return nil
	}
	return s.NoProperties
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	if unmarshaler.PropertiesType == "" {
		return fmt.Errorf("%T did not include discriminant _type", s)
	}
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.SamePropertiesAsObject != nil {
		return internal.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "_type", "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		return internal.MarshalJSONWithExtraProperty(s.SingleProperty, "_type", "singleProperty")
	}
	if s.NoProperties != nil {
		var marshaler = struct {
			PropertiesType string      `json:"_type"`
			NoProperties   interface{} `json:"noProperties,omitempty"`
		}{
			PropertiesType: "noProperties",
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(interface{}) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	if s.SamePropertiesAsObject != nil {
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	}
	if s.SingleProperty != nil {
		return visitor.VisitSingleProperty(s.SingleProperty)
	}
	if s.NoProperties != nil {
		return visitor.VisitNoProperties(s.NoProperties)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUnionTypeProperties) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if s.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if s.PropertiesType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.PropertiesType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.PropertiesType != "" {
		field := fields[0]
		if s.PropertiesType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.PropertiesType,
				s,
			)
		}
	}
	return nil
}

var (
	singleUnionTypePropertyFieldName = big.NewInt(1 << 0)
	singleUnionTypePropertyFieldType = big.NewInt(1 << 1)
)

type SingleUnionTypeProperty struct {
	Name *common.NameAndWireValue `json:"name" url:"name"`
	Type *TypeReference           `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionTypeProperty) GetName() *common.NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleUnionTypeProperty) GetType() *TypeReference {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SingleUnionTypeProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionTypeProperty) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionTypeProperty) SetName(name *common.NameAndWireValue) {
	s.Name = name
	s.require(singleUnionTypePropertyFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUnionTypeProperty) SetType(type_ *TypeReference) {
	s.Type = type_
	s.require(singleUnionTypePropertyFieldType)
}

func (s *SingleUnionTypeProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionTypeProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionTypeProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionTypeProperty) MarshalJSON() ([]byte, error) {
	type embed SingleUnionTypeProperty
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUnionTypeProperty) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The original source of the declared type (e.g. a `.proto` file).
type Source struct {
	Type  string
	Proto *ProtobufType
}

func (s *Source) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Source) GetProto() *ProtobufType {
	if s == nil {
		return nil
	}
	return s.Proto
}

func (s *Source) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "proto":
		var valueUnmarshaler struct {
			Proto *ProtobufType `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.Proto = valueUnmarshaler.Proto
	}
	return nil
}

func (s Source) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Proto != nil {
		var marshaler = struct {
			Type  string        `json:"type"`
			Proto *ProtobufType `json:"value"`
		}{
			Type:  "proto",
			Proto: s.Proto,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SourceVisitor interface {
	VisitProto(*ProtobufType) error
}

func (s *Source) Accept(visitor SourceVisitor) error {
	if s.Proto != nil {
		return visitor.VisitProto(s.Proto)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *Source) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Proto != nil {
		fields = append(fields, "proto")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

var (
	stringTypeFieldDefault    = big.NewInt(1 << 0)
	stringTypeFieldValidation = big.NewInt(1 << 1)
)

type StringType struct {
	Default    *string                `json:"default,omitempty" url:"default,omitempty"`
	Validation *StringValidationRules `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *StringType) GetDefault() *string {
	if s == nil {
		return nil
	}
	return s.Default
}

func (s *StringType) GetValidation() *StringValidationRules {
	if s == nil {
		return nil
	}
	return s.Validation
}

func (s *StringType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringType) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDefault sets the Default field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringType) SetDefault(default_ *string) {
	s.Default = default_
	s.require(stringTypeFieldDefault)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringType) SetValidation(validation *StringValidationRules) {
	s.Validation = validation
	s.require(stringTypeFieldValidation)
}

func (s *StringType) UnmarshalJSON(data []byte) error {
	type unmarshaler StringType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StringType) MarshalJSON() ([]byte, error) {
	type embed StringType
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StringType) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	stringValidationRulesFieldFormat    = big.NewInt(1 << 0)
	stringValidationRulesFieldPattern   = big.NewInt(1 << 1)
	stringValidationRulesFieldMinLength = big.NewInt(1 << 2)
	stringValidationRulesFieldMaxLength = big.NewInt(1 << 3)
)

type StringValidationRules struct {
	Format    *string `json:"format,omitempty" url:"format,omitempty"`
	Pattern   *string `json:"pattern,omitempty" url:"pattern,omitempty"`
	MinLength *int    `json:"minLength,omitempty" url:"minLength,omitempty"`
	MaxLength *int    `json:"maxLength,omitempty" url:"maxLength,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (s *StringValidationRules) GetFormat() *string {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *StringValidationRules) GetPattern() *string {
	if s == nil {
		return nil
	}
	return s.Pattern
}

func (s *StringValidationRules) GetMinLength() *int {
	if s == nil {
		return nil
	}
	return s.MinLength
}

func (s *StringValidationRules) GetMaxLength() *int {
	if s == nil {
		return nil
	}
	return s.MaxLength
}

func (s *StringValidationRules) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringValidationRules) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetFormat sets the Format field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringValidationRules) SetFormat(format *string) {
	s.Format = format
	s.require(stringValidationRulesFieldFormat)
}

// SetPattern sets the Pattern field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringValidationRules) SetPattern(pattern *string) {
	s.Pattern = pattern
	s.require(stringValidationRulesFieldPattern)
}

// SetMinLength sets the MinLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringValidationRules) SetMinLength(minLength *int) {
	s.MinLength = minLength
	s.require(stringValidationRulesFieldMinLength)
}

// SetMaxLength sets the MaxLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringValidationRules) SetMaxLength(maxLength *int) {
	s.MaxLength = maxLength
	s.require(stringValidationRulesFieldMaxLength)
}

func (s *StringValidationRules) UnmarshalJSON(data []byte) error {
	type unmarshaler StringValidationRules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringValidationRules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StringValidationRules) MarshalJSON() ([]byte, error) {
	type embed StringValidationRules
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StringValidationRules) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func (t *Type) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Type) GetAlias() *AliasTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Alias
}

func (t *Type) GetEnum() *EnumTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Enum
}

func (t *Type) GetObject() *ObjectTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *Type) GetUnion() *UnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Union
}

func (t *Type) GetUndiscriminatedUnion() *UndiscriminatedUnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.UndiscriminatedUnion
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Alias != nil {
		return internal.MarshalJSONWithExtraProperty(t.Alias, "_type", "alias")
	}
	if t.Enum != nil {
		return internal.MarshalJSONWithExtraProperty(t.Enum, "_type", "enum")
	}
	if t.Object != nil {
		return internal.MarshalJSONWithExtraProperty(t.Object, "_type", "object")
	}
	if t.Union != nil {
		return internal.MarshalJSONWithExtraProperty(t.Union, "_type", "union")
	}
	if t.UndiscriminatedUnion != nil {
		return internal.MarshalJSONWithExtraProperty(t.UndiscriminatedUnion, "_type", "undiscriminatedUnion")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	if t.Alias != nil {
		return visitor.VisitAlias(t.Alias)
	}
	if t.Enum != nil {
		return visitor.VisitEnum(t.Enum)
	}
	if t.Object != nil {
		return visitor.VisitObject(t.Object)
	}
	if t.Union != nil {
		return visitor.VisitUnion(t.Union)
	}
	if t.UndiscriminatedUnion != nil {
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Type) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Alias != nil {
		fields = append(fields, "alias")
	}
	if t.Enum != nil {
		fields = append(fields, "enum")
	}
	if t.Object != nil {
		fields = append(fields, "object")
	}
	if t.Union != nil {
		fields = append(fields, "union")
	}
	if t.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// A type, which is a name and a shape
var (
	typeDeclarationFieldDocs                  = big.NewInt(1 << 0)
	typeDeclarationFieldAvailability          = big.NewInt(1 << 1)
	typeDeclarationFieldName                  = big.NewInt(1 << 2)
	typeDeclarationFieldShape                 = big.NewInt(1 << 3)
	typeDeclarationFieldAutogeneratedExamples = big.NewInt(1 << 4)
	typeDeclarationFieldUserProvidedExamples  = big.NewInt(1 << 5)
	typeDeclarationFieldV2Examples            = big.NewInt(1 << 6)
	typeDeclarationFieldReferencedTypes       = big.NewInt(1 << 7)
	typeDeclarationFieldEncoding              = big.NewInt(1 << 8)
	typeDeclarationFieldSource                = big.NewInt(1 << 9)
	typeDeclarationFieldInline                = big.NewInt(1 << 10)
)

type TypeDeclaration struct {
	Docs                  *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability          *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name                  *DeclaredTypeName `json:"name" url:"name"`
	Shape                 *Type             `json:"shape" url:"shape"`
	AutogeneratedExamples []*ExampleType    `json:"autogeneratedExamples" url:"autogeneratedExamples"`
	UserProvidedExamples  []*ExampleType    `json:"userProvidedExamples" url:"userProvidedExamples"`
	V2Examples            *V2SchemaExamples `json:"v2Examples,omitempty" url:"v2Examples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []common.TypeId `json:"referencedTypes" url:"referencedTypes"`
	Encoding        *Encoding       `json:"encoding,omitempty" url:"encoding,omitempty"`
	Source          *Source         `json:"source,omitempty" url:"source,omitempty"`
	// Whether to try and inline the type declaration
	Inline *bool `json:"inline,omitempty" url:"inline,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (t *TypeDeclaration) GetDocs() *string {
	if t == nil {
		return nil
	}
	return t.Docs
}

func (t *TypeDeclaration) GetAvailability() *Availability {
	if t == nil {
		return nil
	}
	return t.Availability
}

func (t *TypeDeclaration) GetName() *DeclaredTypeName {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TypeDeclaration) GetShape() *Type {
	if t == nil {
		return nil
	}
	return t.Shape
}

func (t *TypeDeclaration) GetAutogeneratedExamples() []*ExampleType {
	if t == nil {
		return nil
	}
	return t.AutogeneratedExamples
}

func (t *TypeDeclaration) GetUserProvidedExamples() []*ExampleType {
	if t == nil {
		return nil
	}
	return t.UserProvidedExamples
}

func (t *TypeDeclaration) GetV2Examples() *V2SchemaExamples {
	if t == nil {
		return nil
	}
	return t.V2Examples
}

func (t *TypeDeclaration) GetReferencedTypes() []common.TypeId {
	if t == nil {
		return nil
	}
	return t.ReferencedTypes
}

func (t *TypeDeclaration) GetEncoding() *Encoding {
	if t == nil {
		return nil
	}
	return t.Encoding
}

func (t *TypeDeclaration) GetSource() *Source {
	if t == nil {
		return nil
	}
	return t.Source
}

func (t *TypeDeclaration) GetInline() *bool {
	if t == nil {
		return nil
	}
	return t.Inline
}

func (t *TypeDeclaration) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypeDeclaration) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetDocs(docs *string) {
	t.Docs = docs
	t.require(typeDeclarationFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetAvailability(availability *Availability) {
	t.Availability = availability
	t.require(typeDeclarationFieldAvailability)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetName(name *DeclaredTypeName) {
	t.Name = name
	t.require(typeDeclarationFieldName)
}

// SetShape sets the Shape field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetShape(shape *Type) {
	t.Shape = shape
	t.require(typeDeclarationFieldShape)
}

// SetAutogeneratedExamples sets the AutogeneratedExamples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetAutogeneratedExamples(autogeneratedExamples []*ExampleType) {
	t.AutogeneratedExamples = autogeneratedExamples
	t.require(typeDeclarationFieldAutogeneratedExamples)
}

// SetUserProvidedExamples sets the UserProvidedExamples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetUserProvidedExamples(userProvidedExamples []*ExampleType) {
	t.UserProvidedExamples = userProvidedExamples
	t.require(typeDeclarationFieldUserProvidedExamples)
}

// SetV2Examples sets the V2Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetV2Examples(v2Examples *V2SchemaExamples) {
	t.V2Examples = v2Examples
	t.require(typeDeclarationFieldV2Examples)
}

// SetReferencedTypes sets the ReferencedTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetReferencedTypes(referencedTypes []common.TypeId) {
	t.ReferencedTypes = referencedTypes
	t.require(typeDeclarationFieldReferencedTypes)
}

// SetEncoding sets the Encoding field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetEncoding(encoding *Encoding) {
	t.Encoding = encoding
	t.require(typeDeclarationFieldEncoding)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetSource(source *Source) {
	t.Source = source
	t.require(typeDeclarationFieldSource)
}

// SetInline sets the Inline field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypeDeclaration) SetInline(inline *bool) {
	t.Inline = inline
	t.require(typeDeclarationFieldInline)
}

func (t *TypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler TypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed TypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *NamedType
	Primitive *PrimitiveType
	Unknown   interface{}
}

func (t *TypeReference) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TypeReference) GetContainer() *ContainerType {
	if t == nil {
		return nil
	}
	return t.Container
}

func (t *TypeReference) GetNamed() *NamedType {
	if t == nil {
		return nil
	}
	return t.Named
}

func (t *TypeReference) GetPrimitive() *PrimitiveType {
	if t == nil {
		return nil
	}
	return t.Primitive
}

func (t *TypeReference) GetUnknown() interface{} {
	if t == nil {
		return nil
	}
	return t.Unknown
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(NamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *PrimitiveType `json:"primitive"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Container != nil {
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container"`
		}{
			Type:      "container",
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	}
	if t.Named != nil {
		return internal.MarshalJSONWithExtraProperty(t.Named, "_type", "named")
	}
	if t.Primitive != nil {
		var marshaler = struct {
			Type      string         `json:"_type"`
			Primitive *PrimitiveType `json:"primitive"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if t.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*NamedType) error
	VisitPrimitive(*PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	if t.Container != nil {
		return visitor.VisitContainer(t.Container)
	}
	if t.Named != nil {
		return visitor.VisitNamed(t.Named)
	}
	if t.Primitive != nil {
		return visitor.VisitPrimitive(t.Primitive)
	}
	if t.Unknown != nil {
		return visitor.VisitUnknown(t.Unknown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *TypeReference) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Container != nil {
		fields = append(fields, "container")
	}
	if t.Named != nil {
		fields = append(fields, "named")
	}
	if t.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if t.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type Uint64Type struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *Uint64Type) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Uint64Type) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

func (u *Uint64Type) UnmarshalJSON(data []byte) error {
	type unmarshaler Uint64Type
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Uint64Type(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *Uint64Type) MarshalJSON() ([]byte, error) {
	type embed Uint64Type
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *Uint64Type) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UintType struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UintType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UintType) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

func (u *UintType) UnmarshalJSON(data []byte) error {
	type unmarshaler UintType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UintType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UintType) MarshalJSON() ([]byte, error) {
	type embed UintType
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UintType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	undiscriminatedUnionMemberFieldDocs = big.NewInt(1 << 0)
	undiscriminatedUnionMemberFieldType = big.NewInt(1 << 1)
)

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Type *TypeReference `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionMember) GetDocs() *string {
	if u == nil {
		return nil
	}
	return u.Docs
}

func (u *UndiscriminatedUnionMember) GetType() *TypeReference {
	if u == nil {
		return nil
	}
	return u.Type
}

func (u *UndiscriminatedUnionMember) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionMember) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UndiscriminatedUnionMember) SetDocs(docs *string) {
	u.Docs = docs
	u.require(undiscriminatedUnionMemberFieldDocs)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UndiscriminatedUnionMember) SetType(type_ *TypeReference) {
	u.Type = type_
	u.require(undiscriminatedUnionMemberFieldType)
}

func (u *UndiscriminatedUnionMember) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionMember(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionMember) MarshalJSON() ([]byte, error) {
	type embed UndiscriminatedUnionMember
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UndiscriminatedUnionMember) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	undiscriminatedUnionTypeDeclarationFieldMembers = big.NewInt(1 << 0)
)

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members" url:"members"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionTypeDeclaration) GetMembers() []*UndiscriminatedUnionMember {
	if u == nil {
		return nil
	}
	return u.Members
}

func (u *UndiscriminatedUnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionTypeDeclaration) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetMembers sets the Members field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UndiscriminatedUnionTypeDeclaration) SetMembers(members []*UndiscriminatedUnionMember) {
	u.Members = members
	u.require(undiscriminatedUnionTypeDeclarationFieldMembers)
}

func (u *UndiscriminatedUnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionTypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed UndiscriminatedUnionTypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UndiscriminatedUnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	unionTypeDeclarationFieldDiscriminant   = big.NewInt(1 << 0)
	unionTypeDeclarationFieldExtends        = big.NewInt(1 << 1)
	unionTypeDeclarationFieldTypes          = big.NewInt(1 << 2)
	unionTypeDeclarationFieldBaseProperties = big.NewInt(1 << 3)
)

type UnionTypeDeclaration struct {
	Discriminant *common.NameAndWireValue `json:"discriminant" url:"discriminant"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends" url:"extends"`
	Types          []*SingleUnionType  `json:"types" url:"types"`
	BaseProperties []*ObjectProperty   `json:"baseProperties" url:"baseProperties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UnionTypeDeclaration) GetDiscriminant() *common.NameAndWireValue {
	if u == nil {
		return nil
	}
	return u.Discriminant
}

func (u *UnionTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if u == nil {
		return nil
	}
	return u.Extends
}

func (u *UnionTypeDeclaration) GetTypes() []*SingleUnionType {
	if u == nil {
		return nil
	}
	return u.Types
}

func (u *UnionTypeDeclaration) GetBaseProperties() []*ObjectProperty {
	if u == nil {
		return nil
	}
	return u.BaseProperties
}

func (u *UnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnionTypeDeclaration) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetDiscriminant sets the Discriminant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnionTypeDeclaration) SetDiscriminant(discriminant *common.NameAndWireValue) {
	u.Discriminant = discriminant
	u.require(unionTypeDeclarationFieldDiscriminant)
}

// SetExtends sets the Extends field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnionTypeDeclaration) SetExtends(extends []*DeclaredTypeName) {
	u.Extends = extends
	u.require(unionTypeDeclarationFieldExtends)
}

// SetTypes sets the Types field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnionTypeDeclaration) SetTypes(types []*SingleUnionType) {
	u.Types = types
	u.require(unionTypeDeclarationFieldTypes)
}

// SetBaseProperties sets the BaseProperties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnionTypeDeclaration) SetBaseProperties(baseProperties []*ObjectProperty) {
	u.BaseProperties = baseProperties
	u.require(unionTypeDeclarationFieldBaseProperties)
}

func (u *UnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UnionTypeDeclaration) MarshalJSON() ([]byte, error) {
	type embed UnionTypeDeclaration
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UuidType struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (u *UuidType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UuidType) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

func (u *UuidType) UnmarshalJSON(data []byte) error {
	type unmarshaler UuidType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UuidType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UuidType) MarshalJSON() ([]byte, error) {
	type embed UuidType
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UuidType) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

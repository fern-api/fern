// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	core "github.com/fern-api/fern-go/internal/generator/model/core"
	uuid "github.com/google/uuid"
)

type ApiAuth struct {
	Docs        *string                `json:"docs,omitempty"`
	Requirement AuthSchemesRequirement `json:"requirement,omitempty"`
	Schemes     []*AuthScheme          `json:"schemes,omitempty"`
}

func (a *ApiAuth) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthScheme struct {
	Type   string
	Bearer *BearerAuthScheme
	Basic  *BasicAuthScheme
	Header *HeaderAuthScheme
}

func NewAuthSchemeFromBearer(value *BearerAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "bearer", Bearer: value}
}

func NewAuthSchemeFromBasic(value *BasicAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "basic", Basic: value}
}

func NewAuthSchemeFromHeader(value *HeaderAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "header", Header: value}
}

func (a *AuthScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bearer":
		value := new(BearerAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "basic":
		value := new(BasicAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "header":
		value := new(HeaderAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a AuthScheme) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		var marshaler = struct {
			Type string `json:"_type"`
			*BearerAuthScheme
		}{
			Type:             a.Type,
			BearerAuthScheme: a.Bearer,
		}
		return json.Marshal(marshaler)
	case "basic":
		var marshaler = struct {
			Type string `json:"_type"`
			*BasicAuthScheme
		}{
			Type:            a.Type,
			BasicAuthScheme: a.Basic,
		}
		return json.Marshal(marshaler)
	case "header":
		var marshaler = struct {
			Type string `json:"_type"`
			*HeaderAuthScheme
		}{
			Type:             a.Type,
			HeaderAuthScheme: a.Header,
		}
		return json.Marshal(marshaler)
	}
}

type AuthSchemeVisitor interface {
	VisitBearer(*BearerAuthScheme) error
	VisitBasic(*BasicAuthScheme) error
	VisitHeader(*HeaderAuthScheme) error
}

func (a *AuthScheme) Accept(visitor AuthSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

type AuthSchemesRequirement string

const (
	AuthSchemesRequirementAll AuthSchemesRequirement = "ALL"
	AuthSchemesRequirementAny AuthSchemesRequirement = "ANY"
)

func NewAuthSchemesRequirementFromString(s string) (AuthSchemesRequirement, error) {
	switch s {
	case "ALL":
		return AuthSchemesRequirementAll, nil
	case "ANY":
		return AuthSchemesRequirementAny, nil
	}
	var t AuthSchemesRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthSchemesRequirement) Ptr() *AuthSchemesRequirement {
	return &a
}

type BasicAuthScheme struct {
	Docs     *string `json:"docs,omitempty"`
	Username *Name   `json:"username,omitempty"`
	// The environment variable the SDK should use to read the username.
	UsernameEnvVar *EnvironmentVariable `json:"usernameEnvVar,omitempty"`
	Password       *Name                `json:"password,omitempty"`
	// The environment variable the SDK should use to read the password.
	PasswordEnvVar *EnvironmentVariable `json:"passwordEnvVar,omitempty"`
}

func (b *BasicAuthScheme) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthScheme struct {
	Docs  *string `json:"docs,omitempty"`
	Token *Name   `json:"token,omitempty"`
	// The environment variable the SDK should use to read the token.
	TokenEnvVar *EnvironmentVariable `json:"tokenEnvVar,omitempty"`
}

func (b *BearerAuthScheme) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type EnvironmentVariable = string

type HeaderAuthScheme struct {
	Docs      *string           `json:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty"`
	Prefix    *string           `json:"prefix,omitempty"`
	// The environment variable the SDK should use to read the header.
	HeaderEnvVar *EnvironmentVariable `json:"headerEnvVar,omitempty"`
}

func (h *HeaderAuthScheme) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Availability struct {
	Status  AvailabilityStatus `json:"status,omitempty"`
	Message *string            `json:"message,omitempty"`
}

func (a *Availability) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

type Declaration struct {
	Docs         *string       `json:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty"`
}

func (d *Declaration) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointId = string

type ErrorId = string

// Defines the original string, and its escaped-equivalent (depending on the target programming language).
// This is paricularly relevant to example string literals.
//
// For example, in Python we escape strings that contain single or double quotes by using triple quotes,
// in Go we use backticks, etc.
type EscapedString struct {
	Original string `json:"original"`
}

func (e *EscapedString) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FernFilepath struct {
	AllParts    []*Name `json:"allParts,omitempty"`
	PackagePath []*Name `json:"packagePath,omitempty"`
	File        *Name   `json:"file,omitempty"`
}

func (f *FernFilepath) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Name struct {
	OriginalName       string               `json:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase,omitempty"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase,omitempty"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase,omitempty"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase,omitempty"`
}

func (n *Name) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NameAndWireValue struct {
	WireValue string `json:"wireValue"`
	Name      *Name  `json:"name,omitempty"`
}

func (n *NameAndWireValue) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName"`
}

func (s *SafeAndUnsafeString) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceId = string

type SubpackageId = string

type TypeId = string

type WebhookGroupId = string

type WithDocs struct {
	Docs *string `json:"docs,omitempty"`
}

func (w *WithDocs) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WithJsonExample struct {
	JsonExample interface{} `json:"jsonExample,omitempty"`
}

func (w *WithJsonExample) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type Constants struct {
	ErrorInstanceIdKey *NameAndWireValue `json:"errorInstanceIdKey,omitempty"`
}

func (c *Constants) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EnvironmentBaseUrlId = string

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id"`
	Name *Name                `json:"name,omitempty"`
}

func (e *EnvironmentBaseUrlWithId) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func NewEnvironmentsFromSingleBaseUrl(value *SingleBaseUrlEnvironments) *Environments {
	return &Environments{Type: "singleBaseUrl", SingleBaseUrl: value}
}

func NewEnvironmentsFromMultipleBaseUrls(value *MultipleBaseUrlsEnvironments) *Environments {
	return &Environments{Type: "multipleBaseUrls", MultipleBaseUrls: value}
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		var marshaler = struct {
			Type string `json:"type"`
			*SingleBaseUrlEnvironments
		}{
			Type:                      e.Type,
			SingleBaseUrlEnvironments: e.SingleBaseUrl,
		}
		return json.Marshal(marshaler)
	case "multipleBaseUrls":
		var marshaler = struct {
			Type string `json:"type"`
			*MultipleBaseUrlsEnvironments
		}{
			Type:                         e.Type,
			MultipleBaseUrlsEnvironments: e.MultipleBaseUrls,
		}
		return json.Marshal(marshaler)
	}
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	case "multipleBaseUrls":
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
}

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments,omitempty"`
}

func (e *EnvironmentsConfig) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id"`
	Name *Name                                   `json:"name,omitempty"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls,omitempty"`
}

func (m *MultipleBaseUrlsEnvironment) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls,omitempty"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments,omitempty"`
}

func (m *MultipleBaseUrlsEnvironments) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty"`
	Id   EnvironmentId  `json:"id"`
	Name *Name          `json:"name,omitempty"`
	Url  EnvironmentUrl `json:"url"`
}

func (s *SingleBaseUrlEnvironment) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments,omitempty"`
}

func (s *SingleBaseUrlEnvironments) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type DeclaredErrorName struct {
	ErrorId      ErrorId       `json:"errorId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty"`
}

func (d *DeclaredErrorName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ErrorDeclaration struct {
	Docs              *string            `json:"docs,omitempty"`
	Name              *DeclaredErrorName `json:"name,omitempty"`
	DiscriminantValue *NameAndWireValue  `json:"discriminantValue,omitempty"`
	Type              *TypeReference     `json:"type,omitempty"`
	StatusCode        int                `json:"statusCode"`
}

func (e *ErrorDeclaration) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *NameAndWireValue
	StatusCode interface{}
}

func NewErrorDeclarationDiscriminantValueFromProperty(value *NameAndWireValue) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "property", Property: value}
}

func NewErrorDeclarationDiscriminantValueFromStatusCode(value interface{}) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "statusCode", StatusCode: value}
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "property":
		value := new(NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*NameAndWireValue
		}{
			Type:             e.Type,
			NameAndWireValue: e.Property,
		}
		return json.Marshal(marshaler)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       e.Type,
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*NameAndWireValue) error
	VisitStatusCode(interface{}) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return visitor.VisitProperty(e.Property)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	}
}

type BytesRequest struct {
	IsOptional  bool    `json:"isOptional"`
	ContentType *string `json:"contentType,omitempty"`
}

func (b *BytesRequest) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type DeclaredServiceName struct {
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
}

func (d *DeclaredServiceName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointName = *Name

type ExampleEndpointCall struct {
	Docs                   *string                  `json:"docs,omitempty"`
	Name                   *Name                    `json:"name,omitempty"`
	Url                    string                   `json:"url"`
	RootPathParameters     []*ExamplePathParameter  `json:"rootPathParameters,omitempty"`
	ServicePathParameters  []*ExamplePathParameter  `json:"servicePathParameters,omitempty"`
	EndpointPathParameters []*ExamplePathParameter  `json:"endpointPathParameters,omitempty"`
	ServiceHeaders         []*ExampleHeader         `json:"serviceHeaders,omitempty"`
	EndpointHeaders        []*ExampleHeader         `json:"endpointHeaders,omitempty"`
	QueryParameters        []*ExampleQueryParameter `json:"queryParameters,omitempty"`
	Request                *ExampleRequestBody      `json:"request,omitempty"`
	Response               *ExampleResponse         `json:"response,omitempty"`
}

func (e *ExampleEndpointCall) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointErrorResponse struct {
	Error *DeclaredErrorName    `json:"error,omitempty"`
	Body  *ExampleTypeReference `json:"body,omitempty"`
}

func (e *ExampleEndpointErrorResponse) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointSuccessResponse struct {
	Body *ExampleTypeReference `json:"body,omitempty"`
}

func (e *ExampleEndpointSuccessResponse) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleHeader struct {
	Name  *NameAndWireValue     `json:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

func (e *ExampleHeader) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBody struct {
	JsonExample interface{}                          `json:"jsonExample,omitempty"`
	Properties  []*ExampleInlinedRequestBodyProperty `json:"properties,omitempty"`
}

func (e *ExampleInlinedRequestBody) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBodyProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty"`
}

func (e *ExampleInlinedRequestBodyProperty) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePathParameter struct {
	Name  *Name                 `json:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

func (e *ExamplePathParameter) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleQueryParameter struct {
	Name  *NameAndWireValue     `json:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

func (e *ExampleQueryParameter) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleRequestBody struct {
	Type               string
	InlinedRequestBody *ExampleInlinedRequestBody
	Reference          *ExampleTypeReference
}

func NewExampleRequestBodyFromInlinedRequestBody(value *ExampleInlinedRequestBody) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewExampleRequestBodyFromReference(value *ExampleTypeReference) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "reference", Reference: value}
}

func (e *ExampleRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedRequestBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleRequestBody) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleInlinedRequestBody
		}{
			Type:                      e.Type,
			ExampleInlinedRequestBody: e.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 e.Type,
			ExampleTypeReference: e.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleRequestBodyVisitor interface {
	VisitInlinedRequestBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleRequestBody) Accept(visitor ExampleRequestBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(e.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

type ExampleResponse struct {
	Type  string
	Ok    *ExampleEndpointSuccessResponse
	Error *ExampleEndpointErrorResponse
}

func NewExampleResponseFromOk(value *ExampleEndpointSuccessResponse) *ExampleResponse {
	return &ExampleResponse{Type: "ok", Ok: value}
}

func NewExampleResponseFromError(value *ExampleEndpointErrorResponse) *ExampleResponse {
	return &ExampleResponse{Type: "error", Error: value}
}

func (e *ExampleResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "ok":
		value := new(ExampleEndpointSuccessResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Ok = value
	case "error":
		value := new(ExampleEndpointErrorResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExampleResponse) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointSuccessResponse
		}{
			Type:                           e.Type,
			ExampleEndpointSuccessResponse: e.Ok,
		}
		return json.Marshal(marshaler)
	case "error":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointErrorResponse
		}{
			Type:                         e.Type,
			ExampleEndpointErrorResponse: e.Error,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleResponseVisitor interface {
	VisitOk(*ExampleEndpointSuccessResponse) error
	VisitError(*ExampleEndpointErrorResponse) error
}

func (e *ExampleResponse) Accept(visitor ExampleResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return visitor.VisitOk(e.Ok)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

type FileDownloadResponse struct {
	Docs *string `json:"docs,omitempty"`
}

func (f *FileDownloadResponse) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileProperty struct {
	Key        *NameAndWireValue `json:"key,omitempty"`
	IsOptional bool              `json:"isOptional"`
}

func (f *FileProperty) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequest struct {
	Name       *Name                        `json:"name,omitempty"`
	Properties []*FileUploadRequestProperty `json:"properties,omitempty"`
}

func (f *FileUploadRequest) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestProperty struct {
	Type         string
	File         *FileProperty
	BodyProperty *InlinedRequestBodyProperty
}

func NewFileUploadRequestPropertyFromFile(value *FileProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "file", File: value}
}

func NewFileUploadRequestPropertyFromBodyProperty(value *InlinedRequestBodyProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "file":
		value := new(FileProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "bodyProperty":
		value := new(InlinedRequestBodyProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestProperty) MarshalJSON() ([]byte, error) {
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		var marshaler = struct {
			Type string `json:"type"`
			*FileProperty
		}{
			Type:         f.Type,
			FileProperty: f.File,
		}
		return json.Marshal(marshaler)
	case "bodyProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBodyProperty
		}{
			Type:                       f.Type,
			InlinedRequestBodyProperty: f.BodyProperty,
		}
		return json.Marshal(marshaler)
	}
}

type FileUploadRequestPropertyVisitor interface {
	VisitFile(*FileProperty) error
	VisitBodyProperty(*InlinedRequestBodyProperty) error
}

func (f *FileUploadRequestProperty) Accept(visitor FileUploadRequestPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

type HttpEndpoint struct {
	Docs              *string                `json:"docs,omitempty"`
	Availability      *Availability          `json:"availability,omitempty"`
	Id                EndpointId             `json:"id"`
	Name              EndpointName           `json:"name,omitempty"`
	DisplayName       *string                `json:"displayName,omitempty"`
	Method            HttpMethod             `json:"method,omitempty"`
	Headers           []*HttpHeader          `json:"headers,omitempty"`
	BaseUrl           *EnvironmentBaseUrlId  `json:"baseUrl,omitempty"`
	Path              *HttpPath              `json:"path,omitempty"`
	FullPath          *HttpPath              `json:"fullPath,omitempty"`
	PathParameters    []*PathParameter       `json:"pathParameters,omitempty"`
	AllPathParameters []*PathParameter       `json:"allPathParameters,omitempty"`
	QueryParameters   []*QueryParameter      `json:"queryParameters,omitempty"`
	RequestBody       *HttpRequestBody       `json:"requestBody,omitempty"`
	SdkRequest        *SdkRequest            `json:"sdkRequest,omitempty"`
	Response          *HttpResponse          `json:"response,omitempty"`
	Errors            ResponseErrors         `json:"errors,omitempty"`
	Auth              bool                   `json:"auth"`
	Idempotent        bool                   `json:"idempotent"`
	Examples          []*ExampleEndpointCall `json:"examples,omitempty"`
}

func (h *HttpEndpoint) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpHeader struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty"`
}

func (h *HttpHeader) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type HttpPath struct {
	Head  string          `json:"head"`
	Parts []*HttpPathPart `json:"parts,omitempty"`
}

func (h *HttpPath) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpPathPart struct {
	PathParameter string `json:"pathParameter"`
	Tail          string `json:"tail"`
}

func (h *HttpPathPart) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpRequestBody struct {
	Type               string
	InlinedRequestBody *InlinedRequestBody
	Reference          *HttpRequestBodyReference
	FileUpload         *FileUploadRequest
	Bytes              *BytesRequest
}

func NewHttpRequestBodyFromInlinedRequestBody(value *InlinedRequestBody) *HttpRequestBody {
	return &HttpRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewHttpRequestBodyFromReference(value *HttpRequestBodyReference) *HttpRequestBody {
	return &HttpRequestBody{Type: "reference", Reference: value}
}

func NewHttpRequestBodyFromFileUpload(value *FileUploadRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "fileUpload", FileUpload: value}
}

func NewHttpRequestBodyFromBytes(value *BytesRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "bytes", Bytes: value}
}

func (h *HttpRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(InlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.InlinedRequestBody = value
	case "reference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Reference = value
	case "fileUpload":
		value := new(FileUploadRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileUpload = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Bytes = value
	}
	return nil
}

func (h HttpRequestBody) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBody
		}{
			Type:               h.Type,
			InlinedRequestBody: h.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     h.Type,
			HttpRequestBodyReference: h.Reference,
		}
		return json.Marshal(marshaler)
	case "fileUpload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileUploadRequest
		}{
			Type:              h.Type,
			FileUploadRequest: h.FileUpload,
		}
		return json.Marshal(marshaler)
	case "bytes":
		var marshaler = struct {
			Type string `json:"type"`
			*BytesRequest
		}{
			Type:         h.Type,
			BytesRequest: h.Bytes,
		}
		return json.Marshal(marshaler)
	}
}

type HttpRequestBodyVisitor interface {
	VisitInlinedRequestBody(*InlinedRequestBody) error
	VisitReference(*HttpRequestBodyReference) error
	VisitFileUpload(*FileUploadRequest) error
	VisitBytes(*BytesRequest) error
}

func (h *HttpRequestBody) Accept(visitor HttpRequestBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(h.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(h.Reference)
	case "fileUpload":
		return visitor.VisitFileUpload(h.FileUpload)
	case "bytes":
		return visitor.VisitBytes(h.Bytes)
	}
}

type HttpRequestBodyReference struct {
	Docs            *string        `json:"docs,omitempty"`
	RequestBodyType *TypeReference `json:"requestBodyType,omitempty"`
	ContentType     *string        `json:"contentType,omitempty"`
}

func (h *HttpRequestBodyReference) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpResponse struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
	Text         *TextResponse
	Streaming    *StreamingResponse
}

func NewHttpResponseFromJson(value *JsonResponse) *HttpResponse {
	return &HttpResponse{Type: "json", Json: value}
}

func NewHttpResponseFromFileDownload(value *FileDownloadResponse) *HttpResponse {
	return &HttpResponse{Type: "fileDownload", FileDownload: value}
}

func NewHttpResponseFromText(value *TextResponse) *HttpResponse {
	return &HttpResponse{Type: "text", Text: value}
}

func NewHttpResponseFromStreaming(value *StreamingResponse) *HttpResponse {
	return &HttpResponse{Type: "streaming", Streaming: value}
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		var valueUnmarshaler struct {
			Json *JsonResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.Json = valueUnmarshaler.Json
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	case "text":
		value := new(TextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Text = value
	case "streaming":
		value := new(StreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Streaming = value
	}
	return nil
}

func (h HttpResponse) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		var marshaler = struct {
			Type string        `json:"type"`
			Json *JsonResponse `json:"value,omitempty"`
		}{
			Type: h.Type,
			Json: h.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileDownloadResponse
		}{
			Type:                 h.Type,
			FileDownloadResponse: h.FileDownload,
		}
		return json.Marshal(marshaler)
	case "text":
		var marshaler = struct {
			Type string `json:"type"`
			*TextResponse
		}{
			Type:         h.Type,
			TextResponse: h.Text,
		}
		return json.Marshal(marshaler)
	case "streaming":
		var marshaler = struct {
			Type string `json:"type"`
			*StreamingResponse
		}{
			Type:              h.Type,
			StreamingResponse: h.Streaming,
		}
		return json.Marshal(marshaler)
	}
}

type HttpResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
	VisitText(*TextResponse) error
	VisitStreaming(*StreamingResponse) error
}

func (h *HttpResponse) Accept(visitor HttpResponseVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return visitor.VisitJson(h.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(h.FileDownload)
	case "text":
		return visitor.VisitText(h.Text)
	case "streaming":
		return visitor.VisitStreaming(h.Streaming)
	}
}

type HttpService struct {
	Availability   *Availability        `json:"availability,omitempty"`
	Name           *DeclaredServiceName `json:"name,omitempty"`
	DisplayName    *string              `json:"displayName,omitempty"`
	BasePath       *HttpPath            `json:"basePath,omitempty"`
	Endpoints      []*HttpEndpoint      `json:"endpoints,omitempty"`
	Headers        []*HttpHeader        `json:"headers,omitempty"`
	PathParameters []*PathParameter     `json:"pathParameters,omitempty"`
}

func (h *HttpService) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InlinedRequestBody struct {
	Name        *Name                         `json:"name,omitempty"`
	Extends     []*DeclaredTypeName           `json:"extends,omitempty"`
	Properties  []*InlinedRequestBodyProperty `json:"properties,omitempty"`
	ContentType *string                       `json:"contentType,omitempty"`
}

func (i *InlinedRequestBody) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBodyProperty struct {
	Docs      *string           `json:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty"`
}

func (i *InlinedRequestBodyProperty) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonResponse struct {
	Type                     string
	Response                 *JsonResponseBody
	NestedPropertyAsResponse *JsonResponseBodyWithProperty
}

func NewJsonResponseFromResponse(value *JsonResponseBody) *JsonResponse {
	return &JsonResponse{Type: "response", Response: value}
}

func NewJsonResponseFromNestedPropertyAsResponse(value *JsonResponseBodyWithProperty) *JsonResponse {
	return &JsonResponse{Type: "nestedPropertyAsResponse", NestedPropertyAsResponse: value}
}

func (j *JsonResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "response":
		value := new(JsonResponseBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Response = value
	case "nestedPropertyAsResponse":
		value := new(JsonResponseBodyWithProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.NestedPropertyAsResponse = value
	}
	return nil
}

func (j JsonResponse) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponseBody
		}{
			Type:             j.Type,
			JsonResponseBody: j.Response,
		}
		return json.Marshal(marshaler)
	case "nestedPropertyAsResponse":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponseBodyWithProperty
		}{
			Type:                         j.Type,
			JsonResponseBodyWithProperty: j.NestedPropertyAsResponse,
		}
		return json.Marshal(marshaler)
	}
}

type JsonResponseVisitor interface {
	VisitResponse(*JsonResponseBody) error
	VisitNestedPropertyAsResponse(*JsonResponseBodyWithProperty) error
}

func (j *JsonResponse) Accept(visitor JsonResponseVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		return visitor.VisitResponse(j.Response)
	case "nestedPropertyAsResponse":
		return visitor.VisitNestedPropertyAsResponse(j.NestedPropertyAsResponse)
	}
}

type JsonResponseBody struct {
	Docs             *string        `json:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty"`
}

func (j *JsonResponseBody) String() string {
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JsonResponseBodyWithProperty struct {
	Docs             *string        `json:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty"`
	// If set, the SDK will return this property from
	// the response, rather than the response itself.
	//
	// This is particularly useful for JSON API structures
	// (e.g. configure 'data' to return 'response.data').
	ResponseProperty *ObjectProperty `json:"responseProperty,omitempty"`
}

func (j *JsonResponseBodyWithProperty) String() string {
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type PathParameter struct {
	Docs      *string               `json:"docs,omitempty"`
	Name      *Name                 `json:"name,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty"`
	Location  PathParameterLocation `json:"location,omitempty"`
	Variable  *VariableId           `json:"variable,omitempty"`
}

func (p *PathParameter) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PathParameterLocation string

const (
	PathParameterLocationRoot     PathParameterLocation = "ROOT"
	PathParameterLocationService  PathParameterLocation = "SERVICE"
	PathParameterLocationEndpoint PathParameterLocation = "ENDPOINT"
)

func NewPathParameterLocationFromString(s string) (PathParameterLocation, error) {
	switch s {
	case "ROOT":
		return PathParameterLocationRoot, nil
	case "SERVICE":
		return PathParameterLocationService, nil
	case "ENDPOINT":
		return PathParameterLocationEndpoint, nil
	}
	var t PathParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PathParameterLocation) Ptr() *PathParameterLocation {
	return &p
}

type QueryParameter struct {
	Docs          *string           `json:"docs,omitempty"`
	Availability  *Availability     `json:"availability,omitempty"`
	Name          *NameAndWireValue `json:"name,omitempty"`
	ValueType     *TypeReference    `json:"valueType,omitempty"`
	AllowMultiple bool              `json:"allowMultiple"`
}

func (q *QueryParameter) String() string {
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type ResponseError struct {
	Docs  *string            `json:"docs,omitempty"`
	Error *DeclaredErrorName `json:"error,omitempty"`
}

func (r *ResponseError) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseErrors = []*ResponseError

type SdkRequest struct {
	RequestParameterName *Name            `json:"requestParameterName,omitempty"`
	Shape                *SdkRequestShape `json:"shape,omitempty"`
}

func (s *SdkRequest) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SdkRequestBodyType struct {
	Type          string
	TypeReference *HttpRequestBodyReference
	Bytes         *BytesRequest
}

func NewSdkRequestBodyTypeFromTypeReference(value *HttpRequestBodyReference) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "typeReference", TypeReference: value}
}

func NewSdkRequestBodyTypeFromBytes(value *BytesRequest) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "bytes", Bytes: value}
}

func (s *SdkRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "typeReference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TypeReference = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Bytes = value
	}
	return nil
}

func (s SdkRequestBodyType) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     s.Type,
			HttpRequestBodyReference: s.TypeReference,
		}
		return json.Marshal(marshaler)
	case "bytes":
		var marshaler = struct {
			Type string `json:"type"`
			*BytesRequest
		}{
			Type:         s.Type,
			BytesRequest: s.Bytes,
		}
		return json.Marshal(marshaler)
	}
}

type SdkRequestBodyTypeVisitor interface {
	VisitTypeReference(*HttpRequestBodyReference) error
	VisitBytes(*BytesRequest) error
}

func (s *SdkRequestBodyType) Accept(visitor SdkRequestBodyTypeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		return visitor.VisitTypeReference(s.TypeReference)
	case "bytes":
		return visitor.VisitBytes(s.Bytes)
	}
}

type SdkRequestShape struct {
	Type            string
	JustRequestBody *SdkRequestBodyType
	Wrapper         *SdkRequestWrapper
}

func NewSdkRequestShapeFromJustRequestBody(value *SdkRequestBodyType) *SdkRequestShape {
	return &SdkRequestShape{Type: "justRequestBody", JustRequestBody: value}
}

func NewSdkRequestShapeFromWrapper(value *SdkRequestWrapper) *SdkRequestShape {
	return &SdkRequestShape{Type: "wrapper", Wrapper: value}
}

func (s *SdkRequestShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "justRequestBody":
		var valueUnmarshaler struct {
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.JustRequestBody = valueUnmarshaler.JustRequestBody
	case "wrapper":
		value := new(SdkRequestWrapper)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Wrapper = value
	}
	return nil
}

func (s SdkRequestShape) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		var marshaler = struct {
			Type            string              `json:"type"`
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}{
			Type:            s.Type,
			JustRequestBody: s.JustRequestBody,
		}
		return json.Marshal(marshaler)
	case "wrapper":
		var marshaler = struct {
			Type string `json:"type"`
			*SdkRequestWrapper
		}{
			Type:              s.Type,
			SdkRequestWrapper: s.Wrapper,
		}
		return json.Marshal(marshaler)
	}
}

type SdkRequestShapeVisitor interface {
	VisitJustRequestBody(*SdkRequestBodyType) error
	VisitWrapper(*SdkRequestWrapper) error
}

func (s *SdkRequestShape) Accept(visitor SdkRequestShapeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return visitor.VisitJustRequestBody(s.JustRequestBody)
	case "wrapper":
		return visitor.VisitWrapper(s.Wrapper)
	}
}

type SdkRequestWrapper struct {
	WrapperName *Name `json:"wrapperName,omitempty"`
	BodyKey     *Name `json:"bodyKey,omitempty"`
}

func (s *SdkRequestWrapper) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamingResponse struct {
	Docs          *string                     `json:"docs,omitempty"`
	DataEventType *StreamingResponseChunkType `json:"dataEventType,omitempty"`
	Terminator    *string                     `json:"terminator,omitempty"`
}

func (s *StreamingResponse) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamingResponseChunkType struct {
	Type string
	Json *TypeReference
	Text interface{}
}

func NewStreamingResponseChunkTypeFromJson(value *TypeReference) *StreamingResponseChunkType {
	return &StreamingResponseChunkType{Type: "json", Json: value}
}

func NewStreamingResponseChunkTypeFromText(value interface{}) *StreamingResponseChunkType {
	return &StreamingResponseChunkType{Type: "text", Text: value}
}

func (s *StreamingResponseChunkType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		var valueUnmarshaler struct {
			Json *TypeReference `json:"json,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.Json = valueUnmarshaler.Json
	case "text":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	}
	return nil
}

func (s StreamingResponseChunkType) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		var marshaler = struct {
			Type string         `json:"type"`
			Json *TypeReference `json:"json,omitempty"`
		}{
			Type: s.Type,
			Json: s.Json,
		}
		return json.Marshal(marshaler)
	case "text":
		var marshaler = struct {
			Type string      `json:"type"`
			Text interface{} `json:"text,omitempty"`
		}{
			Type: s.Type,
			Text: s.Text,
		}
		return json.Marshal(marshaler)
	}
}

type StreamingResponseChunkTypeVisitor interface {
	VisitJson(*TypeReference) error
	VisitText(interface{}) error
}

func (s *StreamingResponseChunkType) Accept(visitor StreamingResponseChunkTypeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return visitor.VisitJson(s.Json)
	case "text":
		return visitor.VisitText(s.Text)
	}
}

type TextResponse struct {
	Docs *string `json:"docs,omitempty"`
}

func (t *TextResponse) String() string {
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ErrorDiscriminationByPropertyStrategy struct {
	Discriminant    *NameAndWireValue `json:"discriminant,omitempty"`
	ContentProperty *NameAndWireValue `json:"contentProperty,omitempty"`
}

func (e *ErrorDiscriminationByPropertyStrategy) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDiscriminationStrategy struct {
	Type       string
	StatusCode interface{}
	Property   *ErrorDiscriminationByPropertyStrategy
}

func NewErrorDiscriminationStrategyFromStatusCode(value interface{}) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "statusCode", StatusCode: value}
}

func NewErrorDiscriminationStrategyFromProperty(value *ErrorDiscriminationByPropertyStrategy) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "property", Property: value}
}

func (e *ErrorDiscriminationStrategy) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	case "property":
		value := new(ErrorDiscriminationByPropertyStrategy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	}
	return nil
}

func (e ErrorDiscriminationStrategy) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       e.Type,
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*ErrorDiscriminationByPropertyStrategy
		}{
			Type:                                  e.Type,
			ErrorDiscriminationByPropertyStrategy: e.Property,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDiscriminationStrategyVisitor interface {
	VisitStatusCode(interface{}) error
	VisitProperty(*ErrorDiscriminationByPropertyStrategy) error
}

func (e *ErrorDiscriminationStrategy) Accept(visitor ErrorDiscriminationStrategyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	case "property":
		return visitor.VisitProperty(e.Property)
	}
}

// Complete representation of the API schema
type IntermediateRepresentation struct {
	// This is the human readable unique id for the API.
	ApiName        *Name    `json:"apiName,omitempty"`
	ApiDisplayName *string  `json:"apiDisplayName,omitempty"`
	ApiDocs        *string  `json:"apiDocs,omitempty"`
	Auth           *ApiAuth `json:"auth,omitempty"`
	// API Wide headers that are sent on every request
	Headers []*HttpHeader `json:"headers,omitempty"`
	// Headers that are sent for idempotent endpoints
	IdempotencyHeaders []*HttpHeader `json:"idempotencyHeaders,omitempty"`
	// The types described by this API
	Types map[TypeId]*TypeDeclaration `json:"types,omitempty"`
	// The services exposed by this API
	Services map[ServiceId]*HttpService `json:"services,omitempty"`
	// The webhooks sent by this API
	WebhookGroups               map[WebhookGroupId]WebhookGroup `json:"webhookGroups,omitempty"`
	Errors                      map[ErrorId]*ErrorDeclaration   `json:"errors,omitempty"`
	Subpackages                 map[SubpackageId]*Subpackage    `json:"subpackages,omitempty"`
	RootPackage                 *Package                        `json:"rootPackage,omitempty"`
	Constants                   *Constants                      `json:"constants,omitempty"`
	Environments                *EnvironmentsConfig             `json:"environments,omitempty"`
	BasePath                    *HttpPath                       `json:"basePath,omitempty"`
	PathParameters              []*PathParameter                `json:"pathParameters,omitempty"`
	ErrorDiscriminationStrategy *ErrorDiscriminationStrategy    `json:"errorDiscriminationStrategy,omitempty"`
	SdkConfig                   *SdkConfig                      `json:"sdkConfig,omitempty"`
	Variables                   []*VariableDeclaration          `json:"variables,omitempty"`
	ServiceTypeReferenceInfo    *ServiceTypeReferenceInfo       `json:"serviceTypeReferenceInfo,omitempty"`
}

func (i *IntermediateRepresentation) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Package struct {
	Docs               *string                  `json:"docs,omitempty"`
	FernFilepath       *FernFilepath            `json:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty"`
	Types              []TypeId                 `json:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty"`
}

func (p *Package) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PackageNavigationConfig struct {
	PointsTo SubpackageId `json:"pointsTo"`
}

func (p *PackageNavigationConfig) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlatformHeaders struct {
	Language   string `json:"language"`
	SdkName    string `json:"sdkName"`
	SdkVersion string `json:"sdkVersion"`
}

func (p *PlatformHeaders) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SdkConfig struct {
	IsAuthMandatory          bool             `json:"isAuthMandatory"`
	HasStreamingEndpoints    bool             `json:"hasStreamingEndpoints"`
	HasFileDownloadEndpoints bool             `json:"hasFileDownloadEndpoints"`
	PlatformHeaders          *PlatformHeaders `json:"platformHeaders,omitempty"`
}

func (s *SdkConfig) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceTypeReferenceInfo struct {
	// Types referenced by exactly one service.
	TypesReferencedOnlyByService map[ServiceId][]TypeId `json:"typesReferencedOnlyByService,omitempty"`
	// Types referenced by either zero or multiple services.
	SharedTypes []TypeId `json:"sharedTypes,omitempty"`
}

func (s *ServiceTypeReferenceInfo) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subpackage struct {
	Docs               *string                  `json:"docs,omitempty"`
	FernFilepath       *FernFilepath            `json:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty"`
	Types              []TypeId                 `json:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty"`
	Name               *Name                    `json:"name,omitempty"`
}

func (s *Subpackage) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf,omitempty"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType,omitempty"`
}

func (a *AliasTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func NewContainerTypeFromList(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "list", List: value}
}

func NewContainerTypeFromMap(value *MapType) *ContainerType {
	return &ContainerType{Type: "map", Map: value}
}

func NewContainerTypeFromOptional(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "optional", Optional: value}
}

func NewContainerTypeFromSet(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "set", Set: value}
}

func NewContainerTypeFromLiteral(value *Literal) *ContainerType {
	return &ContainerType{Type: "literal", Literal: value}
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list,omitempty"`
		}{
			Type: c.Type,
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string `json:"_type"`
			*MapType
		}{
			Type:    c.Type,
			MapType: c.Map,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional,omitempty"`
		}{
			Type:     c.Type,
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set,omitempty"`
		}{
			Type: c.Type,
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal,omitempty"`
		}{
			Type:    c.Type,
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "map":
		return visitor.VisitMap(c.Map)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	case "set":
		return visitor.VisitSet(c.Set)
	case "literal":
		return visitor.VisitLiteral(c.Literal)
	}
}

type DeclaredTypeName struct {
	TypeId       TypeId        `json:"typeId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty"`
}

func (d *DeclaredTypeName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumTypeDeclaration struct {
	Values []*EnumValue `json:"values,omitempty"`
}

func (e *EnumTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
}

func (e *EnumValue) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value,omitempty"`
}

func (e *ExampleAliasType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleContainer struct {
	Type     string
	List     []*ExampleTypeReference
	Set      []*ExampleTypeReference
	Optional *ExampleTypeReference
	Map      []*ExampleKeyValuePair
}

func NewExampleContainerFromList(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "list", List: value}
}

func NewExampleContainerFromSet(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "set", Set: value}
}

func NewExampleContainerFromOptional(value *ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "optional", Optional: value}
}

func NewExampleContainerFromMap(value []*ExampleKeyValuePair) *ExampleContainer {
	return &ExampleContainer{Type: "map", Map: value}
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*ExampleTypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.List = valueUnmarshaler.List
	case "set":
		var valueUnmarshaler struct {
			Set []*ExampleTypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Set = valueUnmarshaler.Set
	case "optional":
		var valueUnmarshaler struct {
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Optional = valueUnmarshaler.Optional
	case "map":
		var valueUnmarshaler struct {
			Map []*ExampleKeyValuePair `json:"map,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Map = valueUnmarshaler.Map
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		var marshaler = struct {
			Type string                  `json:"type"`
			List []*ExampleTypeReference `json:"list,omitempty"`
		}{
			Type: e.Type,
			List: e.List,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string                  `json:"type"`
			Set  []*ExampleTypeReference `json:"set,omitempty"`
		}{
			Type: e.Type,
			Set:  e.Set,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string                `json:"type"`
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}{
			Type:     e.Type,
			Optional: e.Optional,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string                 `json:"type"`
			Map  []*ExampleKeyValuePair `json:"map,omitempty"`
		}{
			Type: e.Type,
			Map:  e.Map,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleContainerVisitor interface {
	VisitList([]*ExampleTypeReference) error
	VisitSet([]*ExampleTypeReference) error
	VisitOptional(*ExampleTypeReference) error
	VisitMap([]*ExampleKeyValuePair) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return visitor.VisitList(e.List)
	case "set":
		return visitor.VisitSet(e.Set)
	case "optional":
		return visitor.VisitOptional(e.Optional)
	case "map":
		return visitor.VisitMap(e.Map)
	}
}

type ExampleEnumType struct {
	Value *NameAndWireValue `json:"value,omitempty"`
}

func (e *ExampleEnumType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
}

func (e *ExampleKeyValuePair) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName,omitempty"`
	Shape    *ExampleTypeShape `json:"shape,omitempty"`
}

func (e *ExampleNamedType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property.
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty"`
}

func (e *ExampleObjectProperty) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties,omitempty"`
}

func (e *ExampleObjectType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectTypeWithTypeId struct {
	TypeId TypeId             `json:"typeId"`
	Object *ExampleObjectType `json:"object,omitempty"`
}

func (e *ExampleObjectTypeWithTypeId) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePrimitive struct {
	Type     string
	Integer  int
	Double   float64
	String   *EscapedString
	Boolean  bool
	Long     int64
	Datetime time.Time
	Date     time.Time
	Uuid     uuid.UUID
}

func NewExamplePrimitiveFromInteger(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "integer", Integer: value}
}

func NewExamplePrimitiveFromDouble(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "double", Double: value}
}

func NewExamplePrimitiveFromString(value *EscapedString) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "string", String: value}
}

func NewExamplePrimitiveFromBoolean(value bool) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "boolean", Boolean: value}
}

func NewExamplePrimitiveFromLong(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "long", Long: value}
}

func NewExamplePrimitiveFromDatetime(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "datetime", Datetime: value}
}

func NewExamplePrimitiveFromDate(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "date", Date: value}
}

func NewExamplePrimitiveFromUuid(value uuid.UUID) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uuid", Uuid: value}
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "string":
		var valueUnmarshaler struct {
			String *EscapedString `json:"string,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "datetime":
		var valueUnmarshaler struct {
			Datetime time.Time `json:"datetime"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Datetime = valueUnmarshaler.Datetime
	case "date":
		var valueUnmarshaler struct {
			Date time.Time `json:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    e.Type,
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	case "double":
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   e.Type,
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string         `json:"type"`
			String *EscapedString `json:"string,omitempty"`
		}{
			Type:   e.Type,
			String: e.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    e.Type,
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	case "long":
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: e.Type,
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string    `json:"type"`
			Datetime time.Time `json:"datetime"`
		}{
			Type:     e.Type,
			Datetime: e.Datetime,
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string    `json:"type"`
			Date time.Time `json:"date"`
		}{
			Type: e.Type,
			Date: e.Date,
		}
		return json.Marshal(marshaler)
	case "uuid":
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: e.Type,
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	}
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
	VisitString(*EscapedString) error
	VisitBoolean(bool) error
	VisitLong(int64) error
	VisitDatetime(time.Time) error
	VisitDate(time.Time) error
	VisitUuid(uuid.UUID) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "double":
		return visitor.VisitDouble(e.Double)
	case "string":
		return visitor.VisitString(e.String)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	case "long":
		return visitor.VisitLong(e.Long)
	case "datetime":
		return visitor.VisitDatetime(e.Datetime)
	case "date":
		return visitor.VisitDate(e.Date)
	case "uuid":
		return visitor.VisitUuid(e.Uuid)
	}
}

type ExampleSingleUnionType struct {
	WireDiscriminantValue *NameAndWireValue                 `json:"wireDiscriminantValue,omitempty"`
	Shape                 *ExampleSingleUnionTypeProperties `json:"shape,omitempty"`
}

func (e *ExampleSingleUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleObjectTypeWithTypeId
	SingleProperty         *ExampleTypeReference
	NoProperties           interface{}
}

func NewExampleSingleUnionTypePropertiesFromSamePropertiesAsObject(value *ExampleObjectTypeWithTypeId) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewExampleSingleUnionTypePropertiesFromSingleProperty(value *ExampleTypeReference) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "singleProperty", SingleProperty: value}
}

func NewExampleSingleUnionTypePropertiesFromNoProperties(value interface{}) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "noProperties", NoProperties: value}
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleObjectTypeWithTypeId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleObjectTypeWithTypeId
		}{
			Type:                        e.Type,
			ExampleObjectTypeWithTypeId: e.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 e.Type,
			ExampleTypeReference: e.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			Type         string      `json:"type"`
			NoProperties interface{} `json:"noProperties,omitempty"`
		}{
			Type:         e.Type,
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleObjectTypeWithTypeId) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(interface{}) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(e.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(e.NoProperties)
	}
}

type ExampleType struct {
	JsonExample interface{}       `json:"jsonExample,omitempty"`
	Docs        *string           `json:"docs,omitempty"`
	Name        *Name             `json:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape,omitempty"`
}

func (e *ExampleType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReference struct {
	JsonExample interface{}                `json:"jsonExample,omitempty"`
	Shape       *ExampleTypeReferenceShape `json:"shape,omitempty"`
}

func (e *ExampleTypeReference) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   interface{}
	Named     *ExampleNamedType
}

func NewExampleTypeReferenceShapeFromPrimitive(value *ExamplePrimitive) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "primitive", Primitive: value}
}

func NewExampleTypeReferenceShapeFromContainer(value *ExampleContainer) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "container", Container: value}
}

func NewExampleTypeReferenceShapeFromUnknown(value interface{}) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "unknown", Unknown: value}
}

func NewExampleTypeReferenceShapeFromNamed(value *ExampleNamedType) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "named", Named: value}
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown interface{} `json:"unknown,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}{
			Type:      e.Type,
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	case "container":
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container,omitempty"`
		}{
			Type:      e.Type,
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    e.Type,
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleNamedType
		}{
			Type:             e.Type,
			ExampleNamedType: e.Named,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(interface{}) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		return visitor.VisitPrimitive(e.Primitive)
	case "container":
		return visitor.VisitContainer(e.Container)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	case "named":
		return visitor.VisitNamed(e.Named)
	}
}

type ExampleTypeShape struct {
	Type                 string
	Alias                *ExampleAliasType
	Enum                 *ExampleEnumType
	Object               *ExampleObjectType
	Union                *ExampleUnionType
	UndiscriminatedUnion *ExampleUndiscriminatedUnionType
}

func NewExampleTypeShapeFromAlias(value *ExampleAliasType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "alias", Alias: value}
}

func NewExampleTypeShapeFromEnum(value *ExampleEnumType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "enum", Enum: value}
}

func NewExampleTypeShapeFromObject(value *ExampleObjectType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "object", Object: value}
}

func NewExampleTypeShapeFromUnion(value *ExampleUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "union", Union: value}
}

func NewExampleTypeShapeFromUndiscriminatedUnion(value *ExampleUndiscriminatedUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	case "undiscriminatedUnion":
		value := new(ExampleUndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UndiscriminatedUnion = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleAliasType
		}{
			Type:             e.Type,
			ExampleAliasType: e.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEnumType
		}{
			Type:            e.Type,
			ExampleEnumType: e.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleObjectType
		}{
			Type:              e.Type,
			ExampleObjectType: e.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleUnionType
		}{
			Type:             e.Type,
			ExampleUnionType: e.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleUndiscriminatedUnionType
		}{
			Type:                            e.Type,
			ExampleUndiscriminatedUnionType: e.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleUnionType) error
	VisitUndiscriminatedUnion(*ExampleUndiscriminatedUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return visitor.VisitAlias(e.Alias)
	case "enum":
		return visitor.VisitEnum(e.Enum)
	case "object":
		return visitor.VisitObject(e.Object)
	case "union":
		return visitor.VisitUnion(e.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(e.UndiscriminatedUnion)
	}
}

type ExampleUndiscriminatedUnionType struct {
	// The zero-based index of the undiscriminated union variant.
	// For the following undiscriminated union
	//
	// ```
	// MyUnion:
	//
	//	discriminated: false
	//	union:
	//	  - string
	//	  - integer
	//
	// ```
	//
	// a string example would have an index 0 and an integer example
	// would have an index 1.
	Index           int                   `json:"index"`
	SingleUnionType *ExampleTypeReference `json:"singleUnionType,omitempty"`
}

func (e *ExampleUndiscriminatedUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleUnionType struct {
	Discriminant    *NameAndWireValue       `json:"discriminant,omitempty"`
	SingleUnionType *ExampleSingleUnionType `json:"singleUnionType,omitempty"`
}

func (e *ExampleUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Literal struct {
	Type    string
	String  string
	Boolean bool
}

func NewLiteralFromString(value string) *Literal {
	return &Literal{Type: "string", String: value}
}

func NewLiteralFromBoolean(value bool) *Literal {
	return &Literal{Type: "boolean", Boolean: value}
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   l.Type,
			String: l.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    l.Type,
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		return visitor.VisitString(l.String)
	case "boolean":
		return visitor.VisitBoolean(l.Boolean)
	}
}

type MapType struct {
	KeyType   *TypeReference `json:"keyType,omitempty"`
	ValueType *TypeReference `json:"valueType,omitempty"`
}

func (m *MapType) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ObjectProperty struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty"`
}

func (o *ObjectProperty) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends,omitempty"`
	Properties []*ObjectProperty   `json:"properties,omitempty"`
}

func (o *ObjectTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveType string

const (
	PrimitiveTypeInteger PrimitiveType = "INTEGER"
	PrimitiveTypeDouble  PrimitiveType = "DOUBLE"
	PrimitiveTypeString  PrimitiveType = "STRING"
	PrimitiveTypeBoolean PrimitiveType = "BOOLEAN"
	// Within the range -2^53 to 2^53
	PrimitiveTypeLong     PrimitiveType = "LONG"
	PrimitiveTypeDateTime PrimitiveType = "DATE_TIME"
	PrimitiveTypeDate     PrimitiveType = "DATE"
	PrimitiveTypeUuid     PrimitiveType = "UUID"
	PrimitiveTypeBase64   PrimitiveType = "BASE_64"
)

func NewPrimitiveTypeFromString(s string) (PrimitiveType, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeInteger, nil
	case "DOUBLE":
		return PrimitiveTypeDouble, nil
	case "STRING":
		return PrimitiveTypeString, nil
	case "BOOLEAN":
		return PrimitiveTypeBoolean, nil
	case "LONG":
		return PrimitiveTypeLong, nil
	case "DATE_TIME":
		return PrimitiveTypeDateTime, nil
	case "DATE":
		return PrimitiveTypeDate, nil
	case "UUID":
		return PrimitiveTypeUuid, nil
	case "BASE_64":
		return PrimitiveTypeBase64, nil
	}
	var t PrimitiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveType) Ptr() *PrimitiveType {
	return &p
}

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name,omitempty"`
	Shape ShapeType         `json:"shape,omitempty"`
}

func (r *ResolvedNamedType) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewResolvedTypeReferenceFromContainer(value *ContainerType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "container", Container: value}
}

func NewResolvedTypeReferenceFromNamed(value *ResolvedNamedType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "named", Named: value}
}

func NewResolvedTypeReferenceFromPrimitive(value PrimitiveType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "primitive", Primitive: value}
}

func NewResolvedTypeReferenceFromUnknown(value interface{}) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "unknown", Unknown: value}
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      r.Type,
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*ResolvedNamedType
		}{
			Type:              r.Type,
			ResolvedNamedType: r.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      r.Type,
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    r.Type,
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		return visitor.VisitContainer(r.Container)
	case "named":
		return visitor.VisitNamed(r.Named)
	case "primitive":
		return visitor.VisitPrimitive(r.Primitive)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty"`
	DiscriminantValue *NameAndWireValue          `json:"discriminantValue,omitempty"`
	Shape             *SingleUnionTypeProperties `json:"shape,omitempty"`
}

func (s *SingleUnionType) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           interface{}
}

func NewSingleUnionTypePropertiesFromSamePropertiesAsObject(value *DeclaredTypeName) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleUnionTypePropertiesFromSingleProperty(value *SingleUnionTypeProperty) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "singleProperty", SingleProperty: value}
}

func NewSingleUnionTypePropertiesFromNoProperties(value interface{}) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "noProperties", NoProperties: value}
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch s.PropertiesType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*DeclaredTypeName
		}{
			PropertiesType:   s.PropertiesType,
			DeclaredTypeName: s.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*SingleUnionTypeProperty
		}{
			PropertiesType:          s.PropertiesType,
			SingleUnionTypeProperty: s.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			PropertiesType string      `json:"_type"`
			NoProperties   interface{} `json:"noProperties,omitempty"`
		}{
			PropertiesType: s.PropertiesType,
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(interface{}) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	switch s.PropertiesType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

type SingleUnionTypeProperty struct {
	Name *NameAndWireValue `json:"name,omitempty"`
	Type *TypeReference    `json:"type,omitempty"`
}

func (s *SingleUnionTypeProperty) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		var marshaler = struct {
			Type string `json:"_type"`
			*AliasTypeDeclaration
		}{
			Type:                 t.Type,
			AliasTypeDeclaration: t.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"_type"`
			*EnumTypeDeclaration
		}{
			Type:                t.Type,
			EnumTypeDeclaration: t.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"_type"`
			*ObjectTypeDeclaration
		}{
			Type:                  t.Type,
			ObjectTypeDeclaration: t.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"_type"`
			*UnionTypeDeclaration
		}{
			Type:                 t.Type,
			UnionTypeDeclaration: t.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"_type"`
			*UndiscriminatedUnionTypeDeclaration
		}{
			Type:                                t.Type,
			UndiscriminatedUnionTypeDeclaration: t.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return visitor.VisitAlias(t.Alias)
	case "enum":
		return visitor.VisitEnum(t.Enum)
	case "object":
		return visitor.VisitObject(t.Object)
	case "union":
		return visitor.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}

// A type, which is a name and a shape
type TypeDeclaration struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         *DeclaredTypeName `json:"name,omitempty"`
	Shape        *Type             `json:"shape,omitempty"`
	Examples     []*ExampleType    `json:"examples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []TypeId `json:"referencedTypes,omitempty"`
}

func (t *TypeDeclaration) String() string {
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *DeclaredTypeName
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewTypeReferenceFromContainer(value *ContainerType) *TypeReference {
	return &TypeReference{Type: "container", Container: value}
}

func NewTypeReferenceFromNamed(value *DeclaredTypeName) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromPrimitive(value PrimitiveType) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromUnknown(value interface{}) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      t.Type,
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*DeclaredTypeName
		}{
			Type:             t.Type,
			DeclaredTypeName: t.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      t.Type,
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    t.Type,
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*DeclaredTypeName) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		return visitor.VisitContainer(t.Container)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty"`
	Type *TypeReference `json:"type,omitempty"`
}

func (u *UndiscriminatedUnionMember) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members,omitempty"`
}

func (u *UndiscriminatedUnionTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnionTypeDeclaration struct {
	Discriminant *NameAndWireValue `json:"discriminant,omitempty"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends,omitempty"`
	Types          []*SingleUnionType  `json:"types,omitempty"`
	BaseProperties []*ObjectProperty   `json:"baseProperties,omitempty"`
}

func (u *UnionTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VariableDeclaration struct {
	Docs *string        `json:"docs,omitempty"`
	Id   VariableId     `json:"id"`
	Name *Name          `json:"name,omitempty"`
	Type *TypeReference `json:"type,omitempty"`
}

func (v *VariableDeclaration) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VariableId = string

type InlinedWebhookPayload struct {
	Name       *Name                            `json:"name,omitempty"`
	Extends    []*DeclaredTypeName              `json:"extends,omitempty"`
	Properties []*InlinedWebhookPayloadProperty `json:"properties,omitempty"`
}

func (i *InlinedWebhookPayload) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedWebhookPayloadProperty struct {
	Docs      *string           `json:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty"`
}

func (i *InlinedWebhookPayloadProperty) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Webhook struct {
	Docs         *string           `json:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty"`
	Name         WebhookName       `json:"name,omitempty"`
	DisplayName  *string           `json:"displayName,omitempty"`
	Method       WebhookHttpMethod `json:"method,omitempty"`
	Headers      []*HttpHeader     `json:"headers,omitempty"`
	Payload      *WebhookPayload   `json:"payload,omitempty"`
}

func (w *Webhook) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookGroup = []*Webhook

type WebhookHttpMethod string

const (
	WebhookHttpMethodGet  WebhookHttpMethod = "GET"
	WebhookHttpMethodPost WebhookHttpMethod = "POST"
)

func NewWebhookHttpMethodFromString(s string) (WebhookHttpMethod, error) {
	switch s {
	case "GET":
		return WebhookHttpMethodGet, nil
	case "POST":
		return WebhookHttpMethodPost, nil
	}
	var t WebhookHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookHttpMethod) Ptr() *WebhookHttpMethod {
	return &w
}

type WebhookName = *Name

type WebhookPayload struct {
	Type           string
	InlinedPayload *InlinedWebhookPayload
	Reference      *WebhookPayloadReference
}

func NewWebhookPayloadFromInlinedPayload(value *InlinedWebhookPayload) *WebhookPayload {
	return &WebhookPayload{Type: "inlinedPayload", InlinedPayload: value}
}

func NewWebhookPayloadFromReference(value *WebhookPayloadReference) *WebhookPayload {
	return &WebhookPayload{Type: "reference", Reference: value}
}

func (w *WebhookPayload) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedPayload":
		value := new(InlinedWebhookPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.InlinedPayload = value
	case "reference":
		value := new(WebhookPayloadReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Reference = value
	}
	return nil
}

func (w WebhookPayload) MarshalJSON() ([]byte, error) {
	switch w.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedWebhookPayload
		}{
			Type:                  w.Type,
			InlinedWebhookPayload: w.InlinedPayload,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*WebhookPayloadReference
		}{
			Type:                    w.Type,
			WebhookPayloadReference: w.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type WebhookPayloadVisitor interface {
	VisitInlinedPayload(*InlinedWebhookPayload) error
	VisitReference(*WebhookPayloadReference) error
}

func (w *WebhookPayload) Accept(visitor WebhookPayloadVisitor) error {
	switch w.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		return visitor.VisitInlinedPayload(w.InlinedPayload)
	case "reference":
		return visitor.VisitReference(w.Reference)
	}
}

type WebhookPayloadReference struct {
	Docs        *string        `json:"docs,omitempty"`
	PayloadType *TypeReference `json:"payloadType,omitempty"`
}

func (w *WebhookPayloadReference) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

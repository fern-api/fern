// Code generated by Fern. DO NOT EDIT.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	common "github.com/fern-api/fern-go/internal/fern/ir/common"
	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

// An example webhook call. For now, this only includes the payload,
// but it can be easily extended to support other endpoint properties
// (e.g. headers).
var (
	exampleWebhookCallFieldDocs    = big.NewInt(1 << 0)
	exampleWebhookCallFieldName    = big.NewInt(1 << 1)
	exampleWebhookCallFieldPayload = big.NewInt(1 << 2)
)

type ExampleWebhookCall struct {
	Docs    *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name    *common.Name          `json:"name,omitempty" url:"name,omitempty"`
	Payload *ExampleTypeReference `json:"payload" url:"payload"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (e *ExampleWebhookCall) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleWebhookCall) GetName() *common.Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleWebhookCall) GetPayload() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Payload
}

func (e *ExampleWebhookCall) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleWebhookCall) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleWebhookCall) SetDocs(docs *string) {
	e.Docs = docs
	e.require(exampleWebhookCallFieldDocs)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleWebhookCall) SetName(name *common.Name) {
	e.Name = name
	e.require(exampleWebhookCallFieldName)
}

// SetPayload sets the Payload field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExampleWebhookCall) SetPayload(payload *ExampleTypeReference) {
	e.Payload = payload
	e.require(exampleWebhookCallFieldPayload)
}

func (e *ExampleWebhookCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleWebhookCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleWebhookCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleWebhookCall) MarshalJSON() ([]byte, error) {
	type embed ExampleWebhookCall
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExampleWebhookCall) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	inlinedWebhookPayloadFieldName       = big.NewInt(1 << 0)
	inlinedWebhookPayloadFieldExtends    = big.NewInt(1 << 1)
	inlinedWebhookPayloadFieldProperties = big.NewInt(1 << 2)
)

type InlinedWebhookPayload struct {
	Name       *common.Name                     `json:"name" url:"name"`
	Extends    []*DeclaredTypeName              `json:"extends" url:"extends"`
	Properties []*InlinedWebhookPayloadProperty `json:"properties" url:"properties"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InlinedWebhookPayload) GetName() *common.Name {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedWebhookPayload) GetExtends() []*DeclaredTypeName {
	if i == nil {
		return nil
	}
	return i.Extends
}

func (i *InlinedWebhookPayload) GetProperties() []*InlinedWebhookPayloadProperty {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedWebhookPayload) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedWebhookPayload) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayload) SetName(name *common.Name) {
	i.Name = name
	i.require(inlinedWebhookPayloadFieldName)
}

// SetExtends sets the Extends field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayload) SetExtends(extends []*DeclaredTypeName) {
	i.Extends = extends
	i.require(inlinedWebhookPayloadFieldExtends)
}

// SetProperties sets the Properties field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayload) SetProperties(properties []*InlinedWebhookPayloadProperty) {
	i.Properties = properties
	i.require(inlinedWebhookPayloadFieldProperties)
}

func (i *InlinedWebhookPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedWebhookPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedWebhookPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedWebhookPayload) MarshalJSON() ([]byte, error) {
	type embed InlinedWebhookPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InlinedWebhookPayload) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inlinedWebhookPayloadPropertyFieldDocs         = big.NewInt(1 << 0)
	inlinedWebhookPayloadPropertyFieldAvailability = big.NewInt(1 << 1)
	inlinedWebhookPayloadPropertyFieldName         = big.NewInt(1 << 2)
	inlinedWebhookPayloadPropertyFieldValueType    = big.NewInt(1 << 3)
)

type InlinedWebhookPayloadProperty struct {
	Docs         *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability            `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *common.NameAndWireValue `json:"name" url:"name"`
	ValueType    *TypeReference           `json:"valueType" url:"valueType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (i *InlinedWebhookPayloadProperty) GetDocs() *string {
	if i == nil {
		return nil
	}
	return i.Docs
}

func (i *InlinedWebhookPayloadProperty) GetAvailability() *Availability {
	if i == nil {
		return nil
	}
	return i.Availability
}

func (i *InlinedWebhookPayloadProperty) GetName() *common.NameAndWireValue {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedWebhookPayloadProperty) GetValueType() *TypeReference {
	if i == nil {
		return nil
	}
	return i.ValueType
}

func (i *InlinedWebhookPayloadProperty) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedWebhookPayloadProperty) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayloadProperty) SetDocs(docs *string) {
	i.Docs = docs
	i.require(inlinedWebhookPayloadPropertyFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayloadProperty) SetAvailability(availability *Availability) {
	i.Availability = availability
	i.require(inlinedWebhookPayloadPropertyFieldAvailability)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayloadProperty) SetName(name *common.NameAndWireValue) {
	i.Name = name
	i.require(inlinedWebhookPayloadPropertyFieldName)
}

// SetValueType sets the ValueType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InlinedWebhookPayloadProperty) SetValueType(valueType *TypeReference) {
	i.ValueType = valueType
	i.require(inlinedWebhookPayloadPropertyFieldValueType)
}

func (i *InlinedWebhookPayloadProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedWebhookPayloadProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedWebhookPayloadProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedWebhookPayloadProperty) MarshalJSON() ([]byte, error) {
	type embed InlinedWebhookPayloadProperty
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InlinedWebhookPayloadProperty) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	webhookFieldDocs         = big.NewInt(1 << 0)
	webhookFieldAvailability = big.NewInt(1 << 1)
	webhookFieldId           = big.NewInt(1 << 2)
	webhookFieldName         = big.NewInt(1 << 3)
	webhookFieldDisplayName  = big.NewInt(1 << 4)
	webhookFieldMethod       = big.NewInt(1 << 5)
	webhookFieldHeaders      = big.NewInt(1 << 6)
	webhookFieldPayload      = big.NewInt(1 << 7)
	webhookFieldExamples     = big.NewInt(1 << 8)
	webhookFieldV2Examples   = big.NewInt(1 << 9)
)

type Webhook struct {
	Docs         *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability         `json:"availability,omitempty" url:"availability,omitempty"`
	Id           WebhookId             `json:"id" url:"id"`
	Name         WebhookName           `json:"name" url:"name"`
	DisplayName  *string               `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method       WebhookHttpMethod     `json:"method" url:"method"`
	Headers      []*HttpHeader         `json:"headers" url:"headers"`
	Payload      *WebhookPayload       `json:"payload" url:"payload"`
	Examples     []*ExampleWebhookCall `json:"examples,omitempty" url:"examples,omitempty"`
	V2Examples   *V2WebhookExamples    `json:"v2Examples,omitempty" url:"v2Examples,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *Webhook) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *Webhook) GetAvailability() *Availability {
	if w == nil {
		return nil
	}
	return w.Availability
}

func (w *Webhook) GetId() WebhookId {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *Webhook) GetName() WebhookName {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *Webhook) GetDisplayName() *string {
	if w == nil {
		return nil
	}
	return w.DisplayName
}

func (w *Webhook) GetMethod() WebhookHttpMethod {
	if w == nil {
		return ""
	}
	return w.Method
}

func (w *Webhook) GetHeaders() []*HttpHeader {
	if w == nil {
		return nil
	}
	return w.Headers
}

func (w *Webhook) GetPayload() *WebhookPayload {
	if w == nil {
		return nil
	}
	return w.Payload
}

func (w *Webhook) GetExamples() []*ExampleWebhookCall {
	if w == nil {
		return nil
	}
	return w.Examples
}

func (w *Webhook) GetV2Examples() *V2WebhookExamples {
	if w == nil {
		return nil
	}
	return w.V2Examples
}

func (w *Webhook) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Webhook) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetDocs(docs *string) {
	w.Docs = docs
	w.require(webhookFieldDocs)
}

// SetAvailability sets the Availability field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetAvailability(availability *Availability) {
	w.Availability = availability
	w.require(webhookFieldAvailability)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetId(id WebhookId) {
	w.Id = id
	w.require(webhookFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetName(name WebhookName) {
	w.Name = name
	w.require(webhookFieldName)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetDisplayName(displayName *string) {
	w.DisplayName = displayName
	w.require(webhookFieldDisplayName)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetMethod(method WebhookHttpMethod) {
	w.Method = method
	w.require(webhookFieldMethod)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetHeaders(headers []*HttpHeader) {
	w.Headers = headers
	w.require(webhookFieldHeaders)
}

// SetPayload sets the Payload field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetPayload(payload *WebhookPayload) {
	w.Payload = payload
	w.require(webhookFieldPayload)
}

// SetExamples sets the Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetExamples(examples []*ExampleWebhookCall) {
	w.Examples = examples
	w.require(webhookFieldExamples)
}

// SetV2Examples sets the V2Examples field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetV2Examples(v2Examples *V2WebhookExamples) {
	w.V2Examples = v2Examples
	w.require(webhookFieldV2Examples)
}

func (w *Webhook) UnmarshalJSON(data []byte) error {
	type unmarshaler Webhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = Webhook(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *Webhook) MarshalJSON() ([]byte, error) {
	type embed Webhook
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *Webhook) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookGroup = []*Webhook

type WebhookHttpMethod string

const (
	WebhookHttpMethodGet  WebhookHttpMethod = "GET"
	WebhookHttpMethodPost WebhookHttpMethod = "POST"
)

func NewWebhookHttpMethodFromString(s string) (WebhookHttpMethod, error) {
	switch s {
	case "GET":
		return WebhookHttpMethodGet, nil
	case "POST":
		return WebhookHttpMethodPost, nil
	}
	var t WebhookHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookHttpMethod) Ptr() *WebhookHttpMethod {
	return &w
}

type WebhookName = *common.Name

type WebhookPayload struct {
	Type           string
	InlinedPayload *InlinedWebhookPayload
	Reference      *WebhookPayloadReference
}

func (w *WebhookPayload) GetType() string {
	if w == nil {
		return ""
	}
	return w.Type
}

func (w *WebhookPayload) GetInlinedPayload() *InlinedWebhookPayload {
	if w == nil {
		return nil
	}
	return w.InlinedPayload
}

func (w *WebhookPayload) GetReference() *WebhookPayloadReference {
	if w == nil {
		return nil
	}
	return w.Reference
}

func (w *WebhookPayload) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", w)
	}
	switch unmarshaler.Type {
	case "inlinedPayload":
		value := new(InlinedWebhookPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.InlinedPayload = value
	case "reference":
		value := new(WebhookPayloadReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Reference = value
	}
	return nil
}

func (w WebhookPayload) MarshalJSON() ([]byte, error) {
	if err := w.validate(); err != nil {
		return nil, err
	}
	if w.InlinedPayload != nil {
		return internal.MarshalJSONWithExtraProperty(w.InlinedPayload, "type", "inlinedPayload")
	}
	if w.Reference != nil {
		return internal.MarshalJSONWithExtraProperty(w.Reference, "type", "reference")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", w)
}

type WebhookPayloadVisitor interface {
	VisitInlinedPayload(*InlinedWebhookPayload) error
	VisitReference(*WebhookPayloadReference) error
}

func (w *WebhookPayload) Accept(visitor WebhookPayloadVisitor) error {
	if w.InlinedPayload != nil {
		return visitor.VisitInlinedPayload(w.InlinedPayload)
	}
	if w.Reference != nil {
		return visitor.VisitReference(w.Reference)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", w)
}

func (w *WebhookPayload) validate() error {
	if w == nil {
		return fmt.Errorf("type %T is nil", w)
	}
	var fields []string
	if w.InlinedPayload != nil {
		fields = append(fields, "inlinedPayload")
	}
	if w.Reference != nil {
		fields = append(fields, "reference")
	}
	if len(fields) == 0 {
		if w.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", w, w.Type)
		}
		return fmt.Errorf("type %T is empty", w)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", w, fields)
	}
	if w.Type != "" {
		field := fields[0]
		if w.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				w,
				w.Type,
				w,
			)
		}
	}
	return nil
}

var (
	webhookPayloadReferenceFieldDocs        = big.NewInt(1 << 0)
	webhookPayloadReferenceFieldPayloadType = big.NewInt(1 << 1)
)

type WebhookPayloadReference struct {
	Docs        *string        `json:"docs,omitempty" url:"docs,omitempty"`
	PayloadType *TypeReference `json:"payloadType" url:"payloadType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (w *WebhookPayloadReference) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WebhookPayloadReference) GetPayloadType() *TypeReference {
	if w == nil {
		return nil
	}
	return w.PayloadType
}

func (w *WebhookPayloadReference) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookPayloadReference) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetDocs sets the Docs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookPayloadReference) SetDocs(docs *string) {
	w.Docs = docs
	w.require(webhookPayloadReferenceFieldDocs)
}

// SetPayloadType sets the PayloadType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookPayloadReference) SetPayloadType(payloadType *TypeReference) {
	w.PayloadType = payloadType
	w.require(webhookPayloadReferenceFieldPayloadType)
}

func (w *WebhookPayloadReference) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookPayloadReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookPayloadReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WebhookPayloadReference) MarshalJSON() ([]byte, error) {
	type embed WebhookPayloadReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WebhookPayloadReference) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

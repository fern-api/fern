// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

// An example webhook call. For now, this only includes the payload,
// but it can be easily extended to support other endpoint properties
// (e.g. headers).
type ExampleWebhookCall struct {
	Docs    *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name    *Name                 `json:"name,omitempty" url:"name,omitempty"`
	Payload *ExampleTypeReference `json:"payload,omitempty" url:"payload,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleWebhookCall) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleWebhookCall) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleWebhookCall) GetPayload() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Payload
}

func (e *ExampleWebhookCall) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleWebhookCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleWebhookCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleWebhookCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleWebhookCall) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InlinedWebhookPayload struct {
	Name       *Name                            `json:"name,omitempty" url:"name,omitempty"`
	Extends    []*DeclaredTypeName              `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*InlinedWebhookPayloadProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedWebhookPayload) GetName() *Name {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedWebhookPayload) GetExtends() []*DeclaredTypeName {
	if i == nil {
		return nil
	}
	return i.Extends
}

func (i *InlinedWebhookPayload) GetProperties() []*InlinedWebhookPayloadProperty {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedWebhookPayload) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedWebhookPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedWebhookPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedWebhookPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedWebhookPayload) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedWebhookPayloadProperty struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedWebhookPayloadProperty) GetDocs() *string {
	if i == nil {
		return nil
	}
	return i.Docs
}

func (i *InlinedWebhookPayloadProperty) GetAvailability() *Availability {
	if i == nil {
		return nil
	}
	return i.Availability
}

func (i *InlinedWebhookPayloadProperty) GetName() *NameAndWireValue {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedWebhookPayloadProperty) GetValueType() *TypeReference {
	if i == nil {
		return nil
	}
	return i.ValueType
}

func (i *InlinedWebhookPayloadProperty) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedWebhookPayloadProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedWebhookPayloadProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedWebhookPayloadProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedWebhookPayloadProperty) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Webhook struct {
	Docs         *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability         `json:"availability,omitempty" url:"availability,omitempty"`
	Id           WebhookId             `json:"id" url:"id"`
	Name         WebhookName           `json:"name,omitempty" url:"name,omitempty"`
	DisplayName  *string               `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method       WebhookHttpMethod     `json:"method" url:"method"`
	Headers      []*HttpHeader         `json:"headers,omitempty" url:"headers,omitempty"`
	Payload      *WebhookPayload       `json:"payload,omitempty" url:"payload,omitempty"`
	Examples     []*ExampleWebhookCall `json:"examples,omitempty" url:"examples,omitempty"`

	extraProperties map[string]interface{}
}

func (w *Webhook) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *Webhook) GetAvailability() *Availability {
	if w == nil {
		return nil
	}
	return w.Availability
}

func (w *Webhook) GetId() WebhookId {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *Webhook) GetName() WebhookName {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *Webhook) GetDisplayName() *string {
	if w == nil {
		return nil
	}
	return w.DisplayName
}

func (w *Webhook) GetMethod() WebhookHttpMethod {
	if w == nil {
		return ""
	}
	return w.Method
}

func (w *Webhook) GetHeaders() []*HttpHeader {
	if w == nil {
		return nil
	}
	return w.Headers
}

func (w *Webhook) GetPayload() *WebhookPayload {
	if w == nil {
		return nil
	}
	return w.Payload
}

func (w *Webhook) GetExamples() []*ExampleWebhookCall {
	if w == nil {
		return nil
	}
	return w.Examples
}

func (w *Webhook) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Webhook) UnmarshalJSON(data []byte) error {
	type unmarshaler Webhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = Webhook(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *Webhook) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookGroup = []*Webhook

type WebhookHttpMethod string

const (
	WebhookHttpMethodGet  WebhookHttpMethod = "GET"
	WebhookHttpMethodPost WebhookHttpMethod = "POST"
)

func NewWebhookHttpMethodFromString(s string) (WebhookHttpMethod, error) {
	switch s {
	case "GET":
		return WebhookHttpMethodGet, nil
	case "POST":
		return WebhookHttpMethodPost, nil
	}
	var t WebhookHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookHttpMethod) Ptr() *WebhookHttpMethod {
	return &w
}

type WebhookName = *Name

type WebhookPayload struct {
	Type           string
	InlinedPayload *InlinedWebhookPayload
	Reference      *WebhookPayloadReference
}

func NewWebhookPayloadFromInlinedPayload(value *InlinedWebhookPayload) *WebhookPayload {
	return &WebhookPayload{Type: "inlinedPayload", InlinedPayload: value}
}

func NewWebhookPayloadFromReference(value *WebhookPayloadReference) *WebhookPayload {
	return &WebhookPayload{Type: "reference", Reference: value}
}

func (w *WebhookPayload) GetType() string {
	if w == nil {
		return ""
	}
	return w.Type
}

func (w *WebhookPayload) GetInlinedPayload() *InlinedWebhookPayload {
	if w == nil {
		return nil
	}
	return w.InlinedPayload
}

func (w *WebhookPayload) GetReference() *WebhookPayloadReference {
	if w == nil {
		return nil
	}
	return w.Reference
}

func (w *WebhookPayload) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", w)
	}
	switch unmarshaler.Type {
	case "inlinedPayload":
		value := new(InlinedWebhookPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.InlinedPayload = value
	case "reference":
		value := new(WebhookPayloadReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Reference = value
	}
	return nil
}

func (w WebhookPayload) MarshalJSON() ([]byte, error) {
	if err := w.validate(); err != nil {
		return nil, err
	}
	switch w.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		return internal.MarshalJSONWithExtraProperty(w.InlinedPayload, "type", "inlinedPayload")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(w.Reference, "type", "reference")
	}
}

type WebhookPayloadVisitor interface {
	VisitInlinedPayload(*InlinedWebhookPayload) error
	VisitReference(*WebhookPayloadReference) error
}

func (w *WebhookPayload) Accept(visitor WebhookPayloadVisitor) error {
	switch w.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		return visitor.VisitInlinedPayload(w.InlinedPayload)
	case "reference":
		return visitor.VisitReference(w.Reference)
	}
}

func (w *WebhookPayload) validate() error {
	if w == nil {
		return fmt.Errorf("type %T is nil", w)
	}
	var fields []string
	if w.InlinedPayload != nil {
		fields = append(fields, "inlinedPayload")
	}
	if w.Reference != nil {
		fields = append(fields, "reference")
	}
	if len(fields) == 0 {
		if w.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", w, w.Type)
		}
		return fmt.Errorf("type %T is empty", w)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", w, fields)
	}
	if w.Type != "" {
		field := fields[0]
		if w.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				w,
				w.Type,
				w,
			)
		}
	}
	return nil
}

type WebhookPayloadReference struct {
	Docs        *string        `json:"docs,omitempty" url:"docs,omitempty"`
	PayloadType *TypeReference `json:"payloadType,omitempty" url:"payloadType,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WebhookPayloadReference) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WebhookPayloadReference) GetPayloadType() *TypeReference {
	if w == nil {
		return nil
	}
	return w.PayloadType
}

func (w *WebhookPayloadReference) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookPayloadReference) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookPayloadReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookPayloadReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WebhookPayloadReference) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

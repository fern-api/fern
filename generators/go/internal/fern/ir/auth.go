// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type ApiAuth struct {
	Docs        *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Requirement AuthSchemesRequirement `json:"requirement" url:"requirement"`
	Schemes     []*AuthScheme          `json:"schemes,omitempty" url:"schemes,omitempty"`

	extraProperties map[string]interface{}
}

func (a *ApiAuth) GetDocs() *string {
	if a == nil {
		return nil
	}
	return a.Docs
}

func (a *ApiAuth) GetRequirement() AuthSchemesRequirement {
	if a == nil {
		return ""
	}
	return a.Requirement
}

func (a *ApiAuth) GetSchemes() []*AuthScheme {
	if a == nil {
		return nil
	}
	return a.Schemes
}

func (a *ApiAuth) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *ApiAuth) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthScheme struct {
	Type   string
	Bearer *BearerAuthScheme
	Basic  *BasicAuthScheme
	Header *HeaderAuthScheme
	Oauth  *OAuthScheme
}

func NewAuthSchemeFromBearer(value *BearerAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "bearer", Bearer: value}
}

func NewAuthSchemeFromBasic(value *BasicAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "basic", Basic: value}
}

func NewAuthSchemeFromHeader(value *HeaderAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "header", Header: value}
}

func NewAuthSchemeFromOauth(value *OAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "oauth", Oauth: value}
}

func (a *AuthScheme) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AuthScheme) GetBearer() *BearerAuthScheme {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *AuthScheme) GetBasic() *BasicAuthScheme {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *AuthScheme) GetHeader() *HeaderAuthScheme {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *AuthScheme) GetOauth() *OAuthScheme {
	if a == nil {
		return nil
	}
	return a.Oauth
}

func (a *AuthScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", a)
	}
	switch unmarshaler.Type {
	case "bearer":
		value := new(BearerAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "basic":
		value := new(BasicAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "header":
		value := new(HeaderAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	}
	return nil
}

func (a AuthScheme) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "_type", "bearer")
	case "basic":
		return internal.MarshalJSONWithExtraProperty(a.Basic, "_type", "basic")
	case "header":
		return internal.MarshalJSONWithExtraProperty(a.Header, "_type", "header")
	case "oauth":
		return internal.MarshalJSONWithExtraProperty(a.Oauth, "_type", "oauth")
	}
}

type AuthSchemeVisitor interface {
	VisitBearer(*BearerAuthScheme) error
	VisitBasic(*BasicAuthScheme) error
	VisitHeader(*HeaderAuthScheme) error
	VisitOauth(*OAuthScheme) error
}

func (a *AuthScheme) Accept(visitor AuthSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "header":
		return visitor.VisitHeader(a.Header)
	case "oauth":
		return visitor.VisitOauth(a.Oauth)
	}
}

func (a *AuthScheme) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if a.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AuthSchemesRequirement string

const (
	AuthSchemesRequirementAll AuthSchemesRequirement = "ALL"
	AuthSchemesRequirementAny AuthSchemesRequirement = "ANY"
)

func NewAuthSchemesRequirementFromString(s string) (AuthSchemesRequirement, error) {
	switch s {
	case "ALL":
		return AuthSchemesRequirementAll, nil
	case "ANY":
		return AuthSchemesRequirementAny, nil
	}
	var t AuthSchemesRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthSchemesRequirement) Ptr() *AuthSchemesRequirement {
	return &a
}

type BasicAuthScheme struct {
	Docs     *string `json:"docs,omitempty" url:"docs,omitempty"`
	Username *Name   `json:"username,omitempty" url:"username,omitempty"`
	// The environment variable the SDK should use to read the username.
	UsernameEnvVar *EnvironmentVariable `json:"usernameEnvVar,omitempty" url:"usernameEnvVar,omitempty"`
	Password       *Name                `json:"password,omitempty" url:"password,omitempty"`
	// The environment variable the SDK should use to read the password.
	PasswordEnvVar *EnvironmentVariable `json:"passwordEnvVar,omitempty" url:"passwordEnvVar,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BasicAuthScheme) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BasicAuthScheme) GetUsername() *Name {
	if b == nil {
		return nil
	}
	return b.Username
}

func (b *BasicAuthScheme) GetUsernameEnvVar() *EnvironmentVariable {
	if b == nil {
		return nil
	}
	return b.UsernameEnvVar
}

func (b *BasicAuthScheme) GetPassword() *Name {
	if b == nil {
		return nil
	}
	return b.Password
}

func (b *BasicAuthScheme) GetPasswordEnvVar() *EnvironmentVariable {
	if b == nil {
		return nil
	}
	return b.PasswordEnvVar
}

func (b *BasicAuthScheme) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuthScheme) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthScheme struct {
	Docs  *string `json:"docs,omitempty" url:"docs,omitempty"`
	Token *Name   `json:"token,omitempty" url:"token,omitempty"`
	// The environment variable the SDK should use to read the token.
	TokenEnvVar *EnvironmentVariable `json:"tokenEnvVar,omitempty" url:"tokenEnvVar,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BearerAuthScheme) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BearerAuthScheme) GetToken() *Name {
	if b == nil {
		return nil
	}
	return b.Token
}

func (b *BearerAuthScheme) GetTokenEnvVar() *EnvironmentVariable {
	if b == nil {
		return nil
	}
	return b.TokenEnvVar
}

func (b *BearerAuthScheme) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuthScheme) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type EnvironmentVariable = string

type HeaderAuthScheme struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	Prefix    *string           `json:"prefix,omitempty" url:"prefix,omitempty"`
	// The environment variable the SDK should use to read the header.
	HeaderEnvVar *EnvironmentVariable `json:"headerEnvVar,omitempty" url:"headerEnvVar,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuthScheme) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HeaderAuthScheme) GetName() *NameAndWireValue {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HeaderAuthScheme) GetValueType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.ValueType
}

func (h *HeaderAuthScheme) GetPrefix() *string {
	if h == nil {
		return nil
	}
	return h.Prefix
}

func (h *HeaderAuthScheme) GetHeaderEnvVar() *EnvironmentVariable {
	if h == nil {
		return nil
	}
	return h.HeaderEnvVar
}

func (h *HeaderAuthScheme) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuthScheme) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The properties required to retrieve an OAuth token.
type OAuthAccessTokenRequestProperties struct {
	ClientId         *RequestProperty   `json:"clientId,omitempty" url:"clientId,omitempty"`
	ClientSecret     *RequestProperty   `json:"clientSecret,omitempty" url:"clientSecret,omitempty"`
	Scopes           *RequestProperty   `json:"scopes,omitempty" url:"scopes,omitempty"`
	CustomProperties []*RequestProperty `json:"customProperties,omitempty" url:"customProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthAccessTokenRequestProperties) GetClientId() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.ClientId
}

func (o *OAuthAccessTokenRequestProperties) GetClientSecret() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

func (o *OAuthAccessTokenRequestProperties) GetScopes() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.Scopes
}

func (o *OAuthAccessTokenRequestProperties) GetCustomProperties() []*RequestProperty {
	if o == nil {
		return nil
	}
	return o.CustomProperties
}

func (o *OAuthAccessTokenRequestProperties) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthAccessTokenRequestProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAccessTokenRequestProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAccessTokenRequestProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthAccessTokenRequestProperties) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The properties to map to the corresponding OAuth token primitive.
type OAuthAccessTokenResponseProperties struct {
	AccessToken  *ResponseProperty `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	ExpiresIn    *ResponseProperty `json:"expiresIn,omitempty" url:"expiresIn,omitempty"`
	RefreshToken *ResponseProperty `json:"refreshToken,omitempty" url:"refreshToken,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthAccessTokenResponseProperties) GetAccessToken() *ResponseProperty {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *OAuthAccessTokenResponseProperties) GetExpiresIn() *ResponseProperty {
	if o == nil {
		return nil
	}
	return o.ExpiresIn
}

func (o *OAuthAccessTokenResponseProperties) GetRefreshToken() *ResponseProperty {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (o *OAuthAccessTokenResponseProperties) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthAccessTokenResponseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAccessTokenResponseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAccessTokenResponseProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthAccessTokenResponseProperties) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthClientCredentials struct {
	ClientIdEnvVar     *EnvironmentVariable  `json:"clientIdEnvVar,omitempty" url:"clientIdEnvVar,omitempty"`
	ClientSecretEnvVar *EnvironmentVariable  `json:"clientSecretEnvVar,omitempty" url:"clientSecretEnvVar,omitempty"`
	TokenPrefix        *string               `json:"tokenPrefix,omitempty" url:"tokenPrefix,omitempty"`
	TokenHeader        *string               `json:"tokenHeader,omitempty" url:"tokenHeader,omitempty"`
	Scopes             []string              `json:"scopes,omitempty" url:"scopes,omitempty"`
	TokenEndpoint      *OAuthTokenEndpoint   `json:"tokenEndpoint,omitempty" url:"tokenEndpoint,omitempty"`
	RefreshEndpoint    *OAuthRefreshEndpoint `json:"refreshEndpoint,omitempty" url:"refreshEndpoint,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthClientCredentials) GetClientIdEnvVar() *EnvironmentVariable {
	if o == nil {
		return nil
	}
	return o.ClientIdEnvVar
}

func (o *OAuthClientCredentials) GetClientSecretEnvVar() *EnvironmentVariable {
	if o == nil {
		return nil
	}
	return o.ClientSecretEnvVar
}

func (o *OAuthClientCredentials) GetTokenPrefix() *string {
	if o == nil {
		return nil
	}
	return o.TokenPrefix
}

func (o *OAuthClientCredentials) GetTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.TokenHeader
}

func (o *OAuthClientCredentials) GetScopes() []string {
	if o == nil {
		return nil
	}
	return o.Scopes
}

func (o *OAuthClientCredentials) GetTokenEndpoint() *OAuthTokenEndpoint {
	if o == nil {
		return nil
	}
	return o.TokenEndpoint
}

func (o *OAuthClientCredentials) GetRefreshEndpoint() *OAuthRefreshEndpoint {
	if o == nil {
		return nil
	}
	return o.RefreshEndpoint
}

func (o *OAuthClientCredentials) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthClientCredentials) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthClientCredentials
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthClientCredentials(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthClientCredentials) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthConfiguration struct {
	Type              string
	ClientCredentials *OAuthClientCredentials
}

func NewOAuthConfigurationFromClientCredentials(value *OAuthClientCredentials) *OAuthConfiguration {
	return &OAuthConfiguration{Type: "clientCredentials", ClientCredentials: value}
}

func (o *OAuthConfiguration) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *OAuthConfiguration) GetClientCredentials() *OAuthClientCredentials {
	if o == nil {
		return nil
	}
	return o.ClientCredentials
}

func (o *OAuthConfiguration) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "clientCredentials":
		value := new(OAuthClientCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.ClientCredentials = value
	}
	return nil
}

func (o OAuthConfiguration) MarshalJSON() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	switch o.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "clientCredentials":
		return internal.MarshalJSONWithExtraProperty(o.ClientCredentials, "type", "clientCredentials")
	}
}

type OAuthConfigurationVisitor interface {
	VisitClientCredentials(*OAuthClientCredentials) error
}

func (o *OAuthConfiguration) Accept(visitor OAuthConfigurationVisitor) error {
	switch o.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "clientCredentials":
		return visitor.VisitClientCredentials(o.ClientCredentials)
	}
}

func (o *OAuthConfiguration) validate() error {
	if o == nil {
		return fmt.Errorf("type %T is nil", o)
	}
	var fields []string
	if o.ClientCredentials != nil {
		fields = append(fields, "clientCredentials")
	}
	if len(fields) == 0 {
		if o.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", o, o.Type)
		}
		return fmt.Errorf("type %T is empty", o)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", o, fields)
	}
	if o.Type != "" {
		field := fields[0]
		if o.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				o,
				o.Type,
				o,
			)
		}
	}
	return nil
}

type OAuthRefreshEndpoint struct {
	EndpointReference  *EndpointReference                  `json:"endpointReference,omitempty" url:"endpointReference,omitempty"`
	RequestProperties  *OAuthRefreshTokenRequestProperties `json:"requestProperties,omitempty" url:"requestProperties,omitempty"`
	ResponseProperties *OAuthAccessTokenResponseProperties `json:"responseProperties,omitempty" url:"responseProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthRefreshEndpoint) GetEndpointReference() *EndpointReference {
	if o == nil {
		return nil
	}
	return o.EndpointReference
}

func (o *OAuthRefreshEndpoint) GetRequestProperties() *OAuthRefreshTokenRequestProperties {
	if o == nil {
		return nil
	}
	return o.RequestProperties
}

func (o *OAuthRefreshEndpoint) GetResponseProperties() *OAuthAccessTokenResponseProperties {
	if o == nil {
		return nil
	}
	return o.ResponseProperties
}

func (o *OAuthRefreshEndpoint) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthRefreshEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthRefreshEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthRefreshEndpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthRefreshEndpoint) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The properties required to retrieve an OAuth refresh token.
type OAuthRefreshTokenRequestProperties struct {
	RefreshToken *RequestProperty `json:"refreshToken,omitempty" url:"refreshToken,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthRefreshTokenRequestProperties) GetRefreshToken() *RequestProperty {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (o *OAuthRefreshTokenRequestProperties) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthRefreshTokenRequestProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthRefreshTokenRequestProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthRefreshTokenRequestProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthRefreshTokenRequestProperties) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// We currently assume the resultant token is leveraged as a bearer token, e.g. "Authorization Bearer"
type OAuthScheme struct {
	Docs          *string             `json:"docs,omitempty" url:"docs,omitempty"`
	Configuration *OAuthConfiguration `json:"configuration,omitempty" url:"configuration,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthScheme) GetDocs() *string {
	if o == nil {
		return nil
	}
	return o.Docs
}

func (o *OAuthScheme) GetConfiguration() *OAuthConfiguration {
	if o == nil {
		return nil
	}
	return o.Configuration
}

func (o *OAuthScheme) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthScheme) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthTokenEndpoint struct {
	EndpointReference  *EndpointReference                  `json:"endpointReference,omitempty" url:"endpointReference,omitempty"`
	RequestProperties  *OAuthAccessTokenRequestProperties  `json:"requestProperties,omitempty" url:"requestProperties,omitempty"`
	ResponseProperties *OAuthAccessTokenResponseProperties `json:"responseProperties,omitempty" url:"responseProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OAuthTokenEndpoint) GetEndpointReference() *EndpointReference {
	if o == nil {
		return nil
	}
	return o.EndpointReference
}

func (o *OAuthTokenEndpoint) GetRequestProperties() *OAuthAccessTokenRequestProperties {
	if o == nil {
		return nil
	}
	return o.RequestProperties
}

func (o *OAuthTokenEndpoint) GetResponseProperties() *OAuthAccessTokenResponseProperties {
	if o == nil {
		return nil
	}
	return o.ResponseProperties
}

func (o *OAuthTokenEndpoint) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthTokenEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthTokenEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthTokenEndpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OAuthTokenEndpoint) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

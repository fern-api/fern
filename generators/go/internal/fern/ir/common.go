// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type EndpointId = string

type FernFilepath struct {
	AllParts    []*Name `json:"allParts,omitempty" url:"allParts,omitempty"`
	PackagePath []*Name `json:"packagePath,omitempty" url:"packagePath,omitempty"`
	File        *Name   `json:"file,omitempty" url:"file,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FernFilepath) GetAllParts() []*Name {
	if f == nil {
		return nil
	}
	return f.AllParts
}

func (f *FernFilepath) GetPackagePath() []*Name {
	if f == nil {
		return nil
	}
	return f.PackagePath
}

func (f *FernFilepath) GetFile() *Name {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FernFilepath) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FernFilepath) UnmarshalJSON(data []byte) error {
	type unmarshaler FernFilepath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FernFilepath(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FernFilepath) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Name struct {
	OriginalName       string               `json:"originalName" url:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase,omitempty" url:"camelCase,omitempty"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase,omitempty" url:"pascalCase,omitempty"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase,omitempty" url:"snakeCase,omitempty"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase,omitempty" url:"screamingSnakeCase,omitempty"`

	extraProperties map[string]interface{}
}

func (n *Name) GetOriginalName() string {
	if n == nil {
		return ""
	}
	return n.OriginalName
}

func (n *Name) GetCamelCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.CamelCase
}

func (n *Name) GetPascalCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.PascalCase
}

func (n *Name) GetSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.SnakeCase
}

func (n *Name) GetScreamingSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.ScreamingSnakeCase
}

func (n *Name) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Name) UnmarshalJSON(data []byte) error {
	type unmarshaler Name
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Name(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *Name) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NameAndWireValue struct {
	WireValue string `json:"wireValue" url:"wireValue"`
	Name      *Name  `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NameAndWireValue) GetWireValue() string {
	if n == nil {
		return ""
	}
	return n.WireValue
}

func (n *NameAndWireValue) GetName() *Name {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NameAndWireValue) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NameAndWireValue) UnmarshalJSON(data []byte) error {
	type unmarshaler NameAndWireValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NameAndWireValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NameAndWireValue) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName" url:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName" url:"safeName"`

	extraProperties map[string]interface{}
}

func (s *SafeAndUnsafeString) GetUnsafeName() string {
	if s == nil {
		return ""
	}
	return s.UnsafeName
}

func (s *SafeAndUnsafeString) GetSafeName() string {
	if s == nil {
		return ""
	}
	return s.SafeName
}

func (s *SafeAndUnsafeString) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SafeAndUnsafeString) UnmarshalJSON(data []byte) error {
	type unmarshaler SafeAndUnsafeString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SafeAndUnsafeString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SafeAndUnsafeString) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypeId = string

type WithDocs struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WithDocs) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WithDocs) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithDocs) UnmarshalJSON(data []byte) error {
	type unmarshaler WithDocs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithDocs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithDocs) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type EnvironmentBaseUrlId = string

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id" url:"id"`
	Name *Name                `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentBaseUrlWithId) GetId() EnvironmentBaseUrlId {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EnvironmentBaseUrlWithId) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnvironmentBaseUrlWithId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentBaseUrlWithId) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentBaseUrlWithId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentBaseUrlWithId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentBaseUrlWithId) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func NewEnvironmentsFromSingleBaseUrl(value *SingleBaseUrlEnvironments) *Environments {
	return &Environments{Type: "singleBaseUrl", SingleBaseUrl: value}
}

func NewEnvironmentsFromMultipleBaseUrls(value *MultipleBaseUrlsEnvironments) *Environments {
	return &Environments{Type: "multipleBaseUrls", MultipleBaseUrls: value}
}

func (e *Environments) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *Environments) GetSingleBaseUrl() *SingleBaseUrlEnvironments {
	if e == nil {
		return nil
	}
	return e.SingleBaseUrl
}

func (e *Environments) GetMultipleBaseUrls() *MultipleBaseUrlsEnvironments {
	if e == nil {
		return nil
	}
	return e.MultipleBaseUrls
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return internal.MarshalJSONWithExtraProperty(e.SingleBaseUrl, "type", "singleBaseUrl")
	case "multipleBaseUrls":
		return internal.MarshalJSONWithExtraProperty(e.MultipleBaseUrls, "type", "multipleBaseUrls")
	}
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	case "multipleBaseUrls":
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
}

func (e *Environments) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SingleBaseUrl != nil {
		fields = append(fields, "singleBaseUrl")
	}
	if e.MultipleBaseUrls != nil {
		fields = append(fields, "multipleBaseUrls")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty" url:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentsConfig) GetDefaultEnvironment() *EnvironmentId {
	if e == nil {
		return nil
	}
	return e.DefaultEnvironment
}

func (e *EnvironmentsConfig) GetEnvironments() *Environments {
	if e == nil {
		return nil
	}
	return e.Environments
}

func (e *EnvironmentsConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentsConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentsConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentsConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentsConfig) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id" url:"id"`
	Name *Name                                   `json:"name,omitempty" url:"name,omitempty"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls,omitempty" url:"urls,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironment) GetDocs() *string {
	if m == nil {
		return nil
	}
	return m.Docs
}

func (m *MultipleBaseUrlsEnvironment) GetId() EnvironmentId {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MultipleBaseUrlsEnvironment) GetName() *Name {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MultipleBaseUrlsEnvironment) GetUrls() map[EnvironmentBaseUrlId]EnvironmentUrl {
	if m == nil {
		return nil
	}
	return m.Urls
}

func (m *MultipleBaseUrlsEnvironment) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironment) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls,omitempty" url:"baseUrls,omitempty"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironments) GetBaseUrls() []*EnvironmentBaseUrlWithId {
	if m == nil {
		return nil
	}
	return m.BaseUrls
}

func (m *MultipleBaseUrlsEnvironments) GetEnvironments() []*MultipleBaseUrlsEnvironment {
	if m == nil {
		return nil
	}
	return m.Environments
}

func (m *MultipleBaseUrlsEnvironments) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironments) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId  `json:"id" url:"id"`
	Name *Name          `json:"name,omitempty" url:"name,omitempty"`
	Url  EnvironmentUrl `json:"url" url:"url"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironment) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleBaseUrlEnvironment) GetId() EnvironmentId {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SingleBaseUrlEnvironment) GetName() *Name {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleBaseUrlEnvironment) GetUrl() EnvironmentUrl {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *SingleBaseUrlEnvironment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironment) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironments) GetEnvironments() []*SingleBaseUrlEnvironment {
	if s == nil {
		return nil
	}
	return s.Environments
}

func (s *SingleBaseUrlEnvironments) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironments) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
	HttpMethodHead   HttpMethod = "HEAD"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	case "HEAD":
		return HttpMethodHead, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type PrimitiveTypeV1 string

const (
	PrimitiveTypeV1Integer PrimitiveTypeV1 = "INTEGER"
	// Within the range -2^53 to 2^53
	PrimitiveTypeV1Long       PrimitiveTypeV1 = "LONG"
	PrimitiveTypeV1Uint       PrimitiveTypeV1 = "UINT"
	PrimitiveTypeV1Uint64     PrimitiveTypeV1 = "UINT_64"
	PrimitiveTypeV1Float      PrimitiveTypeV1 = "FLOAT"
	PrimitiveTypeV1Double     PrimitiveTypeV1 = "DOUBLE"
	PrimitiveTypeV1Boolean    PrimitiveTypeV1 = "BOOLEAN"
	PrimitiveTypeV1String     PrimitiveTypeV1 = "STRING"
	PrimitiveTypeV1Date       PrimitiveTypeV1 = "DATE"
	PrimitiveTypeV1DateTime   PrimitiveTypeV1 = "DATE_TIME"
	PrimitiveTypeV1Uuid       PrimitiveTypeV1 = "UUID"
	PrimitiveTypeV1Base64     PrimitiveTypeV1 = "BASE_64"
	PrimitiveTypeV1BigInteger PrimitiveTypeV1 = "BIG_INTEGER"
)

func NewPrimitiveTypeV1FromString(s string) (PrimitiveTypeV1, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeV1Integer, nil
	case "LONG":
		return PrimitiveTypeV1Long, nil
	case "UINT":
		return PrimitiveTypeV1Uint, nil
	case "UINT_64":
		return PrimitiveTypeV1Uint64, nil
	case "FLOAT":
		return PrimitiveTypeV1Float, nil
	case "DOUBLE":
		return PrimitiveTypeV1Double, nil
	case "BOOLEAN":
		return PrimitiveTypeV1Boolean, nil
	case "STRING":
		return PrimitiveTypeV1String, nil
	case "DATE":
		return PrimitiveTypeV1Date, nil
	case "DATE_TIME":
		return PrimitiveTypeV1DateTime, nil
	case "UUID":
		return PrimitiveTypeV1Uuid, nil
	case "BASE_64":
		return PrimitiveTypeV1Base64, nil
	case "BIG_INTEGER":
		return PrimitiveTypeV1BigInteger, nil
	}
	var t PrimitiveTypeV1
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveTypeV1) Ptr() *PrimitiveTypeV1 {
	return &p
}

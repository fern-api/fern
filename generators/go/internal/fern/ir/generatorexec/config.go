// Code generated by Fern. DO NOT EDIT.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

type BasicLicense struct {
	Id LicenseId `json:"id" url:"id"`

	extraProperties map[string]interface{}
}

func (b *BasicLicense) GetId() LicenseId {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BasicLicense) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicLicense(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicLicense) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CustomLicense struct {
	Filename string `json:"filename" url:"filename"`

	extraProperties map[string]interface{}
}

func (c *CustomLicense) GetFilename() string {
	if c == nil {
		return ""
	}
	return c.Filename
}

func (c *CustomLicense) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomLicense(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CustomLicense) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EnvironmentVariable = string

type GeneratorConfig struct {
	DryRun                 bool                   `json:"dryRun" url:"dryRun"`
	IrFilepath             string                 `json:"irFilepath" url:"irFilepath"`
	OriginalReadmeFilepath *string                `json:"originalReadmeFilepath,omitempty" url:"originalReadmeFilepath,omitempty"`
	License                *LicenseConfig         `json:"license,omitempty" url:"license,omitempty"`
	Output                 *GeneratorOutputConfig `json:"output" url:"output"`
	// Deprecated. Use output.mode instead.
	Publish                  *GeneratorPublishConfig `json:"publish,omitempty" url:"publish,omitempty"`
	WorkspaceName            string                  `json:"workspaceName" url:"workspaceName"`
	Organization             string                  `json:"organization" url:"organization"`
	CustomConfig             interface{}             `json:"customConfig" url:"customConfig"`
	Environment              *GeneratorEnvironment   `json:"environment" url:"environment"`
	Whitelabel               bool                    `json:"whitelabel" url:"whitelabel"`
	WriteUnitTests           bool                    `json:"writeUnitTests" url:"writeUnitTests"`
	GeneratePaginatedClients *bool                   `json:"generatePaginatedClients,omitempty" url:"generatePaginatedClients,omitempty"`
	GenerateOauthClients     bool                    `json:"generateOauthClients" url:"generateOauthClients"`

	extraProperties map[string]interface{}
}

func (g *GeneratorConfig) GetDryRun() bool {
	if g == nil {
		return false
	}
	return g.DryRun
}

func (g *GeneratorConfig) GetIrFilepath() string {
	if g == nil {
		return ""
	}
	return g.IrFilepath
}

func (g *GeneratorConfig) GetOriginalReadmeFilepath() *string {
	if g == nil {
		return nil
	}
	return g.OriginalReadmeFilepath
}

func (g *GeneratorConfig) GetLicense() *LicenseConfig {
	if g == nil {
		return nil
	}
	return g.License
}

func (g *GeneratorConfig) GetOutput() *GeneratorOutputConfig {
	if g == nil {
		return nil
	}
	return g.Output
}

func (g *GeneratorConfig) GetPublish() *GeneratorPublishConfig {
	if g == nil {
		return nil
	}
	return g.Publish
}

func (g *GeneratorConfig) GetWorkspaceName() string {
	if g == nil {
		return ""
	}
	return g.WorkspaceName
}

func (g *GeneratorConfig) GetOrganization() string {
	if g == nil {
		return ""
	}
	return g.Organization
}

func (g *GeneratorConfig) GetCustomConfig() interface{} {
	if g == nil {
		return nil
	}
	return g.CustomConfig
}

func (g *GeneratorConfig) GetEnvironment() *GeneratorEnvironment {
	if g == nil {
		return nil
	}
	return g.Environment
}

func (g *GeneratorConfig) GetWhitelabel() bool {
	if g == nil {
		return false
	}
	return g.Whitelabel
}

func (g *GeneratorConfig) GetWriteUnitTests() bool {
	if g == nil {
		return false
	}
	return g.WriteUnitTests
}

func (g *GeneratorConfig) GetGeneratePaginatedClients() *bool {
	if g == nil {
		return nil
	}
	return g.GeneratePaginatedClients
}

func (g *GeneratorConfig) GetGenerateOauthClients() bool {
	if g == nil {
		return false
	}
	return g.GenerateOauthClients
}

func (g *GeneratorConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorEnvironment struct {
	Type   string
	Local  interface{}
	Remote *RemoteGeneratorEnvironment
}

func (g *GeneratorEnvironment) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorEnvironment) GetLocal() interface{} {
	if g == nil {
		return nil
	}
	return g.Local
}

func (g *GeneratorEnvironment) GetRemote() *RemoteGeneratorEnvironment {
	if g == nil {
		return nil
	}
	return g.Remote
}

func (g *GeneratorEnvironment) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", g)
	}
	switch unmarshaler.Type {
	case "local":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	case "remote":
		value := new(RemoteGeneratorEnvironment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Remote = value
	}
	return nil
}

func (g GeneratorEnvironment) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Local != nil {
		var marshaler = struct {
			Type  string      `json:"_type"`
			Local interface{} `json:"local,omitempty"`
		}{
			Type:  "local",
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	}
	if g.Remote != nil {
		return internal.MarshalJSONWithExtraProperty(g.Remote, "_type", "remote")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorEnvironmentVisitor interface {
	VisitLocal(interface{}) error
	VisitRemote(*RemoteGeneratorEnvironment) error
}

func (g *GeneratorEnvironment) Accept(visitor GeneratorEnvironmentVisitor) error {
	if g.Local != nil {
		return visitor.VisitLocal(g.Local)
	}
	if g.Remote != nil {
		return visitor.VisitRemote(g.Remote)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorEnvironment) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Local != nil {
		fields = append(fields, "local")
	}
	if g.Remote != nil {
		fields = append(fields, "remote")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

type GeneratorOutputConfig struct {
	Path                    string              `json:"path" url:"path"`
	SnippetFilepath         *string             `json:"snippetFilepath,omitempty" url:"snippetFilepath,omitempty"`
	SnippetTemplateFilepath *string             `json:"snippetTemplateFilepath,omitempty" url:"snippetTemplateFilepath,omitempty"`
	PublishingMetadata      *PublishingMetadata `json:"publishingMetadata,omitempty" url:"publishingMetadata,omitempty"`
	Mode                    *OutputMode         `json:"mode" url:"mode"`

	extraProperties map[string]interface{}
}

func (g *GeneratorOutputConfig) GetPath() string {
	if g == nil {
		return ""
	}
	return g.Path
}

func (g *GeneratorOutputConfig) GetSnippetFilepath() *string {
	if g == nil {
		return nil
	}
	return g.SnippetFilepath
}

func (g *GeneratorOutputConfig) GetSnippetTemplateFilepath() *string {
	if g == nil {
		return nil
	}
	return g.SnippetTemplateFilepath
}

func (g *GeneratorOutputConfig) GetPublishingMetadata() *PublishingMetadata {
	if g == nil {
		return nil
	}
	return g.PublishingMetadata
}

func (g *GeneratorOutputConfig) GetMode() *OutputMode {
	if g == nil {
		return nil
	}
	return g.Mode
}

func (g *GeneratorOutputConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorOutputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorOutputConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorOutputConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries" url:"registries"`
	// Deprecated, use publishTargets instead.
	RegistriesV2  *GeneratorRegistriesConfigV2 `json:"registriesV2" url:"registriesV2"`
	PublishTarget *GeneratorPublishTarget      `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`
	Version       string                       `json:"version" url:"version"`

	extraProperties map[string]interface{}
}

func (g *GeneratorPublishConfig) GetRegistries() *GeneratorRegistriesConfig {
	if g == nil {
		return nil
	}
	return g.Registries
}

func (g *GeneratorPublishConfig) GetRegistriesV2() *GeneratorRegistriesConfigV2 {
	if g == nil {
		return nil
	}
	return g.RegistriesV2
}

func (g *GeneratorPublishConfig) GetPublishTarget() *GeneratorPublishTarget {
	if g == nil {
		return nil
	}
	return g.PublishTarget
}

func (g *GeneratorPublishConfig) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GeneratorPublishConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorPublishConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorPublishConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorPublishConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorPublishConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorPublishTarget struct {
	Type     string
	Maven    *MavenRegistryConfigV2
	Npm      *NpmRegistryConfigV2
	Pypi     *PypiRegistryConfig
	Postman  *PostmanConfig
	Rubygems *RubyGemsRegistryConfig
	Nuget    *NugetRegistryConfig
}

func (g *GeneratorPublishTarget) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorPublishTarget) GetMaven() *MavenRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorPublishTarget) GetNpm() *NpmRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorPublishTarget) GetPypi() *PypiRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GeneratorPublishTarget) GetPostman() *PostmanConfig {
	if g == nil {
		return nil
	}
	return g.Postman
}

func (g *GeneratorPublishTarget) GetRubygems() *RubyGemsRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GeneratorPublishTarget) GetNuget() *NugetRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GeneratorPublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "maven":
		value := new(MavenRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "pypi":
		value := new(PypiRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "postman":
		value := new(PostmanConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "rubygems":
		value := new(RubyGemsRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GeneratorPublishTarget) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	}
	if g.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	}
	if g.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	}
	if g.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	}
	if g.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	}
	if g.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorPublishTargetVisitor interface {
	VisitMaven(*MavenRegistryConfigV2) error
	VisitNpm(*NpmRegistryConfigV2) error
	VisitPypi(*PypiRegistryConfig) error
	VisitPostman(*PostmanConfig) error
	VisitRubygems(*RubyGemsRegistryConfig) error
	VisitNuget(*NugetRegistryConfig) error
}

func (g *GeneratorPublishTarget) Accept(visitor GeneratorPublishTargetVisitor) error {
	if g.Maven != nil {
		return visitor.VisitMaven(g.Maven)
	}
	if g.Npm != nil {
		return visitor.VisitNpm(g.Npm)
	}
	if g.Pypi != nil {
		return visitor.VisitPypi(g.Pypi)
	}
	if g.Postman != nil {
		return visitor.VisitPostman(g.Postman)
	}
	if g.Rubygems != nil {
		return visitor.VisitRubygems(g.Rubygems)
	}
	if g.Nuget != nil {
		return visitor.VisitNuget(g.Nuget)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorPublishTarget) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Maven != nil {
		fields = append(fields, "maven")
	}
	if g.Npm != nil {
		fields = append(fields, "npm")
	}
	if g.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if g.Postman != nil {
		fields = append(fields, "postman")
	}
	if g.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if g.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

type GeneratorRegistriesConfig struct {
	Maven *MavenRegistryConfig `json:"maven" url:"maven"`
	Npm   *NpmRegistryConfig   `json:"npm" url:"npm"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfig) GetMaven() *MavenRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorRegistriesConfig) GetNpm() *NpmRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorRegistriesConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorRegistriesConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorRegistriesConfigV2 struct {
	Maven    *MavenRegistryConfigV2  `json:"maven" url:"maven"`
	Npm      *NpmRegistryConfigV2    `json:"npm" url:"npm"`
	Pypi     *PypiRegistryConfig     `json:"pypi" url:"pypi"`
	Rubygems *RubyGemsRegistryConfig `json:"rubygems" url:"rubygems"`
	Nuget    *NugetRegistryConfig    `json:"nuget" url:"nuget"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfigV2) GetMaven() *MavenRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorRegistriesConfigV2) GetNpm() *NpmRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorRegistriesConfigV2) GetPypi() *PypiRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GeneratorRegistriesConfigV2) GetRubygems() *RubyGemsRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GeneratorRegistriesConfigV2) GetNuget() *NugetRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GeneratorRegistriesConfigV2) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorRegistriesConfigV2) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GithubOutputMode struct {
	Version string `json:"version" url:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`
	// The token scoped to installing the repository. If not specified, the generator
	// should NOT attempt to clone the repository.
	InstallationToken *string            `json:"installationToken,omitempty" url:"installationToken,omitempty"`
	PublishInfo       *GithubPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GithubOutputMode) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GithubOutputMode) GetRepoUrl() string {
	if g == nil {
		return ""
	}
	return g.RepoUrl
}

func (g *GithubOutputMode) GetInstallationToken() *string {
	if g == nil {
		return nil
	}
	return g.InstallationToken
}

func (g *GithubOutputMode) GetPublishInfo() *GithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.PublishInfo
}

func (g *GithubOutputMode) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubOutputMode) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubOutputMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubOutputMode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GithubOutputMode) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GithubPublishInfo struct {
	Type     string
	Npm      *NpmGithubPublishInfo
	Maven    *MavenGithubPublishInfo
	Postman  *PostmanGithubPublishInfo
	Pypi     *PypiGithubPublishInfo
	Rubygems *RubyGemsGithubPublishInfo
	Nuget    *NugetGithubPublishInfo
}

func (g *GithubPublishInfo) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GithubPublishInfo) GetNpm() *NpmGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GithubPublishInfo) GetMaven() *MavenGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GithubPublishInfo) GetPostman() *PostmanGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Postman
}

func (g *GithubPublishInfo) GetPypi() *PypiGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GithubPublishInfo) GetRubygems() *RubyGemsGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GithubPublishInfo) GetNuget() *NugetGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GithubPublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "maven":
		value := new(MavenGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "postman":
		value := new(PostmanGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "pypi":
		value := new(PypiGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "rubygems":
		value := new(RubyGemsGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GithubPublishInfo) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	}
	if g.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	}
	if g.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	}
	if g.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	}
	if g.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	}
	if g.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GithubPublishInfoVisitor interface {
	VisitNpm(*NpmGithubPublishInfo) error
	VisitMaven(*MavenGithubPublishInfo) error
	VisitPostman(*PostmanGithubPublishInfo) error
	VisitPypi(*PypiGithubPublishInfo) error
	VisitRubygems(*RubyGemsGithubPublishInfo) error
	VisitNuget(*NugetGithubPublishInfo) error
}

func (g *GithubPublishInfo) Accept(visitor GithubPublishInfoVisitor) error {
	if g.Npm != nil {
		return visitor.VisitNpm(g.Npm)
	}
	if g.Maven != nil {
		return visitor.VisitMaven(g.Maven)
	}
	if g.Postman != nil {
		return visitor.VisitPostman(g.Postman)
	}
	if g.Pypi != nil {
		return visitor.VisitPypi(g.Pypi)
	}
	if g.Rubygems != nil {
		return visitor.VisitRubygems(g.Rubygems)
	}
	if g.Nuget != nil {
		return visitor.VisitNuget(g.Nuget)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GithubPublishInfo) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Npm != nil {
		fields = append(fields, "npm")
	}
	if g.Maven != nil {
		fields = append(fields, "maven")
	}
	if g.Postman != nil {
		fields = append(fields, "postman")
	}
	if g.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if g.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if g.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

type LicenseConfig struct {
	Type   string
	Basic  *BasicLicense
	Custom *CustomLicense
}

func (l *LicenseConfig) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LicenseConfig) GetBasic() *BasicLicense {
	if l == nil {
		return nil
	}
	return l.Basic
}

func (l *LicenseConfig) GetCustom() *CustomLicense {
	if l == nil {
		return nil
	}
	return l.Custom
}

func (l *LicenseConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Basic = value
	case "custom":
		value := new(CustomLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Custom = value
	}
	return nil
}

func (l LicenseConfig) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	if l.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(l.Basic, "type", "basic")
	}
	if l.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(l.Custom, "type", "custom")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LicenseConfigVisitor interface {
	VisitBasic(*BasicLicense) error
	VisitCustom(*CustomLicense) error
}

func (l *LicenseConfig) Accept(visitor LicenseConfigVisitor) error {
	if l.Basic != nil {
		return visitor.VisitBasic(l.Basic)
	}
	if l.Custom != nil {
		return visitor.VisitCustom(l.Custom)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

func (l *LicenseConfig) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.Basic != nil {
		fields = append(fields, "basic")
	}
	if l.Custom != nil {
		fields = append(fields, "custom")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

type LicenseId string

const (
	LicenseIdMit     LicenseId = "MIT"
	LicenseIdApache2 LicenseId = "Apache-2.0"
)

func NewLicenseIdFromString(s string) (LicenseId, error) {
	switch s {
	case "MIT":
		return LicenseIdMit, nil
	case "Apache-2.0":
		return LicenseIdApache2, nil
	}
	var t LicenseId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LicenseId) Ptr() *LicenseId {
	return &l
}

type MavenCentralSignature struct {
	KeyId     string `json:"keyId" url:"keyId"`
	Password  string `json:"password" url:"password"`
	SecretKey string `json:"secretKey" url:"secretKey"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignature) GetKeyId() string {
	if m == nil {
		return ""
	}
	return m.KeyId
}

func (m *MavenCentralSignature) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenCentralSignature) GetSecretKey() string {
	if m == nil {
		return ""
	}
	return m.SecretKey
}

func (m *MavenCentralSignature) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenCentralSignature) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenCentralSignatureGithubInfo struct {
	KeyIdEnvironmentVariable     EnvironmentVariable `json:"keyIdEnvironmentVariable" url:"keyIdEnvironmentVariable"`
	PasswordEnvironmentVariable  EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	SecretKeyEnvironmentVariable EnvironmentVariable `json:"secretKeyEnvironmentVariable" url:"secretKeyEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignatureGithubInfo) GetKeyIdEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.KeyIdEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetSecretKeyEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.SecretKeyEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignatureGithubInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignatureGithubInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignatureGithubInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenCentralSignatureGithubInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenGithubPublishInfo struct {
	RegistryUrl                   string                           `json:"registryUrl" url:"registryUrl"`
	Coordinate                    string                           `json:"coordinate" url:"coordinate"`
	UsernameEnvironmentVariable   EnvironmentVariable              `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable              `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	Signature                     *MavenCentralSignatureGithubInfo `json:"signature,omitempty" url:"signature,omitempty"`
	ShouldGeneratePublishWorkflow *bool                            `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenGithubPublishInfo) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenGithubPublishInfo) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenGithubPublishInfo) GetUsernameEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.UsernameEnvironmentVariable
}

func (m *MavenGithubPublishInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenGithubPublishInfo) GetSignature() *MavenCentralSignatureGithubInfo {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if m == nil {
		return nil
	}
	return m.ShouldGeneratePublishWorkflow
}

func (m *MavenGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenRegistryConfig struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Group       string                 `json:"group" url:"group"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfig) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenRegistryConfig) GetUsername() string {
	if m == nil {
		return ""
	}
	return m.Username
}

func (m *MavenRegistryConfig) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenRegistryConfig) GetGroup() string {
	if m == nil {
		return ""
	}
	return m.Group
}

func (m *MavenRegistryConfig) GetSignature() *MavenCentralSignature {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenRegistryConfig) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenRegistryConfigV2 struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Coordinate  string                 `json:"coordinate" url:"coordinate"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfigV2) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenRegistryConfigV2) GetUsername() string {
	if m == nil {
		return ""
	}
	return m.Username
}

func (m *MavenRegistryConfigV2) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenRegistryConfigV2) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenRegistryConfigV2) GetSignature() *MavenCentralSignature {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenRegistryConfigV2) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	TokenEnvironmentVariable      EnvironmentVariable `json:"tokenEnvironmentVariable" url:"tokenEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NpmGithubPublishInfo) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmGithubPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmGithubPublishInfo) GetTokenEnvironmentVariable() EnvironmentVariable {
	if n == nil {
		return ""
	}
	return n.TokenEnvironmentVariable
}

func (n *NpmGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if n == nil {
		return nil
	}
	return n.ShouldGeneratePublishWorkflow
}

func (n *NpmGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NpmRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	Scope       string `json:"scope" url:"scope"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfig) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmRegistryConfig) GetToken() string {
	if n == nil {
		return ""
	}
	return n.Token
}

func (n *NpmRegistryConfig) GetScope() string {
	if n == nil {
		return ""
	}
	return n.Scope
}

func (n *NpmRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NpmRegistryConfigV2 struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfigV2) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmRegistryConfigV2) GetToken() string {
	if n == nil {
		return ""
	}
	return n.Token
}

func (n *NpmRegistryConfigV2) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmRegistryConfigV2) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NugetGithubPublishInfo) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NugetGithubPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if n == nil {
		return ""
	}
	return n.ApiKeyEnvironmentVariable
}

func (n *NugetGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if n == nil {
		return nil
	}
	return n.ShouldGeneratePublishWorkflow
}

func (n *NugetGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (n *NugetRegistryConfig) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NugetRegistryConfig) GetApiKey() string {
	if n == nil {
		return ""
	}
	return n.ApiKey
}

func (n *NugetRegistryConfig) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OutputMetadata struct {
	Description *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors     []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadata) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputMetadata) GetAuthors() []*OutputMetadataAuthor {
	if o == nil {
		return nil
	}
	return o.Authors
}

func (o *OutputMetadata) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OutputMetadata) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputMetadataAuthor struct {
	Name  string `json:"name" url:"name"`
	Email string `json:"email" url:"email"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadataAuthor) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OutputMetadataAuthor) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *OutputMetadataAuthor) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadataAuthor) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadataAuthor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadataAuthor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OutputMetadataAuthor) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputMode struct {
	Type          string
	Publish       *GeneratorPublishConfig
	DownloadFiles interface{}
	Github        *GithubOutputMode
}

func (o *OutputMode) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *OutputMode) GetPublish() *GeneratorPublishConfig {
	if o == nil {
		return nil
	}
	return o.Publish
}

func (o *OutputMode) GetDownloadFiles() interface{} {
	if o == nil {
		return nil
	}
	return o.DownloadFiles
}

func (o *OutputMode) GetGithub() *GithubOutputMode {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *OutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "publish":
		value := new(GeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Publish = value
	case "downloadFiles":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Github = value
	}
	return nil
}

func (o OutputMode) MarshalJSON() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	if o.Publish != nil {
		return internal.MarshalJSONWithExtraProperty(o.Publish, "type", "publish")
	}
	if o.DownloadFiles != nil {
		var marshaler = struct {
			Type          string      `json:"type"`
			DownloadFiles interface{} `json:"downloadFiles,omitempty"`
		}{
			Type:          "downloadFiles",
			DownloadFiles: o.DownloadFiles,
		}
		return json.Marshal(marshaler)
	}
	if o.Github != nil {
		return internal.MarshalJSONWithExtraProperty(o.Github, "type", "github")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OutputModeVisitor interface {
	VisitPublish(*GeneratorPublishConfig) error
	VisitDownloadFiles(interface{}) error
	VisitGithub(*GithubOutputMode) error
}

func (o *OutputMode) Accept(visitor OutputModeVisitor) error {
	if o.Publish != nil {
		return visitor.VisitPublish(o.Publish)
	}
	if o.DownloadFiles != nil {
		return visitor.VisitDownloadFiles(o.DownloadFiles)
	}
	if o.Github != nil {
		return visitor.VisitGithub(o.Github)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

func (o *OutputMode) validate() error {
	if o == nil {
		return fmt.Errorf("type %T is nil", o)
	}
	var fields []string
	if o.Publish != nil {
		fields = append(fields, "publish")
	}
	if o.DownloadFiles != nil {
		fields = append(fields, "downloadFiles")
	}
	if o.Github != nil {
		fields = append(fields, "github")
	}
	if len(fields) == 0 {
		if o.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", o, o.Type)
		}
		return fmt.Errorf("type %T is empty", o)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", o, fields)
	}
	if o.Type != "" {
		field := fields[0]
		if o.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				o,
				o.Type,
				o,
			)
		}
	}
	return nil
}

type PostmanConfig struct {
	ApiKey      string `json:"apiKey" url:"apiKey"`
	WorkspaceId string `json:"workspaceId" url:"workspaceId"`

	extraProperties map[string]interface{}
}

func (p *PostmanConfig) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PostmanConfig) GetWorkspaceId() string {
	if p == nil {
		return ""
	}
	return p.WorkspaceId
}

func (p *PostmanConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanConfig) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostmanGithubPublishInfo struct {
	ApiKeyEnvironmentVariable      EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	WorkspaceIdEnvironmentVariable EnvironmentVariable `json:"workspaceIdEnvironmentVariable" url:"workspaceIdEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (p *PostmanGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.ApiKeyEnvironmentVariable
}

func (p *PostmanGithubPublishInfo) GetWorkspaceIdEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.WorkspaceIdEnvironmentVariable
}

func (p *PostmanGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// This should effectively be deprecated in favor of a more specific configuration per-output mode (pypi, maven, etc.).
type PublishingMetadata struct {
	PackageDescription *string `json:"package_description,omitempty" url:"package_description,omitempty"`
	PublisherEmail     *string `json:"publisher_email,omitempty" url:"publisher_email,omitempty"`
	ReferenceUrl       *string `json:"reference_url,omitempty" url:"reference_url,omitempty"`
	PublisherName      *string `json:"publisher_name,omitempty" url:"publisher_name,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PublishingMetadata) GetPackageDescription() *string {
	if p == nil {
		return nil
	}
	return p.PackageDescription
}

func (p *PublishingMetadata) GetPublisherEmail() *string {
	if p == nil {
		return nil
	}
	return p.PublisherEmail
}

func (p *PublishingMetadata) GetReferenceUrl() *string {
	if p == nil {
		return nil
	}
	return p.ReferenceUrl
}

func (p *PublishingMetadata) GetPublisherName() *string {
	if p == nil {
		return nil
	}
	return p.PublisherName
}

func (p *PublishingMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublishingMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PublishingMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PublishingMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PublishingMetadata) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	UsernameEnvironmentVariable   EnvironmentVariable `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	PypiMetadata                  *PypiMetadata       `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiGithubPublishInfo) GetRegistryUrl() string {
	if p == nil {
		return ""
	}
	return p.RegistryUrl
}

func (p *PypiGithubPublishInfo) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiGithubPublishInfo) GetUsernameEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.UsernameEnvironmentVariable
}

func (p *PypiGithubPublishInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.PasswordEnvironmentVariable
}

func (p *PypiGithubPublishInfo) GetPypiMetadata() *PypiMetadata {
	if p == nil {
		return nil
	}
	return p.PypiMetadata
}

func (p *PypiGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if p == nil {
		return nil
	}
	return p.ShouldGeneratePublishWorkflow
}

func (p *PypiGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiMetadata struct {
	Description       *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors           []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`
	Keywords          []string                `json:"keywords,omitempty" url:"keywords,omitempty"`
	DocumentationLink *string                 `json:"documentationLink,omitempty" url:"documentationLink,omitempty"`
	HomepageLink      *string                 `json:"homepageLink,omitempty" url:"homepageLink,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiMetadata) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PypiMetadata) GetAuthors() []*OutputMetadataAuthor {
	if p == nil {
		return nil
	}
	return p.Authors
}

func (p *PypiMetadata) GetKeywords() []string {
	if p == nil {
		return nil
	}
	return p.Keywords
}

func (p *PypiMetadata) GetDocumentationLink() *string {
	if p == nil {
		return nil
	}
	return p.DocumentationLink
}

func (p *PypiMetadata) GetHomepageLink() *string {
	if p == nil {
		return nil
	}
	return p.HomepageLink
}

func (p *PypiMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiMetadata) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiRegistryConfig struct {
	RegistryUrl  string        `json:"registryUrl" url:"registryUrl"`
	Username     string        `json:"username" url:"username"`
	Password     string        `json:"password" url:"password"`
	PackageName  string        `json:"packageName" url:"packageName"`
	PypiMetadata *PypiMetadata `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiRegistryConfig) GetRegistryUrl() string {
	if p == nil {
		return ""
	}
	return p.RegistryUrl
}

func (p *PypiRegistryConfig) GetUsername() string {
	if p == nil {
		return ""
	}
	return p.Username
}

func (p *PypiRegistryConfig) GetPassword() string {
	if p == nil {
		return ""
	}
	return p.Password
}

func (p *PypiRegistryConfig) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiRegistryConfig) GetPypiMetadata() *PypiMetadata {
	if p == nil {
		return nil
	}
	return p.PypiMetadata
}

func (p *PypiRegistryConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RemoteGeneratorEnvironment struct {
	CoordinatorUrl   string `json:"coordinatorUrl" url:"coordinatorUrl"`
	CoordinatorUrlV2 string `json:"coordinatorUrlV2" url:"coordinatorUrlV2"`
	Id               string `json:"id" url:"id"`

	extraProperties map[string]interface{}
}

func (r *RemoteGeneratorEnvironment) GetCoordinatorUrl() string {
	if r == nil {
		return ""
	}
	return r.CoordinatorUrl
}

func (r *RemoteGeneratorEnvironment) GetCoordinatorUrlV2() string {
	if r == nil {
		return ""
	}
	return r.CoordinatorUrlV2
}

func (r *RemoteGeneratorEnvironment) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RemoteGeneratorEnvironment) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteGeneratorEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteGeneratorEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteGeneratorEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RemoteGeneratorEnvironment) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyGemsGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsGithubPublishInfo) GetRegistryUrl() string {
	if r == nil {
		return ""
	}
	return r.RegistryUrl
}

func (r *RubyGemsGithubPublishInfo) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if r == nil {
		return ""
	}
	return r.ApiKeyEnvironmentVariable
}

func (r *RubyGemsGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if r == nil {
		return nil
	}
	return r.ShouldGeneratePublishWorkflow
}

func (r *RubyGemsGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyGemsRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsRegistryConfig) GetRegistryUrl() string {
	if r == nil {
		return ""
	}
	return r.RegistryUrl
}

func (r *RubyGemsRegistryConfig) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RubyGemsRegistryConfig) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsRegistryConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

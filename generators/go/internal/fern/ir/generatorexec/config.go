// Code generated by Fern. DO NOT EDIT.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"

	internal "github.com/fern-api/fern-go/internal/fern/ir/internal"
)

var (
	basicLicenseFieldId = big.NewInt(1 << 0)
)

type BasicLicense struct {
	Id LicenseId `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (b *BasicLicense) GetId() LicenseId {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BasicLicense) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicLicense) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasicLicense) SetId(id LicenseId) {
	b.Id = id
	b.require(basicLicenseFieldId)
}

func (b *BasicLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicLicense(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicLicense) MarshalJSON() ([]byte, error) {
	type embed BasicLicense
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasicLicense) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	customLicenseFieldFilename = big.NewInt(1 << 0)
)

type CustomLicense struct {
	Filename string `json:"filename" url:"filename"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (c *CustomLicense) GetFilename() string {
	if c == nil {
		return ""
	}
	return c.Filename
}

func (c *CustomLicense) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLicense) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetFilename sets the Filename field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomLicense) SetFilename(filename string) {
	c.Filename = filename
	c.require(customLicenseFieldFilename)
}

func (c *CustomLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomLicense(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	return nil
}

func (c *CustomLicense) MarshalJSON() ([]byte, error) {
	type embed CustomLicense
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CustomLicense) String() string {
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EnvironmentVariable = string

var (
	generatorConfigFieldDryRun                   = big.NewInt(1 << 0)
	generatorConfigFieldIrFilepath               = big.NewInt(1 << 1)
	generatorConfigFieldOriginalReadmeFilepath   = big.NewInt(1 << 2)
	generatorConfigFieldLicense                  = big.NewInt(1 << 3)
	generatorConfigFieldOutput                   = big.NewInt(1 << 4)
	generatorConfigFieldPublish                  = big.NewInt(1 << 5)
	generatorConfigFieldWorkspaceName            = big.NewInt(1 << 6)
	generatorConfigFieldOrganization             = big.NewInt(1 << 7)
	generatorConfigFieldCustomConfig             = big.NewInt(1 << 8)
	generatorConfigFieldEnvironment              = big.NewInt(1 << 9)
	generatorConfigFieldWhitelabel               = big.NewInt(1 << 10)
	generatorConfigFieldWriteUnitTests           = big.NewInt(1 << 11)
	generatorConfigFieldGeneratePaginatedClients = big.NewInt(1 << 12)
	generatorConfigFieldGenerateOauthClients     = big.NewInt(1 << 13)
)

type GeneratorConfig struct {
	DryRun                 bool                   `json:"dryRun" url:"dryRun"`
	IrFilepath             string                 `json:"irFilepath" url:"irFilepath"`
	OriginalReadmeFilepath *string                `json:"originalReadmeFilepath,omitempty" url:"originalReadmeFilepath,omitempty"`
	License                *LicenseConfig         `json:"license,omitempty" url:"license,omitempty"`
	Output                 *GeneratorOutputConfig `json:"output" url:"output"`
	// Deprecated. Use output.mode instead.
	Publish                  *GeneratorPublishConfig `json:"publish,omitempty" url:"publish,omitempty"`
	WorkspaceName            string                  `json:"workspaceName" url:"workspaceName"`
	Organization             string                  `json:"organization" url:"organization"`
	CustomConfig             interface{}             `json:"customConfig" url:"customConfig"`
	Environment              *GeneratorEnvironment   `json:"environment" url:"environment"`
	Whitelabel               bool                    `json:"whitelabel" url:"whitelabel"`
	WriteUnitTests           bool                    `json:"writeUnitTests" url:"writeUnitTests"`
	GeneratePaginatedClients *bool                   `json:"generatePaginatedClients,omitempty" url:"generatePaginatedClients,omitempty"`
	GenerateOauthClients     bool                    `json:"generateOauthClients" url:"generateOauthClients"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorConfig) GetDryRun() bool {
	if g == nil {
		return false
	}
	return g.DryRun
}

func (g *GeneratorConfig) GetIrFilepath() string {
	if g == nil {
		return ""
	}
	return g.IrFilepath
}

func (g *GeneratorConfig) GetOriginalReadmeFilepath() *string {
	if g == nil {
		return nil
	}
	return g.OriginalReadmeFilepath
}

func (g *GeneratorConfig) GetLicense() *LicenseConfig {
	if g == nil {
		return nil
	}
	return g.License
}

func (g *GeneratorConfig) GetOutput() *GeneratorOutputConfig {
	if g == nil {
		return nil
	}
	return g.Output
}

func (g *GeneratorConfig) GetPublish() *GeneratorPublishConfig {
	if g == nil {
		return nil
	}
	return g.Publish
}

func (g *GeneratorConfig) GetWorkspaceName() string {
	if g == nil {
		return ""
	}
	return g.WorkspaceName
}

func (g *GeneratorConfig) GetOrganization() string {
	if g == nil {
		return ""
	}
	return g.Organization
}

func (g *GeneratorConfig) GetCustomConfig() interface{} {
	if g == nil {
		return nil
	}
	return g.CustomConfig
}

func (g *GeneratorConfig) GetEnvironment() *GeneratorEnvironment {
	if g == nil {
		return nil
	}
	return g.Environment
}

func (g *GeneratorConfig) GetWhitelabel() bool {
	if g == nil {
		return false
	}
	return g.Whitelabel
}

func (g *GeneratorConfig) GetWriteUnitTests() bool {
	if g == nil {
		return false
	}
	return g.WriteUnitTests
}

func (g *GeneratorConfig) GetGeneratePaginatedClients() *bool {
	if g == nil {
		return nil
	}
	return g.GeneratePaginatedClients
}

func (g *GeneratorConfig) GetGenerateOauthClients() bool {
	if g == nil {
		return false
	}
	return g.GenerateOauthClients
}

func (g *GeneratorConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorConfig) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetDryRun sets the DryRun field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetDryRun(dryRun bool) {
	g.DryRun = dryRun
	g.require(generatorConfigFieldDryRun)
}

// SetIrFilepath sets the IrFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetIrFilepath(irFilepath string) {
	g.IrFilepath = irFilepath
	g.require(generatorConfigFieldIrFilepath)
}

// SetOriginalReadmeFilepath sets the OriginalReadmeFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetOriginalReadmeFilepath(originalReadmeFilepath *string) {
	g.OriginalReadmeFilepath = originalReadmeFilepath
	g.require(generatorConfigFieldOriginalReadmeFilepath)
}

// SetLicense sets the License field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetLicense(license *LicenseConfig) {
	g.License = license
	g.require(generatorConfigFieldLicense)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetOutput(output *GeneratorOutputConfig) {
	g.Output = output
	g.require(generatorConfigFieldOutput)
}

// SetPublish sets the Publish field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetPublish(publish *GeneratorPublishConfig) {
	g.Publish = publish
	g.require(generatorConfigFieldPublish)
}

// SetWorkspaceName sets the WorkspaceName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetWorkspaceName(workspaceName string) {
	g.WorkspaceName = workspaceName
	g.require(generatorConfigFieldWorkspaceName)
}

// SetOrganization sets the Organization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetOrganization(organization string) {
	g.Organization = organization
	g.require(generatorConfigFieldOrganization)
}

// SetCustomConfig sets the CustomConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetCustomConfig(customConfig interface{}) {
	g.CustomConfig = customConfig
	g.require(generatorConfigFieldCustomConfig)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetEnvironment(environment *GeneratorEnvironment) {
	g.Environment = environment
	g.require(generatorConfigFieldEnvironment)
}

// SetWhitelabel sets the Whitelabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetWhitelabel(whitelabel bool) {
	g.Whitelabel = whitelabel
	g.require(generatorConfigFieldWhitelabel)
}

// SetWriteUnitTests sets the WriteUnitTests field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetWriteUnitTests(writeUnitTests bool) {
	g.WriteUnitTests = writeUnitTests
	g.require(generatorConfigFieldWriteUnitTests)
}

// SetGeneratePaginatedClients sets the GeneratePaginatedClients field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetGeneratePaginatedClients(generatePaginatedClients *bool) {
	g.GeneratePaginatedClients = generatePaginatedClients
	g.require(generatorConfigFieldGeneratePaginatedClients)
}

// SetGenerateOauthClients sets the GenerateOauthClients field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorConfig) SetGenerateOauthClients(generateOauthClients bool) {
	g.GenerateOauthClients = generateOauthClients
	g.require(generatorConfigFieldGenerateOauthClients)
}

func (g *GeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorConfig) MarshalJSON() ([]byte, error) {
	type embed GeneratorConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorEnvironment struct {
	Type   string
	Local  interface{}
	Remote *RemoteGeneratorEnvironment
}

func (g *GeneratorEnvironment) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorEnvironment) GetLocal() interface{} {
	if g == nil {
		return nil
	}
	return g.Local
}

func (g *GeneratorEnvironment) GetRemote() *RemoteGeneratorEnvironment {
	if g == nil {
		return nil
	}
	return g.Remote
}

func (g *GeneratorEnvironment) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", g)
	}
	switch unmarshaler.Type {
	case "local":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	case "remote":
		value := new(RemoteGeneratorEnvironment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Remote = value
	}
	return nil
}

func (g GeneratorEnvironment) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Local != nil {
		var marshaler = struct {
			Type  string      `json:"_type"`
			Local interface{} `json:"local,omitempty"`
		}{
			Type:  "local",
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	}
	if g.Remote != nil {
		return internal.MarshalJSONWithExtraProperty(g.Remote, "_type", "remote")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorEnvironmentVisitor interface {
	VisitLocal(interface{}) error
	VisitRemote(*RemoteGeneratorEnvironment) error
}

func (g *GeneratorEnvironment) Accept(visitor GeneratorEnvironmentVisitor) error {
	if g.Local != nil {
		return visitor.VisitLocal(g.Local)
	}
	if g.Remote != nil {
		return visitor.VisitRemote(g.Remote)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorEnvironment) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Local != nil {
		fields = append(fields, "local")
	}
	if g.Remote != nil {
		fields = append(fields, "remote")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

var (
	generatorOutputConfigFieldPath                    = big.NewInt(1 << 0)
	generatorOutputConfigFieldSnippetFilepath         = big.NewInt(1 << 1)
	generatorOutputConfigFieldSnippetTemplateFilepath = big.NewInt(1 << 2)
	generatorOutputConfigFieldPublishingMetadata      = big.NewInt(1 << 3)
	generatorOutputConfigFieldMode                    = big.NewInt(1 << 4)
)

type GeneratorOutputConfig struct {
	Path                    string              `json:"path" url:"path"`
	SnippetFilepath         *string             `json:"snippetFilepath,omitempty" url:"snippetFilepath,omitempty"`
	SnippetTemplateFilepath *string             `json:"snippetTemplateFilepath,omitempty" url:"snippetTemplateFilepath,omitempty"`
	PublishingMetadata      *PublishingMetadata `json:"publishingMetadata,omitempty" url:"publishingMetadata,omitempty"`
	Mode                    *OutputMode         `json:"mode" url:"mode"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorOutputConfig) GetPath() string {
	if g == nil {
		return ""
	}
	return g.Path
}

func (g *GeneratorOutputConfig) GetSnippetFilepath() *string {
	if g == nil {
		return nil
	}
	return g.SnippetFilepath
}

func (g *GeneratorOutputConfig) GetSnippetTemplateFilepath() *string {
	if g == nil {
		return nil
	}
	return g.SnippetTemplateFilepath
}

func (g *GeneratorOutputConfig) GetPublishingMetadata() *PublishingMetadata {
	if g == nil {
		return nil
	}
	return g.PublishingMetadata
}

func (g *GeneratorOutputConfig) GetMode() *OutputMode {
	if g == nil {
		return nil
	}
	return g.Mode
}

func (g *GeneratorOutputConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorOutputConfig) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorOutputConfig) SetPath(path string) {
	g.Path = path
	g.require(generatorOutputConfigFieldPath)
}

// SetSnippetFilepath sets the SnippetFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorOutputConfig) SetSnippetFilepath(snippetFilepath *string) {
	g.SnippetFilepath = snippetFilepath
	g.require(generatorOutputConfigFieldSnippetFilepath)
}

// SetSnippetTemplateFilepath sets the SnippetTemplateFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorOutputConfig) SetSnippetTemplateFilepath(snippetTemplateFilepath *string) {
	g.SnippetTemplateFilepath = snippetTemplateFilepath
	g.require(generatorOutputConfigFieldSnippetTemplateFilepath)
}

// SetPublishingMetadata sets the PublishingMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorOutputConfig) SetPublishingMetadata(publishingMetadata *PublishingMetadata) {
	g.PublishingMetadata = publishingMetadata
	g.require(generatorOutputConfigFieldPublishingMetadata)
}

// SetMode sets the Mode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorOutputConfig) SetMode(mode *OutputMode) {
	g.Mode = mode
	g.require(generatorOutputConfigFieldMode)
}

func (g *GeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorOutputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorOutputConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorOutputConfig) MarshalJSON() ([]byte, error) {
	type embed GeneratorOutputConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorOutputConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	generatorPublishConfigFieldRegistries    = big.NewInt(1 << 0)
	generatorPublishConfigFieldRegistriesV2  = big.NewInt(1 << 1)
	generatorPublishConfigFieldPublishTarget = big.NewInt(1 << 2)
	generatorPublishConfigFieldVersion       = big.NewInt(1 << 3)
)

type GeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries" url:"registries"`
	// Deprecated, use publishTargets instead.
	RegistriesV2  *GeneratorRegistriesConfigV2 `json:"registriesV2" url:"registriesV2"`
	PublishTarget *GeneratorPublishTarget      `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`
	Version       string                       `json:"version" url:"version"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorPublishConfig) GetRegistries() *GeneratorRegistriesConfig {
	if g == nil {
		return nil
	}
	return g.Registries
}

func (g *GeneratorPublishConfig) GetRegistriesV2() *GeneratorRegistriesConfigV2 {
	if g == nil {
		return nil
	}
	return g.RegistriesV2
}

func (g *GeneratorPublishConfig) GetPublishTarget() *GeneratorPublishTarget {
	if g == nil {
		return nil
	}
	return g.PublishTarget
}

func (g *GeneratorPublishConfig) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GeneratorPublishConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorPublishConfig) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetRegistries sets the Registries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorPublishConfig) SetRegistries(registries *GeneratorRegistriesConfig) {
	g.Registries = registries
	g.require(generatorPublishConfigFieldRegistries)
}

// SetRegistriesV2 sets the RegistriesV2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorPublishConfig) SetRegistriesV2(registriesV2 *GeneratorRegistriesConfigV2) {
	g.RegistriesV2 = registriesV2
	g.require(generatorPublishConfigFieldRegistriesV2)
}

// SetPublishTarget sets the PublishTarget field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorPublishConfig) SetPublishTarget(publishTarget *GeneratorPublishTarget) {
	g.PublishTarget = publishTarget
	g.require(generatorPublishConfigFieldPublishTarget)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorPublishConfig) SetVersion(version string) {
	g.Version = version
	g.require(generatorPublishConfigFieldVersion)
}

func (g *GeneratorPublishConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorPublishConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorPublishConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorPublishConfig) MarshalJSON() ([]byte, error) {
	type embed GeneratorPublishConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorPublishConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorPublishTarget struct {
	Type     string
	Maven    *MavenRegistryConfigV2
	Npm      *NpmRegistryConfigV2
	Pypi     *PypiRegistryConfig
	Postman  *PostmanConfig
	Rubygems *RubyGemsRegistryConfig
	Nuget    *NugetRegistryConfig
}

func (g *GeneratorPublishTarget) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorPublishTarget) GetMaven() *MavenRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorPublishTarget) GetNpm() *NpmRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorPublishTarget) GetPypi() *PypiRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GeneratorPublishTarget) GetPostman() *PostmanConfig {
	if g == nil {
		return nil
	}
	return g.Postman
}

func (g *GeneratorPublishTarget) GetRubygems() *RubyGemsRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GeneratorPublishTarget) GetNuget() *NugetRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GeneratorPublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "maven":
		value := new(MavenRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "pypi":
		value := new(PypiRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "postman":
		value := new(PostmanConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "rubygems":
		value := new(RubyGemsRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GeneratorPublishTarget) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	}
	if g.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	}
	if g.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	}
	if g.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	}
	if g.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	}
	if g.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorPublishTargetVisitor interface {
	VisitMaven(*MavenRegistryConfigV2) error
	VisitNpm(*NpmRegistryConfigV2) error
	VisitPypi(*PypiRegistryConfig) error
	VisitPostman(*PostmanConfig) error
	VisitRubygems(*RubyGemsRegistryConfig) error
	VisitNuget(*NugetRegistryConfig) error
}

func (g *GeneratorPublishTarget) Accept(visitor GeneratorPublishTargetVisitor) error {
	if g.Maven != nil {
		return visitor.VisitMaven(g.Maven)
	}
	if g.Npm != nil {
		return visitor.VisitNpm(g.Npm)
	}
	if g.Pypi != nil {
		return visitor.VisitPypi(g.Pypi)
	}
	if g.Postman != nil {
		return visitor.VisitPostman(g.Postman)
	}
	if g.Rubygems != nil {
		return visitor.VisitRubygems(g.Rubygems)
	}
	if g.Nuget != nil {
		return visitor.VisitNuget(g.Nuget)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorPublishTarget) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Maven != nil {
		fields = append(fields, "maven")
	}
	if g.Npm != nil {
		fields = append(fields, "npm")
	}
	if g.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if g.Postman != nil {
		fields = append(fields, "postman")
	}
	if g.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if g.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

var (
	generatorRegistriesConfigFieldMaven = big.NewInt(1 << 0)
	generatorRegistriesConfigFieldNpm   = big.NewInt(1 << 1)
)

type GeneratorRegistriesConfig struct {
	Maven *MavenRegistryConfig `json:"maven" url:"maven"`
	Npm   *NpmRegistryConfig   `json:"npm" url:"npm"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfig) GetMaven() *MavenRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorRegistriesConfig) GetNpm() *NpmRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorRegistriesConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfig) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMaven sets the Maven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfig) SetMaven(maven *MavenRegistryConfig) {
	g.Maven = maven
	g.require(generatorRegistriesConfigFieldMaven)
}

// SetNpm sets the Npm field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfig) SetNpm(npm *NpmRegistryConfig) {
	g.Npm = npm
	g.require(generatorRegistriesConfigFieldNpm)
}

func (g *GeneratorRegistriesConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorRegistriesConfig) MarshalJSON() ([]byte, error) {
	type embed GeneratorRegistriesConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorRegistriesConfig) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	generatorRegistriesConfigV2FieldMaven    = big.NewInt(1 << 0)
	generatorRegistriesConfigV2FieldNpm      = big.NewInt(1 << 1)
	generatorRegistriesConfigV2FieldPypi     = big.NewInt(1 << 2)
	generatorRegistriesConfigV2FieldRubygems = big.NewInt(1 << 3)
	generatorRegistriesConfigV2FieldNuget    = big.NewInt(1 << 4)
)

type GeneratorRegistriesConfigV2 struct {
	Maven    *MavenRegistryConfigV2  `json:"maven" url:"maven"`
	Npm      *NpmRegistryConfigV2    `json:"npm" url:"npm"`
	Pypi     *PypiRegistryConfig     `json:"pypi" url:"pypi"`
	Rubygems *RubyGemsRegistryConfig `json:"rubygems" url:"rubygems"`
	Nuget    *NugetRegistryConfig    `json:"nuget" url:"nuget"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfigV2) GetMaven() *MavenRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GeneratorRegistriesConfigV2) GetNpm() *NpmRegistryConfigV2 {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GeneratorRegistriesConfigV2) GetPypi() *PypiRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GeneratorRegistriesConfigV2) GetRubygems() *RubyGemsRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GeneratorRegistriesConfigV2) GetNuget() *NugetRegistryConfig {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GeneratorRegistriesConfigV2) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfigV2) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMaven sets the Maven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfigV2) SetMaven(maven *MavenRegistryConfigV2) {
	g.Maven = maven
	g.require(generatorRegistriesConfigV2FieldMaven)
}

// SetNpm sets the Npm field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfigV2) SetNpm(npm *NpmRegistryConfigV2) {
	g.Npm = npm
	g.require(generatorRegistriesConfigV2FieldNpm)
}

// SetPypi sets the Pypi field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfigV2) SetPypi(pypi *PypiRegistryConfig) {
	g.Pypi = pypi
	g.require(generatorRegistriesConfigV2FieldPypi)
}

// SetRubygems sets the Rubygems field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfigV2) SetRubygems(rubygems *RubyGemsRegistryConfig) {
	g.Rubygems = rubygems
	g.require(generatorRegistriesConfigV2FieldRubygems)
}

// SetNuget sets the Nuget field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeneratorRegistriesConfigV2) SetNuget(nuget *NugetRegistryConfig) {
	g.Nuget = nuget
	g.require(generatorRegistriesConfigV2FieldNuget)
}

func (g *GeneratorRegistriesConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GeneratorRegistriesConfigV2) MarshalJSON() ([]byte, error) {
	type embed GeneratorRegistriesConfigV2
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeneratorRegistriesConfigV2) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	githubOutputModeFieldVersion           = big.NewInt(1 << 0)
	githubOutputModeFieldRepoUrl           = big.NewInt(1 << 1)
	githubOutputModeFieldInstallationToken = big.NewInt(1 << 2)
	githubOutputModeFieldPublishInfo       = big.NewInt(1 << 3)
)

type GithubOutputMode struct {
	Version string `json:"version" url:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`
	// The token scoped to installing the repository. If not specified, the generator
	// should NOT attempt to clone the repository.
	InstallationToken *string            `json:"installationToken,omitempty" url:"installationToken,omitempty"`
	PublishInfo       *GithubPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (g *GithubOutputMode) GetVersion() string {
	if g == nil {
		return ""
	}
	return g.Version
}

func (g *GithubOutputMode) GetRepoUrl() string {
	if g == nil {
		return ""
	}
	return g.RepoUrl
}

func (g *GithubOutputMode) GetInstallationToken() *string {
	if g == nil {
		return nil
	}
	return g.InstallationToken
}

func (g *GithubOutputMode) GetPublishInfo() *GithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.PublishInfo
}

func (g *GithubOutputMode) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubOutputMode) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubOutputMode) SetVersion(version string) {
	g.Version = version
	g.require(githubOutputModeFieldVersion)
}

// SetRepoUrl sets the RepoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubOutputMode) SetRepoUrl(repoUrl string) {
	g.RepoUrl = repoUrl
	g.require(githubOutputModeFieldRepoUrl)
}

// SetInstallationToken sets the InstallationToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubOutputMode) SetInstallationToken(installationToken *string) {
	g.InstallationToken = installationToken
	g.require(githubOutputModeFieldInstallationToken)
}

// SetPublishInfo sets the PublishInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GithubOutputMode) SetPublishInfo(publishInfo *GithubPublishInfo) {
	g.PublishInfo = publishInfo
	g.require(githubOutputModeFieldPublishInfo)
}

func (g *GithubOutputMode) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubOutputMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubOutputMode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	return nil
}

func (g *GithubOutputMode) MarshalJSON() ([]byte, error) {
	type embed GithubOutputMode
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GithubOutputMode) String() string {
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GithubPublishInfo struct {
	Type     string
	Npm      *NpmGithubPublishInfo
	Maven    *MavenGithubPublishInfo
	Postman  *PostmanGithubPublishInfo
	Pypi     *PypiGithubPublishInfo
	Rubygems *RubyGemsGithubPublishInfo
	Nuget    *NugetGithubPublishInfo
}

func (g *GithubPublishInfo) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GithubPublishInfo) GetNpm() *NpmGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Npm
}

func (g *GithubPublishInfo) GetMaven() *MavenGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Maven
}

func (g *GithubPublishInfo) GetPostman() *PostmanGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Postman
}

func (g *GithubPublishInfo) GetPypi() *PypiGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Pypi
}

func (g *GithubPublishInfo) GetRubygems() *RubyGemsGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Rubygems
}

func (g *GithubPublishInfo) GetNuget() *NugetGithubPublishInfo {
	if g == nil {
		return nil
	}
	return g.Nuget
}

func (g *GithubPublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "maven":
		value := new(MavenGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "postman":
		value := new(PostmanGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "pypi":
		value := new(PypiGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "rubygems":
		value := new(RubyGemsGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GithubPublishInfo) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	}
	if g.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	}
	if g.Postman != nil {
		return internal.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	}
	if g.Pypi != nil {
		return internal.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	}
	if g.Rubygems != nil {
		return internal.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	}
	if g.Nuget != nil {
		return internal.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GithubPublishInfoVisitor interface {
	VisitNpm(*NpmGithubPublishInfo) error
	VisitMaven(*MavenGithubPublishInfo) error
	VisitPostman(*PostmanGithubPublishInfo) error
	VisitPypi(*PypiGithubPublishInfo) error
	VisitRubygems(*RubyGemsGithubPublishInfo) error
	VisitNuget(*NugetGithubPublishInfo) error
}

func (g *GithubPublishInfo) Accept(visitor GithubPublishInfoVisitor) error {
	if g.Npm != nil {
		return visitor.VisitNpm(g.Npm)
	}
	if g.Maven != nil {
		return visitor.VisitMaven(g.Maven)
	}
	if g.Postman != nil {
		return visitor.VisitPostman(g.Postman)
	}
	if g.Pypi != nil {
		return visitor.VisitPypi(g.Pypi)
	}
	if g.Rubygems != nil {
		return visitor.VisitRubygems(g.Rubygems)
	}
	if g.Nuget != nil {
		return visitor.VisitNuget(g.Nuget)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GithubPublishInfo) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Npm != nil {
		fields = append(fields, "npm")
	}
	if g.Maven != nil {
		fields = append(fields, "maven")
	}
	if g.Postman != nil {
		fields = append(fields, "postman")
	}
	if g.Pypi != nil {
		fields = append(fields, "pypi")
	}
	if g.Rubygems != nil {
		fields = append(fields, "rubygems")
	}
	if g.Nuget != nil {
		fields = append(fields, "nuget")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

type LicenseConfig struct {
	Type   string
	Basic  *BasicLicense
	Custom *CustomLicense
}

func (l *LicenseConfig) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LicenseConfig) GetBasic() *BasicLicense {
	if l == nil {
		return nil
	}
	return l.Basic
}

func (l *LicenseConfig) GetCustom() *CustomLicense {
	if l == nil {
		return nil
	}
	return l.Custom
}

func (l *LicenseConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Basic = value
	case "custom":
		value := new(CustomLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Custom = value
	}
	return nil
}

func (l LicenseConfig) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	if l.Basic != nil {
		return internal.MarshalJSONWithExtraProperty(l.Basic, "type", "basic")
	}
	if l.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(l.Custom, "type", "custom")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LicenseConfigVisitor interface {
	VisitBasic(*BasicLicense) error
	VisitCustom(*CustomLicense) error
}

func (l *LicenseConfig) Accept(visitor LicenseConfigVisitor) error {
	if l.Basic != nil {
		return visitor.VisitBasic(l.Basic)
	}
	if l.Custom != nil {
		return visitor.VisitCustom(l.Custom)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

func (l *LicenseConfig) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.Basic != nil {
		fields = append(fields, "basic")
	}
	if l.Custom != nil {
		fields = append(fields, "custom")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

type LicenseId string

const (
	LicenseIdMit     LicenseId = "MIT"
	LicenseIdApache2 LicenseId = "Apache-2.0"
)

func NewLicenseIdFromString(s string) (LicenseId, error) {
	switch s {
	case "MIT":
		return LicenseIdMit, nil
	case "Apache-2.0":
		return LicenseIdApache2, nil
	}
	var t LicenseId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LicenseId) Ptr() *LicenseId {
	return &l
}

var (
	mavenCentralSignatureFieldKeyId     = big.NewInt(1 << 0)
	mavenCentralSignatureFieldPassword  = big.NewInt(1 << 1)
	mavenCentralSignatureFieldSecretKey = big.NewInt(1 << 2)
)

type MavenCentralSignature struct {
	KeyId     string `json:"keyId" url:"keyId"`
	Password  string `json:"password" url:"password"`
	SecretKey string `json:"secretKey" url:"secretKey"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignature) GetKeyId() string {
	if m == nil {
		return ""
	}
	return m.KeyId
}

func (m *MavenCentralSignature) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenCentralSignature) GetSecretKey() string {
	if m == nil {
		return ""
	}
	return m.SecretKey
}

func (m *MavenCentralSignature) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignature) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetKeyId sets the KeyId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignature) SetKeyId(keyId string) {
	m.KeyId = keyId
	m.require(mavenCentralSignatureFieldKeyId)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignature) SetPassword(password string) {
	m.Password = password
	m.require(mavenCentralSignatureFieldPassword)
}

// SetSecretKey sets the SecretKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignature) SetSecretKey(secretKey string) {
	m.SecretKey = secretKey
	m.require(mavenCentralSignatureFieldSecretKey)
}

func (m *MavenCentralSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenCentralSignature) MarshalJSON() ([]byte, error) {
	type embed MavenCentralSignature
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenCentralSignature) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	mavenCentralSignatureGithubInfoFieldKeyIdEnvironmentVariable     = big.NewInt(1 << 0)
	mavenCentralSignatureGithubInfoFieldPasswordEnvironmentVariable  = big.NewInt(1 << 1)
	mavenCentralSignatureGithubInfoFieldSecretKeyEnvironmentVariable = big.NewInt(1 << 2)
)

type MavenCentralSignatureGithubInfo struct {
	KeyIdEnvironmentVariable     EnvironmentVariable `json:"keyIdEnvironmentVariable" url:"keyIdEnvironmentVariable"`
	PasswordEnvironmentVariable  EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	SecretKeyEnvironmentVariable EnvironmentVariable `json:"secretKeyEnvironmentVariable" url:"secretKeyEnvironmentVariable"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignatureGithubInfo) GetKeyIdEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.KeyIdEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetSecretKeyEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.SecretKeyEnvironmentVariable
}

func (m *MavenCentralSignatureGithubInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignatureGithubInfo) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetKeyIdEnvironmentVariable sets the KeyIdEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignatureGithubInfo) SetKeyIdEnvironmentVariable(keyIdEnvironmentVariable EnvironmentVariable) {
	m.KeyIdEnvironmentVariable = keyIdEnvironmentVariable
	m.require(mavenCentralSignatureGithubInfoFieldKeyIdEnvironmentVariable)
}

// SetPasswordEnvironmentVariable sets the PasswordEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignatureGithubInfo) SetPasswordEnvironmentVariable(passwordEnvironmentVariable EnvironmentVariable) {
	m.PasswordEnvironmentVariable = passwordEnvironmentVariable
	m.require(mavenCentralSignatureGithubInfoFieldPasswordEnvironmentVariable)
}

// SetSecretKeyEnvironmentVariable sets the SecretKeyEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCentralSignatureGithubInfo) SetSecretKeyEnvironmentVariable(secretKeyEnvironmentVariable EnvironmentVariable) {
	m.SecretKeyEnvironmentVariable = secretKeyEnvironmentVariable
	m.require(mavenCentralSignatureGithubInfoFieldSecretKeyEnvironmentVariable)
}

func (m *MavenCentralSignatureGithubInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignatureGithubInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignatureGithubInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenCentralSignatureGithubInfo) MarshalJSON() ([]byte, error) {
	type embed MavenCentralSignatureGithubInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenCentralSignatureGithubInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	mavenGithubPublishInfoFieldRegistryUrl                   = big.NewInt(1 << 0)
	mavenGithubPublishInfoFieldCoordinate                    = big.NewInt(1 << 1)
	mavenGithubPublishInfoFieldUsernameEnvironmentVariable   = big.NewInt(1 << 2)
	mavenGithubPublishInfoFieldPasswordEnvironmentVariable   = big.NewInt(1 << 3)
	mavenGithubPublishInfoFieldSignature                     = big.NewInt(1 << 4)
	mavenGithubPublishInfoFieldShouldGeneratePublishWorkflow = big.NewInt(1 << 5)
)

type MavenGithubPublishInfo struct {
	RegistryUrl                   string                           `json:"registryUrl" url:"registryUrl"`
	Coordinate                    string                           `json:"coordinate" url:"coordinate"`
	UsernameEnvironmentVariable   EnvironmentVariable              `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable              `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	Signature                     *MavenCentralSignatureGithubInfo `json:"signature,omitempty" url:"signature,omitempty"`
	ShouldGeneratePublishWorkflow *bool                            `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenGithubPublishInfo) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenGithubPublishInfo) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenGithubPublishInfo) GetUsernameEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.UsernameEnvironmentVariable
}

func (m *MavenGithubPublishInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if m == nil {
		return ""
	}
	return m.PasswordEnvironmentVariable
}

func (m *MavenGithubPublishInfo) GetSignature() *MavenCentralSignatureGithubInfo {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if m == nil {
		return nil
	}
	return m.ShouldGeneratePublishWorkflow
}

func (m *MavenGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenGithubPublishInfo) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetRegistryUrl(registryUrl string) {
	m.RegistryUrl = registryUrl
	m.require(mavenGithubPublishInfoFieldRegistryUrl)
}

// SetCoordinate sets the Coordinate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetCoordinate(coordinate string) {
	m.Coordinate = coordinate
	m.require(mavenGithubPublishInfoFieldCoordinate)
}

// SetUsernameEnvironmentVariable sets the UsernameEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetUsernameEnvironmentVariable(usernameEnvironmentVariable EnvironmentVariable) {
	m.UsernameEnvironmentVariable = usernameEnvironmentVariable
	m.require(mavenGithubPublishInfoFieldUsernameEnvironmentVariable)
}

// SetPasswordEnvironmentVariable sets the PasswordEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetPasswordEnvironmentVariable(passwordEnvironmentVariable EnvironmentVariable) {
	m.PasswordEnvironmentVariable = passwordEnvironmentVariable
	m.require(mavenGithubPublishInfoFieldPasswordEnvironmentVariable)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetSignature(signature *MavenCentralSignatureGithubInfo) {
	m.Signature = signature
	m.require(mavenGithubPublishInfoFieldSignature)
}

// SetShouldGeneratePublishWorkflow sets the ShouldGeneratePublishWorkflow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenGithubPublishInfo) SetShouldGeneratePublishWorkflow(shouldGeneratePublishWorkflow *bool) {
	m.ShouldGeneratePublishWorkflow = shouldGeneratePublishWorkflow
	m.require(mavenGithubPublishInfoFieldShouldGeneratePublishWorkflow)
}

func (m *MavenGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed MavenGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	mavenRegistryConfigFieldRegistryUrl = big.NewInt(1 << 0)
	mavenRegistryConfigFieldUsername    = big.NewInt(1 << 1)
	mavenRegistryConfigFieldPassword    = big.NewInt(1 << 2)
	mavenRegistryConfigFieldGroup       = big.NewInt(1 << 3)
	mavenRegistryConfigFieldSignature   = big.NewInt(1 << 4)
)

type MavenRegistryConfig struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Group       string                 `json:"group" url:"group"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfig) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenRegistryConfig) GetUsername() string {
	if m == nil {
		return ""
	}
	return m.Username
}

func (m *MavenRegistryConfig) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenRegistryConfig) GetGroup() string {
	if m == nil {
		return ""
	}
	return m.Group
}

func (m *MavenRegistryConfig) GetSignature() *MavenCentralSignature {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenRegistryConfig) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfig) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfig) SetRegistryUrl(registryUrl string) {
	m.RegistryUrl = registryUrl
	m.require(mavenRegistryConfigFieldRegistryUrl)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfig) SetUsername(username string) {
	m.Username = username
	m.require(mavenRegistryConfigFieldUsername)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfig) SetPassword(password string) {
	m.Password = password
	m.require(mavenRegistryConfigFieldPassword)
}

// SetGroup sets the Group field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfig) SetGroup(group string) {
	m.Group = group
	m.require(mavenRegistryConfigFieldGroup)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfig) SetSignature(signature *MavenCentralSignature) {
	m.Signature = signature
	m.require(mavenRegistryConfigFieldSignature)
}

func (m *MavenRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenRegistryConfig) MarshalJSON() ([]byte, error) {
	type embed MavenRegistryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	mavenRegistryConfigV2FieldRegistryUrl = big.NewInt(1 << 0)
	mavenRegistryConfigV2FieldUsername    = big.NewInt(1 << 1)
	mavenRegistryConfigV2FieldPassword    = big.NewInt(1 << 2)
	mavenRegistryConfigV2FieldCoordinate  = big.NewInt(1 << 3)
	mavenRegistryConfigV2FieldSignature   = big.NewInt(1 << 4)
)

type MavenRegistryConfigV2 struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Coordinate  string                 `json:"coordinate" url:"coordinate"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfigV2) GetRegistryUrl() string {
	if m == nil {
		return ""
	}
	return m.RegistryUrl
}

func (m *MavenRegistryConfigV2) GetUsername() string {
	if m == nil {
		return ""
	}
	return m.Username
}

func (m *MavenRegistryConfigV2) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MavenRegistryConfigV2) GetCoordinate() string {
	if m == nil {
		return ""
	}
	return m.Coordinate
}

func (m *MavenRegistryConfigV2) GetSignature() *MavenCentralSignature {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MavenRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfigV2) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfigV2) SetRegistryUrl(registryUrl string) {
	m.RegistryUrl = registryUrl
	m.require(mavenRegistryConfigV2FieldRegistryUrl)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfigV2) SetUsername(username string) {
	m.Username = username
	m.require(mavenRegistryConfigV2FieldUsername)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfigV2) SetPassword(password string) {
	m.Password = password
	m.require(mavenRegistryConfigV2FieldPassword)
}

// SetCoordinate sets the Coordinate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfigV2) SetCoordinate(coordinate string) {
	m.Coordinate = coordinate
	m.require(mavenRegistryConfigV2FieldCoordinate)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenRegistryConfigV2) SetSignature(signature *MavenCentralSignature) {
	m.Signature = signature
	m.require(mavenRegistryConfigV2FieldSignature)
}

func (m *MavenRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MavenRegistryConfigV2) MarshalJSON() ([]byte, error) {
	type embed MavenRegistryConfigV2
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenRegistryConfigV2) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	npmGithubPublishInfoFieldRegistryUrl                   = big.NewInt(1 << 0)
	npmGithubPublishInfoFieldPackageName                   = big.NewInt(1 << 1)
	npmGithubPublishInfoFieldTokenEnvironmentVariable      = big.NewInt(1 << 2)
	npmGithubPublishInfoFieldShouldGeneratePublishWorkflow = big.NewInt(1 << 3)
)

type NpmGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	TokenEnvironmentVariable      EnvironmentVariable `json:"tokenEnvironmentVariable" url:"tokenEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NpmGithubPublishInfo) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmGithubPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmGithubPublishInfo) GetTokenEnvironmentVariable() EnvironmentVariable {
	if n == nil {
		return ""
	}
	return n.TokenEnvironmentVariable
}

func (n *NpmGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if n == nil {
		return nil
	}
	return n.ShouldGeneratePublishWorkflow
}

func (n *NpmGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmGithubPublishInfo) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmGithubPublishInfo) SetRegistryUrl(registryUrl string) {
	n.RegistryUrl = registryUrl
	n.require(npmGithubPublishInfoFieldRegistryUrl)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmGithubPublishInfo) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(npmGithubPublishInfoFieldPackageName)
}

// SetTokenEnvironmentVariable sets the TokenEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmGithubPublishInfo) SetTokenEnvironmentVariable(tokenEnvironmentVariable EnvironmentVariable) {
	n.TokenEnvironmentVariable = tokenEnvironmentVariable
	n.require(npmGithubPublishInfoFieldTokenEnvironmentVariable)
}

// SetShouldGeneratePublishWorkflow sets the ShouldGeneratePublishWorkflow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmGithubPublishInfo) SetShouldGeneratePublishWorkflow(shouldGeneratePublishWorkflow *bool) {
	n.ShouldGeneratePublishWorkflow = shouldGeneratePublishWorkflow
	n.require(npmGithubPublishInfoFieldShouldGeneratePublishWorkflow)
}

func (n *NpmGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed NpmGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	npmRegistryConfigFieldRegistryUrl = big.NewInt(1 << 0)
	npmRegistryConfigFieldToken       = big.NewInt(1 << 1)
	npmRegistryConfigFieldScope       = big.NewInt(1 << 2)
)

type NpmRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	Scope       string `json:"scope" url:"scope"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfig) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmRegistryConfig) GetToken() string {
	if n == nil {
		return ""
	}
	return n.Token
}

func (n *NpmRegistryConfig) GetScope() string {
	if n == nil {
		return ""
	}
	return n.Scope
}

func (n *NpmRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfig) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfig) SetRegistryUrl(registryUrl string) {
	n.RegistryUrl = registryUrl
	n.require(npmRegistryConfigFieldRegistryUrl)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfig) SetToken(token string) {
	n.Token = token
	n.require(npmRegistryConfigFieldToken)
}

// SetScope sets the Scope field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfig) SetScope(scope string) {
	n.Scope = scope
	n.require(npmRegistryConfigFieldScope)
}

func (n *NpmRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmRegistryConfig) MarshalJSON() ([]byte, error) {
	type embed NpmRegistryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	npmRegistryConfigV2FieldRegistryUrl = big.NewInt(1 << 0)
	npmRegistryConfigV2FieldToken       = big.NewInt(1 << 1)
	npmRegistryConfigV2FieldPackageName = big.NewInt(1 << 2)
)

type NpmRegistryConfigV2 struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	PackageName string `json:"packageName" url:"packageName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfigV2) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NpmRegistryConfigV2) GetToken() string {
	if n == nil {
		return ""
	}
	return n.Token
}

func (n *NpmRegistryConfigV2) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NpmRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfigV2) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfigV2) SetRegistryUrl(registryUrl string) {
	n.RegistryUrl = registryUrl
	n.require(npmRegistryConfigV2FieldRegistryUrl)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfigV2) SetToken(token string) {
	n.Token = token
	n.require(npmRegistryConfigV2FieldToken)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmRegistryConfigV2) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(npmRegistryConfigV2FieldPackageName)
}

func (n *NpmRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NpmRegistryConfigV2) MarshalJSON() ([]byte, error) {
	type embed NpmRegistryConfigV2
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmRegistryConfigV2) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nugetGithubPublishInfoFieldRegistryUrl                   = big.NewInt(1 << 0)
	nugetGithubPublishInfoFieldPackageName                   = big.NewInt(1 << 1)
	nugetGithubPublishInfoFieldApiKeyEnvironmentVariable     = big.NewInt(1 << 2)
	nugetGithubPublishInfoFieldShouldGeneratePublishWorkflow = big.NewInt(1 << 3)
)

type NugetGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NugetGithubPublishInfo) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NugetGithubPublishInfo) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if n == nil {
		return ""
	}
	return n.ApiKeyEnvironmentVariable
}

func (n *NugetGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if n == nil {
		return nil
	}
	return n.ShouldGeneratePublishWorkflow
}

func (n *NugetGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetGithubPublishInfo) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetGithubPublishInfo) SetRegistryUrl(registryUrl string) {
	n.RegistryUrl = registryUrl
	n.require(nugetGithubPublishInfoFieldRegistryUrl)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetGithubPublishInfo) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(nugetGithubPublishInfoFieldPackageName)
}

// SetApiKeyEnvironmentVariable sets the ApiKeyEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetGithubPublishInfo) SetApiKeyEnvironmentVariable(apiKeyEnvironmentVariable EnvironmentVariable) {
	n.ApiKeyEnvironmentVariable = apiKeyEnvironmentVariable
	n.require(nugetGithubPublishInfoFieldApiKeyEnvironmentVariable)
}

// SetShouldGeneratePublishWorkflow sets the ShouldGeneratePublishWorkflow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetGithubPublishInfo) SetShouldGeneratePublishWorkflow(shouldGeneratePublishWorkflow *bool) {
	n.ShouldGeneratePublishWorkflow = shouldGeneratePublishWorkflow
	n.require(nugetGithubPublishInfoFieldShouldGeneratePublishWorkflow)
}

func (n *NugetGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed NugetGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NugetGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nugetRegistryConfigFieldRegistryUrl = big.NewInt(1 << 0)
	nugetRegistryConfigFieldApiKey      = big.NewInt(1 << 1)
	nugetRegistryConfigFieldPackageName = big.NewInt(1 << 2)
)

type NugetRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (n *NugetRegistryConfig) GetRegistryUrl() string {
	if n == nil {
		return ""
	}
	return n.RegistryUrl
}

func (n *NugetRegistryConfig) GetApiKey() string {
	if n == nil {
		return ""
	}
	return n.ApiKey
}

func (n *NugetRegistryConfig) GetPackageName() string {
	if n == nil {
		return ""
	}
	return n.PackageName
}

func (n *NugetRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetRegistryConfig) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetRegistryConfig) SetRegistryUrl(registryUrl string) {
	n.RegistryUrl = registryUrl
	n.require(nugetRegistryConfigFieldRegistryUrl)
}

// SetApiKey sets the ApiKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetRegistryConfig) SetApiKey(apiKey string) {
	n.ApiKey = apiKey
	n.require(nugetRegistryConfigFieldApiKey)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NugetRegistryConfig) SetPackageName(packageName string) {
	n.PackageName = packageName
	n.require(nugetRegistryConfigFieldPackageName)
}

func (n *NugetRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NugetRegistryConfig) MarshalJSON() ([]byte, error) {
	type embed NugetRegistryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NugetRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	outputMetadataFieldDescription = big.NewInt(1 << 0)
	outputMetadataFieldAuthors     = big.NewInt(1 << 1)
)

type OutputMetadata struct {
	Description *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors     []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadata) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputMetadata) GetAuthors() []*OutputMetadataAuthor {
	if o == nil {
		return nil
	}
	return o.Authors
}

func (o *OutputMetadata) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadata) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OutputMetadata) SetDescription(description *string) {
	o.Description = description
	o.require(outputMetadataFieldDescription)
}

// SetAuthors sets the Authors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OutputMetadata) SetAuthors(authors []*OutputMetadataAuthor) {
	o.Authors = authors
	o.require(outputMetadataFieldAuthors)
}

func (o *OutputMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OutputMetadata) MarshalJSON() ([]byte, error) {
	type embed OutputMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OutputMetadata) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	outputMetadataAuthorFieldName  = big.NewInt(1 << 0)
	outputMetadataAuthorFieldEmail = big.NewInt(1 << 1)
)

type OutputMetadataAuthor struct {
	Name  string `json:"name" url:"name"`
	Email string `json:"email" url:"email"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadataAuthor) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OutputMetadataAuthor) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *OutputMetadataAuthor) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadataAuthor) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OutputMetadataAuthor) SetName(name string) {
	o.Name = name
	o.require(outputMetadataAuthorFieldName)
}

// SetEmail sets the Email field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OutputMetadataAuthor) SetEmail(email string) {
	o.Email = email
	o.require(outputMetadataAuthorFieldEmail)
}

func (o *OutputMetadataAuthor) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadataAuthor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadataAuthor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *OutputMetadataAuthor) MarshalJSON() ([]byte, error) {
	type embed OutputMetadataAuthor
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OutputMetadataAuthor) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputMode struct {
	Type          string
	Publish       *GeneratorPublishConfig
	DownloadFiles interface{}
	Github        *GithubOutputMode
}

func (o *OutputMode) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *OutputMode) GetPublish() *GeneratorPublishConfig {
	if o == nil {
		return nil
	}
	return o.Publish
}

func (o *OutputMode) GetDownloadFiles() interface{} {
	if o == nil {
		return nil
	}
	return o.DownloadFiles
}

func (o *OutputMode) GetGithub() *GithubOutputMode {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *OutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "publish":
		value := new(GeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Publish = value
	case "downloadFiles":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Github = value
	}
	return nil
}

func (o OutputMode) MarshalJSON() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	if o.Publish != nil {
		return internal.MarshalJSONWithExtraProperty(o.Publish, "type", "publish")
	}
	if o.DownloadFiles != nil {
		var marshaler = struct {
			Type          string      `json:"type"`
			DownloadFiles interface{} `json:"downloadFiles,omitempty"`
		}{
			Type:          "downloadFiles",
			DownloadFiles: o.DownloadFiles,
		}
		return json.Marshal(marshaler)
	}
	if o.Github != nil {
		return internal.MarshalJSONWithExtraProperty(o.Github, "type", "github")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OutputModeVisitor interface {
	VisitPublish(*GeneratorPublishConfig) error
	VisitDownloadFiles(interface{}) error
	VisitGithub(*GithubOutputMode) error
}

func (o *OutputMode) Accept(visitor OutputModeVisitor) error {
	if o.Publish != nil {
		return visitor.VisitPublish(o.Publish)
	}
	if o.DownloadFiles != nil {
		return visitor.VisitDownloadFiles(o.DownloadFiles)
	}
	if o.Github != nil {
		return visitor.VisitGithub(o.Github)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

func (o *OutputMode) validate() error {
	if o == nil {
		return fmt.Errorf("type %T is nil", o)
	}
	var fields []string
	if o.Publish != nil {
		fields = append(fields, "publish")
	}
	if o.DownloadFiles != nil {
		fields = append(fields, "downloadFiles")
	}
	if o.Github != nil {
		fields = append(fields, "github")
	}
	if len(fields) == 0 {
		if o.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", o, o.Type)
		}
		return fmt.Errorf("type %T is empty", o)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", o, fields)
	}
	if o.Type != "" {
		field := fields[0]
		if o.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				o,
				o.Type,
				o,
			)
		}
	}
	return nil
}

var (
	postmanConfigFieldApiKey      = big.NewInt(1 << 0)
	postmanConfigFieldWorkspaceId = big.NewInt(1 << 1)
)

type PostmanConfig struct {
	ApiKey      string `json:"apiKey" url:"apiKey"`
	WorkspaceId string `json:"workspaceId" url:"workspaceId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PostmanConfig) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PostmanConfig) GetWorkspaceId() string {
	if p == nil {
		return ""
	}
	return p.WorkspaceId
}

func (p *PostmanConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanConfig) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetApiKey sets the ApiKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanConfig) SetApiKey(apiKey string) {
	p.ApiKey = apiKey
	p.require(postmanConfigFieldApiKey)
}

// SetWorkspaceId sets the WorkspaceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanConfig) SetWorkspaceId(workspaceId string) {
	p.WorkspaceId = workspaceId
	p.require(postmanConfigFieldWorkspaceId)
}

func (p *PostmanConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanConfig) MarshalJSON() ([]byte, error) {
	type embed PostmanConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PostmanConfig) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	postmanGithubPublishInfoFieldApiKeyEnvironmentVariable      = big.NewInt(1 << 0)
	postmanGithubPublishInfoFieldWorkspaceIdEnvironmentVariable = big.NewInt(1 << 1)
)

type PostmanGithubPublishInfo struct {
	ApiKeyEnvironmentVariable      EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	WorkspaceIdEnvironmentVariable EnvironmentVariable `json:"workspaceIdEnvironmentVariable" url:"workspaceIdEnvironmentVariable"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PostmanGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.ApiKeyEnvironmentVariable
}

func (p *PostmanGithubPublishInfo) GetWorkspaceIdEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.WorkspaceIdEnvironmentVariable
}

func (p *PostmanGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanGithubPublishInfo) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetApiKeyEnvironmentVariable sets the ApiKeyEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanGithubPublishInfo) SetApiKeyEnvironmentVariable(apiKeyEnvironmentVariable EnvironmentVariable) {
	p.ApiKeyEnvironmentVariable = apiKeyEnvironmentVariable
	p.require(postmanGithubPublishInfoFieldApiKeyEnvironmentVariable)
}

// SetWorkspaceIdEnvironmentVariable sets the WorkspaceIdEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostmanGithubPublishInfo) SetWorkspaceIdEnvironmentVariable(workspaceIdEnvironmentVariable EnvironmentVariable) {
	p.WorkspaceIdEnvironmentVariable = workspaceIdEnvironmentVariable
	p.require(postmanGithubPublishInfoFieldWorkspaceIdEnvironmentVariable)
}

func (p *PostmanGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PostmanGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed PostmanGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PostmanGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// This should effectively be deprecated in favor of a more specific configuration per-output mode (pypi, maven, etc.).
var (
	publishingMetadataFieldPackageDescription = big.NewInt(1 << 0)
	publishingMetadataFieldPublisherEmail     = big.NewInt(1 << 1)
	publishingMetadataFieldReferenceUrl       = big.NewInt(1 << 2)
	publishingMetadataFieldPublisherName      = big.NewInt(1 << 3)
)

type PublishingMetadata struct {
	PackageDescription *string `json:"package_description,omitempty" url:"package_description,omitempty"`
	PublisherEmail     *string `json:"publisher_email,omitempty" url:"publisher_email,omitempty"`
	ReferenceUrl       *string `json:"reference_url,omitempty" url:"reference_url,omitempty"`
	PublisherName      *string `json:"publisher_name,omitempty" url:"publisher_name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PublishingMetadata) GetPackageDescription() *string {
	if p == nil {
		return nil
	}
	return p.PackageDescription
}

func (p *PublishingMetadata) GetPublisherEmail() *string {
	if p == nil {
		return nil
	}
	return p.PublisherEmail
}

func (p *PublishingMetadata) GetReferenceUrl() *string {
	if p == nil {
		return nil
	}
	return p.ReferenceUrl
}

func (p *PublishingMetadata) GetPublisherName() *string {
	if p == nil {
		return nil
	}
	return p.PublisherName
}

func (p *PublishingMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublishingMetadata) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPackageDescription sets the PackageDescription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PublishingMetadata) SetPackageDescription(packageDescription *string) {
	p.PackageDescription = packageDescription
	p.require(publishingMetadataFieldPackageDescription)
}

// SetPublisherEmail sets the PublisherEmail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PublishingMetadata) SetPublisherEmail(publisherEmail *string) {
	p.PublisherEmail = publisherEmail
	p.require(publishingMetadataFieldPublisherEmail)
}

// SetReferenceUrl sets the ReferenceUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PublishingMetadata) SetReferenceUrl(referenceUrl *string) {
	p.ReferenceUrl = referenceUrl
	p.require(publishingMetadataFieldReferenceUrl)
}

// SetPublisherName sets the PublisherName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PublishingMetadata) SetPublisherName(publisherName *string) {
	p.PublisherName = publisherName
	p.require(publishingMetadataFieldPublisherName)
}

func (p *PublishingMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PublishingMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PublishingMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PublishingMetadata) MarshalJSON() ([]byte, error) {
	type embed PublishingMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PublishingMetadata) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pypiGithubPublishInfoFieldRegistryUrl                   = big.NewInt(1 << 0)
	pypiGithubPublishInfoFieldPackageName                   = big.NewInt(1 << 1)
	pypiGithubPublishInfoFieldUsernameEnvironmentVariable   = big.NewInt(1 << 2)
	pypiGithubPublishInfoFieldPasswordEnvironmentVariable   = big.NewInt(1 << 3)
	pypiGithubPublishInfoFieldPypiMetadata                  = big.NewInt(1 << 4)
	pypiGithubPublishInfoFieldShouldGeneratePublishWorkflow = big.NewInt(1 << 5)
)

type PypiGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	UsernameEnvironmentVariable   EnvironmentVariable `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	PypiMetadata                  *PypiMetadata       `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PypiGithubPublishInfo) GetRegistryUrl() string {
	if p == nil {
		return ""
	}
	return p.RegistryUrl
}

func (p *PypiGithubPublishInfo) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiGithubPublishInfo) GetUsernameEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.UsernameEnvironmentVariable
}

func (p *PypiGithubPublishInfo) GetPasswordEnvironmentVariable() EnvironmentVariable {
	if p == nil {
		return ""
	}
	return p.PasswordEnvironmentVariable
}

func (p *PypiGithubPublishInfo) GetPypiMetadata() *PypiMetadata {
	if p == nil {
		return nil
	}
	return p.PypiMetadata
}

func (p *PypiGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if p == nil {
		return nil
	}
	return p.ShouldGeneratePublishWorkflow
}

func (p *PypiGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiGithubPublishInfo) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetRegistryUrl(registryUrl string) {
	p.RegistryUrl = registryUrl
	p.require(pypiGithubPublishInfoFieldRegistryUrl)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetPackageName(packageName string) {
	p.PackageName = packageName
	p.require(pypiGithubPublishInfoFieldPackageName)
}

// SetUsernameEnvironmentVariable sets the UsernameEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetUsernameEnvironmentVariable(usernameEnvironmentVariable EnvironmentVariable) {
	p.UsernameEnvironmentVariable = usernameEnvironmentVariable
	p.require(pypiGithubPublishInfoFieldUsernameEnvironmentVariable)
}

// SetPasswordEnvironmentVariable sets the PasswordEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetPasswordEnvironmentVariable(passwordEnvironmentVariable EnvironmentVariable) {
	p.PasswordEnvironmentVariable = passwordEnvironmentVariable
	p.require(pypiGithubPublishInfoFieldPasswordEnvironmentVariable)
}

// SetPypiMetadata sets the PypiMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetPypiMetadata(pypiMetadata *PypiMetadata) {
	p.PypiMetadata = pypiMetadata
	p.require(pypiGithubPublishInfoFieldPypiMetadata)
}

// SetShouldGeneratePublishWorkflow sets the ShouldGeneratePublishWorkflow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiGithubPublishInfo) SetShouldGeneratePublishWorkflow(shouldGeneratePublishWorkflow *bool) {
	p.ShouldGeneratePublishWorkflow = shouldGeneratePublishWorkflow
	p.require(pypiGithubPublishInfoFieldShouldGeneratePublishWorkflow)
}

func (p *PypiGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed PypiGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PypiGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pypiMetadataFieldDescription       = big.NewInt(1 << 0)
	pypiMetadataFieldAuthors           = big.NewInt(1 << 1)
	pypiMetadataFieldKeywords          = big.NewInt(1 << 2)
	pypiMetadataFieldDocumentationLink = big.NewInt(1 << 3)
	pypiMetadataFieldHomepageLink      = big.NewInt(1 << 4)
)

type PypiMetadata struct {
	Description       *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors           []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`
	Keywords          []string                `json:"keywords,omitempty" url:"keywords,omitempty"`
	DocumentationLink *string                 `json:"documentationLink,omitempty" url:"documentationLink,omitempty"`
	HomepageLink      *string                 `json:"homepageLink,omitempty" url:"homepageLink,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PypiMetadata) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PypiMetadata) GetAuthors() []*OutputMetadataAuthor {
	if p == nil {
		return nil
	}
	return p.Authors
}

func (p *PypiMetadata) GetKeywords() []string {
	if p == nil {
		return nil
	}
	return p.Keywords
}

func (p *PypiMetadata) GetDocumentationLink() *string {
	if p == nil {
		return nil
	}
	return p.DocumentationLink
}

func (p *PypiMetadata) GetHomepageLink() *string {
	if p == nil {
		return nil
	}
	return p.HomepageLink
}

func (p *PypiMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiMetadata) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiMetadata) SetDescription(description *string) {
	p.Description = description
	p.require(pypiMetadataFieldDescription)
}

// SetAuthors sets the Authors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiMetadata) SetAuthors(authors []*OutputMetadataAuthor) {
	p.Authors = authors
	p.require(pypiMetadataFieldAuthors)
}

// SetKeywords sets the Keywords field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiMetadata) SetKeywords(keywords []string) {
	p.Keywords = keywords
	p.require(pypiMetadataFieldKeywords)
}

// SetDocumentationLink sets the DocumentationLink field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiMetadata) SetDocumentationLink(documentationLink *string) {
	p.DocumentationLink = documentationLink
	p.require(pypiMetadataFieldDocumentationLink)
}

// SetHomepageLink sets the HomepageLink field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiMetadata) SetHomepageLink(homepageLink *string) {
	p.HomepageLink = homepageLink
	p.require(pypiMetadataFieldHomepageLink)
}

func (p *PypiMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiMetadata) MarshalJSON() ([]byte, error) {
	type embed PypiMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PypiMetadata) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pypiRegistryConfigFieldRegistryUrl  = big.NewInt(1 << 0)
	pypiRegistryConfigFieldUsername     = big.NewInt(1 << 1)
	pypiRegistryConfigFieldPassword     = big.NewInt(1 << 2)
	pypiRegistryConfigFieldPackageName  = big.NewInt(1 << 3)
	pypiRegistryConfigFieldPypiMetadata = big.NewInt(1 << 4)
)

type PypiRegistryConfig struct {
	RegistryUrl  string        `json:"registryUrl" url:"registryUrl"`
	Username     string        `json:"username" url:"username"`
	Password     string        `json:"password" url:"password"`
	PackageName  string        `json:"packageName" url:"packageName"`
	PypiMetadata *PypiMetadata `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (p *PypiRegistryConfig) GetRegistryUrl() string {
	if p == nil {
		return ""
	}
	return p.RegistryUrl
}

func (p *PypiRegistryConfig) GetUsername() string {
	if p == nil {
		return ""
	}
	return p.Username
}

func (p *PypiRegistryConfig) GetPassword() string {
	if p == nil {
		return ""
	}
	return p.Password
}

func (p *PypiRegistryConfig) GetPackageName() string {
	if p == nil {
		return ""
	}
	return p.PackageName
}

func (p *PypiRegistryConfig) GetPypiMetadata() *PypiMetadata {
	if p == nil {
		return nil
	}
	return p.PypiMetadata
}

func (p *PypiRegistryConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiRegistryConfig) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiRegistryConfig) SetRegistryUrl(registryUrl string) {
	p.RegistryUrl = registryUrl
	p.require(pypiRegistryConfigFieldRegistryUrl)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiRegistryConfig) SetUsername(username string) {
	p.Username = username
	p.require(pypiRegistryConfigFieldUsername)
}

// SetPassword sets the Password field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiRegistryConfig) SetPassword(password string) {
	p.Password = password
	p.require(pypiRegistryConfigFieldPassword)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiRegistryConfig) SetPackageName(packageName string) {
	p.PackageName = packageName
	p.require(pypiRegistryConfigFieldPackageName)
}

// SetPypiMetadata sets the PypiMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PypiRegistryConfig) SetPypiMetadata(pypiMetadata *PypiMetadata) {
	p.PypiMetadata = pypiMetadata
	p.require(pypiRegistryConfigFieldPypiMetadata)
}

func (p *PypiRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PypiRegistryConfig) MarshalJSON() ([]byte, error) {
	type embed PypiRegistryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PypiRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	remoteGeneratorEnvironmentFieldCoordinatorUrl   = big.NewInt(1 << 0)
	remoteGeneratorEnvironmentFieldCoordinatorUrlV2 = big.NewInt(1 << 1)
	remoteGeneratorEnvironmentFieldId               = big.NewInt(1 << 2)
)

type RemoteGeneratorEnvironment struct {
	CoordinatorUrl   string `json:"coordinatorUrl" url:"coordinatorUrl"`
	CoordinatorUrlV2 string `json:"coordinatorUrlV2" url:"coordinatorUrlV2"`
	Id               string `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *RemoteGeneratorEnvironment) GetCoordinatorUrl() string {
	if r == nil {
		return ""
	}
	return r.CoordinatorUrl
}

func (r *RemoteGeneratorEnvironment) GetCoordinatorUrlV2() string {
	if r == nil {
		return ""
	}
	return r.CoordinatorUrlV2
}

func (r *RemoteGeneratorEnvironment) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RemoteGeneratorEnvironment) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteGeneratorEnvironment) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetCoordinatorUrl sets the CoordinatorUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RemoteGeneratorEnvironment) SetCoordinatorUrl(coordinatorUrl string) {
	r.CoordinatorUrl = coordinatorUrl
	r.require(remoteGeneratorEnvironmentFieldCoordinatorUrl)
}

// SetCoordinatorUrlV2 sets the CoordinatorUrlV2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RemoteGeneratorEnvironment) SetCoordinatorUrlV2(coordinatorUrlV2 string) {
	r.CoordinatorUrlV2 = coordinatorUrlV2
	r.require(remoteGeneratorEnvironmentFieldCoordinatorUrlV2)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RemoteGeneratorEnvironment) SetId(id string) {
	r.Id = id
	r.require(remoteGeneratorEnvironmentFieldId)
}

func (r *RemoteGeneratorEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteGeneratorEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteGeneratorEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RemoteGeneratorEnvironment) MarshalJSON() ([]byte, error) {
	type embed RemoteGeneratorEnvironment
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RemoteGeneratorEnvironment) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	rubyGemsGithubPublishInfoFieldRegistryUrl                   = big.NewInt(1 << 0)
	rubyGemsGithubPublishInfoFieldPackageName                   = big.NewInt(1 << 1)
	rubyGemsGithubPublishInfoFieldApiKeyEnvironmentVariable     = big.NewInt(1 << 2)
	rubyGemsGithubPublishInfoFieldShouldGeneratePublishWorkflow = big.NewInt(1 << 3)
)

type RubyGemsGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsGithubPublishInfo) GetRegistryUrl() string {
	if r == nil {
		return ""
	}
	return r.RegistryUrl
}

func (r *RubyGemsGithubPublishInfo) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsGithubPublishInfo) GetApiKeyEnvironmentVariable() EnvironmentVariable {
	if r == nil {
		return ""
	}
	return r.ApiKeyEnvironmentVariable
}

func (r *RubyGemsGithubPublishInfo) GetShouldGeneratePublishWorkflow() *bool {
	if r == nil {
		return nil
	}
	return r.ShouldGeneratePublishWorkflow
}

func (r *RubyGemsGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsGithubPublishInfo) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsGithubPublishInfo) SetRegistryUrl(registryUrl string) {
	r.RegistryUrl = registryUrl
	r.require(rubyGemsGithubPublishInfoFieldRegistryUrl)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsGithubPublishInfo) SetPackageName(packageName string) {
	r.PackageName = packageName
	r.require(rubyGemsGithubPublishInfoFieldPackageName)
}

// SetApiKeyEnvironmentVariable sets the ApiKeyEnvironmentVariable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsGithubPublishInfo) SetApiKeyEnvironmentVariable(apiKeyEnvironmentVariable EnvironmentVariable) {
	r.ApiKeyEnvironmentVariable = apiKeyEnvironmentVariable
	r.require(rubyGemsGithubPublishInfoFieldApiKeyEnvironmentVariable)
}

// SetShouldGeneratePublishWorkflow sets the ShouldGeneratePublishWorkflow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsGithubPublishInfo) SetShouldGeneratePublishWorkflow(shouldGeneratePublishWorkflow *bool) {
	r.ShouldGeneratePublishWorkflow = shouldGeneratePublishWorkflow
	r.require(rubyGemsGithubPublishInfoFieldShouldGeneratePublishWorkflow)
}

func (r *RubyGemsGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsGithubPublishInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsGithubPublishInfo) MarshalJSON() ([]byte, error) {
	type embed RubyGemsGithubPublishInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RubyGemsGithubPublishInfo) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	rubyGemsRegistryConfigFieldRegistryUrl = big.NewInt(1 << 0)
	rubyGemsRegistryConfigFieldApiKey      = big.NewInt(1 << 1)
	rubyGemsRegistryConfigFieldPackageName = big.NewInt(1 << 2)
)

type RubyGemsRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsRegistryConfig) GetRegistryUrl() string {
	if r == nil {
		return ""
	}
	return r.RegistryUrl
}

func (r *RubyGemsRegistryConfig) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RubyGemsRegistryConfig) GetPackageName() string {
	if r == nil {
		return ""
	}
	return r.PackageName
}

func (r *RubyGemsRegistryConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsRegistryConfig) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRegistryUrl sets the RegistryUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsRegistryConfig) SetRegistryUrl(registryUrl string) {
	r.RegistryUrl = registryUrl
	r.require(rubyGemsRegistryConfigFieldRegistryUrl)
}

// SetApiKey sets the ApiKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsRegistryConfig) SetApiKey(apiKey string) {
	r.ApiKey = apiKey
	r.require(rubyGemsRegistryConfigFieldApiKey)
}

// SetPackageName sets the PackageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RubyGemsRegistryConfig) SetPackageName(packageName string) {
	r.PackageName = packageName
	r.require(rubyGemsRegistryConfigFieldPackageName)
}

func (r *RubyGemsRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsRegistryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RubyGemsRegistryConfig) MarshalJSON() ([]byte, error) {
	type embed RubyGemsRegistryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RubyGemsRegistryConfig) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

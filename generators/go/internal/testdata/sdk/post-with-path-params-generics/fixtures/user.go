// This file was auto-generated by Fern from our API Definition.

package api

import (
	core "acme.io/sdk/core"
	internal "acme.io/sdk/internal"
	json "encoding/json"
	fmt "fmt"
)

type SetNameRequest struct {
	UserName string `json:"userName" url:"-"`
}

type SetNameRequestV3 struct {
	XEndpointHeader string                `json:"-" url:"-"`
	Body            *SetNameRequestV3Body `json:"-" url:"-"`
}

func (s *SetNameRequestV3) UnmarshalJSON(data []byte) error {
	body := new(SetNameRequestV3Body)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SetNameRequestV3) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

type SetNameRequestV3Optional struct {
	XEndpointHeader string                `json:"-" url:"-"`
	Body            *SetNameRequestV3Body `json:"-" url:"-"`
}

func (s *SetNameRequestV3Optional) UnmarshalJSON(data []byte) error {
	body := new(SetNameRequestV3Body)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SetNameRequestV3Optional) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

type SetNameRequestV4 struct {
	XEndpointHeader string   `json:"-" url:"-"`
	Body            []string `json:"-" url:"-"`
}

func (s *SetNameRequestV4) UnmarshalJSON(data []byte) error {
	var body []string
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SetNameRequestV4) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

type SetNameRequestV5 struct {
	XEndpointHeader string `json:"-" url:"-"`
	Body            string `json:"-" url:"-"`
}

func (s *SetNameRequestV5) UnmarshalJSON(data []byte) error {
	var body string
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	if body != "fern" {
		return fmt.Errorf("expected literal %q, but found %q", "fern", body)
	}
	s.Body = body
	return nil
}

func (s *SetNameRequestV5) MarshalJSON() ([]byte, error) {
	return json.Marshal("fern")
}

type Bar struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Bar) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *Bar) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bar) UnmarshalJSON(data []byte) error {
	type unmarshaler Bar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bar(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bar) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Filter struct {
	Tag string `json:"tag" url:"tag"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Filter) GetTag() string {
	if f == nil {
		return ""
	}
	return f.Tag
}

func (f *Filter) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Filter) UnmarshalJSON(data []byte) error {
	type unmarshaler Filter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Filter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Filter) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Foo struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Foo) GetId() string {
	if f == nil {
		return ""
	}
	return f.Id
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Foo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type SetNameRequestV3Body struct {
	UserName string `json:"userName" url:"userName"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SetNameRequestV3Body) GetUserName() string {
	if s == nil {
		return ""
	}
	return s.UserName
}

func (s *SetNameRequestV3Body) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SetNameRequestV3Body) UnmarshalJSON(data []byte) error {
	type unmarshaler SetNameRequestV3Body
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SetNameRequestV3Body(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SetNameRequestV3Body) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Union struct {
	Type string
	Foo  *Foo
	Bar  *Bar
}

func NewUnionFromFoo(value *Foo) *Union {
	return &Union{Type: "foo", Foo: value}
}

func NewUnionFromBar(value *Bar) *Union {
	return &Union{Type: "bar", Bar: value}
}

func (u *Union) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *Union) GetFoo() *Foo {
	if u == nil {
		return nil
	}
	return u.Foo
}

func (u *Union) GetBar() *Bar {
	if u == nil {
		return nil
	}
	return u.Bar
}

func (u *Union) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "bar":
		value := new(Bar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Bar = value
	}
	return nil
}

func (u Union) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return internal.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	case "bar":
		return internal.MarshalJSONWithExtraProperty(u.Bar, "type", "bar")
	}
}

type UnionVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *Union) Accept(visitor UnionVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "bar":
		return visitor.VisitBar(u.Bar)
	}
}

func (u *Union) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Foo != nil {
		fields = append(fields, "foo")
	}
	if u.Bar != nil {
		fields = append(fields, "bar")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type UpdateRequest struct {
	Tag            string                   `json:"-" url:"tag"`
	Extra          *string                  `json:"-" url:"extra,omitempty"`
	Union          *Union                   `json:"union,omitempty" url:"-"`
	Filter         *Filter                  `json:"filter,omitempty" url:"-"`
	OptionalUnion  *core.Optional[Union]    `json:"optionalUnion,omitempty" url:"-"`
	OptionalFilter *core.Optional[Filter]   `json:"optionalFilter,omitempty" url:"-"`
	OptionalTags   *core.Optional[[]string] `json:"optionalTags,omitempty" url:"-"`
}

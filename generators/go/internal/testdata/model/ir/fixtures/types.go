// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	internal "sdk/internal"
	time "time"
)

type DeclaredErrorName struct {
	ErrorId      ErrorId       `json:"errorId" url:"errorId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredErrorName) GetErrorId() ErrorId {
	if d == nil {
		return ""
	}
	return d.ErrorId
}

func (d *DeclaredErrorName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredErrorName) GetName() *Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredErrorName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredErrorName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredErrorName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredErrorName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredErrorName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ErrorDeclaration struct {
	Docs              *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Name              *DeclaredErrorName `json:"name,omitempty" url:"name,omitempty"`
	DiscriminantValue *NameAndWireValue  `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Type              *TypeReference     `json:"type,omitempty" url:"type,omitempty"`
	StatusCode        int                `json:"statusCode" url:"statusCode"`

	extraProperties map[string]interface{}
}

func (e *ErrorDeclaration) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ErrorDeclaration) GetName() *DeclaredErrorName {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ErrorDeclaration) GetDiscriminantValue() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.DiscriminantValue
}

func (e *ErrorDeclaration) GetType() *TypeReference {
	if e == nil {
		return nil
	}
	return e.Type
}

func (e *ErrorDeclaration) GetStatusCode() int {
	if e == nil {
		return 0
	}
	return e.StatusCode
}

func (e *ErrorDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ErrorDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *NameAndWireValue
	StatusCode interface{}
}

func NewErrorDeclarationDiscriminantValueFromProperty(value *NameAndWireValue) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "property", Property: value}
}

func NewErrorDeclarationDiscriminantValueFromStatusCode(value interface{}) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "statusCode", StatusCode: value}
}

func (e *ErrorDeclarationDiscriminantValue) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ErrorDeclarationDiscriminantValue) GetProperty() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Property
}

func (e *ErrorDeclarationDiscriminantValue) GetStatusCode() interface{} {
	if e == nil {
		return nil
	}
	return e.StatusCode
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "property":
		value := new(NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return internal.MarshalJSONWithExtraProperty(e.Property, "type", "property")
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*NameAndWireValue) error
	VisitStatusCode(interface{}) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return visitor.VisitProperty(e.Property)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	}
}

func (e *ErrorDeclarationDiscriminantValue) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Property != nil {
		fields = append(fields, "property")
	}
	if e.StatusCode != nil {
		fields = append(fields, "statusCode")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf,omitempty" url:"aliasOf,omitempty"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType,omitempty" url:"resolvedType,omitempty"`

	extraProperties map[string]interface{}
}

func (a *AliasTypeDeclaration) GetAliasOf() *TypeReference {
	if a == nil {
		return nil
	}
	return a.AliasOf
}

func (a *AliasTypeDeclaration) GetResolvedType() *ResolvedTypeReference {
	if a == nil {
		return nil
	}
	return a.ResolvedType
}

func (a *AliasTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *AliasTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func NewContainerTypeFromList(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "list", List: value}
}

func NewContainerTypeFromMap(value *MapType) *ContainerType {
	return &ContainerType{Type: "map", Map: value}
}

func NewContainerTypeFromOptional(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "optional", Optional: value}
}

func NewContainerTypeFromSet(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "set", Set: value}
}

func NewContainerTypeFromLiteral(value *Literal) *ContainerType {
	return &ContainerType{Type: "literal", Literal: value}
}

func (c *ContainerType) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContainerType) GetList() *TypeReference {
	if c == nil {
		return nil
	}
	return c.List
}

func (c *ContainerType) GetMap() *MapType {
	if c == nil {
		return nil
	}
	return c.Map
}

func (c *ContainerType) GetOptional() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Optional
}

func (c *ContainerType) GetSet() *TypeReference {
	if c == nil {
		return nil
	}
	return c.Set
}

func (c *ContainerType) GetLiteral() *Literal {
	if c == nil {
		return nil
	}
	return c.Literal
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", c)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list,omitempty"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "map":
		return internal.MarshalJSONWithExtraProperty(c.Map, "_type", "map")
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional,omitempty"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set,omitempty"`
		}{
			Type: "set",
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal,omitempty"`
		}{
			Type:    "literal",
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "map":
		return visitor.VisitMap(c.Map)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	case "set":
		return visitor.VisitSet(c.Set)
	case "literal":
		return visitor.VisitLiteral(c.Literal)
	}
}

func (c *ContainerType) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.List != nil {
		fields = append(fields, "list")
	}
	if c.Map != nil {
		fields = append(fields, "map")
	}
	if c.Optional != nil {
		fields = append(fields, "optional")
	}
	if c.Set != nil {
		fields = append(fields, "set")
	}
	if c.Literal != nil {
		fields = append(fields, "literal")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type DeclaredTypeName struct {
	TypeId       TypeId        `json:"typeId" url:"typeId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredTypeName) GetTypeId() TypeId {
	if d == nil {
		return ""
	}
	return d.TypeId
}

func (d *DeclaredTypeName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredTypeName) GetName() *Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeclaredTypeName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredTypeName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredTypeName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredTypeName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredTypeName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumTypeDeclaration struct {
	Values []*EnumValue `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumTypeDeclaration) GetValues() []*EnumValue {
	if e == nil {
		return nil
	}
	return e.Values
}

func (e *EnumTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumValue) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *EnumValue) GetAvailability() *Availability {
	if e == nil {
		return nil
	}
	return e.Availability
}

func (e *EnumValue) GetName() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnumValue) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumValue) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnumValue) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleAliasType) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleAliasType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleAliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleAliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleAliasType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleAliasType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleContainer struct {
	Type     string
	List     []*ExampleTypeReference
	Set      []*ExampleTypeReference
	Optional *ExampleTypeReference
	Map      []*ExampleKeyValuePair
}

func NewExampleContainerFromList(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "list", List: value}
}

func NewExampleContainerFromSet(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "set", Set: value}
}

func NewExampleContainerFromOptional(value *ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "optional", Optional: value}
}

func NewExampleContainerFromMap(value []*ExampleKeyValuePair) *ExampleContainer {
	return &ExampleContainer{Type: "map", Map: value}
}

func (e *ExampleContainer) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleContainer) GetList() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.List
}

func (e *ExampleContainer) GetSet() []*ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Set
}

func (e *ExampleContainer) GetOptional() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Optional
}

func (e *ExampleContainer) GetMap() []*ExampleKeyValuePair {
	if e == nil {
		return nil
	}
	return e.Map
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*ExampleTypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.List = valueUnmarshaler.List
	case "set":
		var valueUnmarshaler struct {
			Set []*ExampleTypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Set = valueUnmarshaler.Set
	case "optional":
		var valueUnmarshaler struct {
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Optional = valueUnmarshaler.Optional
	case "map":
		var valueUnmarshaler struct {
			Map []*ExampleKeyValuePair `json:"map,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Map = valueUnmarshaler.Map
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		var marshaler = struct {
			Type string                  `json:"type"`
			List []*ExampleTypeReference `json:"list,omitempty"`
		}{
			Type: "list",
			List: e.List,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string                  `json:"type"`
			Set  []*ExampleTypeReference `json:"set,omitempty"`
		}{
			Type: "set",
			Set:  e.Set,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string                `json:"type"`
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}{
			Type:     "optional",
			Optional: e.Optional,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string                 `json:"type"`
			Map  []*ExampleKeyValuePair `json:"map,omitempty"`
		}{
			Type: "map",
			Map:  e.Map,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleContainerVisitor interface {
	VisitList([]*ExampleTypeReference) error
	VisitSet([]*ExampleTypeReference) error
	VisitOptional(*ExampleTypeReference) error
	VisitMap([]*ExampleKeyValuePair) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return visitor.VisitList(e.List)
	case "set":
		return visitor.VisitSet(e.Set)
	case "optional":
		return visitor.VisitOptional(e.Optional)
	case "map":
		return visitor.VisitMap(e.Map)
	}
}

func (e *ExampleContainer) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.List != nil {
		fields = append(fields, "list")
	}
	if e.Set != nil {
		fields = append(fields, "set")
	}
	if e.Optional != nil {
		fields = append(fields, "optional")
	}
	if e.Map != nil {
		fields = append(fields, "map")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleEnumType struct {
	WireValue string `json:"wireValue" url:"wireValue"`

	extraProperties map[string]interface{}
}

func (e *ExampleEnumType) GetWireValue() string {
	if e == nil {
		return ""
	}
	return e.WireValue
}

func (e *ExampleEnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEnumType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEnumType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key,omitempty" url:"key,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleKeyValuePair) GetKey() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *ExampleKeyValuePair) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleKeyValuePair) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleKeyValuePair) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleKeyValuePair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleKeyValuePair(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleKeyValuePair) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName,omitempty" url:"typeName,omitempty"`
	Shape    *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleNamedType) GetTypeName() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.TypeName
}

func (e *ExampleNamedType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleNamedType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleNamedType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectProperty struct {
	WireKey string                `json:"wireKey" url:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// this property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectProperty) GetWireKey() string {
	if e == nil {
		return ""
	}
	return e.WireKey
}

func (e *ExampleObjectProperty) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleObjectProperty) GetOriginalTypeDeclaration() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.OriginalTypeDeclaration
}

func (e *ExampleObjectProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectProperty) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleObjectType) GetProperties() []*ExampleObjectProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleObjectType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleObjectType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleObjectType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePrimitive struct {
	Type     string
	Integer  int
	Double   float64
	String   string
	Boolean  bool
	Long     int64
	Datetime time.Time
	Date     time.Time
	Uuid     uuid.UUID
}

func NewExamplePrimitiveFromInteger(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "integer", Integer: value}
}

func NewExamplePrimitiveFromDouble(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "double", Double: value}
}

func NewExamplePrimitiveFromString(value string) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "string", String: value}
}

func NewExamplePrimitiveFromBoolean(value bool) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "boolean", Boolean: value}
}

func NewExamplePrimitiveFromLong(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "long", Long: value}
}

func NewExamplePrimitiveFromDatetime(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "datetime", Datetime: value}
}

func NewExamplePrimitiveFromDate(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "date", Date: value}
}

func NewExamplePrimitiveFromUuid(value uuid.UUID) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uuid", Uuid: value}
}

func (e *ExamplePrimitive) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExamplePrimitive) GetInteger() int {
	if e == nil {
		return 0
	}
	return e.Integer
}

func (e *ExamplePrimitive) GetDouble() float64 {
	if e == nil {
		return 0
	}
	return e.Double
}

func (e *ExamplePrimitive) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *ExamplePrimitive) GetBoolean() bool {
	if e == nil {
		return false
	}
	return e.Boolean
}

func (e *ExamplePrimitive) GetLong() int64 {
	if e == nil {
		return 0
	}
	return e.Long
}

func (e *ExamplePrimitive) GetDatetime() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Datetime
}

func (e *ExamplePrimitive) GetDate() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Date
}

func (e *ExamplePrimitive) GetUuid() uuid.UUID {
	if e == nil {
		return uuid.Nil
	}
	return e.Uuid
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "datetime":
		var valueUnmarshaler struct {
			Datetime *internal.DateTime `json:"datetime"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Datetime = valueUnmarshaler.Datetime.Time()
	case "date":
		var valueUnmarshaler struct {
			Date *internal.Date `json:"date" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date.Time()
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    "integer",
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	case "double":
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   "double",
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   "string",
			String: e.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	case "long":
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: "long",
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string             `json:"type"`
			Datetime *internal.DateTime `json:"datetime"`
		}{
			Type:     "datetime",
			Datetime: internal.NewDateTime(e.Datetime),
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string         `json:"type"`
			Date *internal.Date `json:"date" format:"date"`
		}{
			Type: "date",
			Date: internal.NewDate(e.Date),
		}
		return json.Marshal(marshaler)
	case "uuid":
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: "uuid",
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	}
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
	VisitString(string) error
	VisitBoolean(bool) error
	VisitLong(int64) error
	VisitDatetime(time.Time) error
	VisitDate(time.Time) error
	VisitUuid(uuid.UUID) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "double":
		return visitor.VisitDouble(e.Double)
	case "string":
		return visitor.VisitString(e.String)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	case "long":
		return visitor.VisitLong(e.Long)
	case "datetime":
		return visitor.VisitDatetime(e.Datetime)
	case "date":
		return visitor.VisitDate(e.Date)
	case "uuid":
		return visitor.VisitUuid(e.Uuid)
	}
}

func (e *ExamplePrimitive) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Integer != 0 {
		fields = append(fields, "integer")
	}
	if e.Double != 0 {
		fields = append(fields, "double")
	}
	if e.String != "" {
		fields = append(fields, "string")
	}
	if e.Boolean != false {
		fields = append(fields, "boolean")
	}
	if e.Long != 0 {
		fields = append(fields, "long")
	}
	if !e.Datetime.IsZero() {
		fields = append(fields, "datetime")
	}
	if !e.Date.IsZero() {
		fields = append(fields, "date")
	}
	if e.Uuid != uuid.Nil {
		fields = append(fields, "uuid")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleSingleUnionType struct {
	WireDiscriminantValue string                            `json:"wireDiscriminantValue" url:"wireDiscriminantValue"`
	Properties            *ExampleSingleUnionTypeProperties `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleSingleUnionType) GetWireDiscriminantValue() string {
	if e == nil {
		return ""
	}
	return e.WireDiscriminantValue
}

func (e *ExampleSingleUnionType) GetProperties() *ExampleSingleUnionTypeProperties {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleSingleUnionType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleSingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleSingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleSingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleSingleUnionType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleNamedType
	SingleProperty         *ExampleTypeReference
	NoProperties           interface{}
}

func NewExampleSingleUnionTypePropertiesFromSamePropertiesAsObject(value *ExampleNamedType) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewExampleSingleUnionTypePropertiesFromSingleProperty(value *ExampleTypeReference) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "singleProperty", SingleProperty: value}
}

func NewExampleSingleUnionTypePropertiesFromNoProperties(value interface{}) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "noProperties", NoProperties: value}
}

func (e *ExampleSingleUnionTypeProperties) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleSingleUnionTypeProperties) GetSamePropertiesAsObject() *ExampleNamedType {
	if e == nil {
		return nil
	}
	return e.SamePropertiesAsObject
}

func (e *ExampleSingleUnionTypeProperties) GetSingleProperty() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.SingleProperty
}

func (e *ExampleSingleUnionTypeProperties) GetNoProperties() interface{} {
	if e == nil {
		return nil
	}
	return e.NoProperties
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return internal.MarshalJSONWithExtraProperty(e.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	case "singleProperty":
		return internal.MarshalJSONWithExtraProperty(e.SingleProperty, "type", "singleProperty")
	case "noProperties":
		var marshaler = struct {
			Type         string      `json:"type"`
			NoProperties interface{} `json:"noProperties,omitempty"`
		}{
			Type:         "noProperties",
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleNamedType) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(interface{}) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(e.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(e.NoProperties)
	}
}

func (e *ExampleSingleUnionTypeProperties) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if e.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if e.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleType struct {
	JsonExample interface{}       `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *Name             `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleType) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleType) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleType) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleType) GetShape() *ExampleTypeShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleType) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleType) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReference struct {
	JsonExample interface{}                `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Shape       *ExampleTypeReferenceShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleTypeReference) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleTypeReference) GetShape() *ExampleTypeReferenceShape {
	if e == nil {
		return nil
	}
	return e.Shape
}

func (e *ExampleTypeReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleTypeReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleTypeReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleTypeReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleTypeReference) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   interface{}
	Named     *ExampleNamedType
}

func NewExampleTypeReferenceShapeFromPrimitive(value *ExamplePrimitive) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "primitive", Primitive: value}
}

func NewExampleTypeReferenceShapeFromContainer(value *ExampleContainer) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "container", Container: value}
}

func NewExampleTypeReferenceShapeFromUnknown(value interface{}) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "unknown", Unknown: value}
}

func NewExampleTypeReferenceShapeFromNamed(value *ExampleNamedType) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "named", Named: value}
}

func (e *ExampleTypeReferenceShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeReferenceShape) GetPrimitive() *ExamplePrimitive {
	if e == nil {
		return nil
	}
	return e.Primitive
}

func (e *ExampleTypeReferenceShape) GetContainer() *ExampleContainer {
	if e == nil {
		return nil
	}
	return e.Container
}

func (e *ExampleTypeReferenceShape) GetUnknown() interface{} {
	if e == nil {
		return nil
	}
	return e.Unknown
}

func (e *ExampleTypeReferenceShape) GetNamed() *ExampleNamedType {
	if e == nil {
		return nil
	}
	return e.Named
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown interface{} `json:"unknown,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	case "container":
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(e.Named, "type", "named")
	}
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(interface{}) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		return visitor.VisitPrimitive(e.Primitive)
	case "container":
		return visitor.VisitContainer(e.Container)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	case "named":
		return visitor.VisitNamed(e.Named)
	}
}

func (e *ExampleTypeReferenceShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if e.Container != nil {
		fields = append(fields, "container")
	}
	if e.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if e.Named != nil {
		fields = append(fields, "named")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleTypeShape struct {
	Type   string
	Alias  *ExampleAliasType
	Enum   *ExampleEnumType
	Object *ExampleObjectType
	Union  *ExampleSingleUnionType
}

func NewExampleTypeShapeFromAlias(value *ExampleAliasType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "alias", Alias: value}
}

func NewExampleTypeShapeFromEnum(value *ExampleEnumType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "enum", Enum: value}
}

func NewExampleTypeShapeFromObject(value *ExampleObjectType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "object", Object: value}
}

func NewExampleTypeShapeFromUnion(value *ExampleSingleUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "union", Union: value}
}

func (e *ExampleTypeShape) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleTypeShape) GetAlias() *ExampleAliasType {
	if e == nil {
		return nil
	}
	return e.Alias
}

func (e *ExampleTypeShape) GetEnum() *ExampleEnumType {
	if e == nil {
		return nil
	}
	return e.Enum
}

func (e *ExampleTypeShape) GetObject() *ExampleObjectType {
	if e == nil {
		return nil
	}
	return e.Object
}

func (e *ExampleTypeShape) GetUnion() *ExampleSingleUnionType {
	if e == nil {
		return nil
	}
	return e.Union
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleSingleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return internal.MarshalJSONWithExtraProperty(e.Alias, "type", "alias")
	case "enum":
		return internal.MarshalJSONWithExtraProperty(e.Enum, "type", "enum")
	case "object":
		return internal.MarshalJSONWithExtraProperty(e.Object, "type", "object")
	case "union":
		return internal.MarshalJSONWithExtraProperty(e.Union, "type", "union")
	}
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleSingleUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return visitor.VisitAlias(e.Alias)
	case "enum":
		return visitor.VisitEnum(e.Enum)
	case "object":
		return visitor.VisitObject(e.Object)
	case "union":
		return visitor.VisitUnion(e.Union)
	}
}

func (e *ExampleTypeShape) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Alias != nil {
		fields = append(fields, "alias")
	}
	if e.Enum != nil {
		fields = append(fields, "enum")
	}
	if e.Object != nil {
		fields = append(fields, "object")
	}
	if e.Union != nil {
		fields = append(fields, "union")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type Literal struct {
	Type   string
	String string
}

func NewLiteralFromString(value string) *Literal {
	return &Literal{Type: "string", String: value}
}

func (l *Literal) GetType() string {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *Literal) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	if err := l.validate(); err != nil {
		return nil, err
	}
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralVisitor interface {
	VisitString(string) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		return visitor.VisitString(l.String)
	}
}

func (l *Literal) validate() error {
	if l == nil {
		return fmt.Errorf("type %T is nil", l)
	}
	var fields []string
	if l.String != "" {
		fields = append(fields, "string")
	}
	if len(fields) == 0 {
		if l.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", l, l.Type)
		}
		return fmt.Errorf("type %T is empty", l)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", l, fields)
	}
	if l.Type != "" {
		field := fields[0]
		if l.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				l,
				l.Type,
				l,
			)
		}
	}
	return nil
}

type MapType struct {
	KeyType   *TypeReference `json:"keyType,omitempty" url:"keyType,omitempty"`
	ValueType *TypeReference `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetKeyType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.KeyType
}

func (m *MapType) GetValueType() *TypeReference {
	if m == nil {
		return nil
	}
	return m.ValueType
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MapType) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ObjectProperty struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (o *ObjectProperty) GetDocs() *string {
	if o == nil {
		return nil
	}
	return o.Docs
}

func (o *ObjectProperty) GetAvailability() *Availability {
	if o == nil {
		return nil
	}
	return o.Availability
}

func (o *ObjectProperty) GetName() *NameAndWireValue {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ObjectProperty) GetValueType() *TypeReference {
	if o == nil {
		return nil
	}
	return o.ValueType
}

func (o *ObjectProperty) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectProperty) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*ObjectProperty   `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *ObjectTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if o == nil {
		return nil
	}
	return o.Extends
}

func (o *ObjectTypeDeclaration) GetProperties() []*ObjectProperty {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *ObjectTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	return nil
}

func (o *ObjectTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveType string

const (
	PrimitiveTypeInteger PrimitiveType = "INTEGER"
	PrimitiveTypeDouble  PrimitiveType = "DOUBLE"
	PrimitiveTypeString  PrimitiveType = "STRING"
	PrimitiveTypeBoolean PrimitiveType = "BOOLEAN"
	// Within the range -2^53 to 2^53
	PrimitiveTypeLong     PrimitiveType = "LONG"
	PrimitiveTypeDateTime PrimitiveType = "DATE_TIME"
	PrimitiveTypeDate     PrimitiveType = "DATE"
	PrimitiveTypeUuid     PrimitiveType = "UUID"
	PrimitiveTypeBase64   PrimitiveType = "BASE_64"
)

func NewPrimitiveTypeFromString(s string) (PrimitiveType, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeInteger, nil
	case "DOUBLE":
		return PrimitiveTypeDouble, nil
	case "STRING":
		return PrimitiveTypeString, nil
	case "BOOLEAN":
		return PrimitiveTypeBoolean, nil
	case "LONG":
		return PrimitiveTypeLong, nil
	case "DATE_TIME":
		return PrimitiveTypeDateTime, nil
	case "DATE":
		return PrimitiveTypeDate, nil
	case "UUID":
		return PrimitiveTypeUuid, nil
	case "BASE_64":
		return PrimitiveTypeBase64, nil
	}
	var t PrimitiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveType) Ptr() *PrimitiveType {
	return &p
}

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape ShapeType         `json:"shape" url:"shape"`

	extraProperties map[string]interface{}
}

func (r *ResolvedNamedType) GetName() *DeclaredTypeName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *ResolvedNamedType) GetShape() ShapeType {
	if r == nil {
		return ""
	}
	return r.Shape
}

func (r *ResolvedNamedType) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolvedNamedType) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolvedNamedType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolvedNamedType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResolvedNamedType) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewResolvedTypeReferenceFromContainer(value *ContainerType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "container", Container: value}
}

func NewResolvedTypeReferenceFromNamed(value *ResolvedNamedType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "named", Named: value}
}

func NewResolvedTypeReferenceFromPrimitive(value PrimitiveType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "primitive", Primitive: value}
}

func NewResolvedTypeReferenceFromUnknown(value interface{}) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "unknown", Unknown: value}
}

func (r *ResolvedTypeReference) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResolvedTypeReference) GetContainer() *ContainerType {
	if r == nil {
		return nil
	}
	return r.Container
}

func (r *ResolvedTypeReference) GetNamed() *ResolvedNamedType {
	if r == nil {
		return nil
	}
	return r.Named
}

func (r *ResolvedTypeReference) GetPrimitive() PrimitiveType {
	if r == nil {
		return ""
	}
	return r.Primitive
}

func (r *ResolvedTypeReference) GetUnknown() interface{} {
	if r == nil {
		return nil
	}
	return r.Unknown
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", r)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(r.Named, "_type", "named")
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive"`
		}{
			Type:      "primitive",
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		return visitor.VisitContainer(r.Container)
	case "named":
		return visitor.VisitNamed(r.Named)
	case "primitive":
		return visitor.VisitPrimitive(r.Primitive)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

func (r *ResolvedTypeReference) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Container != nil {
		fields = append(fields, "container")
	}
	if r.Named != nil {
		fields = append(fields, "named")
	}
	if r.Primitive != "" {
		fields = append(fields, "primitive")
	}
	if r.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty" url:"docs,omitempty"`
	DiscriminantValue *NameAndWireValue          `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Shape             *SingleUnionTypeProperties `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionType) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleUnionType) GetDiscriminantValue() *NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.DiscriminantValue
}

func (s *SingleUnionType) GetShape() *SingleUnionTypeProperties {
	if s == nil {
		return nil
	}
	return s.Shape
}

func (s *SingleUnionType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionType) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           interface{}
}

func NewSingleUnionTypePropertiesFromSamePropertiesAsObject(value *DeclaredTypeName) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleUnionTypePropertiesFromSingleProperty(value *SingleUnionTypeProperty) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "singleProperty", SingleProperty: value}
}

func NewSingleUnionTypePropertiesFromNoProperties(value interface{}) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "noProperties", NoProperties: value}
}

func (s *SingleUnionTypeProperties) GetPropertiesType() string {
	if s == nil {
		return ""
	}
	return s.PropertiesType
}

func (s *SingleUnionTypeProperties) GetSamePropertiesAsObject() *DeclaredTypeName {
	if s == nil {
		return nil
	}
	return s.SamePropertiesAsObject
}

func (s *SingleUnionTypeProperties) GetSingleProperty() *SingleUnionTypeProperty {
	if s == nil {
		return nil
	}
	return s.SingleProperty
}

func (s *SingleUnionTypeProperties) GetNoProperties() interface{} {
	if s == nil {
		return nil
	}
	return s.NoProperties
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	if unmarshaler.PropertiesType == "" {
		return fmt.Errorf("%T did not include discriminant _type", s)
	}
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.PropertiesType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return internal.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "_type", "samePropertiesAsObject")
	case "singleProperty":
		return internal.MarshalJSONWithExtraProperty(s.SingleProperty, "_type", "singleProperty")
	case "noProperties":
		var marshaler = struct {
			PropertiesType string      `json:"_type"`
			NoProperties   interface{} `json:"noProperties,omitempty"`
		}{
			PropertiesType: "noProperties",
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(interface{}) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	switch s.PropertiesType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

func (s *SingleUnionTypeProperties) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.SamePropertiesAsObject != nil {
		fields = append(fields, "samePropertiesAsObject")
	}
	if s.SingleProperty != nil {
		fields = append(fields, "singleProperty")
	}
	if s.NoProperties != nil {
		fields = append(fields, "noProperties")
	}
	if len(fields) == 0 {
		if s.PropertiesType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.PropertiesType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.PropertiesType != "" {
		field := fields[0]
		if s.PropertiesType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.PropertiesType,
				s,
			)
		}
	}
	return nil
}

type SingleUnionTypeProperty struct {
	Name *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	Type *TypeReference    `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleUnionTypeProperty) GetName() *NameAndWireValue {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleUnionTypeProperty) GetType() *TypeReference {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SingleUnionTypeProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUnionTypeProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUnionTypeProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUnionTypeProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleUnionTypeProperty) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Type) GetAlias() *AliasTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Alias
}

func (t *Type) GetEnum() *EnumTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Enum
}

func (t *Type) GetObject() *ObjectTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *Type) GetUnion() *UnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.Union
}

func (t *Type) GetUndiscriminatedUnion() *UndiscriminatedUnionTypeDeclaration {
	if t == nil {
		return nil
	}
	return t.UndiscriminatedUnion
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return internal.MarshalJSONWithExtraProperty(t.Alias, "_type", "alias")
	case "enum":
		return internal.MarshalJSONWithExtraProperty(t.Enum, "_type", "enum")
	case "object":
		return internal.MarshalJSONWithExtraProperty(t.Object, "_type", "object")
	case "union":
		return internal.MarshalJSONWithExtraProperty(t.Union, "_type", "union")
	case "undiscriminatedUnion":
		return internal.MarshalJSONWithExtraProperty(t.UndiscriminatedUnion, "_type", "undiscriminatedUnion")
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return visitor.VisitAlias(t.Alias)
	case "enum":
		return visitor.VisitEnum(t.Enum)
	case "object":
		return visitor.VisitObject(t.Object)
	case "union":
		return visitor.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}

func (t *Type) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Alias != nil {
		fields = append(fields, "alias")
	}
	if t.Enum != nil {
		fields = append(fields, "enum")
	}
	if t.Object != nil {
		fields = append(fields, "object")
	}
	if t.Union != nil {
		fields = append(fields, "union")
	}
	if t.UndiscriminatedUnion != nil {
		fields = append(fields, "undiscriminatedUnion")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// A type, which is a name and a shape
type TypeDeclaration struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape        *Type             `json:"shape,omitempty" url:"shape,omitempty"`
	Examples     []*ExampleType    `json:"examples,omitempty" url:"examples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []*DeclaredTypeName `json:"referencedTypes,omitempty" url:"referencedTypes,omitempty"`

	extraProperties map[string]interface{}
}

func (t *TypeDeclaration) GetDocs() *string {
	if t == nil {
		return nil
	}
	return t.Docs
}

func (t *TypeDeclaration) GetAvailability() *Availability {
	if t == nil {
		return nil
	}
	return t.Availability
}

func (t *TypeDeclaration) GetName() *DeclaredTypeName {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TypeDeclaration) GetShape() *Type {
	if t == nil {
		return nil
	}
	return t.Shape
}

func (t *TypeDeclaration) GetExamples() []*ExampleType {
	if t == nil {
		return nil
	}
	return t.Examples
}

func (t *TypeDeclaration) GetReferencedTypes() []*DeclaredTypeName {
	if t == nil {
		return nil
	}
	return t.ReferencedTypes
}

func (t *TypeDeclaration) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler TypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	return nil
}

func (t *TypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *DeclaredTypeName
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewTypeReferenceFromContainer(value *ContainerType) *TypeReference {
	return &TypeReference{Type: "container", Container: value}
}

func NewTypeReferenceFromNamed(value *DeclaredTypeName) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromPrimitive(value PrimitiveType) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromUnknown(value interface{}) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TypeReference) GetContainer() *ContainerType {
	if t == nil {
		return nil
	}
	return t.Container
}

func (t *TypeReference) GetNamed() *DeclaredTypeName {
	if t == nil {
		return nil
	}
	return t.Named
}

func (t *TypeReference) GetPrimitive() PrimitiveType {
	if t == nil {
		return ""
	}
	return t.Primitive
}

func (t *TypeReference) GetUnknown() interface{} {
	if t == nil {
		return nil
	}
	return t.Unknown
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		return internal.MarshalJSONWithExtraProperty(t.Named, "_type", "named")
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*DeclaredTypeName) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		return visitor.VisitContainer(t.Container)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

func (t *TypeReference) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Container != nil {
		fields = append(fields, "container")
	}
	if t.Named != nil {
		fields = append(fields, "named")
	}
	if t.Primitive != "" {
		fields = append(fields, "primitive")
	}
	if t.Unknown != nil {
		fields = append(fields, "unknown")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Type *TypeReference `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionMember) GetDocs() *string {
	if u == nil {
		return nil
	}
	return u.Docs
}

func (u *UndiscriminatedUnionMember) GetType() *TypeReference {
	if u == nil {
		return nil
	}
	return u.Type
}

func (u *UndiscriminatedUnionMember) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionMember) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionMember(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionMember) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members,omitempty" url:"members,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionTypeDeclaration) GetMembers() []*UndiscriminatedUnionMember {
	if u == nil {
		return nil
	}
	return u.Members
}

func (u *UndiscriminatedUnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UndiscriminatedUnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnionTypeDeclaration struct {
	Discriminant *NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Types          []*SingleUnionType  `json:"types,omitempty" url:"types,omitempty"`
	BaseProperties []*ObjectProperty   `json:"baseProperties,omitempty" url:"baseProperties,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UnionTypeDeclaration) GetDiscriminant() *NameAndWireValue {
	if u == nil {
		return nil
	}
	return u.Discriminant
}

func (u *UnionTypeDeclaration) GetExtends() []*DeclaredTypeName {
	if u == nil {
		return nil
	}
	return u.Extends
}

func (u *UnionTypeDeclaration) GetTypes() []*SingleUnionType {
	if u == nil {
		return nil
	}
	return u.Types
}

func (u *UnionTypeDeclaration) GetBaseProperties() []*ObjectProperty {
	if u == nil {
		return nil
	}
	return u.BaseProperties
}

func (u *UnionTypeDeclaration) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnionTypeDeclaration) UnmarshalJSON(data []byte) error {
	type unmarshaler UnionTypeDeclaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnionTypeDeclaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	return nil
}

func (u *UnionTypeDeclaration) String() string {
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

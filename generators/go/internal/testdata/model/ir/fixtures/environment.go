// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

type EnvironmentBaseUrlId = string

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id" url:"id"`
	Name *Name                `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentBaseUrlWithId) GetId() EnvironmentBaseUrlId {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EnvironmentBaseUrlWithId) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EnvironmentBaseUrlWithId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentBaseUrlWithId) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentBaseUrlWithId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentBaseUrlWithId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentBaseUrlWithId) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func NewEnvironmentsFromSingleBaseUrl(value *SingleBaseUrlEnvironments) *Environments {
	return &Environments{Type: "singleBaseUrl", SingleBaseUrl: value}
}

func NewEnvironmentsFromMultipleBaseUrls(value *MultipleBaseUrlsEnvironments) *Environments {
	return &Environments{Type: "multipleBaseUrls", MultipleBaseUrls: value}
}

func (e *Environments) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *Environments) GetSingleBaseUrl() *SingleBaseUrlEnvironments {
	if e == nil {
		return nil
	}
	return e.SingleBaseUrl
}

func (e *Environments) GetMultipleBaseUrls() *MultipleBaseUrlsEnvironments {
	if e == nil {
		return nil
	}
	return e.MultipleBaseUrls
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return internal.MarshalJSONWithExtraProperty(e.SingleBaseUrl, "type", "singleBaseUrl")
	case "multipleBaseUrls":
		return internal.MarshalJSONWithExtraProperty(e.MultipleBaseUrls, "type", "multipleBaseUrls")
	}
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	case "multipleBaseUrls":
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
}

func (e *Environments) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.SingleBaseUrl != nil {
		fields = append(fields, "singleBaseUrl")
	}
	if e.MultipleBaseUrls != nil {
		fields = append(fields, "multipleBaseUrls")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty" url:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnvironmentsConfig) GetDefaultEnvironment() *EnvironmentId {
	if e == nil {
		return nil
	}
	return e.DefaultEnvironment
}

func (e *EnvironmentsConfig) GetEnvironments() *Environments {
	if e == nil {
		return nil
	}
	return e.Environments
}

func (e *EnvironmentsConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentsConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentsConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentsConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *EnvironmentsConfig) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id" url:"id"`
	Name *Name                                   `json:"name,omitempty" url:"name,omitempty"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls,omitempty" url:"urls,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironment) GetDocs() *string {
	if m == nil {
		return nil
	}
	return m.Docs
}

func (m *MultipleBaseUrlsEnvironment) GetId() EnvironmentId {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MultipleBaseUrlsEnvironment) GetName() *Name {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MultipleBaseUrlsEnvironment) GetUrls() map[EnvironmentBaseUrlId]EnvironmentUrl {
	if m == nil {
		return nil
	}
	return m.Urls
}

func (m *MultipleBaseUrlsEnvironment) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironment) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls,omitempty" url:"baseUrls,omitempty"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MultipleBaseUrlsEnvironments) GetBaseUrls() []*EnvironmentBaseUrlWithId {
	if m == nil {
		return nil
	}
	return m.BaseUrls
}

func (m *MultipleBaseUrlsEnvironments) GetEnvironments() []*MultipleBaseUrlsEnvironment {
	if m == nil {
		return nil
	}
	return m.Environments
}

func (m *MultipleBaseUrlsEnvironments) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipleBaseUrlsEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipleBaseUrlsEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipleBaseUrlsEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MultipleBaseUrlsEnvironments) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId  `json:"id" url:"id"`
	Name *Name          `json:"name,omitempty" url:"name,omitempty"`
	Url  EnvironmentUrl `json:"url" url:"url"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironment) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *SingleBaseUrlEnvironment) GetId() EnvironmentId {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SingleBaseUrlEnvironment) GetName() *Name {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SingleBaseUrlEnvironment) GetUrl() EnvironmentUrl {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *SingleBaseUrlEnvironment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironment) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleBaseUrlEnvironments) GetEnvironments() []*SingleBaseUrlEnvironment {
	if s == nil {
		return nil
	}
	return s.Environments
}

func (s *SingleBaseUrlEnvironments) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleBaseUrlEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleBaseUrlEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleBaseUrlEnvironments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SingleBaseUrlEnvironments) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

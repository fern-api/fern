// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

type ErrorDiscriminationByPropertyStrategy struct {
	Discriminant    *NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	ContentProperty *NameAndWireValue `json:"contentProperty,omitempty" url:"contentProperty,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ErrorDiscriminationByPropertyStrategy) GetDiscriminant() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.Discriminant
}

func (e *ErrorDiscriminationByPropertyStrategy) GetContentProperty() *NameAndWireValue {
	if e == nil {
		return nil
	}
	return e.ContentProperty
}

func (e *ErrorDiscriminationByPropertyStrategy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorDiscriminationByPropertyStrategy) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorDiscriminationByPropertyStrategy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorDiscriminationByPropertyStrategy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ErrorDiscriminationByPropertyStrategy) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDiscriminationStrategy struct {
	Type       string
	StatusCode interface{}
	Property   *ErrorDiscriminationByPropertyStrategy
}

func NewErrorDiscriminationStrategyFromStatusCode(value interface{}) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "statusCode", StatusCode: value}
}

func NewErrorDiscriminationStrategyFromProperty(value *ErrorDiscriminationByPropertyStrategy) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "property", Property: value}
}

func (e *ErrorDiscriminationStrategy) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ErrorDiscriminationStrategy) GetStatusCode() interface{} {
	if e == nil {
		return nil
	}
	return e.StatusCode
}

func (e *ErrorDiscriminationStrategy) GetProperty() *ErrorDiscriminationByPropertyStrategy {
	if e == nil {
		return nil
	}
	return e.Property
}

func (e *ErrorDiscriminationStrategy) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	case "property":
		value := new(ErrorDiscriminationByPropertyStrategy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	}
	return nil
}

func (e ErrorDiscriminationStrategy) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	case "property":
		return internal.MarshalJSONWithExtraProperty(e.Property, "type", "property")
	}
}

type ErrorDiscriminationStrategyVisitor interface {
	VisitStatusCode(interface{}) error
	VisitProperty(*ErrorDiscriminationByPropertyStrategy) error
}

func (e *ErrorDiscriminationStrategy) Accept(visitor ErrorDiscriminationStrategyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	case "property":
		return visitor.VisitProperty(e.Property)
	}
}

func (e *ErrorDiscriminationStrategy) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.StatusCode != nil {
		fields = append(fields, "statusCode")
	}
	if e.Property != nil {
		fields = append(fields, "property")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

// Complete representation of the API schema
type IntermediateRepresentation struct {
	// This is the human readable unique id for the API.
	ApiName        *Name    `json:"apiName,omitempty" url:"apiName,omitempty"`
	ApiDisplayName *string  `json:"apiDisplayName,omitempty" url:"apiDisplayName,omitempty"`
	ApiDocs        *string  `json:"apiDocs,omitempty" url:"apiDocs,omitempty"`
	Auth           *ApiAuth `json:"auth,omitempty" url:"auth,omitempty"`
	// API Wide headers that are sent on every request
	Headers []*HttpHeader `json:"headers,omitempty" url:"headers,omitempty"`
	// The types described by this API
	Types map[TypeId]*TypeDeclaration `json:"types,omitempty" url:"types,omitempty"`
	// The services exposed by this API
	Services                    map[ServiceId]*HttpService    `json:"services,omitempty" url:"services,omitempty"`
	Errors                      map[ErrorId]*ErrorDeclaration `json:"errors,omitempty" url:"errors,omitempty"`
	Subpackages                 map[SubpackageId]*Subpackage  `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	RootPackage                 *Package                      `json:"rootPackage,omitempty" url:"rootPackage,omitempty"`
	Constants                   *Constants                    `json:"constants,omitempty" url:"constants,omitempty"`
	Environments                *EnvironmentsConfig           `json:"environments,omitempty" url:"environments,omitempty"`
	BasePath                    *HttpPath                     `json:"basePath,omitempty" url:"basePath,omitempty"`
	PathParameters              []*PathParameter              `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	ErrorDiscriminationStrategy *ErrorDiscriminationStrategy  `json:"errorDiscriminationStrategy,omitempty" url:"errorDiscriminationStrategy,omitempty"`
	SdkConfig                   *SdkConfig                    `json:"sdkConfig,omitempty" url:"sdkConfig,omitempty"`
	Variables                   []*VariableDeclaration        `json:"variables,omitempty" url:"variables,omitempty"`

	extraProperties map[string]interface{}
}

func (i *IntermediateRepresentation) GetApiName() *Name {
	if i == nil {
		return nil
	}
	return i.ApiName
}

func (i *IntermediateRepresentation) GetApiDisplayName() *string {
	if i == nil {
		return nil
	}
	return i.ApiDisplayName
}

func (i *IntermediateRepresentation) GetApiDocs() *string {
	if i == nil {
		return nil
	}
	return i.ApiDocs
}

func (i *IntermediateRepresentation) GetAuth() *ApiAuth {
	if i == nil {
		return nil
	}
	return i.Auth
}

func (i *IntermediateRepresentation) GetHeaders() []*HttpHeader {
	if i == nil {
		return nil
	}
	return i.Headers
}

func (i *IntermediateRepresentation) GetTypes() map[TypeId]*TypeDeclaration {
	if i == nil {
		return nil
	}
	return i.Types
}

func (i *IntermediateRepresentation) GetServices() map[ServiceId]*HttpService {
	if i == nil {
		return nil
	}
	return i.Services
}

func (i *IntermediateRepresentation) GetErrors() map[ErrorId]*ErrorDeclaration {
	if i == nil {
		return nil
	}
	return i.Errors
}

func (i *IntermediateRepresentation) GetSubpackages() map[SubpackageId]*Subpackage {
	if i == nil {
		return nil
	}
	return i.Subpackages
}

func (i *IntermediateRepresentation) GetRootPackage() *Package {
	if i == nil {
		return nil
	}
	return i.RootPackage
}

func (i *IntermediateRepresentation) GetConstants() *Constants {
	if i == nil {
		return nil
	}
	return i.Constants
}

func (i *IntermediateRepresentation) GetEnvironments() *EnvironmentsConfig {
	if i == nil {
		return nil
	}
	return i.Environments
}

func (i *IntermediateRepresentation) GetBasePath() *HttpPath {
	if i == nil {
		return nil
	}
	return i.BasePath
}

func (i *IntermediateRepresentation) GetPathParameters() []*PathParameter {
	if i == nil {
		return nil
	}
	return i.PathParameters
}

func (i *IntermediateRepresentation) GetErrorDiscriminationStrategy() *ErrorDiscriminationStrategy {
	if i == nil {
		return nil
	}
	return i.ErrorDiscriminationStrategy
}

func (i *IntermediateRepresentation) GetSdkConfig() *SdkConfig {
	if i == nil {
		return nil
	}
	return i.SdkConfig
}

func (i *IntermediateRepresentation) GetVariables() []*VariableDeclaration {
	if i == nil {
		return nil
	}
	return i.Variables
}

func (i *IntermediateRepresentation) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntermediateRepresentation) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermediateRepresentation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermediateRepresentation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *IntermediateRepresentation) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Package struct {
	Docs               *string        `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *FernFilepath  `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId     `json:"service,omitempty" url:"service,omitempty"`
	Types              []TypeId       `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId      `json:"errors,omitempty" url:"errors,omitempty"`
	Subpackages        []SubpackageId `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool           `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`

	extraProperties map[string]interface{}
}

func (p *Package) GetDocs() *string {
	if p == nil {
		return nil
	}
	return p.Docs
}

func (p *Package) GetFernFilepath() *FernFilepath {
	if p == nil {
		return nil
	}
	return p.FernFilepath
}

func (p *Package) GetService() *ServiceId {
	if p == nil {
		return nil
	}
	return p.Service
}

func (p *Package) GetTypes() []TypeId {
	if p == nil {
		return nil
	}
	return p.Types
}

func (p *Package) GetErrors() []ErrorId {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *Package) GetSubpackages() []SubpackageId {
	if p == nil {
		return nil
	}
	return p.Subpackages
}

func (p *Package) GetHasEndpointsInTree() bool {
	if p == nil {
		return false
	}
	return p.HasEndpointsInTree
}

func (p *Package) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Package) UnmarshalJSON(data []byte) error {
	type unmarshaler Package
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Package(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *Package) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlatformHeaders struct {
	Language   string `json:"language" url:"language"`
	SdkName    string `json:"sdkName" url:"sdkName"`
	SdkVersion string `json:"sdkVersion" url:"sdkVersion"`

	extraProperties map[string]interface{}
}

func (p *PlatformHeaders) GetLanguage() string {
	if p == nil {
		return ""
	}
	return p.Language
}

func (p *PlatformHeaders) GetSdkName() string {
	if p == nil {
		return ""
	}
	return p.SdkName
}

func (p *PlatformHeaders) GetSdkVersion() string {
	if p == nil {
		return ""
	}
	return p.SdkVersion
}

func (p *PlatformHeaders) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlatformHeaders) UnmarshalJSON(data []byte) error {
	type unmarshaler PlatformHeaders
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlatformHeaders(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PlatformHeaders) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SdkConfig struct {
	IsAuthMandatory       bool             `json:"isAuthMandatory" url:"isAuthMandatory"`
	HasStreamingEndpoints bool             `json:"hasStreamingEndpoints" url:"hasStreamingEndpoints"`
	PlatformHeaders       *PlatformHeaders `json:"platformHeaders,omitempty" url:"platformHeaders,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkConfig) GetIsAuthMandatory() bool {
	if s == nil {
		return false
	}
	return s.IsAuthMandatory
}

func (s *SdkConfig) GetHasStreamingEndpoints() bool {
	if s == nil {
		return false
	}
	return s.HasStreamingEndpoints
}

func (s *SdkConfig) GetPlatformHeaders() *PlatformHeaders {
	if s == nil {
		return nil
	}
	return s.PlatformHeaders
}

func (s *SdkConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkConfig) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subpackage struct {
	Docs               *string        `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *FernFilepath  `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId     `json:"service,omitempty" url:"service,omitempty"`
	Types              []TypeId       `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId      `json:"errors,omitempty" url:"errors,omitempty"`
	Subpackages        []SubpackageId `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool           `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`
	Name               *Name          `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (s *Subpackage) GetDocs() *string {
	if s == nil {
		return nil
	}
	return s.Docs
}

func (s *Subpackage) GetFernFilepath() *FernFilepath {
	if s == nil {
		return nil
	}
	return s.FernFilepath
}

func (s *Subpackage) GetService() *ServiceId {
	if s == nil {
		return nil
	}
	return s.Service
}

func (s *Subpackage) GetTypes() []TypeId {
	if s == nil {
		return nil
	}
	return s.Types
}

func (s *Subpackage) GetErrors() []ErrorId {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *Subpackage) GetSubpackages() []SubpackageId {
	if s == nil {
		return nil
	}
	return s.Subpackages
}

func (s *Subpackage) GetHasEndpointsInTree() bool {
	if s == nil {
		return false
	}
	return s.HasEndpointsInTree
}

func (s *Subpackage) GetName() *Name {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *Subpackage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subpackage) UnmarshalJSON(data []byte) error {
	type unmarshaler Subpackage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Subpackage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *Subpackage) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

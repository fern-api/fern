// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

type ApiAuth struct {
	Docs        *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Requirement AuthSchemesRequirement `json:"requirement" url:"requirement"`
	Schemes     []*AuthScheme          `json:"schemes,omitempty" url:"schemes,omitempty"`

	extraProperties map[string]interface{}
}

func (a *ApiAuth) GetDocs() *string {
	if a == nil {
		return nil
	}
	return a.Docs
}

func (a *ApiAuth) GetRequirement() AuthSchemesRequirement {
	if a == nil {
		return ""
	}
	return a.Requirement
}

func (a *ApiAuth) GetSchemes() []*AuthScheme {
	if a == nil {
		return nil
	}
	return a.Schemes
}

func (a *ApiAuth) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *ApiAuth) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthScheme struct {
	Type   string
	Bearer *BearerAuthScheme
	Basic  *BasicAuthScheme
	Header *HeaderAuthScheme
}

func NewAuthSchemeFromBearer(value *BearerAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "bearer", Bearer: value}
}

func NewAuthSchemeFromBasic(value *BasicAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "basic", Basic: value}
}

func NewAuthSchemeFromHeader(value *HeaderAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "header", Header: value}
}

func (a *AuthScheme) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AuthScheme) GetBearer() *BearerAuthScheme {
	if a == nil {
		return nil
	}
	return a.Bearer
}

func (a *AuthScheme) GetBasic() *BasicAuthScheme {
	if a == nil {
		return nil
	}
	return a.Basic
}

func (a *AuthScheme) GetHeader() *HeaderAuthScheme {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *AuthScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", a)
	}
	switch unmarshaler.Type {
	case "bearer":
		value := new(BearerAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "basic":
		value := new(BasicAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "header":
		value := new(HeaderAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a AuthScheme) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return internal.MarshalJSONWithExtraProperty(a.Bearer, "_type", "bearer")
	case "basic":
		return internal.MarshalJSONWithExtraProperty(a.Basic, "_type", "basic")
	case "header":
		return internal.MarshalJSONWithExtraProperty(a.Header, "_type", "header")
	}
}

type AuthSchemeVisitor interface {
	VisitBearer(*BearerAuthScheme) error
	VisitBasic(*BasicAuthScheme) error
	VisitHeader(*HeaderAuthScheme) error
}

func (a *AuthScheme) Accept(visitor AuthSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

func (a *AuthScheme) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Bearer != nil {
		fields = append(fields, "bearer")
	}
	if a.Basic != nil {
		fields = append(fields, "basic")
	}
	if a.Header != nil {
		fields = append(fields, "header")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AuthSchemesRequirement string

const (
	AuthSchemesRequirementAll AuthSchemesRequirement = "ALL"
	AuthSchemesRequirementAny AuthSchemesRequirement = "ANY"
)

func NewAuthSchemesRequirementFromString(s string) (AuthSchemesRequirement, error) {
	switch s {
	case "ALL":
		return AuthSchemesRequirementAll, nil
	case "ANY":
		return AuthSchemesRequirementAny, nil
	}
	var t AuthSchemesRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthSchemesRequirement) Ptr() *AuthSchemesRequirement {
	return &a
}

type BasicAuthScheme struct {
	Docs     *string `json:"docs,omitempty" url:"docs,omitempty"`
	Username *Name   `json:"username,omitempty" url:"username,omitempty"`
	Password *Name   `json:"password,omitempty" url:"password,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BasicAuthScheme) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BasicAuthScheme) GetUsername() *Name {
	if b == nil {
		return nil
	}
	return b.Username
}

func (b *BasicAuthScheme) GetPassword() *Name {
	if b == nil {
		return nil
	}
	return b.Password
}

func (b *BasicAuthScheme) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BasicAuthScheme) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthScheme struct {
	Docs  *string `json:"docs,omitempty" url:"docs,omitempty"`
	Token *Name   `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BearerAuthScheme) GetDocs() *string {
	if b == nil {
		return nil
	}
	return b.Docs
}

func (b *BearerAuthScheme) GetToken() *Name {
	if b == nil {
		return nil
	}
	return b.Token
}

func (b *BearerAuthScheme) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *BearerAuthScheme) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type HeaderAuthScheme struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	Prefix    *string           `json:"prefix,omitempty" url:"prefix,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuthScheme) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HeaderAuthScheme) GetName() *NameAndWireValue {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HeaderAuthScheme) GetValueType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.ValueType
}

func (h *HeaderAuthScheme) GetPrefix() *string {
	if h == nil {
		return nil
	}
	return h.Prefix
}

func (h *HeaderAuthScheme) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuthScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuthScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuthScheme(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HeaderAuthScheme) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

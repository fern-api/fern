// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

type Availability struct {
	Status  AvailabilityStatus `json:"status" url:"status"`
	Message *string            `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
}

func (a *Availability) GetStatus() AvailabilityStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *Availability) GetMessage() *string {
	if a == nil {
		return nil
	}
	return a.Message
}

func (a *Availability) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Availability) UnmarshalJSON(data []byte) error {
	type unmarshaler Availability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Availability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	return nil
}

func (a *Availability) String() string {
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

type Declaration struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetDocs() *string {
	if d == nil {
		return nil
	}
	return d.Docs
}

func (d *Declaration) GetAvailability() *Availability {
	if d == nil {
		return nil
	}
	return d.Availability
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *Declaration) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ErrorId = string

type FernFilepath struct {
	AllParts    []*Name `json:"allParts,omitempty" url:"allParts,omitempty"`
	PackagePath []*Name `json:"packagePath,omitempty" url:"packagePath,omitempty"`
	File        *Name   `json:"file,omitempty" url:"file,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FernFilepath) GetAllParts() []*Name {
	if f == nil {
		return nil
	}
	return f.AllParts
}

func (f *FernFilepath) GetPackagePath() []*Name {
	if f == nil {
		return nil
	}
	return f.PackagePath
}

func (f *FernFilepath) GetFile() *Name {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FernFilepath) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FernFilepath) UnmarshalJSON(data []byte) error {
	type unmarshaler FernFilepath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FernFilepath(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FernFilepath) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Name struct {
	OriginalName       string               `json:"originalName" url:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase,omitempty" url:"camelCase,omitempty"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase,omitempty" url:"pascalCase,omitempty"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase,omitempty" url:"snakeCase,omitempty"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase,omitempty" url:"screamingSnakeCase,omitempty"`

	extraProperties map[string]interface{}
}

func (n *Name) GetOriginalName() string {
	if n == nil {
		return ""
	}
	return n.OriginalName
}

func (n *Name) GetCamelCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.CamelCase
}

func (n *Name) GetPascalCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.PascalCase
}

func (n *Name) GetSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.SnakeCase
}

func (n *Name) GetScreamingSnakeCase() *SafeAndUnsafeString {
	if n == nil {
		return nil
	}
	return n.ScreamingSnakeCase
}

func (n *Name) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Name) UnmarshalJSON(data []byte) error {
	type unmarshaler Name
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Name(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *Name) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NameAndWireValue struct {
	WireValue string `json:"wireValue" url:"wireValue"`
	Name      *Name  `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NameAndWireValue) GetWireValue() string {
	if n == nil {
		return ""
	}
	return n.WireValue
}

func (n *NameAndWireValue) GetName() *Name {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NameAndWireValue) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NameAndWireValue) UnmarshalJSON(data []byte) error {
	type unmarshaler NameAndWireValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NameAndWireValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NameAndWireValue) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName" url:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName" url:"safeName"`

	extraProperties map[string]interface{}
}

func (s *SafeAndUnsafeString) GetUnsafeName() string {
	if s == nil {
		return ""
	}
	return s.UnsafeName
}

func (s *SafeAndUnsafeString) GetSafeName() string {
	if s == nil {
		return ""
	}
	return s.SafeName
}

func (s *SafeAndUnsafeString) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SafeAndUnsafeString) UnmarshalJSON(data []byte) error {
	type unmarshaler SafeAndUnsafeString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SafeAndUnsafeString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SafeAndUnsafeString) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceId = string

type SubpackageId = string

type TypeId = string

type WithDocs struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WithDocs) GetDocs() *string {
	if w == nil {
		return nil
	}
	return w.Docs
}

func (w *WithDocs) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithDocs) UnmarshalJSON(data []byte) error {
	type unmarshaler WithDocs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithDocs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithDocs) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WithJsonExample struct {
	JsonExample interface{} `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`

	extraProperties map[string]interface{}
}

func (w *WithJsonExample) GetJsonExample() interface{} {
	if w == nil {
		return nil
	}
	return w.JsonExample
}

func (w *WithJsonExample) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WithJsonExample) UnmarshalJSON(data []byte) error {
	type unmarshaler WithJsonExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WithJsonExample(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	return nil
}

func (w *WithJsonExample) String() string {
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

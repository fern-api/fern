// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

type DeclaredServiceName struct {
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DeclaredServiceName) GetFernFilepath() *FernFilepath {
	if d == nil {
		return nil
	}
	return d.FernFilepath
}

func (d *DeclaredServiceName) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeclaredServiceName) UnmarshalJSON(data []byte) error {
	type unmarshaler DeclaredServiceName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeclaredServiceName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	return nil
}

func (d *DeclaredServiceName) String() string {
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointName = *Name

type ExampleEndpointCall struct {
	Docs                   *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Name                   *Name                    `json:"name,omitempty" url:"name,omitempty"`
	Url                    string                   `json:"url" url:"url"`
	RootPathParameters     []*ExamplePathParameter  `json:"rootPathParameters,omitempty" url:"rootPathParameters,omitempty"`
	ServicePathParameters  []*ExamplePathParameter  `json:"servicePathParameters,omitempty" url:"servicePathParameters,omitempty"`
	EndpointPathParameters []*ExamplePathParameter  `json:"endpointPathParameters,omitempty" url:"endpointPathParameters,omitempty"`
	ServiceHeaders         []*ExampleHeader         `json:"serviceHeaders,omitempty" url:"serviceHeaders,omitempty"`
	EndpointHeaders        []*ExampleHeader         `json:"endpointHeaders,omitempty" url:"endpointHeaders,omitempty"`
	QueryParameters        []*ExampleQueryParameter `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Request                *ExampleRequestBody      `json:"request,omitempty" url:"request,omitempty"`
	Response               *ExampleResponse         `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEndpointCall) GetDocs() *string {
	if e == nil {
		return nil
	}
	return e.Docs
}

func (e *ExampleEndpointCall) GetName() *Name {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ExampleEndpointCall) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *ExampleEndpointCall) GetRootPathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.RootPathParameters
}

func (e *ExampleEndpointCall) GetServicePathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.ServicePathParameters
}

func (e *ExampleEndpointCall) GetEndpointPathParameters() []*ExamplePathParameter {
	if e == nil {
		return nil
	}
	return e.EndpointPathParameters
}

func (e *ExampleEndpointCall) GetServiceHeaders() []*ExampleHeader {
	if e == nil {
		return nil
	}
	return e.ServiceHeaders
}

func (e *ExampleEndpointCall) GetEndpointHeaders() []*ExampleHeader {
	if e == nil {
		return nil
	}
	return e.EndpointHeaders
}

func (e *ExampleEndpointCall) GetQueryParameters() []*ExampleQueryParameter {
	if e == nil {
		return nil
	}
	return e.QueryParameters
}

func (e *ExampleEndpointCall) GetRequest() *ExampleRequestBody {
	if e == nil {
		return nil
	}
	return e.Request
}

func (e *ExampleEndpointCall) GetResponse() *ExampleResponse {
	if e == nil {
		return nil
	}
	return e.Response
}

func (e *ExampleEndpointCall) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEndpointCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEndpointCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEndpointCall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEndpointCall) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointErrorResponse struct {
	Error *DeclaredErrorName    `json:"error,omitempty" url:"error,omitempty"`
	Body  *ExampleTypeReference `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEndpointErrorResponse) GetError() *DeclaredErrorName {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExampleEndpointErrorResponse) GetBody() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Body
}

func (e *ExampleEndpointErrorResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEndpointErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEndpointErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEndpointErrorResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEndpointErrorResponse) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointSuccessResponse struct {
	Body *ExampleTypeReference `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleEndpointSuccessResponse) GetBody() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Body
}

func (e *ExampleEndpointSuccessResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleEndpointSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleEndpointSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleEndpointSuccessResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleEndpointSuccessResponse) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleHeader struct {
	WireKey string                `json:"wireKey" url:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleHeader) GetWireKey() string {
	if e == nil {
		return ""
	}
	return e.WireKey
}

func (e *ExampleHeader) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleHeader) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleHeader(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleHeader) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBody struct {
	JsonExample interface{}                          `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Properties  []*ExampleInlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleInlinedRequestBody) GetJsonExample() interface{} {
	if e == nil {
		return nil
	}
	return e.JsonExample
}

func (e *ExampleInlinedRequestBody) GetProperties() []*ExampleInlinedRequestBodyProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *ExampleInlinedRequestBody) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleInlinedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleInlinedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleInlinedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleInlinedRequestBody) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBodyProperty struct {
	WireKey string                `json:"wireKey" url:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// this property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleInlinedRequestBodyProperty) GetWireKey() string {
	if e == nil {
		return ""
	}
	return e.WireKey
}

func (e *ExampleInlinedRequestBodyProperty) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleInlinedRequestBodyProperty) GetOriginalTypeDeclaration() *DeclaredTypeName {
	if e == nil {
		return nil
	}
	return e.OriginalTypeDeclaration
}

func (e *ExampleInlinedRequestBodyProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleInlinedRequestBodyProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleInlinedRequestBodyProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleInlinedRequestBodyProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleInlinedRequestBodyProperty) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePathParameter struct {
	Key   string                `json:"key" url:"key"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExamplePathParameter) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *ExamplePathParameter) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExamplePathParameter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExamplePathParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ExamplePathParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExamplePathParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExamplePathParameter) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleQueryParameter struct {
	WireKey string                `json:"wireKey" url:"wireKey"`
	Value   *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (e *ExampleQueryParameter) GetWireKey() string {
	if e == nil {
		return ""
	}
	return e.WireKey
}

func (e *ExampleQueryParameter) GetValue() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExampleQueryParameter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExampleQueryParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ExampleQueryParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExampleQueryParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	return nil
}

func (e *ExampleQueryParameter) String() string {
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleRequestBody struct {
	Type               string
	InlinedRequestBody *ExampleInlinedRequestBody
	Reference          *ExampleTypeReference
}

func NewExampleRequestBodyFromInlinedRequestBody(value *ExampleInlinedRequestBody) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewExampleRequestBodyFromReference(value *ExampleTypeReference) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "reference", Reference: value}
}

func (e *ExampleRequestBody) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleRequestBody) GetInlinedRequestBody() *ExampleInlinedRequestBody {
	if e == nil {
		return nil
	}
	return e.InlinedRequestBody
}

func (e *ExampleRequestBody) GetReference() *ExampleTypeReference {
	if e == nil {
		return nil
	}
	return e.Reference
}

func (e *ExampleRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedRequestBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleRequestBody) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return internal.MarshalJSONWithExtraProperty(e.InlinedRequestBody, "type", "inlinedRequestBody")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(e.Reference, "type", "reference")
	}
}

type ExampleRequestBodyVisitor interface {
	VisitInlinedRequestBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleRequestBody) Accept(visitor ExampleRequestBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(e.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

func (e *ExampleRequestBody) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.InlinedRequestBody != nil {
		fields = append(fields, "inlinedRequestBody")
	}
	if e.Reference != nil {
		fields = append(fields, "reference")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type ExampleResponse struct {
	Type  string
	Ok    *ExampleEndpointSuccessResponse
	Error *ExampleEndpointErrorResponse
}

func NewExampleResponseFromOk(value *ExampleEndpointSuccessResponse) *ExampleResponse {
	return &ExampleResponse{Type: "ok", Ok: value}
}

func NewExampleResponseFromError(value *ExampleEndpointErrorResponse) *ExampleResponse {
	return &ExampleResponse{Type: "error", Error: value}
}

func (e *ExampleResponse) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExampleResponse) GetOk() *ExampleEndpointSuccessResponse {
	if e == nil {
		return nil
	}
	return e.Ok
}

func (e *ExampleResponse) GetError() *ExampleEndpointErrorResponse {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExampleResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "ok":
		value := new(ExampleEndpointSuccessResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Ok = value
	case "error":
		value := new(ExampleEndpointErrorResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExampleResponse) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return internal.MarshalJSONWithExtraProperty(e.Ok, "type", "ok")
	case "error":
		return internal.MarshalJSONWithExtraProperty(e.Error, "type", "error")
	}
}

type ExampleResponseVisitor interface {
	VisitOk(*ExampleEndpointSuccessResponse) error
	VisitError(*ExampleEndpointErrorResponse) error
}

func (e *ExampleResponse) Accept(visitor ExampleResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return visitor.VisitOk(e.Ok)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

func (e *ExampleResponse) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Ok != nil {
		fields = append(fields, "ok")
	}
	if e.Error != nil {
		fields = append(fields, "error")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type FileDownloadResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileDownloadResponse) GetDocs() *string {
	if f == nil {
		return nil
	}
	return f.Docs
}

func (f *FileDownloadResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileDownloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileDownloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileDownloadResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileDownloadResponse) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileProperty struct {
	Key        *NameAndWireValue `json:"key,omitempty" url:"key,omitempty"`
	IsOptional bool              `json:"isOptional" url:"isOptional"`

	extraProperties map[string]interface{}
}

func (f *FileProperty) GetKey() *NameAndWireValue {
	if f == nil {
		return nil
	}
	return f.Key
}

func (f *FileProperty) GetIsOptional() bool {
	if f == nil {
		return false
	}
	return f.IsOptional
}

func (f *FileProperty) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler FileProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileProperty) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequest struct {
	Name       *Name                        `json:"name,omitempty" url:"name,omitempty"`
	Properties []*FileUploadRequestProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileUploadRequest) GetName() *Name {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FileUploadRequest) GetProperties() []*FileUploadRequestProperty {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FileUploadRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *FileUploadRequest) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestProperty struct {
	Type         string
	File         *FileProperty
	BodyProperty *InlinedRequestBodyProperty
}

func NewFileUploadRequestPropertyFromFile(value *FileProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "file", File: value}
}

func NewFileUploadRequestPropertyFromBodyProperty(value *InlinedRequestBodyProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestProperty) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FileUploadRequestProperty) GetFile() *FileProperty {
	if f == nil {
		return nil
	}
	return f.File
}

func (f *FileUploadRequestProperty) GetBodyProperty() *InlinedRequestBodyProperty {
	if f == nil {
		return nil
	}
	return f.BodyProperty
}

func (f *FileUploadRequestProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		value := new(FileProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "bodyProperty":
		value := new(InlinedRequestBodyProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestProperty) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return internal.MarshalJSONWithExtraProperty(f.File, "type", "file")
	case "bodyProperty":
		return internal.MarshalJSONWithExtraProperty(f.BodyProperty, "type", "bodyProperty")
	}
}

type FileUploadRequestPropertyVisitor interface {
	VisitFile(*FileProperty) error
	VisitBodyProperty(*InlinedRequestBodyProperty) error
}

func (f *FileUploadRequestProperty) Accept(visitor FileUploadRequestPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

func (f *FileUploadRequestProperty) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.File != nil {
		fields = append(fields, "file")
	}
	if f.BodyProperty != nil {
		fields = append(fields, "bodyProperty")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

type HttpEndpoint struct {
	Docs              *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Availability      *Availability          `json:"availability,omitempty" url:"availability,omitempty"`
	Name              EndpointName           `json:"name,omitempty" url:"name,omitempty"`
	DisplayName       *string                `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method            HttpMethod             `json:"method" url:"method"`
	Headers           []*HttpHeader          `json:"headers,omitempty" url:"headers,omitempty"`
	BaseUrl           *EnvironmentBaseUrlId  `json:"baseUrl,omitempty" url:"baseUrl,omitempty"`
	Path              *HttpPath              `json:"path,omitempty" url:"path,omitempty"`
	FullPath          *HttpPath              `json:"fullPath,omitempty" url:"fullPath,omitempty"`
	PathParameters    []*PathParameter       `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	AllPathParameters []*PathParameter       `json:"allPathParameters,omitempty" url:"allPathParameters,omitempty"`
	QueryParameters   []*QueryParameter      `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	RequestBody       *HttpRequestBody       `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	SdkRequest        *SdkRequest            `json:"sdkRequest,omitempty" url:"sdkRequest,omitempty"`
	Response          *HttpResponse          `json:"response,omitempty" url:"response,omitempty"`
	StreamingResponse *StreamingResponse     `json:"streamingResponse,omitempty" url:"streamingResponse,omitempty"`
	SdkResponse       *SdkResponse           `json:"sdkResponse,omitempty" url:"sdkResponse,omitempty"`
	Errors            ResponseErrors         `json:"errors,omitempty" url:"errors,omitempty"`
	Auth              bool                   `json:"auth" url:"auth"`
	Examples          []*ExampleEndpointCall `json:"examples,omitempty" url:"examples,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpEndpoint) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpEndpoint) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpEndpoint) GetName() EndpointName {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpEndpoint) GetDisplayName() *string {
	if h == nil {
		return nil
	}
	return h.DisplayName
}

func (h *HttpEndpoint) GetMethod() HttpMethod {
	if h == nil {
		return ""
	}
	return h.Method
}

func (h *HttpEndpoint) GetHeaders() []*HttpHeader {
	if h == nil {
		return nil
	}
	return h.Headers
}

func (h *HttpEndpoint) GetBaseUrl() *EnvironmentBaseUrlId {
	if h == nil {
		return nil
	}
	return h.BaseUrl
}

func (h *HttpEndpoint) GetPath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.Path
}

func (h *HttpEndpoint) GetFullPath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.FullPath
}

func (h *HttpEndpoint) GetPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.PathParameters
}

func (h *HttpEndpoint) GetAllPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.AllPathParameters
}

func (h *HttpEndpoint) GetQueryParameters() []*QueryParameter {
	if h == nil {
		return nil
	}
	return h.QueryParameters
}

func (h *HttpEndpoint) GetRequestBody() *HttpRequestBody {
	if h == nil {
		return nil
	}
	return h.RequestBody
}

func (h *HttpEndpoint) GetSdkRequest() *SdkRequest {
	if h == nil {
		return nil
	}
	return h.SdkRequest
}

func (h *HttpEndpoint) GetResponse() *HttpResponse {
	if h == nil {
		return nil
	}
	return h.Response
}

func (h *HttpEndpoint) GetStreamingResponse() *StreamingResponse {
	if h == nil {
		return nil
	}
	return h.StreamingResponse
}

func (h *HttpEndpoint) GetSdkResponse() *SdkResponse {
	if h == nil {
		return nil
	}
	return h.SdkResponse
}

func (h *HttpEndpoint) GetErrors() ResponseErrors {
	if h == nil {
		return nil
	}
	return h.Errors
}

func (h *HttpEndpoint) GetAuth() bool {
	if h == nil {
		return false
	}
	return h.Auth
}

func (h *HttpEndpoint) GetExamples() []*ExampleEndpointCall {
	if h == nil {
		return nil
	}
	return h.Examples
}

func (h *HttpEndpoint) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpEndpoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpEndpoint) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpHeader struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpHeader) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpHeader) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpHeader) GetName() *NameAndWireValue {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpHeader) GetValueType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.ValueType
}

func (h *HttpHeader) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpHeader(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpHeader) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type HttpPath struct {
	Head  string          `json:"head" url:"head"`
	Parts []*HttpPathPart `json:"parts,omitempty" url:"parts,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpPath) GetHead() string {
	if h == nil {
		return ""
	}
	return h.Head
}

func (h *HttpPath) GetParts() []*HttpPathPart {
	if h == nil {
		return nil
	}
	return h.Parts
}

func (h *HttpPath) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpPath) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpPath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpPath(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpPath) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpPathPart struct {
	PathParameter string `json:"pathParameter" url:"pathParameter"`
	Tail          string `json:"tail" url:"tail"`

	extraProperties map[string]interface{}
}

func (h *HttpPathPart) GetPathParameter() string {
	if h == nil {
		return ""
	}
	return h.PathParameter
}

func (h *HttpPathPart) GetTail() string {
	if h == nil {
		return ""
	}
	return h.Tail
}

func (h *HttpPathPart) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpPathPart) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpPathPart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpPathPart(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpPathPart) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpRequestBody struct {
	Type               string
	InlinedRequestBody *InlinedRequestBody
	Reference          *HttpRequestBodyReference
	FileUpload         *FileUploadRequest
}

func NewHttpRequestBodyFromInlinedRequestBody(value *InlinedRequestBody) *HttpRequestBody {
	return &HttpRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewHttpRequestBodyFromReference(value *HttpRequestBodyReference) *HttpRequestBody {
	return &HttpRequestBody{Type: "reference", Reference: value}
}

func NewHttpRequestBodyFromFileUpload(value *FileUploadRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "fileUpload", FileUpload: value}
}

func (h *HttpRequestBody) GetType() string {
	if h == nil {
		return ""
	}
	return h.Type
}

func (h *HttpRequestBody) GetInlinedRequestBody() *InlinedRequestBody {
	if h == nil {
		return nil
	}
	return h.InlinedRequestBody
}

func (h *HttpRequestBody) GetReference() *HttpRequestBodyReference {
	if h == nil {
		return nil
	}
	return h.Reference
}

func (h *HttpRequestBody) GetFileUpload() *FileUploadRequest {
	if h == nil {
		return nil
	}
	return h.FileUpload
}

func (h *HttpRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", h)
	}
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(InlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.InlinedRequestBody = value
	case "reference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Reference = value
	case "fileUpload":
		value := new(FileUploadRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileUpload = value
	}
	return nil
}

func (h HttpRequestBody) MarshalJSON() ([]byte, error) {
	if err := h.validate(); err != nil {
		return nil, err
	}
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return internal.MarshalJSONWithExtraProperty(h.InlinedRequestBody, "type", "inlinedRequestBody")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(h.Reference, "type", "reference")
	case "fileUpload":
		return internal.MarshalJSONWithExtraProperty(h.FileUpload, "type", "fileUpload")
	}
}

type HttpRequestBodyVisitor interface {
	VisitInlinedRequestBody(*InlinedRequestBody) error
	VisitReference(*HttpRequestBodyReference) error
	VisitFileUpload(*FileUploadRequest) error
}

func (h *HttpRequestBody) Accept(visitor HttpRequestBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(h.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(h.Reference)
	case "fileUpload":
		return visitor.VisitFileUpload(h.FileUpload)
	}
}

func (h *HttpRequestBody) validate() error {
	if h == nil {
		return fmt.Errorf("type %T is nil", h)
	}
	var fields []string
	if h.InlinedRequestBody != nil {
		fields = append(fields, "inlinedRequestBody")
	}
	if h.Reference != nil {
		fields = append(fields, "reference")
	}
	if h.FileUpload != nil {
		fields = append(fields, "fileUpload")
	}
	if len(fields) == 0 {
		if h.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", h, h.Type)
		}
		return fmt.Errorf("type %T is empty", h)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", h, fields)
	}
	if h.Type != "" {
		field := fields[0]
		if h.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				h,
				h.Type,
				h,
			)
		}
	}
	return nil
}

type HttpRequestBodyReference struct {
	Docs            *string        `json:"docs,omitempty" url:"docs,omitempty"`
	RequestBodyType *TypeReference `json:"requestBodyType,omitempty" url:"requestBodyType,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpRequestBodyReference) GetDocs() *string {
	if h == nil {
		return nil
	}
	return h.Docs
}

func (h *HttpRequestBodyReference) GetRequestBodyType() *TypeReference {
	if h == nil {
		return nil
	}
	return h.RequestBodyType
}

func (h *HttpRequestBodyReference) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpRequestBodyReference) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpRequestBodyReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpRequestBodyReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpRequestBodyReference) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpResponse struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
}

func NewHttpResponseFromJson(value *JsonResponse) *HttpResponse {
	return &HttpResponse{Type: "json", Json: value}
}

func NewHttpResponseFromFileDownload(value *FileDownloadResponse) *HttpResponse {
	return &HttpResponse{Type: "fileDownload", FileDownload: value}
}

func (h *HttpResponse) GetType() string {
	if h == nil {
		return ""
	}
	return h.Type
}

func (h *HttpResponse) GetJson() *JsonResponse {
	if h == nil {
		return nil
	}
	return h.Json
}

func (h *HttpResponse) GetFileDownload() *FileDownloadResponse {
	if h == nil {
		return nil
	}
	return h.FileDownload
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", h)
	}
	switch unmarshaler.Type {
	case "json":
		value := new(JsonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Json = value
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	}
	return nil
}

func (h HttpResponse) MarshalJSON() ([]byte, error) {
	if err := h.validate(); err != nil {
		return nil, err
	}
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return internal.MarshalJSONWithExtraProperty(h.Json, "type", "json")
	case "fileDownload":
		return internal.MarshalJSONWithExtraProperty(h.FileDownload, "type", "fileDownload")
	}
}

type HttpResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
}

func (h *HttpResponse) Accept(visitor HttpResponseVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return visitor.VisitJson(h.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(h.FileDownload)
	}
}

func (h *HttpResponse) validate() error {
	if h == nil {
		return fmt.Errorf("type %T is nil", h)
	}
	var fields []string
	if h.Json != nil {
		fields = append(fields, "json")
	}
	if h.FileDownload != nil {
		fields = append(fields, "fileDownload")
	}
	if len(fields) == 0 {
		if h.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", h, h.Type)
		}
		return fmt.Errorf("type %T is empty", h)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", h, fields)
	}
	if h.Type != "" {
		field := fields[0]
		if h.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				h,
				h.Type,
				h,
			)
		}
	}
	return nil
}

type HttpService struct {
	Availability   *Availability        `json:"availability,omitempty" url:"availability,omitempty"`
	Name           *DeclaredServiceName `json:"name,omitempty" url:"name,omitempty"`
	DisplayName    *string              `json:"displayName,omitempty" url:"displayName,omitempty"`
	BasePath       *HttpPath            `json:"basePath,omitempty" url:"basePath,omitempty"`
	Endpoints      []*HttpEndpoint      `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	Headers        []*HttpHeader        `json:"headers,omitempty" url:"headers,omitempty"`
	PathParameters []*PathParameter     `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HttpService) GetAvailability() *Availability {
	if h == nil {
		return nil
	}
	return h.Availability
}

func (h *HttpService) GetName() *DeclaredServiceName {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HttpService) GetDisplayName() *string {
	if h == nil {
		return nil
	}
	return h.DisplayName
}

func (h *HttpService) GetBasePath() *HttpPath {
	if h == nil {
		return nil
	}
	return h.BasePath
}

func (h *HttpService) GetEndpoints() []*HttpEndpoint {
	if h == nil {
		return nil
	}
	return h.Endpoints
}

func (h *HttpService) GetHeaders() []*HttpHeader {
	if h == nil {
		return nil
	}
	return h.Headers
}

func (h *HttpService) GetPathParameters() []*PathParameter {
	if h == nil {
		return nil
	}
	return h.PathParameters
}

func (h *HttpService) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpService) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpService
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpService(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	return nil
}

func (h *HttpService) String() string {
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InlinedRequestBody struct {
	Name       *Name                         `json:"name,omitempty" url:"name,omitempty"`
	Extends    []*DeclaredTypeName           `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*InlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestBody) GetName() *Name {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedRequestBody) GetExtends() []*DeclaredTypeName {
	if i == nil {
		return nil
	}
	return i.Extends
}

func (i *InlinedRequestBody) GetProperties() []*InlinedRequestBodyProperty {
	if i == nil {
		return nil
	}
	return i.Properties
}

func (i *InlinedRequestBody) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestBody) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBodyProperty struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequestBodyProperty) GetDocs() *string {
	if i == nil {
		return nil
	}
	return i.Docs
}

func (i *InlinedRequestBodyProperty) GetName() *NameAndWireValue {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InlinedRequestBodyProperty) GetValueType() *TypeReference {
	if i == nil {
		return nil
	}
	return i.ValueType
}

func (i *InlinedRequestBodyProperty) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequestBodyProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequestBodyProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequestBodyProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlinedRequestBodyProperty) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonResponse struct {
	Docs             *string        `json:"docs,omitempty" url:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty" url:"responseBodyType,omitempty"`

	extraProperties map[string]interface{}
}

func (j *JsonResponse) GetDocs() *string {
	if j == nil {
		return nil
	}
	return j.Docs
}

func (j *JsonResponse) GetResponseBodyType() *TypeReference {
	if j == nil {
		return nil
	}
	return j.ResponseBodyType
}

func (j *JsonResponse) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	return nil
}

func (j *JsonResponse) String() string {
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type MaybeStreamingResponse struct {
	Condition    *StreamCondition   `json:"condition,omitempty" url:"condition,omitempty"`
	NonStreaming *HttpResponse      `json:"nonStreaming,omitempty" url:"nonStreaming,omitempty"`
	Streaming    *StreamingResponse `json:"streaming,omitempty" url:"streaming,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MaybeStreamingResponse) GetCondition() *StreamCondition {
	if m == nil {
		return nil
	}
	return m.Condition
}

func (m *MaybeStreamingResponse) GetNonStreaming() *HttpResponse {
	if m == nil {
		return nil
	}
	return m.NonStreaming
}

func (m *MaybeStreamingResponse) GetStreaming() *StreamingResponse {
	if m == nil {
		return nil
	}
	return m.Streaming
}

func (m *MaybeStreamingResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MaybeStreamingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MaybeStreamingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MaybeStreamingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	return nil
}

func (m *MaybeStreamingResponse) String() string {
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PathParameter struct {
	Docs      *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *Name                 `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`
	Location  PathParameterLocation `json:"location" url:"location"`
	Variable  *VariableId           `json:"variable,omitempty" url:"variable,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PathParameter) GetDocs() *string {
	if p == nil {
		return nil
	}
	return p.Docs
}

func (p *PathParameter) GetName() *Name {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PathParameter) GetValueType() *TypeReference {
	if p == nil {
		return nil
	}
	return p.ValueType
}

func (p *PathParameter) GetLocation() PathParameterLocation {
	if p == nil {
		return ""
	}
	return p.Location
}

func (p *PathParameter) GetVariable() *VariableId {
	if p == nil {
		return nil
	}
	return p.Variable
}

func (p *PathParameter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PathParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler PathParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PathParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	return nil
}

func (p *PathParameter) String() string {
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PathParameterLocation string

const (
	PathParameterLocationRoot     PathParameterLocation = "ROOT"
	PathParameterLocationService  PathParameterLocation = "SERVICE"
	PathParameterLocationEndpoint PathParameterLocation = "ENDPOINT"
)

func NewPathParameterLocationFromString(s string) (PathParameterLocation, error) {
	switch s {
	case "ROOT":
		return PathParameterLocationRoot, nil
	case "SERVICE":
		return PathParameterLocationService, nil
	case "ENDPOINT":
		return PathParameterLocationEndpoint, nil
	}
	var t PathParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PathParameterLocation) Ptr() *PathParameterLocation {
	return &p
}

type QueryParameter struct {
	Docs          *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability  *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name          *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType     *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	AllowMultiple bool              `json:"allowMultiple" url:"allowMultiple"`

	extraProperties map[string]interface{}
}

func (q *QueryParameter) GetDocs() *string {
	if q == nil {
		return nil
	}
	return q.Docs
}

func (q *QueryParameter) GetAvailability() *Availability {
	if q == nil {
		return nil
	}
	return q.Availability
}

func (q *QueryParameter) GetName() *NameAndWireValue {
	if q == nil {
		return nil
	}
	return q.Name
}

func (q *QueryParameter) GetValueType() *TypeReference {
	if q == nil {
		return nil
	}
	return q.ValueType
}

func (q *QueryParameter) GetAllowMultiple() bool {
	if q == nil {
		return false
	}
	return q.AllowMultiple
}

func (q *QueryParameter) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	return nil
}

func (q *QueryParameter) String() string {
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type ResponseError struct {
	Docs  *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Error *DeclaredErrorName `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
}

func (r *ResponseError) GetDocs() *string {
	if r == nil {
		return nil
	}
	return r.Docs
}

func (r *ResponseError) GetError() *DeclaredErrorName {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *ResponseError) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseError) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *ResponseError) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseErrors = []*ResponseError

type SdkRequest struct {
	RequestParameterName *Name            `json:"requestParameterName,omitempty" url:"requestParameterName,omitempty"`
	Shape                *SdkRequestShape `json:"shape,omitempty" url:"shape,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkRequest) GetRequestParameterName() *Name {
	if s == nil {
		return nil
	}
	return s.RequestParameterName
}

func (s *SdkRequest) GetShape() *SdkRequestShape {
	if s == nil {
		return nil
	}
	return s.Shape
}

func (s *SdkRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkRequest) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SdkRequestShape struct {
	Type            string
	JustRequestBody *HttpRequestBodyReference
	Wrapper         *SdkRequestWrapper
}

func NewSdkRequestShapeFromJustRequestBody(value *HttpRequestBodyReference) *SdkRequestShape {
	return &SdkRequestShape{Type: "justRequestBody", JustRequestBody: value}
}

func NewSdkRequestShapeFromWrapper(value *SdkRequestWrapper) *SdkRequestShape {
	return &SdkRequestShape{Type: "wrapper", Wrapper: value}
}

func (s *SdkRequestShape) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SdkRequestShape) GetJustRequestBody() *HttpRequestBodyReference {
	if s == nil {
		return nil
	}
	return s.JustRequestBody
}

func (s *SdkRequestShape) GetWrapper() *SdkRequestWrapper {
	if s == nil {
		return nil
	}
	return s.Wrapper
}

func (s *SdkRequestShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "justRequestBody":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.JustRequestBody = value
	case "wrapper":
		value := new(SdkRequestWrapper)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Wrapper = value
	}
	return nil
}

func (s SdkRequestShape) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return internal.MarshalJSONWithExtraProperty(s.JustRequestBody, "type", "justRequestBody")
	case "wrapper":
		return internal.MarshalJSONWithExtraProperty(s.Wrapper, "type", "wrapper")
	}
}

type SdkRequestShapeVisitor interface {
	VisitJustRequestBody(*HttpRequestBodyReference) error
	VisitWrapper(*SdkRequestWrapper) error
}

func (s *SdkRequestShape) Accept(visitor SdkRequestShapeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return visitor.VisitJustRequestBody(s.JustRequestBody)
	case "wrapper":
		return visitor.VisitWrapper(s.Wrapper)
	}
}

func (s *SdkRequestShape) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.JustRequestBody != nil {
		fields = append(fields, "justRequestBody")
	}
	if s.Wrapper != nil {
		fields = append(fields, "wrapper")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SdkRequestWrapper struct {
	WrapperName *Name `json:"wrapperName,omitempty" url:"wrapperName,omitempty"`
	BodyKey     *Name `json:"bodyKey,omitempty" url:"bodyKey,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SdkRequestWrapper) GetWrapperName() *Name {
	if s == nil {
		return nil
	}
	return s.WrapperName
}

func (s *SdkRequestWrapper) GetBodyKey() *Name {
	if s == nil {
		return nil
	}
	return s.BodyKey
}

func (s *SdkRequestWrapper) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SdkRequestWrapper) UnmarshalJSON(data []byte) error {
	type unmarshaler SdkRequestWrapper
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SdkRequestWrapper(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *SdkRequestWrapper) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SdkResponse struct {
	Type           string
	Json           *JsonResponse
	Streaming      *StreamingResponse
	MaybeStreaming *MaybeStreamingResponse
	FileDownload   *FileDownloadResponse
}

func NewSdkResponseFromJson(value *JsonResponse) *SdkResponse {
	return &SdkResponse{Type: "json", Json: value}
}

func NewSdkResponseFromStreaming(value *StreamingResponse) *SdkResponse {
	return &SdkResponse{Type: "streaming", Streaming: value}
}

func NewSdkResponseFromMaybeStreaming(value *MaybeStreamingResponse) *SdkResponse {
	return &SdkResponse{Type: "maybeStreaming", MaybeStreaming: value}
}

func NewSdkResponseFromFileDownload(value *FileDownloadResponse) *SdkResponse {
	return &SdkResponse{Type: "fileDownload", FileDownload: value}
}

func (s *SdkResponse) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SdkResponse) GetJson() *JsonResponse {
	if s == nil {
		return nil
	}
	return s.Json
}

func (s *SdkResponse) GetStreaming() *StreamingResponse {
	if s == nil {
		return nil
	}
	return s.Streaming
}

func (s *SdkResponse) GetMaybeStreaming() *MaybeStreamingResponse {
	if s == nil {
		return nil
	}
	return s.MaybeStreaming
}

func (s *SdkResponse) GetFileDownload() *FileDownloadResponse {
	if s == nil {
		return nil
	}
	return s.FileDownload
}

func (s *SdkResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "json":
		value := new(JsonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Json = value
	case "streaming":
		value := new(StreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Streaming = value
	case "maybeStreaming":
		value := new(MaybeStreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.MaybeStreaming = value
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.FileDownload = value
	}
	return nil
}

func (s SdkResponse) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return internal.MarshalJSONWithExtraProperty(s.Json, "type", "json")
	case "streaming":
		return internal.MarshalJSONWithExtraProperty(s.Streaming, "type", "streaming")
	case "maybeStreaming":
		return internal.MarshalJSONWithExtraProperty(s.MaybeStreaming, "type", "maybeStreaming")
	case "fileDownload":
		return internal.MarshalJSONWithExtraProperty(s.FileDownload, "type", "fileDownload")
	}
}

type SdkResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitStreaming(*StreamingResponse) error
	VisitMaybeStreaming(*MaybeStreamingResponse) error
	VisitFileDownload(*FileDownloadResponse) error
}

func (s *SdkResponse) Accept(visitor SdkResponseVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return visitor.VisitJson(s.Json)
	case "streaming":
		return visitor.VisitStreaming(s.Streaming)
	case "maybeStreaming":
		return visitor.VisitMaybeStreaming(s.MaybeStreaming)
	case "fileDownload":
		return visitor.VisitFileDownload(s.FileDownload)
	}
}

func (s *SdkResponse) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Json != nil {
		fields = append(fields, "json")
	}
	if s.Streaming != nil {
		fields = append(fields, "streaming")
	}
	if s.MaybeStreaming != nil {
		fields = append(fields, "maybeStreaming")
	}
	if s.FileDownload != nil {
		fields = append(fields, "fileDownload")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type StreamCondition struct {
	Type string
	// The name of a boolean query parameter. If it is true, the response
	// should be streamed. Otherwise, it should not be streamed.
	QueryParameterKey string
	// The name of a boolean property on the request. If it is true, the response
	// should be streamed. Otherwise, it should not be streamed.
	RequestPropertyKey string
}

func NewStreamConditionFromQueryParameterKey(value string) *StreamCondition {
	return &StreamCondition{Type: "queryParameterKey", QueryParameterKey: value}
}

func NewStreamConditionFromRequestPropertyKey(value string) *StreamCondition {
	return &StreamCondition{Type: "requestPropertyKey", RequestPropertyKey: value}
}

func (s *StreamCondition) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *StreamCondition) GetQueryParameterKey() string {
	if s == nil {
		return ""
	}
	return s.QueryParameterKey
}

func (s *StreamCondition) GetRequestPropertyKey() string {
	if s == nil {
		return ""
	}
	return s.RequestPropertyKey
}

func (s *StreamCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "queryParameterKey":
		var valueUnmarshaler struct {
			QueryParameterKey string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.QueryParameterKey = valueUnmarshaler.QueryParameterKey
	case "requestPropertyKey":
		var valueUnmarshaler struct {
			RequestPropertyKey string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.RequestPropertyKey = valueUnmarshaler.RequestPropertyKey
	}
	return nil
}

func (s StreamCondition) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "queryParameterKey":
		var marshaler = struct {
			Type              string `json:"type"`
			QueryParameterKey string `json:"value"`
		}{
			Type:              "queryParameterKey",
			QueryParameterKey: s.QueryParameterKey,
		}
		return json.Marshal(marshaler)
	case "requestPropertyKey":
		var marshaler = struct {
			Type               string `json:"type"`
			RequestPropertyKey string `json:"value"`
		}{
			Type:               "requestPropertyKey",
			RequestPropertyKey: s.RequestPropertyKey,
		}
		return json.Marshal(marshaler)
	}
}

type StreamConditionVisitor interface {
	VisitQueryParameterKey(string) error
	VisitRequestPropertyKey(string) error
}

func (s *StreamCondition) Accept(visitor StreamConditionVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "queryParameterKey":
		return visitor.VisitQueryParameterKey(s.QueryParameterKey)
	case "requestPropertyKey":
		return visitor.VisitRequestPropertyKey(s.RequestPropertyKey)
	}
}

func (s *StreamCondition) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.QueryParameterKey != "" {
		fields = append(fields, "queryParameterKey")
	}
	if s.RequestPropertyKey != "" {
		fields = append(fields, "requestPropertyKey")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type StreamingResponse struct {
	DataEventType *TypeReference `json:"dataEventType,omitempty" url:"dataEventType,omitempty"`
	Terminator    *string        `json:"terminator,omitempty" url:"terminator,omitempty"`

	extraProperties map[string]interface{}
}

func (s *StreamingResponse) GetDataEventType() *TypeReference {
	if s == nil {
		return nil
	}
	return s.DataEventType
}

func (s *StreamingResponse) GetTerminator() *string {
	if s == nil {
		return nil
	}
	return s.Terminator
}

func (s *StreamingResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StreamingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	return nil
}

func (s *StreamingResponse) String() string {
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

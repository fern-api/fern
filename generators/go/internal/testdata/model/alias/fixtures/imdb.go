// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	internal "sdk/internal"
	time "time"
)

type Bar struct {
	Foo *Foo `json:"foo,omitempty" url:"foo,omitempty"`

	extraProperties map[string]interface{}
}

func (b *Bar) GetFoo() *Foo {
	if b == nil {
		return nil
	}
	return b.Foo
}

func (b *Bar) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bar) UnmarshalJSON(data []byte) error {
	type unmarshaler Bar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bar(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	return nil
}

func (b *Bar) String() string {
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BarAlias = *Bar

type Base64 = []byte

type Boolean = bool

type Date = time.Time

type DateTime = time.Time

type Double = float64

type DoubleSet = []float64

type Foo struct {
	Id          uuid.UUID `json:"id" url:"id"`
	Name        string    `json:"name" url:"name"`
	StringAlias String    `json:"stringAlias" url:"stringAlias"`

	extraProperties map[string]interface{}
}

func (f *Foo) GetId() uuid.UUID {
	if f == nil {
		return uuid.Nil
	}
	return f.Id
}

func (f *Foo) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *Foo) GetStringAlias() String {
	if f == nil {
		return ""
	}
	return f.StringAlias
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	return nil
}

func (f *Foo) String() string {
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FooAlias = *Foo

type Integer = int

type IntegerList = []int

type ListListInteger = [][]int

type ListOptionalUuid = []*uuid.UUID

type ListStringIntegerMap = []map[string]int

type Long = int64

type OptionalLong = *int64

type String = string

type StringBooleanMap = map[string]bool

type Union struct {
	Type        string
	FooAlias    *Foo
	BarAlias    BarAlias
	DoubleAlias Double
}

func NewUnionFromFooAlias(value *Foo) *Union {
	return &Union{Type: "fooAlias", FooAlias: value}
}

func NewUnionFromBarAlias(value BarAlias) *Union {
	return &Union{Type: "barAlias", BarAlias: value}
}

func NewUnionFromDoubleAlias(value Double) *Union {
	return &Union{Type: "doubleAlias", DoubleAlias: value}
}

func (u *Union) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *Union) GetFooAlias() *Foo {
	if u == nil {
		return nil
	}
	return u.FooAlias
}

func (u *Union) GetBarAlias() BarAlias {
	if u == nil {
		return nil
	}
	return u.BarAlias
}

func (u *Union) GetDoubleAlias() Double {
	if u == nil {
		return 0
	}
	return u.DoubleAlias
}

func (u *Union) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "fooAlias":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.FooAlias = value
	case "barAlias":
		var valueUnmarshaler struct {
			BarAlias BarAlias `json:"barAlias,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.BarAlias = valueUnmarshaler.BarAlias
	case "doubleAlias":
		var valueUnmarshaler struct {
			DoubleAlias Double `json:"doubleAlias"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.DoubleAlias = valueUnmarshaler.DoubleAlias
	}
	return nil
}

func (u Union) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "fooAlias":
		return internal.MarshalJSONWithExtraProperty(u.FooAlias, "type", "fooAlias")
	case "barAlias":
		var marshaler = struct {
			Type     string   `json:"type"`
			BarAlias BarAlias `json:"barAlias,omitempty"`
		}{
			Type:     "barAlias",
			BarAlias: u.BarAlias,
		}
		return json.Marshal(marshaler)
	case "doubleAlias":
		var marshaler = struct {
			Type        string `json:"type"`
			DoubleAlias Double `json:"doubleAlias"`
		}{
			Type:        "doubleAlias",
			DoubleAlias: u.DoubleAlias,
		}
		return json.Marshal(marshaler)
	}
}

type UnionVisitor interface {
	VisitFooAlias(*Foo) error
	VisitBarAlias(BarAlias) error
	VisitDoubleAlias(Double) error
}

func (u *Union) Accept(visitor UnionVisitor) error {
	switch u.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Type, u)
	case "fooAlias":
		return visitor.VisitFooAlias(u.FooAlias)
	case "barAlias":
		return visitor.VisitBarAlias(u.BarAlias)
	case "doubleAlias":
		return visitor.VisitDoubleAlias(u.DoubleAlias)
	}
}

func (u *Union) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.FooAlias != nil {
		fields = append(fields, "fooAlias")
	}
	if u.BarAlias != nil {
		fields = append(fields, "barAlias")
	}
	if u.DoubleAlias != 0 {
		fields = append(fields, "doubleAlias")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}

type Unknown = interface{}

type Uuid = uuid.UUID
